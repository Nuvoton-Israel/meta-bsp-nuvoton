From fb460caec94eb4eec17c4af8e4e682ce455c5ce7 Mon Sep 17 00:00:00 2001
From: tmaimon <tomer.maimon@nuvoton.com>
Date: Mon, 3 Apr 2017 17:48:09 +0300
Subject: [PATCH] PolegSVB-Uboot-2015.10-Rev-1.00-03.04.2017

---
 arch/arm/Kconfig                                   |    6 +
 arch/arm/cpu/armv7/Makefile                        |    2 +
 arch/arm/cpu/armv7/npcm750/Makefile                |    8 +
 arch/arm/cpu/armv7/npcm750/cache.c                 |   26 +
 arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c        |   18 +
 arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S   |   86 +
 arch/arm/dts/nuvoton-poleg.dts                     |   60 +
 arch/arm/include/asm/arch-npcm750/gpio.h           |   12 +
 arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h  |   13 +
 arch/arm/include/asm/mach-types.h                  |   39 +
 arch/arm/include/asm/system.h                      |    4 +-
 arch/arm/lib/Makefile                              |    4 +
 arch/arm/lib/board.c                               |  698 +++++++
 arch/arm/lib/cache-cp15.c                          |    2 +-
 arch/arm/lib/cache-pl310.c                         |    5 +
 board/nuvoton/HermonSVB/HermonSVB_init.c           |   63 +
 board/nuvoton/HermonSVB/HermonSVB_low_level_init.S |  800 ++++++++
 board/nuvoton/HermonSVB/Makefile                   |   27 +
 board/nuvoton/HermonSVB/config.mk                  |    5 +
 board/nuvoton/PolegSVB/Kconfig                     |   18 +
 board/nuvoton/PolegSVB/Makefile                    |    8 +
 board/nuvoton/PolegSVB/PolegSVB_init.c             |   79 +
 board/nuvoton/PolegSVB/PolegSVB_low_level_init.S   |   45 +
 board/nuvoton/PolegSVB/cmd_usb_device.c            |   52 +
 board/nuvoton/PolegSVB/config.mk                   |    5 +
 board/nuvoton/YarkonSVB/Makefile                   |   26 +
 board/nuvoton/YarkonSVB/YarkonSVB_init.c           |   77 +
 board/nuvoton/YarkonSVB/config.mk                  |    5 +
 board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.c  |  364 ++++
 board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.h  |   49 +
 board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.c    |  362 ++++
 board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.h    |   73 +
 .../BMC_HAL/Apps/serial_printf/serial_printf.c     |  490 +++++
 .../BMC_HAL/Apps/serial_printf/serial_printf.h     |   21 +
 .../common/BMC_HAL/Boards/HermonSVB/HermonSVB.c    |   30 +
 .../common/BMC_HAL/Boards/HermonSVB/HermonSVB.h    |   50 +
 .../common/BMC_HAL/Boards/PolegSVB/PolegSVB.c      |   28 +
 .../common/BMC_HAL/Boards/PolegSVB/PolegSVB.h      |  110 ++
 .../common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.c    |   28 +
 .../common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.h    |   62 +
 board/nuvoton/common/BMC_HAL/Boards/board.c        |   28 +
 board/nuvoton/common/BMC_HAL/Boards/board.h        |   35 +
 board/nuvoton/common/BMC_HAL/Changelog.txt         |  249 +++
 board/nuvoton/common/BMC_HAL/Chips/chip.c          |  158 ++
 board/nuvoton/common/BMC_HAL/Chips/chip.h          |   32 +
 board/nuvoton/common/BMC_HAL/Chips/chip_if.h       |  100 +
 .../nuvoton/common/BMC_HAL/Chips/npcm650/npcm650.h |  822 ++++++++
 .../nuvoton/common/BMC_HAL/Chips/npcm750/npcm750.h | 1276 +++++++++++++
 .../nuvoton/common/BMC_HAL/Chips/wpcm450/wpcm450.h |  507 +++++
 board/nuvoton/common/BMC_HAL/Common/hal_common.h   |   72 +
 board/nuvoton/common/BMC_HAL/Common/hal_error.h    |   62 +
 board/nuvoton/common/BMC_HAL/Common/hal_ethernet.h |  214 +++
 board/nuvoton/common/BMC_HAL/Defines.txt           |   20 +
 board/nuvoton/common/BMC_HAL/Modules/aes/aes_if.h  |  111 ++
 .../common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.c  |  347 ++++
 .../common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.h  |   19 +
 .../common/BMC_HAL/Modules/aic/Poleg_IP/aic_regs.h |   35 +
 board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.c  |   21 +
 board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.h  |  158 ++
 .../common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.c  | 1999 ++++++++++++++++++++
 .../common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.h  |   19 +
 .../common/BMC_HAL/Modules/clk/Poleg_IP/clk_regs.h |  770 ++++++++
 board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.c  |   22 +
 board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.h  |  462 +++++
 board/nuvoton/common/BMC_HAL/Modules/des/des_if.h  |  104 +
 board/nuvoton/common/BMC_HAL/Modules/ece/ece_if.h  |  278 +++
 .../common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.c | 1622 ++++++++++++++++
 .../common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.h |   20 +
 .../BMC_HAL/Modules/emc/Hermon_IP/emc_regs.h       |  226 +++
 board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.c  |   22 +
 board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.h  |  123 ++
 .../common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_defs.h |  180 ++
 .../common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.c  |  529 ++++++
 .../common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.h  |   21 +
 .../common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_regs.h |  245 +++
 board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.c  |   22 +
 board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.h  |  118 ++
 .../BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.c       |  986 ++++++++++
 .../BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.h       |   21 +
 .../BMC_HAL/Modules/fuse/Poleg_IP/fuse_regs.h      |  102 +
 .../nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.c  |   22 +
 .../nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.h  |  152 ++
 .../common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.c  |  823 ++++++++
 .../common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.h  |   19 +
 .../common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_regs.h |  814 ++++++++
 board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.c  |   22 +
 board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.h  |  429 +++++
 .../nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.c  |   22 +
 .../nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.h  |  109 ++
 .../BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.c      | 1020 ++++++++++
 .../BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.h      |   20 +
 .../BMC_HAL/Modules/gpio/Hermon_IP/gpio_regs.h     |   80 +
 .../nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.c  |   23 +
 .../nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.h  |  450 +++++
 board/nuvoton/common/BMC_HAL/Modules/mc/mc_if.h    |  146 ++
 .../nuvoton/common/BMC_HAL/Modules/pspi/pspi_if.h  |  101 +
 board/nuvoton/common/BMC_HAL/Modules/sd/sd_if.h    |  232 +++
 .../nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.c |  861 +++++++++
 .../nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.h |   21 +
 .../common/BMC_HAL/Modules/sha/1/sha_regs.h        |   50 +
 board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.c  |   21 +
 board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.h  |  194 ++
 board/nuvoton/common/BMC_HAL/Modules/shm/shm_if.h  |   72 +
 .../BMC_HAL/Modules/strp/Poleg_IP/strp_drv.c       |  261 +++
 .../BMC_HAL/Modules/strp/Poleg_IP/strp_drv.h       |   21 +
 .../nuvoton/common/BMC_HAL/Modules/strp/strp_if.c  |   23 +
 .../nuvoton/common/BMC_HAL/Modules/strp/strp_if.h  |  274 +++
 .../BMC_HAL/Modules/timer/Hermon_IP/timer_drv.c    |  541 ++++++
 .../BMC_HAL/Modules/timer/Hermon_IP/timer_drv.h    |   23 +
 .../BMC_HAL/Modules/timer/Hermon_IP/timer_regs.h   |   91 +
 .../common/BMC_HAL/Modules/timer/timer_if.c        |   23 +
 .../common/BMC_HAL/Modules/timer/timer_if.h        |  185 ++
 .../BMC_HAL/Modules/uart/Hermon_IP/uart_drv.c      |  852 +++++++++
 .../BMC_HAL/Modules/uart/Hermon_IP/uart_drv.h      |   20 +
 .../BMC_HAL/Modules/uart/Hermon_IP/uart_regs.h     |  160 ++
 .../nuvoton/common/BMC_HAL/Modules/uart/uart_if.c  |   23 +
 .../nuvoton/common/BMC_HAL/Modules/uart/uart_if.h  |  385 ++++
 board/nuvoton/common/BMC_HAL/Modules/vcd/vcd_if.h  |  564 ++++++
 .../Peripherals/eth_phy/bcm5221/bcm5221_drv.c      |  378 ++++
 .../Peripherals/eth_phy/bcm5221/bcm5221_drv.h      |   45 +
 .../Peripherals/eth_phy/bcm5221/bcm5221_regs.h     |   60 +
 .../Peripherals/eth_phy/bcm54210e/bcm54210e_drv.c  |  389 ++++
 .../Peripherals/eth_phy/bcm54210e/bcm54210e_drv.h  |   45 +
 .../Peripherals/eth_phy/bcm54210e/bcm54210e_regs.h |   60 +
 .../Peripherals/eth_phy/bcm54612e/bcm54612e_drv.c  |  397 ++++
 .../Peripherals/eth_phy/bcm54612e/bcm54612e_drv.h  |   45 +
 .../Peripherals/eth_phy/bcm54612e/bcm54612e_regs.h |   64 +
 .../Peripherals/eth_phy/bcm5481/bcm5481_drv.c      |  389 ++++
 .../Peripherals/eth_phy/bcm5481/bcm5481_drv.h      |   45 +
 .../Peripherals/eth_phy/bcm5481/bcm5481_regs.h     |   61 +
 .../Peripherals/eth_phy/dp83848c/dp83848c_drv.c    |  378 ++++
 .../Peripherals/eth_phy/dp83848c/dp83848c_drv.h    |   45 +
 .../Peripherals/eth_phy/dp83848c/dp83848c_regs.h   |   62 +
 .../common/BMC_HAL/Peripherals/eth_phy/eth_phy.c   |    8 +
 .../common/BMC_HAL/Peripherals/eth_phy/eth_phy.h   |   27 +
 .../spi_flash/common/spi_flash_common.c            |  213 +++
 .../spi_flash/common/spi_flash_common.h            |  138 ++
 .../BMC_HAL/Peripherals/spi_flash/spi_flash.c      |  757 ++++++++
 .../BMC_HAL/Peripherals/spi_flash/spi_flash.h      |  152 ++
 .../common/BMC_HAL/Tools/erase_unused_files.pl     |  206 ++
 .../common/BMC_HAL/Tools/modules_by_chip.pl        |  113 ++
 board/nuvoton/common/BMC_HAL/version.h             |   22 +
 board/nuvoton/common/Makefile                      |   11 +
 board/nuvoton/common/SWC_DEFS/defs.h               |   29 +
 board/nuvoton/common/SWC_DEFS/defs_access.h        |  312 +++
 board/nuvoton/common/SWC_DEFS/defs_core_arm.h      |  433 +++++
 board/nuvoton/common/SWC_DEFS/defs_core_default.h  |  249 +++
 board/nuvoton/common/SWC_DEFS/defs_errors.h        |  262 +++
 board/nuvoton/common/SWC_DEFS/defs_internal.h      |   96 +
 board/nuvoton/common/SWC_DEFS/defs_os_linux.h      |   91 +
 board/nuvoton/common/SWC_DEFS/defs_os_linux_app.h  |   33 +
 board/nuvoton/common/SWC_DEFS/defs_secured.h       |  382 ++++
 board/nuvoton/common/SWC_DEFS/defs_types.h         |  202 ++
 board/nuvoton/common/SWC_DEFS/defs_utils.h         |  441 +++++
 board/nuvoton/common/SWC_DEFS/swc-defs.lnt         |   56 +
 board/nuvoton/common/config.mk                     |   45 +
 board/nuvoton/common/nuvoton_aic.c                 |   43 +
 board/nuvoton/common/nuvoton_eth.c                 |  103 +
 board/nuvoton/common/nuvoton_flash.c               |  195 ++
 board/nuvoton/common/nuvoton_hal.h                 |   26 +
 board/nuvoton/common/nuvoton_init.c                |  186 ++
 board/nuvoton/common/nuvoton_low_level.S           |   75 +
 board/nuvoton/common/nuvoton_serial.c              |  156 ++
 board/nuvoton/common/nuvoton_timer.c               |  167 ++
 board/nuvoton/common/nuvoton_usb.c                 |  107 ++
 common/Makefile                                    |    3 +
 common/board_f.c                                   |    3 +
 common/board_r.c                                   |    6 +-
 common/cmd_cache.c                                 |  469 ++++-
 common/cmd_fuse.c                                  |   16 +-
 common/cmd_gmac.c                                  |  604 ++++++
 common/cmd_mem.c                                   |   45 +-
 common/cmd_rng.c                                   |   54 +
 common/cmd_sha256sum.c                             |   54 +
 common/hash.c                                      |   29 +-
 common/image-fit.c                                 |   34 +-
 configs/PolegSVB_defconfig                         |   23 +
 drivers/crypto/Kconfig                             |    7 +
 drivers/crypto/Makefile                            |    1 +
 drivers/crypto/nuvoton/Kconfig                     |   10 +
 drivers/crypto/nuvoton/Makefile                    |    9 +
 drivers/crypto/nuvoton/nuvoton_rng.c               |   91 +
 drivers/crypto/nuvoton/nuvoton_rng.h               |   86 +
 drivers/crypto/nuvoton/nuvoton_sha.c               | 1264 +++++++++++++
 drivers/crypto/nuvoton/nuvoton_sha.h               |  103 +
 drivers/misc/Makefile                              |    1 +
 drivers/misc/fuse_wrapper.c                        |  294 +++
 drivers/misc/fuse_wrapper.h                        |  187 ++
 drivers/misc/npcm750_otp.c                         |   42 +
 drivers/mmc/Makefile                               |    1 +
 drivers/mmc/npcmx50_sdhci.c                        | 1112 +++++++++++
 drivers/net/Makefile                               |    1 +
 drivers/net/designware.c                           |   11 +-
 drivers/net/nuc970_eth.c                           |  349 ++++
 drivers/net/nuc970_eth.h                           |  159 ++
 drivers/net/phy/broadcom.c                         |   63 +
 drivers/net/phy/phy.c                              |   14 +-
 drivers/serial/serial.c                            |    2 +
 include/configs/HermonSVB.h                        |   82 +
 include/configs/PolegSVB.h                         |  199 ++
 include/configs/YarkonSVB.h                        |  122 ++
 include/configs/nuvoton.h                          |  188 ++
 include/usb.h                                      |    5 +-
 poleg_fit.its                                      |   60 +
 scripts/Makefile.autoconf                          |    8 +-
 205 files changed, 38746 insertions(+), 30 deletions(-)
 mode change 100644 => 100755 arch/arm/Kconfig
 mode change 100644 => 100755 arch/arm/cpu/armv7/Makefile
 create mode 100755 arch/arm/cpu/armv7/npcm750/Makefile
 create mode 100755 arch/arm/cpu/armv7/npcm750/cache.c
 create mode 100755 arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
 create mode 100755 arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
 create mode 100755 arch/arm/dts/nuvoton-poleg.dts
 create mode 100755 arch/arm/include/asm/arch-npcm750/gpio.h
 create mode 100755 arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
 mode change 100644 => 100755 arch/arm/include/asm/mach-types.h
 mode change 100644 => 100755 arch/arm/include/asm/system.h
 mode change 100644 => 100755 arch/arm/lib/Makefile
 create mode 100755 arch/arm/lib/board.c
 mode change 100644 => 100755 arch/arm/lib/cache-cp15.c
 mode change 100644 => 100755 arch/arm/lib/cache-pl310.c
 create mode 100755 board/nuvoton/HermonSVB/HermonSVB_init.c
 create mode 100755 board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
 create mode 100755 board/nuvoton/HermonSVB/Makefile
 create mode 100755 board/nuvoton/HermonSVB/config.mk
 create mode 100755 board/nuvoton/PolegSVB/Kconfig
 create mode 100755 board/nuvoton/PolegSVB/Makefile
 create mode 100755 board/nuvoton/PolegSVB/PolegSVB_init.c
 create mode 100755 board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
 create mode 100755 board/nuvoton/PolegSVB/cmd_usb_device.c
 create mode 100755 board/nuvoton/PolegSVB/config.mk
 create mode 100755 board/nuvoton/YarkonSVB/Makefile
 create mode 100755 board/nuvoton/YarkonSVB/YarkonSVB_init.c
 create mode 100755 board/nuvoton/YarkonSVB/config.mk
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/board.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Boards/board.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Changelog.txt
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/chip.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/chip.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/chip_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/npcm650/npcm650.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/npcm750/npcm750.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Chips/wpcm450/wpcm450.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Common/hal_common.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Common/hal_error.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Common/hal_ethernet.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Defines.txt
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aes/aes_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/des/des_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/ece/ece_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_defs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/mc/mc_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/pspi/pspi_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sd/sd_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/shm/shm_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Modules/vcd/vcd_if.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_regs.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.c
 create mode 100755 board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.h
 create mode 100755 board/nuvoton/common/BMC_HAL/Tools/erase_unused_files.pl
 create mode 100755 board/nuvoton/common/BMC_HAL/Tools/modules_by_chip.pl
 create mode 100755 board/nuvoton/common/BMC_HAL/version.h
 create mode 100755 board/nuvoton/common/Makefile
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_access.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_core_arm.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_core_default.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_errors.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_internal.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_os_linux.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_os_linux_app.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_secured.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_types.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/defs_utils.h
 create mode 100755 board/nuvoton/common/SWC_DEFS/swc-defs.lnt
 create mode 100755 board/nuvoton/common/config.mk
 create mode 100755 board/nuvoton/common/nuvoton_aic.c
 create mode 100755 board/nuvoton/common/nuvoton_eth.c
 create mode 100755 board/nuvoton/common/nuvoton_flash.c
 create mode 100755 board/nuvoton/common/nuvoton_hal.h
 create mode 100755 board/nuvoton/common/nuvoton_init.c
 create mode 100755 board/nuvoton/common/nuvoton_low_level.S
 create mode 100755 board/nuvoton/common/nuvoton_serial.c
 create mode 100755 board/nuvoton/common/nuvoton_timer.c
 create mode 100755 board/nuvoton/common/nuvoton_usb.c
 mode change 100644 => 100755 common/Makefile
 mode change 100644 => 100755 common/board_f.c
 mode change 100644 => 100755 common/board_r.c
 mode change 100644 => 100755 common/cmd_cache.c
 mode change 100644 => 100755 common/cmd_fuse.c
 create mode 100755 common/cmd_gmac.c
 mode change 100644 => 100755 common/cmd_mem.c
 create mode 100755 common/cmd_rng.c
 create mode 100755 common/cmd_sha256sum.c
 mode change 100644 => 100755 common/hash.c
 mode change 100644 => 100755 common/image-fit.c
 create mode 100755 configs/PolegSVB_defconfig
 mode change 100644 => 100755 drivers/crypto/Kconfig
 mode change 100644 => 100755 drivers/crypto/Makefile
 create mode 100755 drivers/crypto/nuvoton/Kconfig
 create mode 100755 drivers/crypto/nuvoton/Makefile
 create mode 100755 drivers/crypto/nuvoton/nuvoton_rng.c
 create mode 100755 drivers/crypto/nuvoton/nuvoton_rng.h
 create mode 100755 drivers/crypto/nuvoton/nuvoton_sha.c
 create mode 100755 drivers/crypto/nuvoton/nuvoton_sha.h
 mode change 100644 => 100755 drivers/misc/Makefile
 create mode 100755 drivers/misc/fuse_wrapper.c
 create mode 100755 drivers/misc/fuse_wrapper.h
 create mode 100755 drivers/misc/npcm750_otp.c
 mode change 100644 => 100755 drivers/mmc/Makefile
 create mode 100755 drivers/mmc/npcmx50_sdhci.c
 mode change 100644 => 100755 drivers/net/Makefile
 mode change 100644 => 100755 drivers/net/designware.c
 create mode 100755 drivers/net/nuc970_eth.c
 create mode 100755 drivers/net/nuc970_eth.h
 mode change 100644 => 100755 drivers/net/phy/broadcom.c
 mode change 100644 => 100755 drivers/net/phy/phy.c
 mode change 100644 => 100755 drivers/serial/serial.c
 create mode 100755 include/configs/HermonSVB.h
 create mode 100755 include/configs/PolegSVB.h
 create mode 100755 include/configs/YarkonSVB.h
 create mode 100755 include/configs/nuvoton.h
 mode change 100644 => 100755 include/usb.h
 create mode 100755 poleg_fit.its
 mode change 100644 => 100755 scripts/Makefile.autoconf

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
old mode 100644
new mode 100755
index 7981355..9a67474
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -666,6 +666,11 @@ config ARCH_ROCKCHIP
 	select CPU_V7
 	select DM
 
+config TARGET_NPCM750
+	bool "Support npcm750"
+	select CPU_V7
+
+
 endchoice
 
 source "arch/arm/mach-at91/Kconfig"
@@ -762,6 +767,7 @@ source "board/h2200/Kconfig"
 source "board/hisilicon/hikey/Kconfig"
 source "board/imx31_phycore/Kconfig"
 source "board/isee/igep0033/Kconfig"
+source "board/nuvoton/PolegSVB/Kconfig"
 source "board/maxbcm/Kconfig"
 source "board/mpl/vcma9/Kconfig"
 source "board/olimex/mx23_olinuxino/Kconfig"
diff --git a/arch/arm/cpu/armv7/Makefile b/arch/arm/cpu/armv7/Makefile
old mode 100644
new mode 100755
index c8d1422..0a01ba7
--- a/arch/arm/cpu/armv7/Makefile
+++ b/arch/arm/cpu/armv7/Makefile
@@ -53,3 +53,5 @@ obj-$(CONFIG_ARCH_S5PC1XX) += s5pc1xx/
 obj-$(if $(filter stv0991,$(SOC)),y) += stv0991/
 obj-$(CONFIG_ARCH_SUNXI) += sunxi/
 obj-$(CONFIG_VF610) += vf610/
+obj-$(CONFIG_NUVOTON) += npcm750/
+
diff --git a/arch/arm/cpu/armv7/npcm750/Makefile b/arch/arm/cpu/armv7/npcm750/Makefile
new file mode 100755
index 0000000..b8977d0
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= l2_cache_pl310_init.o l2_cache_pl310.o cache.o
diff --git a/arch/arm/cpu/armv7/npcm750/cache.c b/arch/arm/cpu/armv7/npcm750/cache.c
new file mode 100755
index 0000000..a49ed07
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/cache.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2014 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Robert Baldyga <r.baldyga@samsung.com>
+ *
+ * based on arch/arm/cpu/armv7/omap3/cache.S
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+
+void enable_caches(void)
+{
+	dcache_enable();
+}
+
+void disable_caches(void)
+{
+	dcache_disable();
+}
+
+#endif
+
diff --git a/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
new file mode 100755
index 0000000..4363ebb
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
@@ -0,0 +1,18 @@
+#include <common.h>
+
+extern  void l2_pl310_init(void);
+void set_pl310_ctrl(u32 enable);
+ 
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+void v7_outer_cache_enable(void)
+{
+   l2_pl310_init();
+   set_pl310_ctrl(1);
+}
+
+void v7_outer_cache_disable(void)
+{
+   set_pl310_ctrl(0);
+}
+#endif /* !CONFIG_SYS_L2CACHE_OFF */
diff --git a/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
new file mode 100755
index 0000000..250c538
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
@@ -0,0 +1,86 @@
+
+.align 5
+
+#include <linux/linkage.h>
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+
+ENTRY(l2_pl310_init)
+
+
+ @------------------------------------------------------------------
+ @ L2CC (PL310) Initialization
+ @------------------------------------------------------------------
+ 	@ In this example PL310 PA = VA. The memory was marked as Device memory
+ 	@ in previous stages when defining CORE0 private address space
+ 	LDR     r0, =0xF03FC000        @ A9_BASE_ADDR
+ 
+ 	@ Disable L2 Cache controller just in case it is already on
+ 	LDR     r1, =0x0
+ 	STR     r1, [r0,#0x100]
+ 
+ 	@ Set aux cntrl
+ 	@ Way size = 32KB
+        @ Way = 16
+ 	LDR     r1, =0x02050000         
+ 	ORR	r1, r1, #(1 << 29)	@ Instruction prefetch enable
+ 	ORR	r1, r1, #(1 << 28)	@ Data prefetch enable
+ 	ORR	r1, r1, #(1 << 22)	@ cache replacement policy
+ 	STR     r1, [r0,#0x104]		@ auxilary control reg at offset 0x104
+ 
+ 	@ Set tag RAM latency
+ 	@ 1 cycle RAM write access latency
+ 	@ 1 cycle RAM read access latency
+ 	@ 1 cycle RAM setup latency
+ 	LDR     r1, =0x00000000
+ 	STR     r1, [r0,#0x108]		@ tag ram control reg at offset 0x108
+ 
+ 	@ Set Data RAM latency
+ 	@ 1 cycle RAM write access latency
+ 	@ 2 cycles RAM read access latency
+ 	@ 1 cycle RAM setup latency
+ 	//LDR     r1, =0x00000010	@ Altera uses read latency 1, but 0 seems to work
+ 	LDR     r1, =0x00000000
+ 	STR     r1, [r0,#0x10C]		@ data ram control reg at offset 0x108
+ 
+ 	@Cache maintenance - invalidate by way (0xff) - base offset 0x77C
+ 	LDR     r1, =0xFF
+ 	STR     r1, [r0,#0x77C]		@ invalidate by way register at offset 0x77C
+ poll_invalidate:
+ 	LDR     r1, [r0,#0x77C]		@ invalidate by way register at offset 0x77C
+ 	TST     r1, #1
+ 	BNE     poll_invalidate
+ 
+ /*
+ 	@ Enable Event Counter Control Register. Reset counter 0 and 1 values
+ 	LDR     r1, =0x007
+ 	STR     r1, [r0,#0x200]
+ 
+ 	@ Counter 1. Count Drhit event
+ 	LDR     r1, =0x008
+ 	STR     r1, [r0,#0x204]
+ 
+ 	@ Counter 0. Count Dwhit event
+ 	LDR     r1, =0x010
+ 	STR     r1, [r0,#0x208]
+ */
+ 
+ 	@ Ensure L2 remains disabled for the time being
+ 	LDR     r1, =0x0
+ 	STR     r1, [r0,#0x100]
+
+	MRC     p15, 4, r0, c15, c0, 0     @ Read periph base address
+ 	@ SCU offset from base of private peripheral space = 0x000
+ 
+ 	LDR     r1, [r0, #0x0]             @ Read the SCU Control Register
+ 	ORR     r1, r1, #0x1               @ Set bit 0 (The Enable bit)
+ 	STR     r1, [r0, #0x0]             @ Write back modifed value
+ 
+ 	BX	lr
+
+
+
+ENDPROC(l2_pl310_init)
+
+
+#endif
diff --git a/arch/arm/dts/nuvoton-poleg.dts b/arch/arm/dts/nuvoton-poleg.dts
new file mode 100755
index 0000000..12d6d19
--- /dev/null
+++ b/arch/arm/dts/nuvoton-poleg.dts
@@ -0,0 +1,60 @@
+/dts-v1/;
+/ {
+    description = "Simple image with single Linux kernel and ramdisk";
+    #address-cells = <0x1>;
+
+    images {
+        kernel@1 {
+            description = "Nuvoton Linux kernel";
+            data = /incbin/("/home/ubuntu/shared/releases/poleg/file_sys/4112.01.13/dual/deliverables/PolegSVB/zImage");
+            type = "kernel";
+            arch = "arm";
+            os = "linux";
+            compression = "none";
+            load = <0x8000>;
+            entry = <0x8000>;
+            hash@1 {
+                algo = "sha256";
+            };
+	    signature@1 {
+                algo = "sha256";
+                key-name-hint = "poleg";
+                key-dir = "./build_output/tools/keys";
+            };
+        };
+        ramdisk@1 {
+            description = "Nuvoton Ramdisk Image";
+            data = /incbin/("/home/ubuntu/shared/releases/poleg/file_sys/4112.01.13/dual/deliverables/PolegSVB/romfs.img.gz");
+            type = "ramdisk";
+            arch = "arm";
+            os = "linux";
+            compression = "none";
+            load = <0x01d00000>;
+            entry = <0x01d00000>;
+            hash@1 {
+                algo = "sha256";
+            };
+	    signature@1 {
+                algo = "sha256";
+                key-name-hint = "poleg";
+                key-dir = "./build_output/tools/keys";
+            };
+       };
+    };
+    configurations {
+        default = "conf@1";
+        conf@1 {
+            description = "Boot Linux kernel and ramdisk";
+            kernel = "kernel@1";
+            ramdisk = "ramdisk@1";
+        };
+        hash@1 {
+                algo = "sha256";
+        };
+ 	signature@1 {
+            algo = "sha256,rsa2048";
+            key-name-hint = "poleg";
+            key-dir = "./build_output/tools/keys";
+        };
+    };
+};
diff --git a/arch/arm/include/asm/arch-npcm750/gpio.h b/arch/arm/include/asm/arch-npcm750/gpio.h
new file mode 100755
index 0000000..ca8ee25
--- /dev/null
+++ b/arch/arm/include/asm/arch-npcm750/gpio.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2015 Xilinx, Inc.
+ *
+ * SPDX-License-Identifier:      GPL-2.0+
+ */
+
+#ifndef __ARCH_NPCM750_GPIO_H
+#define __ARCH_NPCM750_GPIO_H
+
+/* Empty file - sdhci requires this. */
+
+#endif
diff --git a/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h b/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
new file mode 100755
index 0000000..2eb234b
--- /dev/null
+++ b/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
@@ -0,0 +1,13 @@
+/*
+ * (C) Copyright 2014 - 2015 Xilinx, Inc.
+ * Michal Simek <michal.simek@xilinx.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARCH_NPCM750_SDHCI_H
+#define _ASM_ARCH_NPCM750_SDHCI_H
+
+int npcmx50_mmc_init(void);
+
+#endif /* _ASM_ARCH_NPCM750_SDHCI_H */
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
old mode 100644
new mode 100755
index d51be0b..f035a37
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -262,6 +262,9 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_TERASTATION_PRO2     1584
 #define MACH_TYPE_LINKSTATION_PRO      1585
 #define MACH_TYPE_E350                 1596
+#define MACH_TYPE_WPCM450              1597
+#define MACH_TYPE_NPCM650              1598
+#define MACH_TYPE_NPCM750              1599
 #define MACH_TYPE_TS409                1601
 #define MACH_TYPE_CM_X300              1616
 #define MACH_TYPE_AT91SAM9G20EK        1624
@@ -4108,6 +4111,42 @@ extern unsigned int __machine_arch_type;
 # define machine_is_e350()	(0)
 #endif
 
+#ifdef CONFIG_MACH_WPCM450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WPCM450
+# endif
+# define machine_is_wpcm450()	(machine_arch_type == MACH_TYPE_WPCM450)
+#else
+# define machine_is_wpcm450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NPCM650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NPCM650
+# endif
+# define machine_is_npcm650()	(machine_arch_type == MACH_TYPE_NPCM650)
+#else
+# define machine_is_npcm650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NPCM750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NPCM750
+# endif
+# define machine_is_npcm750()	(machine_arch_type == MACH_TYPE_NPCM750)
+#else
+# define machine_is_npcm750()	(0)
+#endif
+
 #ifdef CONFIG_MACH_TS409
 # ifdef machine_arch_type
 #  undef machine_arch_type
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
old mode 100644
new mode 100755
index cfc7834..6586f2f
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -219,7 +219,7 @@ static inline void set_dacr(unsigned int val)
 	isb();
 }
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)
 /* Short-Descriptor Translation Table Level 1 Bits */
 #define TTB_SECT_NS_MASK	(1 << 19)
 #define TTB_SECT_NG_MASK	(1 << 17)
@@ -256,7 +256,7 @@ enum {
 	MMU_SECTION_SIZE	= 1 << MMU_SECTION_SHIFT,
 };
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)   // Trego - need to check the following TLB change
 /* TTBR0 bits */
 #define TTBR0_BASE_ADDR_MASK	0xFFFFC000
 #define TTBR0_RGN_NC			(0 << 3)
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
old mode 100644
new mode 100755
index 2bdfaba..64b4b37
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -22,6 +22,10 @@ obj-y	+= relocate_64.o
 else
 obj-y	+= relocate.o
 endif
+#Trego- UBOOT Relocation old way (for Now)
+ifndef CONFIG_SYS_GENERIC_BOARD
+obj-y	+= board.o
+endif
 
 obj-$(CONFIG_CPU_V7M) += cmd_boot.o
 obj-$(CONFIG_OF_LIBFDT) += bootm-fdt.o
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
new file mode 100755
index 0000000..5106d43
--- /dev/null
+++ b/arch/arm/lib/board.c
@@ -0,0 +1,698 @@
+/*
+ * (C) Copyright 2002-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * To match the U-Boot user interface on ARM platforms to the U-Boot
+ * standard (as on PPC platforms), some messages with debug character
+ * are removed from the default U-Boot build.
+ *
+ * Define DEBUG here if you want additional info as shown below
+ * printed upon startup:
+ *
+ * U-Boot code: 00F00000 -> 00F3C774  BSS: -> 00FC3274
+ * IRQ Stack: 00ebff7c
+ * FIQ Stack: 00ebef7c
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <version.h>
+#include <net.h>
+#include <serial.h>
+#include <nand.h>
+#include <onenand_uboot.h>
+#include <mmc.h>
+#include <scsi.h>
+#include <status_led.h>
+#include <libfdt.h>
+#include <fdtdec.h>
+#include <post.h>
+#include <logbuff.h>
+#include <asm/sections.h>
+
+#ifdef CONFIG_BITBANGMII
+#include <miiphy.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ulong monitor_flash_len;
+
+#ifdef CONFIG_HAS_DATAFLASH
+extern int  AT91F_DataflashInit(void);
+extern void dataflash_print_info(void);
+#endif
+
+#if defined(CONFIG_HARD_I2C) || \
+	defined(CONFIG_SYS_I2C)
+#include <i2c.h>
+#endif
+
+/************************************************************************
+ * Coloured LED functionality
+ ************************************************************************
+ * May be supplied by boards if desired
+ */
+__weak void coloured_LED_init(void) {}
+__weak void red_led_on(void) {}
+__weak void red_led_off(void) {}
+__weak void green_led_on(void) {}
+__weak void green_led_off(void) {}
+__weak void yellow_led_on(void) {}
+__weak void yellow_led_off(void) {}
+__weak void blue_led_on(void) {}
+__weak void blue_led_off(void) {}
+
+/*
+ ************************************************************************
+ * Init Utilities							*
+ ************************************************************************
+ * Some of this code should be moved into the core functions,
+ * or dropped completely,
+ * but let's get it working (again) first...
+ */
+
+#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
+#define CONFIG_BAUDRATE 115200
+#endif
+
+static int init_baudrate(void)
+{
+	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
+	return 0;
+}
+
+static int display_banner(void)
+{
+	printf("\n\n%s\n\n", version_string);
+	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	       (ulong)&_start,
+	       (ulong)&__bss_start, (ulong)&__bss_end);
+#ifdef CONFIG_MODEM_SUPPORT
+	debug("Modem Support enabled\n");
+#endif
+#ifdef CONFIG_USE_IRQ
+	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
+	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
+#endif
+
+	return (0);
+}
+
+/*
+ * WARNING: this code looks "cleaner" than the PowerPC version, but
+ * has the disadvantage that you either get nothing, or everything.
+ * On PowerPC, you might see "DRAM: " before the system hangs - which
+ * gives a simple yet clear indication which part of the
+ * initialization if failing.
+ */
+static int display_dram_config(void)
+{
+	int i;
+	
+    dram_init_banksize();
+
+#ifdef DEBUG
+	puts("RAM Configuration:\n");
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		printf("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
+		print_size(gd->bd->bi_dram[i].size, "\n");
+	}
+#else
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		size += gd->bd->bi_dram[i].size;
+
+	puts("DRAM:  ");
+	print_size(size, "\n");
+#endif
+
+	return (0);
+}
+
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
+static int init_func_i2c(void)
+{
+	puts("I2C:   ");
+#ifdef CONFIG_SYS_I2C
+	i2c_init_all();
+#else
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+	puts("ready\n");
+	return (0);
+}
+#endif
+
+#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
+#include <pci.h>
+static int arm_pci_init(void)
+{
+	pci_init();
+	return 0;
+}
+#endif /* CONFIG_CMD_PCI || CONFIG_PCI */
+
+/*
+ * Breathe some life into the board...
+ *
+ * Initialize a serial port as console, and carry out some hardware
+ * tests.
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependent #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+__weak void dram_init_banksize(void)
+{
+    gd->bd->bi_dram[0].start    = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size     = PHYS_SDRAM_1_SIZE;
+
+    gd->bd->bi_dram[1].start    = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size     = gd->ram_size;
+}
+
+__weak int arch_cpu_init(void)
+{
+	return 0;
+}
+
+__weak int power_init_board(void)
+{
+	return 0;
+}
+
+	/* Record the board_init_f() bootstage (after arch_cpu_init()) */
+static int mark_bootstage(void)
+{
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");
+
+	return 0;
+}
+
+init_fnc_t *init_sequence_ram[] = {
+	arch_cpu_init,		/* basic arch cpu dependent setup */
+	mark_bootstage,
+#ifdef CONFIG_OF_CONTROL
+	fdtdec_check_fdt,
+#endif
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+	board_early_init_f,
+#endif
+	interrupt_init,         // Trego - Include timer_init
+#ifdef CONFIG_BOARD_POSTCLK_INIT
+	board_postclk_init,
+#endif
+#ifdef CONFIG_FSL_ESDHC
+	get_clocks,
+#endif
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,		/* stage 1 init of console */
+	display_banner,		/* say that we are here */
+#if defined(CONFIG_DISPLAY_CPUINFO)
+	print_cpuinfo,		/* display cpu info (and speed) */
+#endif
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+	checkboard,		/* display board info */
+#endif
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
+	init_func_i2c,
+#endif
+	display_dram_config,	/* configure available RAM banks and display it */
+	NULL,
+};
+
+void board_init_f(ulong bootflag)
+{
+	bd_t *bd;
+	gd_t *id;
+	ulong addr, addr_sp;
+#ifdef CONFIG_PRAM
+	ulong reg;
+#endif
+	void *new_fdt = NULL;
+	size_t fdt_size = 0;
+
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	gd->mon_len = (ulong)&__bss_end - (ulong)_start;
+#ifdef CONFIG_OF_EMBED
+	/* Get a pointer to the FDT */
+	gd->fdt_blob = __dtb_dt_begin;
+#elif defined CONFIG_OF_SEPARATE
+	/* FDT is at end of image */
+	gd->fdt_blob = &_end;
+#endif
+ 
+    dram_init();
+
+#ifdef CONFIG_OF_CONTROL
+	/* For now, put this check after the console is ready */
+	if (fdtdec_prepare_fdt()) {
+		panic("** CONFIG_OF_CONTROL defined but no FDT - please see "
+			"doc/README.fdt-control");
+	}
+#endif
+
+//	debug("monitor len: %08lX\n", gd->mon_len);
+	/*
+	 * Ram is setup, size stored in gd !!
+	 */
+//	debug("ramsize: %08lX\n", gd->ram_size);
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	/*
+	 * Subtract specified amount of memory to hide so that it won't
+	 * get "touched" at all by U-Boot. By fixing up gd->ram_size
+	 * the Linux kernel should now get passed the now "corrected"
+	 * memory size and won't touch it either. This should work
+	 * for arch/ppc and arch/powerpc. Only Linux board ports in
+	 * arch/powerpc with bootwrapper support, that recalculate the
+	 * memory size from the SDRAM controller setup will have to
+	 * get fixed.
+	 */
+	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
+	addr = CONFIG_SYS_SDRAM_BASE + get_effective_memsize();
+
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+	/* reserve kernel log buffer */
+	addr -= (LOGBUFF_RESERVE);
+//	debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
+//		addr);
+#endif
+#endif
+
+#ifdef CONFIG_PRAM
+	/*
+	 * reserve protected RAM
+	 */
+	reg = getenv_ulong("pram", 10, CONFIG_PRAM);
+	addr -= (reg << 10);		/* size is in kB */
+//	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
+#endif /* CONFIG_PRAM */
+
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
+	/* reserve TLB table */
+	gd->arch.tlb_size = PGTABLE_SIZE;
+	addr -= gd->arch.tlb_size;
+
+	/* round down to next 64 kB limit */
+	addr &= ~(0x10000 - 1);
+
+	gd->arch.tlb_addr = addr;
+//	debug("TLB table from %08lx to %08lx\n", addr, addr + gd->arch.tlb_size);
+#endif
+
+	/* round down to next 4 kB limit */
+	addr &= ~(4096 - 1);
+//	debug("Top of RAM usable for U-Boot at: %08lx\n", addr);
+
+#ifdef CONFIG_LCD
+#ifdef CONFIG_FB_ADDR
+	gd->fb_base = CONFIG_FB_ADDR;
+#else
+	/* reserve memory for LCD display (always full pages) */
+	addr = lcd_setmem(addr);
+	gd->fb_base = addr;
+#endif /* CONFIG_FB_ADDR */
+#endif /* CONFIG_LCD */
+
+	/*
+	 * reserve memory for U-Boot code, data & bss
+	 * round down to next 4 kB limit
+	 */
+	addr -= gd->mon_len;
+	addr &= ~(4096 - 1);
+    addr += CONFIG_SYS_TEXT_BASE & 0xFF;     // Trego - Keep original alignments since we relocate from CONFIG_SYS_TEXT_BASE
+
+//	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
+
+#ifndef CONFIG_SPL_BUILD
+	/*
+	 * reserve memory for malloc() arena
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+//	debug("Reserving %dk for malloc() at: %08lx\n",
+//			TOTAL_MALLOC_LEN >> 10, addr_sp);
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof (bd_t);
+	bd = (bd_t *) addr_sp;
+	gd->bd = bd;
+//	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
+//			sizeof (bd_t), addr_sp);
+
+#ifdef CONFIG_MACH_TYPE
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
+#endif
+
+	addr_sp -= sizeof (gd_t);
+	id = (gd_t *) addr_sp;
+//	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
+//			sizeof (gd_t), addr_sp);
+
+#if defined(CONFIG_OF_SEPARATE) && defined(CONFIG_OF_CONTROL)
+	/*
+	 * If the device tree is sitting immediate above our image then we
+	 * must relocate it. If it is embedded in the data section, then it
+	 * will be relocated with other data.
+	 */
+	if (gd->fdt_blob) {
+		fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32);
+
+		addr_sp -= fdt_size;
+		new_fdt = (void *)addr_sp;
+//		debug("Reserving %zu Bytes for FDT at: %08lx\n",
+//		      fdt_size, addr_sp);
+	}
+#endif
+
+#ifndef CONFIG_ARM64
+	/* setup stackpointer for exeptions */
+	gd->irq_sp = addr_sp;
+#ifdef CONFIG_USE_IRQ
+	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
+//	debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
+//		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);
+#endif
+	/* leave 3 words for abort-stack    */
+	addr_sp -= 12;
+
+	/* 8-byte alignment for ABI compliance */
+	addr_sp &= ~0x07;
+#else	/* CONFIG_ARM64 */
+	/* 16-byte alignment for ABI compliance */
+	addr_sp &= ~0x0f;
+#endif	/* CONFIG_ARM64 */
+#else
+	addr_sp += 128;	/* leave 32 words for abort-stack   */
+	gd->irq_sp = addr_sp;
+#endif
+
+//	debug("New Stack Pointer is: %08lx\n", addr_sp);
+
+#ifdef CONFIG_POST
+	post_bootmode_init();
+	post_run(NULL, POST_ROM | post_bootmode_get(0));
+#endif
+
+	/* Ram ist board specific, so move it to board code ... */
+
+	gd->relocaddr = addr;
+	gd->start_addr_sp = addr_sp;
+	gd->reloc_off = addr - (ulong)&_start;
+//	debug("relocation Offset is: %08lx\n", gd->reloc_off);
+	if (new_fdt) {
+		memcpy(new_fdt, gd->fdt_blob, fdt_size);
+		gd->fdt_blob = new_fdt;
+	}
+	memcpy(id, (void *)gd, sizeof(gd_t));
+}
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+static char *failed = "*** failed ***\n";
+#endif
+
+/*
+ * Tell if it's OK to load the environment early in boot.
+ *
+ * If CONFIG_OF_CONFIG is defined, we'll check with the FDT to see
+ * if this is OK (defaulting to saying it's not OK).
+ *
+ * NOTE: Loading the environment early can be a bad idea if security is
+ *       important, since no verification is done on the environment.
+ *
+ * @return 0 if environment should not be loaded, !=0 if it is ok to load
+ */
+static int should_load_env(void)
+{
+#ifdef CONFIG_OF_CONTROL
+	return fdtdec_get_config_int(gd->fdt_blob, "load-environment", 1);
+#elif defined CONFIG_DELAY_ENVIRONMENT
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+#if defined(CONFIG_DISPLAY_BOARDINFO_LATE) && defined(CONFIG_OF_CONTROL)
+static void display_fdt_model(const void *blob)
+{
+	const char *model;
+
+	model = (char *)fdt_getprop(blob, 0, "model", NULL);
+	printf("Model: %s\n", model ? model : "<unknown>");
+}
+#endif
+
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void board_init_r(gd_t *id, ulong dest_addr)
+{
+	ulong malloc_start;
+#if !defined(CONFIG_SYS_NO_FLASH)
+	ulong flash_size;
+#endif
+	init_fnc_t **init_fnc_ptr;
+
+	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");
+
+	/* Allow the early environment to override the fdt address */
+	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
+						(uintptr_t)gd->fdt_blob);
+
+	for (init_fnc_ptr = init_sequence_ram; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+	monitor_flash_len = (ulong)&__rel_dyn_end - (ulong)_start;
+
+	/* Enable caches */
+	enable_caches();
+
+	debug("monitor flash len: %08lX\n", monitor_flash_len);
+	board_init();	/* Setup chipselects */
+	/*
+	 * TODO: printing of the clock inforamtion of the board is now
+	 * implemented as part of bdinfo command. Currently only support for
+	 * davinci SOC's is added. Remove this check once all the board
+	 * implement this.
+	 */
+#ifdef CONFIG_CLOCKS
+	set_cpu_clk_info(); /* Setup clock information */
+#endif
+	serial_initialize();
+
+	debug("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
+
+#ifdef CONFIG_LOGBUFFER
+	logbuff_init_ptrs();
+#endif
+#ifdef CONFIG_POST
+	post_output_backlog();
+#endif
+
+	/* The Malloc area is immediately below the monitor copy in DRAM */
+	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
+
+#ifdef CONFIG_ARCH_EARLY_INIT_R
+	arch_early_init_r();
+#endif
+	power_init_board();
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+	puts("Flash: ");
+
+	flash_size = flash_init();
+	if (flash_size > 0) {
+# ifdef CONFIG_SYS_FLASH_CHECKSUM
+		print_size(flash_size, "");
+		/*
+		 * Compute and print flash CRC if flashchecksum is set to 'y'
+		 *
+		 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
+		 */
+		if (getenv_yesno("flashchecksum") == 1) {
+			printf("  CRC: %08X", crc32(0,
+				(const unsigned char *) CONFIG_SYS_FLASH_BASE,
+				flash_size));
+		}
+		putc('\n');
+# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
+		print_size(flash_size, "\n");
+# endif /* CONFIG_SYS_FLASH_CHECKSUM */
+	} else {
+		puts(failed);
+		hang();
+	}
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+	puts("NAND:  ");
+	nand_init();		/* go init the NAND */
+#endif
+
+#if defined(CONFIG_CMD_ONENAND)
+	onenand_init();
+#endif
+
+
+#ifdef CONFIG_HAS_DATAFLASH
+	AT91F_DataflashInit();
+	dataflash_print_info();
+#endif
+
+	/* initialize environment */
+	if (should_load_env())
+		env_relocate();
+	else
+		set_default_env(NULL);
+
+#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
+	arm_pci_init();
+#endif
+
+	stdio_init();	/* get the devices list going. */
+
+	jumptable_init();
+
+#if defined(CONFIG_API)
+	/* Initialize API */
+	api_init();
+#endif
+
+	console_init_r();	/* fully init console as a device */
+
+#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
+# ifdef CONFIG_OF_CONTROL
+	/* Put this here so it appears on the LCD, now it is ready */
+	display_fdt_model(gd->fdt_blob);
+# else
+	checkboard();
+# endif
+#endif
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+	/* miscellaneous arch dependent initialisations */
+	arch_misc_init();
+#endif
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r();
+#endif
+
+	 /* set up exceptions */
+	interrupt_init();
+	/* enable exceptions */
+	enable_interrupts();
+
+	/* Initialize from environment */
+	load_addr = getenv_ulong("loadaddr", 16, load_addr);
+
+#ifdef CONFIG_BOARD_LATE_INIT
+	board_late_init();
+#endif
+
+// Trego - MMC Must be after enable_interrupts
+#ifdef CONFIG_GENERIC_MMC
+	puts("MMC:   ");
+	mmc_initialize(gd->bd);
+#endif
+
+#ifdef CONFIG_CMD_SCSI
+	puts("SCSI:  ");
+	scsi_init();
+#endif
+
+#ifdef CONFIG_BITBANGMII
+	bb_miiphy_init();
+#endif
+#if defined(CONFIG_CMD_NET)
+	puts("Net:   ");
+	eth_initialize();
+#if defined(CONFIG_RESET_PHY_R)
+	debug("Reset Ethernet PHY\n");
+	reset_phy();
+#endif
+#endif
+
+#ifdef CONFIG_POST
+	post_run(NULL, POST_RAM | post_bootmode_get(0));
+#endif
+
+#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
+	/*
+	 * Export available size of memory for Linux,
+	 * taking into account the protected RAM at top of memory
+	 */
+	{
+		ulong pram = 0;
+		uchar memsz[32];
+
+#ifdef CONFIG_PRAM
+		pram = getenv_ulong("pram", 10, CONFIG_PRAM);
+#endif
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+		/* Also take the logbuffer into account (pram is in kB) */
+		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
+#endif
+#endif
+		sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
+		setenv("mem", (char *)memsz);
+	}
+#endif
+
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
old mode 100644
new mode 100755
index c65e068..defe9c9
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -96,7 +96,7 @@ static inline void mmu_setup(void)
 		dram_bank_mmu_setup(i);
 	}
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)     // Trego - need to check the following TLB change
 	/* Set TTBR0 */
 	reg = gd->arch.tlb_addr & TTBR0_BASE_ADDR_MASK;
 #if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
diff --git a/arch/arm/lib/cache-pl310.c b/arch/arm/lib/cache-pl310.c
old mode 100644
new mode 100755
index 1ad1f8a..a1fe32d
--- a/arch/arm/lib/cache-pl310.c
+++ b/arch/arm/lib/cache-pl310.c
@@ -39,6 +39,11 @@ static void pl310_background_op_all_ways(u32 *op_reg)
 	pl310_cache_sync();
 }
 
+void set_pl310_ctrl(u32 enable)
+{
+	writel(enable, &pl310->pl310_ctrl);
+}
+
 void v7_outer_cache_inval_all(void)
 {
 	pl310_background_op_all_ways(&pl310->pl310_inv_way);
diff --git a/board/nuvoton/HermonSVB/HermonSVB_init.c b/board/nuvoton/HermonSVB/HermonSVB_init.c
new file mode 100755
index 0000000..282ccfb
--- /dev/null
+++ b/board/nuvoton/HermonSVB/HermonSVB_init.c
@@ -0,0 +1,63 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+
+    printf("RomCode : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+
+    return 0;
+}
+
+
+
diff --git a/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S b/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
new file mode 100755
index 0000000..39749b4
--- /dev/null
+++ b/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
@@ -0,0 +1,800 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_low_level_init.S                                                                            */
+/*            This file contains WPCM450 low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include <config.h>
+#include <version.h>
+
+
+
+
+
+
+.globl board_lowlevel_init
+board_lowlevel_init:
+
+/*      
+;----------------------------------------------------------
+; Disable Interrupt, This is for safe ...
+;----------------------------------------------------------
+*/
+    LDR     r0, =AIC_MDCR
+    LDR     r1, =AIC_MASKALL
+    STR     r1, [r0]
+    MRS     r0, CPSR
+    ORR     r0, r0, #0xC0
+    MSR     CPSR_c, r0
+
+/*
+;----------------------------------------------------------
+; Set mode to SVC, interrupts disabled (just paranoid)
+;----------------------------------------------------------
+*/
+    MRS   r0, cpsr
+    BIC   r0, r0, #0xF0000000
+    BIC   r0, r0, #0x1F
+    ORR   r0, r0, #0xD3
+    MSR   cpsr_fc, r0
+
+    
+/*
+;----------------------------------------------------------
+; If Watchdog Reset was set and code arrive to this point
+; that mean FIU work properly . In this case flag bit in 
+; INTCR2 register and Watchdog Register must be reset to
+; to default values.
+;----------------------------------------------------------
+*/
+    LDR   r0, =TMR_WTCR
+    LDR   r1, [r0]
+    TST   r1, #0x2
+    BEQ   _POR_Reset_Detect
+    MOV   r1, #0x400
+    STR   r1, [r0]
+    LDR   r0, =GCR_INTCR2
+    LDR   r1, [r0]
+    BIC   r1, r1, #0x80000000
+    STR   r1, [r0]
+
+    
+    
+_POR_Reset_Detect:      
+/*
+;----------------------------------------------------------     
+; If (INTCR2.30 == 0)   can be 0 only after POR reset
+;       INTCR2.29 = 1;      coming from POR reset
+; else
+;       INTCR2.29 = 0;      coming from Watchdog/Software reset
+; INTCR2.30 = 1;        set the indication that will be cleared only at POR reset
+;----------------------------------------------------------
+*/
+
+    LDR   r0,=GCR_INTCR2
+    LDR   r1,[r0]
+    TST   r1,#0x40000000
+    ORREQ r1,r1,#0x20000000
+    BICNE r1,r1,#0x20000000
+    ORR   r1,r1, #0x40000000
+
+
+/*
+;----------------------------------------------------------     
+;Stack initialisation
+;----------------------------------------------------------
+*/
+    MSR   CPSR_c, #Mode_SYS | F_Bit 
+    LDR   sp, = top_of_usr_stack 
+
+    LDR   r0, = Top_Of_Stacks 
+      
+    MSR   CPSR_c, #Mode_FIQ | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_FIQ_Stack 
+
+    MSR   CPSR_c, #Mode_IRQ | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_IRQ_Stack 
+
+    MSR   CPSR_c, #Mode_ABT | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_ABT_Stack 
+
+    MSR   CPSR_c, #Mode_UND | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_UND_Stack 
+
+    MSR   CPSR_c, #Mode_SVC | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_SVC_Stack 
+
+
+    MOV   r0,pc
+    AND   r0,r0,#0x40000000
+    CMP   r0,#0
+    BEQ   mc_init_end
+    
+/************************************************************************/
+/*   Init Clocks                                                        */
+/************************************************************************/
+
+        
+/************************************************************************/
+/*  Read STRAP clock configuration                                      */
+/************************************************************************/
+/* idx1 = GET_FIELD(power_cfg, PWRON_CPU_CORE_CLK);                     */
+/************************************************************************/
+    LDR   r8, =GCR_BA
+	/* if clock source is not 48MHz, skip initialization as it
+	   was done by ROM code */
+	LDR   r1, [r8, #0x204]
+	mov   r1, r1, lsl #29
+	mov   r1, r1, lsr #29
+	mov   r2, #0x2
+	cmp   r1, r2
+	bne   end_clk_init
+    LDR   r0,[r8,#4]             /* Read PWRON register */
+    MOVS  r2, r0, LSL #21
+    MOVS  r2, r2, LSR #29
+          
+           
+/************************************************************************/    
+/* if(idx1 != CLK_BYPASS_MODE)                                          */
+/************************************************************************/
+    BEQ      clk_bypass_mode_init
+
+    ADD      r7,pc,#0
+    B        clk_init_func
+/************************************************************************/
+/* PLL Clock Divider + PLLCON configurayion values                      */
+/************************************************************************/
+clk_div_pll0con_reg_val:
+.word  CLK_180MHZ_DIV_REG_CFG, CLK_180MHZ_PLLCON_REG_CFG
+.word  CLK_133MHZ_DIV_REG_CFG, CLK_133MHZ_PLLCON_REG_CFG
+.word  CLK_250MHZ_DIV_REG_CFG, CLK_250MHZ_PLLCON_REG_CFG
+.word  CLK_160MHZ_DIV_REG_CFG, CLK_250MHZ_PLLCON_REG_CFG
+.word  CLK_220MHZ_DIV_REG_CFG, CLK_220MHZ_PLLCON_REG_CFG
+.word  CLK_125MHZ_DIV_REG_CFG, CLK_125MHZ_PLLCON_REG_CFG
+.word  CLK_200MHZ_DIV_REG_CFG, CLK_200MHZ_PLLCON_REG_CFG
+
+clk_init_func:
+/***********************************************************************
+ *                                                                     *
+ *   Clock configuration arrays not contain                            *
+ *   BY_PASS mode configuration values                                 *
+ *   idx1 -= 1;                                                        *
+ ***********************************************************************/
+
+    SUB      r4,r2,#1
+
+/************************************************************************/
+/*   SET_BIT(CLK_PLLCON0,CLK_PRST_BIT);                                 */
+/************************************************************************/
+;
+;	LDR   r2, [r8, #0x20c]
+;	orr   r2, r2, #0x2000
+;	str   r2, [r8, #0x20c]
+;
+
+/************************************************************************/          
+/*   CLK_PLLCON0 = CLK_PLLCON_REG_Val[idx1];                            */
+/************************************************************************/
+    ADD      r9,r7,#4
+    LDR      r2,[r9,r4,LSL #3]
+    STR      r2,[r8,#0x20c]
+          
+    
+/************************************************************************/  
+/*   Wait Loop                                                          */
+/*   WAIT_DELAY(idx2, DELAY_10_MICRO_SEC);                              */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#20
+wait_pll0_10micro:
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_pll0_10micro
+         
+/************************************************************************/          
+/*   CLEAR_BIT(CLK_PLLCON0,CLK_PRST_BIT);                               */
+/************************************************************************/
+    LDR      r1,[r8,#0x20c]
+    BIC      r1,r1,#0x2000
+    STR      r1,[r8,#0x20c]
+          
+/************************************************************************/   
+/*   Wait Loop                                                          */
+/*   WAIT_DELAY(idx2, DELAY_500_MICRO_SEC);                             */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#1000
+wait_resset_500micro:
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_resset_500micro
+          
+    
+      
+/************************************************************************/
+/* Set clock divider accordingly setted PLL configuration               */
+/************************************************************************/
+/*   CLK_DIV     = CLK_DIV_REG_Val[idx1];                               */
+/************************************************************************/
+    LDR      r1,[r7,r4,LSL #3]
+    STR      r1,[r8,#0x208]
+
+/************************************************************************/    
+/*   Wait Loop 200 cycles                                               */
+/*   WAIT_DELAY(idx2, DELAY_10_MICRO_SEC);                              */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#20
+wait_div_10micro:      
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_div_10micro
+          
+            
+/************************************************************************/
+/* Set clock sources selection to PLLCON0                               */
+/************************************************************************/
+/*   SET_FIELD(CLK_SEL,CLK_CPU_CLK, CLK_PLL0_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#3
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/*   SET_FIELD(CLK_SEL,CLK_CPU_OUT, CLK_PLL0_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1, r1, #0xc
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/*   SET_FIELD(CLK_SEL,CLK_PIX_SRC, CLK_PIX_PLL_GFX_SEL );              */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#0x30
+    STR      r1, [r8, #0x204]
+
+    B        end_clk_init
+
+clk_bypass_mode_init:
+
+/************************************************************************/
+/* By pass mode                                                         */
+/* Bypass mode: Core clock from reference clock PWM3/GPIO83 pin as      */
+/* input and pixel clock from GPI96. Reference clock 24 MHz and the SPI */
+/* clock is 3 MHz by default register values.                           */
+/************************************************************************/
+/*   SET_BIT(MFSEL2, MF_PWM3SEL_BIT);                                   */
+/*   SET_FIELD(CLK_SEL,CLK_CPU_CLK, CLK_PWM3_GPIO83_SRC_SEL);           */
+/*   CLEAR_BIT(MFSEL1, MF_CLKOSEL_BIT);                                 */
+/*   SET_FIELD(CLK_SEL,CLK_PIX_SRC, CLK_PIX_GPI96_SEL );                */
+/************************************************************************/
+           
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/* }                                                                    */
+/* SET_FIELD(CLK_SEL,CLK_USB1CKSEL, CLK_PLL1_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#0xc0
+    ORR      r1,r1,#0x40
+    STR      r1,[r8,#0x204]
+        
+/************************************************************************/
+/* Set HUART clock source to 24Mhz                                      */
+/************************************************************************/
+/*  SET_BIT(CLK_SEL, CLK_HUART_SRC_BIT);                                */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    ORR      r1,r1,#0x400
+    STR      r1,[r8,#0x204]
+
+
+
+    
+end_clk_init:    
+/*
+;----------------------------------------------------------
+; --- Init Memory Controller
+;----------------------------------------------------------
+*/
+    
+/************************************************************************/
+/*  idx1 is RAM size index                                              */
+/************************************************************************/
+/*     idx1 = GET_FIELD(power_cfg, PWRON_RAM_SIZE);                     */
+/************************************************************************/
+    LDR   r8, =GCR_BA
+    LDR   r0,[r8,#4]             /* Read PWRON register */
+    
+    MOV   r2,r0,LSL #28
+    MOV   r1,r2,LSR #30 
+    
+/************************************************************************/
+/* Release memory Controller from reset by                              */
+/* clearing Memory Controller reset bit                                 */
+/************************************************************************/
+/*        if(idx1 == MEM_128MB_MODE)                                    */
+/*        {                                                             */
+/*          SET_BIT(MFSEL1, MF_MBEN_BIT);                               */
+/*        }                                                             */
+/************************************************************************/
+    CMP   r1,#1 
+    LDREQ r2,[r8,#0xc]
+    ORREQ r2,r2,#0x4000000
+    STREQ r2,[r8,#0xc]
+
+/************************************************************************/     
+/*        CLEAR_BIT(CLK_IPSRST,CLK_IPSRST_MC_BIT);                      */
+/************************************************************************/
+    LDR   r9, =CLK_BA
+    LDR   r2,[r9,#0x20]
+    BIC   r2,r2,#0x1000
+    STR   r2,[r9,#0x20]
+
+/************************************************************************/
+/*        Wait Loop  500 micro sec                                      */
+/************************************************************************/
+
+    MOV   r2,#0
+    
+start_wait_loop:
+   CMP      r2,#0x500
+   ADD      r2,r2,#1
+   BNE      start_wait_loop
+
+
+/************************************************************************/
+/*  Save MC Config Table base Addr                                      */
+/************************************************************************/
+   ADD      r7,pc,#0
+   B        mc_init_func
+
+
+   
+mc_128M_cfg:
+
+         /* 180 MHz    133 MHz     250 MHz     160MHz      220 MHz     125MHz      200 MHz  */
+.word    0x241B457C, 0x2312240E, 0x3624079E, 0x239AA4E0, 0x362406B4, 0x231223CE, 0x241B4618
+.word    0x22162323, 0x21162223, 0x22162424, 0x22162323, 0x22162424, 0x21162223, 0x22162323
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0xA,        0x7,        0xD,        0x8,        0xD,        0x7,        0xA
+.word    0x00190202
+.word    0x00000000
+.word    0x00000001
+.word    0x00000023
+.word    0x00000005
+.word    0x2A,       0x1E,       0x30,       0x24,       0x30,       0x1E,       0x2A
+.word    0x00000001
+.word    0x00000064
+.word    0x00000000
+.word    0x00000064
+.word    0x00000000
+.word    0x000001B8
+.word    0x00000005
+.word    0x0000000C
+.word    0x00000000
+.word    0x00000002
+.word    0x00000002
+.word    0x00000004
+.word    0x00000004
+.word    0x00010106
+.word    0x00000106
+    
+mc_64M_cfg:
+
+    /* 180 MHz     133 MHz     250 MHz     160MHz      220 MHz    125MHz      200 MHz  */
+.word    0x241AA57C, 0x2311C40E, 0x3623679E, 0x239A24E0, 0x362366B4, 0x2311C3CE, 0x241AA618
+.word    0x22122323, 0x21122223, 0x22122424, 0x22122323, 0x22122424, 0x21122223, 0x22122323
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0xA,        0x7,        0xD,        0x8,        0xD,        0x7,        0xA 
+.word    0x550202
+.word    0x0
+.word    0x1
+.word    0x23
+.word    0x5
+.word    0x2A,       0x1E,       0x30,       0x24,       0x30,       0x1E,       0x2A
+.word    0x1
+.word    0x64
+.word    0x0
+.word    0x64
+.word    0x0
+.word    0x1B8
+.word    0x5
+.word    0xC
+.word    0x0
+.word    0x2
+.word    0x2
+.word    0x4
+.word    0x4
+.word    0x00010106
+.word    0x00000106
+    
+mc_32M_cfg:
+
+.word    /*180 MHz     133 MHz     250 MHz     160MHz      220 MHz     125MHz      200 MHz   */
+.word    0x249B857C, 0x2312A40E, 0x3624E79E, 0x241B24E0, 0x352466B4, 0x231283CE, 0x249BE618
+.word    0x220E2324, 0x210E2224, 0x220E2424, 0x220E2324, 0x220E2424, 0x110E2224, 0x220E2324
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0x9,        0x7,        0xD,        0x8,        0xB,        0x7,        0xA
+.word    0x310202
+.word    0x0
+.word    0x1
+.word    0x23
+.word    0x5
+.word    0x30,       0x1E,       0x30,       0x24,       0x30,       0x1E,      0x30
+.word    0x1
+.word    0x64
+.word    0x0
+.word    0x64
+.word    0x0
+.word    0x1B8
+.word    0x5
+.word    0xC
+.word    0x0
+.word    0x2
+.word    0x2
+.word    0x4
+.word    0x4
+.word    0x00010106
+.word    0x00000106
+
+
+mc_init_func:          
+/************************************************************************/
+/*  idx2 is clock frequency index                                       */
+/************************************************************************/
+/* idx2 = GET_FIELD(power_cfg, PWRON_CPU_CORE_CLK);                     */
+/*  idx2 -= 1;    Clock Bypass Mode not present in Config table         */
+
+    MOV   r2,r0,LSL #21              /* Get STRAP 9-11 value bits 8-10 */
+    MOV   r2,r2,LSR #29
+    SUB   r2,r2,#1
+
+    CMP   r1,#RAM_SIZE_128M
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+
+    CMP   r1,#RAM_SIZE_64M
+    ADDEQ r7, r7, #0xe0
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+
+    CMP   r1,#RAM_SIZE_32M
+    ADDEQ r7, r7, #0x1c0
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+        
+    MOV   r3, #mc_128M_cfg
+    
+start_mc_init:
+
+    LDR   r6, =MC_BA       /* r6 - base address MC Configuration registers */
+    ADD   r5,r3,r2,LSL #2  /* idx2 *= 4; create clock index shift value */
+
+
+/************************************************************************/
+/*        MC_CFG0     = MC_Cfg[idx1].mc_cfg0[idx2];                     */
+/************************************************************************/
+    LDR      r4,[r5,#0]
+    STR      r4,[r6,#0]
+/************************************************************************/
+/*        MC_CFG1     = MC_Cfg[idx1].mc_cfg1[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x1c]
+    STR      r4,[r6,#4]
+/************************************************************************/
+/*        MC_CFG2     = MC_Cfg[idx1].mc_cfg2[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x38]
+    STR      r4,[r6,#8]
+/************************************************************************/
+/*        MC_CFG3     = MC_Cfg[idx1].mc_cfg3;
+/************************************************************************/
+    LDR      r4,[r3,#0x54]
+    STR      r4,[r6,#0xc]
+/************************************************************************/
+/*        MC_CFG4     = MC_Cfg[idx1].mc_cfg4[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x58]
+    STR      r4,[r6,#0x10]
+/************************************************************************/
+/*        MC_CFG5     = MC_Cfg[idx1].mc_cfg5;
+/************************************************************************/
+    LDR      r4,[r3,#0x74]
+    STR      r4,[r6,#0x14]
+/************************************************************************/
+/*        MC_CFG6     = MC_Cfg[idx1].mc_cfg6;
+/************************************************************************/
+    LDR      r4,[r3,#0x78]
+    STR      r4,[r6,#0x18]
+/************************************************************************/
+/*        MC_P1_ARBT  = MC_Cfg[idx1].mc_p1_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0x80]
+    STR      r4,[r6,#0x24]
+/************************************************************************/
+/*        MC_P1_CNT   = MC_Cfg[idx1].mc_p1_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0x84]
+    STR      r4,[r6,#0x20]
+/************************************************************************/
+/*        MC_P2_ARBT  = MC_Cfg[idx1].mc_p2_arbt[idx2];
+/************************************************************************/
+	LDR      r4, [r5, #0x88]
+    STR      r4,[r6,#0x2c]
+/************************************************************************/
+/*        MC_P2_CNT   = MC_Cfg[idx1].mc_p2_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xa4]
+    STR      r4,[r6,#0x28]
+/************************************************************************/
+/*        MC_P3_ARBT  = MC_Cfg[idx1].mc_p3_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xa8]
+    STR      r4,[r6,#0x34]
+/************************************************************************/
+/*        MC_P3_CNT   = MC_Cfg[idx1].mc_p3_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xac]
+    STR      r4,[r6,#0x30]
+/************************************************************************/
+/*        MC_P4_ARBT  = MC_Cfg[idx1].mc_p4_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb0]
+    STR      r4,[r6,#0x3c]
+/************************************************************************/
+/*        MC_P4_CNT   = MC_Cfg[idx1].mc_p4_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb4]
+    STR      r4,[r6,#0x38]
+/************************************************************************/
+/*        MC_P5_ARBT  = MC_Cfg[idx1].mc_p5_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb8]
+    STR      r4,[r6,#0x44]
+/************************************************************************/
+/*        MC_P5_CNT   = MC_Cfg[idx1].mc_p5_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xbc]
+    STR      r4,[r6,#0x40]
+/************************************************************************/
+/*        MC_P6_ARBT  = MC_Cfg[idx1].mc_p6_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xc0]
+    STR      r4,[r6,#0x4c]
+/************************************************************************/
+/*        MC_P6_CNT   = MC_Cfg[idx1].mc_p6_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xc4]
+    STR      r4,[r6,#0x48]
+/************************************************************************/
+/*        MC_P1_INCRS = MC_Cfg[idx1].mc_p1_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xc8]
+    STR      r4,[r6,#0x50]
+/************************************************************************/
+/*        MC_P2_INCRS = MC_Cfg[idx1].mc_p2_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xcc]
+    STR      r4,[r6,#0x54]
+/************************************************************************/
+/*        MC_P3_INCRS = MC_Cfg[idx1].mc_p3_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xd0]
+    STR      r4,[r6,#0x58]
+/************************************************************************/
+/*        MC_P4_INCRS = MC_Cfg[idx1].mc_p4_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xd4]
+    STR      r4,[r6,#0x5c]
+/************************************************************************/
+/*        MC_DLL_0    = MC_Cfg[idx1].mc_dll_0;
+/************************************************************************/
+    LDR      r4,[r3,#0xd4]
+    
+	/* on A1 chip, also set the DQSI_ENDLY bit */
+	LDR   r9, =GCR_BA
+	LDR   r9, [r9]
+	mov   r9, r9, lsr #24
+	mov   r10, #0x8
+	cmp   r9, r10
+	orrge r4, #0x400
+    STR      r4,[r6,#0x60]
+
+/************************************************************************/
+/*        MC_DLL_1    = MC_Cfg[idx1].mc_dll_1;
+/************************************************************************/
+	LDR   r4, [r3, #0xdc]
+    STR      r4,[r6,#0x64] 
+
+
+mc_init_end: 
+/*
+;----------------------------------------------------------
+; Handle Watchdog Reset    
+;----------------------------------------------------------        
+*/
+    LDR      r6, =TIMER_BA     
+    LDR      r4, [r6, #0x1c]
+    TST      r4, #0x2
+    MOVEQ    r4, #0x400 
+    STREQ    r4, [r6, #0x1c]
+   
+   
+/*
+;----------------------------------------------------------
+; Set the high exception vector of CP15 control bit    
+;----------------------------------------------------------        
+*/
+    MRC     p15, 0, r0, c1, c0, 0  /* read control register  */       
+    BIC     r0, r0, #0x2000        /* clear bit 13           */        
+    MCR     p15, 0, r0, c1, c0, 0  /* write control register */
+/*
+;----------------------------------------------------------
+; --- back to arch calling code 
+;----------------------------------------------------------
+*/
+    MOV     pc,     lr
+
+/* the literal pools origin */
+        .ltorg
+
+
+/*----------------------------------------------------------
+ *  WPCS410 platform definitions
+ *----------------------------------------------------------
+ */
+
+/*
+;----------------------------------------------------------
+; --- Standard definitions of mode bits and interrupt (I & F) flags in PSRs
+;----------------------------------------------------------
+*/
+.equ Mode_USR,             0x10
+.equ Mode_FIQ,             0x11
+.equ Mode_IRQ,             0x12
+.equ Mode_SVC,             0x13
+.equ Mode_ABT,             0x17
+.equ Mode_UND,             0x1B
+.equ Mode_SYS,             0x1F /* available on ARM Arch 4 and later*/
+
+.equ I_Bit,                0x80 /* when I bit is set, IRQ is disabled*/
+.equ F_Bit,                0x40 /* when F bit is set, FIQ is disabled*/
+
+/*
+;----------------------------------------------------------
+; --- Stack memory locations
+;----------------------------------------------------------
+*/
+
+/*
+;----------------------------------------------------------
+; Stack's length
+;----------------------------------------------------------
+*/
+.equ Len_FIQ_Stack,             256
+.equ Len_IRQ_Stack,             256
+.equ Len_SVC_Stack,             1024
+.equ Len_ABT_Stack,             256
+.equ Len_UND_Stack,             256
+.equ Len_SYS_Stack,             256
+
+/*
+;----------------------------------------------------------
+; Stack's offset
+;----------------------------------------------------------
+*/
+.equ Offset_FIQ_Stack,    0
+.equ Offset_IRQ_Stack,    Offset_FIQ_Stack + Len_FIQ_Stack 
+.equ Offset_ABT_Stack,    Offset_IRQ_Stack + Len_ABT_Stack  
+.equ Offset_UND_Stack,    Offset_ABT_Stack + Len_UND_Stack  
+.equ Offset_SVC_Stack,    Offset_UND_Stack + Len_SVC_Stack 
+
+.equ Size_Of_Stack,       Offset_SVC_Stack
+  
+      
+/*
+;----------------------------------------------------------
+; AIC Control Registers
+;----------------------------------------------------------
+*/
+.equ AIC_BA,            0xB8002000
+.equ AIC_MDCR,                  AIC_BA+0x124    /* W90P410 AIC Mask Disable Control Register */
+.equ AIC_MASKALL,           0xFFFFFFFE
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ GCR_BA,             0xB0000000
+.equ GCR_INTCR2,         GCR_BA + 0x060 
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ CLK_BA,             0xB0000200
+
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ MC_BA,             0xB0001000
+.equ RAM_SIZE_128M,     0x01
+.equ RAM_SIZE_64M,      0x02
+.equ RAM_SIZE_32M,      0x03
+
+
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ TIMER_BA,             0xB8001000
+.equ TMR_WTCR,             TIMER_BA + 0x01C
+
+
+/*
+;----------------------------------------------------------
+; Stack's base location
+;----------------------------------------------------------
+*/
+
+/*
+    IMPORT      Top_Of_Stacks
+    IMPORT      top_of_usr_stack
+*/
+.equ Top_Of_Stacks,     0x1FF0
+.equ top_of_usr_stack,  0x80000
+
+/************************************************************************/
+/* CLOCK DEVIDERS REGISTER CONFIGURATIONS                               */
+/************************************************************************/
+.equ CLK_125MHZ_DIV_REG_CFG,     0x04010300
+.equ CLK_133MHZ_DIV_REG_CFG,     0x05010200
+.equ CLK_160MHZ_DIV_REG_CFG,     0x05010200
+.equ CLK_180MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_200MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_220MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_250MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_BYPASS_DIV_REG_CFG,     0x05010300
+
+
+/************************************************************************/
+/* CLOCK PLL0 REGISTER CONFIGURATIONS                                   */
+/************************************************************************/
+
+.equ CLK_125MHZ_PLLCON_REG_CFG,  0x007C210B
+.equ CLK_133MHZ_PLLCON_REG_CFG,  0x00632108
+.equ CLK_160MHZ_PLLCON_REG_CFG,  0x00272005
+.equ CLK_180MHZ_PLLCON_REG_CFG,  0x002C2005
+.equ CLK_200MHZ_PLLCON_REG_CFG,  0x00312005
+.equ CLK_220MHZ_PLLCON_REG_CFG,  0x00362005
+.equ CLK_250MHZ_PLLCON_REG_CFG,  0x007C200B
+
+/************************************************************************/
+/* Clock Source selection                                               */
+/************************************************************************/
+.equ CLK_PLL0_SRC_SEL,           0x00
+.equ CLK_PLL1_SRC_SEL,           0x01
+.equ CLK_48M_SRC_SEL,            0x02
+.equ CLK_PWM3_GPIO83_SRC_SEL,    0x03
+
+/************************************************************************/
+/* Pixel Clock Source Select Bits                                       */
+/************************************************************************/
+.equ CLK_PIX_PLL_GFX_SEL,        0x00
+.equ CLK_PIX_GPI96_SEL,          0x01
+.equ CLK_PIX_48M_SEL,            0x02  
diff --git a/board/nuvoton/HermonSVB/Makefile b/board/nuvoton/HermonSVB/Makefile
new file mode 100755
index 0000000..e32800f
--- /dev/null
+++ b/board/nuvoton/HermonSVB/Makefile
@@ -0,0 +1,27 @@
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= HermonSVB_init.o ../common/BMC_HAL/Boards/board.o
+SOBJS	:= HermonSVB_low_level_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	.local_dep $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+.local_dep:
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Boards
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Chips
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+
+#########################################################################
diff --git a/board/nuvoton/HermonSVB/config.mk b/board/nuvoton/HermonSVB/config.mk
new file mode 100755
index 0000000..ec30fca
--- /dev/null
+++ b/board/nuvoton/HermonSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(TOPDIR)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=wpcm450
diff --git a/board/nuvoton/PolegSVB/Kconfig b/board/nuvoton/PolegSVB/Kconfig
new file mode 100755
index 0000000..f34eca3
--- /dev/null
+++ b/board/nuvoton/PolegSVB/Kconfig
@@ -0,0 +1,18 @@
+if TARGET_NPCM750
+
+config SYS_BOARD
+	default "PolegSVB"
+
+config SYS_VENDOR
+	default "nuvoton"
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_SOC
+	default "npcm750"
+
+config SYS_CONFIG_NAME
+	default "PolegSVB"
+
+endif
diff --git a/board/nuvoton/PolegSVB/Makefile b/board/nuvoton/PolegSVB/Makefile
new file mode 100755
index 0000000..8a3fad1
--- /dev/null
+++ b/board/nuvoton/PolegSVB/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= PolegSVB_init.o PolegSVB_low_level_init.o ../common/BMC_HAL/Boards/board.o cmd_usb_device.o
diff --git a/board/nuvoton/PolegSVB/PolegSVB_init.c b/board/nuvoton/PolegSVB/PolegSVB_init.c
new file mode 100755
index 0000000..6408b66
--- /dev/null
+++ b/board/nuvoton/PolegSVB/PolegSVB_init.c
@@ -0,0 +1,79 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "../common/BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+    #define BOOTER_VER      *((PTR32)(BOOTER_VER_ADDR))
+
+    printf("RomCode   : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+    printf("BootBlock : v%02x.%02x.%02x.%02x\n", MSB0(BOOTER_VER),  MSB1(BOOTER_VER),  MSB2(BOOTER_VER),  MSB3(BOOTER_VER));
+
+    printf("\n");
+
+    printf("PolegSVB Power-On Straps = 0x%x\n",(unsigned int)*((PTR32)(GCR_BASE_ADDR + 0x004)));
+
+    if (STRP_SecureBoot_On())
+    {
+        printf("Security: ENABLED, running in secure mode\n");
+    }
+    else
+    {
+        printf("Security: DISABLED, running in non-secure mode\n");
+    }
+
+    return 0;
+}
+
+
diff --git a/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S b/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
new file mode 100755
index 0000000..d7335a8
--- /dev/null
+++ b/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB_low_level_init.S                                                                            */
+/*            This file contains NPCM750 low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <version.h>
+#include <linux/linkage.h>
+
+ENTRY(board_lowlevel_init)
+
+	/*
+	 * Setup a temporary stack
+	 */
+	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR
+	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
+	sub	sp, #GD_SIZE
+	bic	sp, sp, #7
+	mov	r9, sp
+
+	/*
+	 * Save the old lr(passed in ip) and the current lr to stack
+	 */
+	push	{ip, lr}
+
+	/*
+	 *  Invalidate l2-Cache 
+	 */
+	bl	v7_outer_cache_inval_all
+	
+	pop	{ip, pc}
+
+ENDPROC(board_lowlevel_init)
+
+
diff --git a/board/nuvoton/PolegSVB/cmd_usb_device.c b/board/nuvoton/PolegSVB/cmd_usb_device.c
new file mode 100755
index 0000000..da8bad6
--- /dev/null
+++ b/board/nuvoton/PolegSVB/cmd_usb_device.c
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * Cache support: switch on or off, get status
+ */
+#include <common.h>
+#include <command.h>
+#include <linux/compiler.h>
+
+
+
+int do_usb_device(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	uint32_t device_number = 0;
+	uint32_t *pAppAddr __attribute__((unused));
+
+	if(argc > 1)
+	{
+		device_number = (argv[1][0]) - '0';
+		if(device_number > 9)
+		{
+                printf( " Invalid device number\n" );
+				return 0;
+		}
+	}
+	
+    printf( " running device %d \n",  device_number);
+	
+	*((volatile uint32_t *)(0x7000)) = 0xa5b6c7d8;
+	*((volatile uint32_t *)(0x7004)) = device_number;
+
+	pAppAddr= (uint32_t *)(0x8000);     // load bin address
+
+	// jump to application
+	asm volatile(	"ldr r0,%[addr] \n"
+    				"bx r0 \n"
+    				: :[addr]"m"(pAppAddr):"memory");
+	
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	usb_device,   2,   1,     do_usb_device,
+	"usb device test",
+	"<device_num>"
+);
diff --git a/board/nuvoton/PolegSVB/config.mk b/board/nuvoton/PolegSVB/config.mk
new file mode 100755
index 0000000..99640aa
--- /dev/null
+++ b/board/nuvoton/PolegSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(srctree)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=npcm750
diff --git a/board/nuvoton/YarkonSVB/Makefile b/board/nuvoton/YarkonSVB/Makefile
new file mode 100755
index 0000000..7eac1c3
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/Makefile
@@ -0,0 +1,26 @@
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= YarkonSVB_init.o ../common/BMC_HAL/Boards/board.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	.local_dep $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+.local_dep:
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Boards
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Chips
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+
+#########################################################################
diff --git a/board/nuvoton/YarkonSVB/YarkonSVB_init.c b/board/nuvoton/YarkonSVB/YarkonSVB_init.c
new file mode 100755
index 0000000..32e6ba9
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/YarkonSVB_init.c
@@ -0,0 +1,77 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+    #define BOOTER_VER      *((PTR32)(0x40000204))
+
+    printf("RomCode : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+    printf("Booter  : v%02x.%02x.%02x.%02x\n", MSB0(BOOTER_VER),  MSB1(BOOTER_VER),  MSB2(BOOTER_VER),  MSB3(BOOTER_VER));
+
+    printf("\n");
+
+    if (STRP_Strap19_On())
+    {
+        printf("Security: ENABLED, running in secure mode\n");
+    }
+    else
+    {
+        printf("Security: DISABLED, running in non-secure mode\n");
+    }
+
+    return 0;
+}
+
+
diff --git a/board/nuvoton/YarkonSVB/config.mk b/board/nuvoton/YarkonSVB/config.mk
new file mode 100755
index 0000000..0d50543
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(TOPDIR)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=npcm650
diff --git a/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.c b/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.c
new file mode 100755
index 0000000..02eac2c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.c
@@ -0,0 +1,364 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   cmac_aes.c                                                                                            */
+/*      This file contains Cipher-based Message Authentication Code (CMAC)                                 */
+/*      algorithm module.                                                                                  */
+/*      The algorithm is specified by the National Institute of Standards and                              */
+/*      Technology (NIST) Special Publication 800-38B.                                                     */
+/* Project:                                                                                                */
+/*      BMC HAL                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AES_CMAC_C
+
+#ifndef NO_LIBC
+#include <string.h>
+#endif
+
+#include "../../Modules/aes/aes_if.h"
+#include "cmac_aes.h"
+
+/* R  - Constant string for subkey generation for a cipher with block size b.
+    b   For AES block cipher, b = 128
+
+                120
+        R    = 0   10000111
+         128                                 */
+const UINT8 AES_Rb_Block[AES_BLOCK_SIZE] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87
+};
+
+/*  b - Constant bit string required for subkey generation process.
+   0    For AES block cipher, b = 128
+        
+         128
+        0                                    */
+const UINT8 AES_Zero_Block[AES_BLOCK_SIZE] = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES-128 CMAC Functions                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+static void CMAC_AES_XOR_128      (const UINT8 *inputX, const UINT8 *inputY, UINT8 *output);
+static void CMAC_AES_LS1_128      (const UINT8 *input, UINT8 *output);
+static void CMAC_AES_Pad_128      (const UINT8 *input, UINT8 *output, UINT32 length);
+static void CMAC_AES_Gen_SUBK     (AES_KEY_INSTANCE *key, UINT8 *K1, UINT8 *K2);
+static void CMAC_AES_PadLastBlock (AES_KEY_INSTANCE *key, AES_DATA_INSTANCE *data, UINT8 *paddedBlock);
+
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_XOR_128                                          */
+/*                                                                            */
+/* Parameters:      inputX - Bit string X [input].                            */
+/*                  inputY - Bit string Y [input].                            */
+/*                  output - Result of (X XOR Y) [output].                    */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      output = X (+) Y                                                      */
+/*      The bitwise exclusive-OR of two bit strings X and Y of 128-bit length.*/
+/*----------------------------------------------------------------------------*/
+static void CMAC_AES_XOR_128 (
+    const UINT8 *inputX,
+    const UINT8 *inputY, 
+    UINT8       *output
+)
+{
+    UINT i;
+      
+    for (i = 0; i < AES_KEY_BYTE_SIZE(AES_128); i++)
+    {
+        output[i] = inputX[i] ^ inputY[i];
+    }
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_LS1_128                                          */
+/*                                                                            */
+/* Parameters:      input  - 128-bit string to be shifted [input].            */
+/*                  output - Result of shift operation [output].              */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      output = input << 1                                                   */
+/*      Perform a single left shift function on a 128-bit string.             */
+/*----------------------------------------------------------------------------*/
+static void CMAC_AES_LS1_128 (
+    const UINT8 *input, 
+    UINT8       *output
+)
+{
+    INT i;
+    UINT8         overflow = 0;
+
+    for (i = (AES_KEY_BYTE_SIZE(AES_128) - 1); i >= 0; i--)
+    {
+        output[i]  = input[i] << 1;
+        output[i] |= overflow;
+        overflow   = (input[i] & 0x80) ? 1 : 0;
+    }
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_Pad_128                                          */
+/*                                                                            */
+/* Parameters:      input  - Block to be padded [input].                      */
+/*                  output - Result of padding operation [output].            */
+/*                  length - Size of input block [input].                     */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*                          j                                                 */
+/*      output = input || 10  , where j = (16 - length - 1)                   */
+/*      Append a padding string to input string, in particular, a single 1*/
+/*      bit followed by the minimum number of 0 bits, possibly none, that   */
+/*      are necessary to form a complete 128-bit block.                       */
+/*----------------------------------------------------------------------------*/
+static void CMAC_AES_Pad_128 (
+    const UINT8 *input, 
+    UINT8       *output, 
+    UINT32       length
+)
+{
+    UINT i;
+
+    /* Original last block */
+    for (i = 0; i < AES_KEY_BYTE_SIZE(AES_128); i++)
+    {
+        if (i < length)
+        {
+            output[i] = input[i];
+        }
+        else if (i == length)
+        {
+            output[i] = 0x80;
+        }
+        else
+        {
+            output[i] = 0x00;
+        }
+    }
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_Gen_SUBK                                         */
+/*                                                                            */
+/* Parameters:      key - Block Cipher Key information [input].               */
+/*                  K1  - The first subkey [output].                          */
+/*                  K2  - The second subkey [output].                         */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      The block cipher key is used to derive two additional secret values,  */
+/*      called the subkeys, denoted K1 and K2.                                */
+/*      The length of each subkey is the block size.                          */
+/*      The subkeys are fixed for any invocation of CMAC with the given key.  */
+/*                                                                            */
+/*      Subkey generation process of CMAC:                                    */
+/*       1. Let L = CIPHk(0).                                                 */
+/*       2. If MSB(L) = 0, then K1 = L << 1;                                  */
+/*          Else K1 = (L << 1) XOR Rb;                                        */
+/*       3. If MSB(K1) = 0, then K2 = K1 << 1;                                */
+/*          Else K2 = (K1 << 1) XOR Rb.                                       */
+/*----------------------------------------------------------------------------*/
+static void CMAC_AES_Gen_SUBK (
+    AES_KEY_INSTANCE  *key, 
+    UINT8             *K1, 
+    UINT8             *K2
+)
+{
+	UINT8 L[AES_BLOCK_SIZE];
+
+    /* Configure the AES engine to perform a basic AES operation */
+    AES_CIPHER_INSTANCE cipher = {AES_ENCRYPT, AES_MODE_ECB};
+    AES_DATA_INSTANCE   data   = {AES_BLOCK_SIZE, AES_Zero_Block};
+    
+    data.output = L;
+
+    /*            128
+       L = CIPH (0   )
+               k       */
+    AES_Crypt(&cipher, key, &data);
+
+    /* K1 = (L << 1) */
+    CMAC_AES_LS1_128(L, K1);
+
+    /* If MSB(L) = 1, K1 = (L << 1) XOR Rb */
+    if ((L[0] & 0x80) != 0)
+    {
+        CMAC_AES_XOR_128(K1, AES_Rb_Block, K1);
+    }
+
+    /* K2 = (K1 << 1) */
+    CMAC_AES_LS1_128(K1, K2);
+
+    /* If MSB(K1) = 1, K2 = (K1 << 1) XOR Rb */
+    if ((K1[0] & 0x80) != 0)
+    {
+        CMAC_AES_XOR_128(K2, AES_Rb_Block, K2);
+    }
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_PadLastBlock                                     */
+/*                                                                            */
+/* Parameters:      key      - Block Cipher Key information [input].          */
+/*                  data     - Data information structure [input].            */
+/*                  padBlock - Last message block to pad [output].            */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      Pad the final block of a formatted message.                           */
+/*      Mn* is the final block, possibly a partial block, of the formatted    */
+/*      message.                                                              */
+/*                                                                            */
+/*      If Mn* is a complete block:                                           */
+/*          Mn = K1 XOR Mn*                                                   */
+/*      If Mn* is a partial block:											  */
+/*          Mn = K2 XOR (Mn* || 10j), where j = size % 16				      */
+/*----------------------------------------------------------------------------*/
+static void CMAC_AES_PadLastBlock (
+    AES_KEY_INSTANCE  *key, 
+    AES_DATA_INSTANCE *data, 
+    UINT8             *padBlock
+)
+{
+    UINT8         K1[AES_BLOCK_SIZE], K2[AES_BLOCK_SIZE];
+    const UINT8  *lastBlock;
+    UINT32        n;
+    BOOLEAN       completeBlock;
+
+    /* Generate subkeys */
+    CMAC_AES_Gen_SUBK(key, K1, K2);
+
+    /* Calculate the number of complete blocks */
+    n = AES_COMPLETE_BLOCKS(data->size);
+
+    /* Point to the last block */
+    if (n > 0)
+    {
+        lastBlock = &(data->input[AES_BLOCK_SIZE * (n - 1)]);
+    }
+    else
+    {
+        lastBlock = data->input;
+    }
+
+    if (n == 0)
+    {
+        /* Message length is less than a complete block */
+        n = 1;
+        completeBlock = FALSE;
+    }
+    else
+    {
+        if ((data->size % AES_BLOCK_SIZE) == 0)
+        {
+            /* Last block is a complete block */
+            completeBlock = TRUE;
+        }
+        else
+        { 
+            /* Last block is not a complete block */
+            completeBlock = FALSE;
+        }
+    }
+
+    if (completeBlock)
+    { 
+        /* Last block is a complete block => XOR with K1 */
+        CMAC_AES_XOR_128(lastBlock, K1, padBlock);
+    }
+    else
+    {
+        /* Last block is not a complete block => Pad and XOR with K2 */
+        CMAC_AES_Pad_128(lastBlock, padBlock, data->size % AES_BLOCK_SIZE);
+        CMAC_AES_XOR_128(padBlock, K2, padBlock);
+    }
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_Signature                                        */
+/*                                                                            */
+/* Parameters:      key  - Block Cipher Key information [input].              */
+/*                  data - Data information structure [input/output].         */
+/* Returns:         none                                                      */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      AES CMAC Algorithm described in SP800-38B.                            */
+/*      Sign code pointed by data->input using loaded key, and put signature*/
+/*      in memory at data->output.                                          */
+/*----------------------------------------------------------------------------*/
+void CMAC_AES_Signature (
+    AES_KEY_INSTANCE  *key, 
+    AES_DATA_INSTANCE *data
+)
+{
+    UINT8             lastBlock[AES_BLOCK_SIZE];
+    UINT32            n;
+    AES_DATA_INSTANCE idata;
+
+    /* Configure the AES engine to perform a AES-CMAC operation */
+    AES_CIPHER_INSTANCE cipher = {AES_ENCRYPT, AES_MODE_MAC, AES_Zero_Block};
+
+    /* Calculate the number of complete blocks */
+    n = AES_COMPLETE_BLOCKS(data->size);
+
+    /* Feed the entire data to the AES engine */
+    idata.input  = data->input;
+    idata.output = data->output;
+    idata.size   = n  * AES_BLOCK_SIZE;
+
+    /* Perform CMAC-AES */
+    AES_Crypt(&cipher, key, &idata);
+
+    /* Pad the last data block and XOR it with the K1 or K2 subkeys */
+    CMAC_AES_PadLastBlock(key, data, lastBlock);
+
+    /* XOR the last block with the Previous IV register */
+    CMAC_AES_XOR_128(data->output, lastBlock, lastBlock);
+
+    /* Feed the result to the AES engine to calculate the final XCBC-MAC TAG value */
+    cipher.mode = AES_MODE_ECB;
+
+    idata.input  = lastBlock;
+    idata.output = data->output;
+    idata.size   = AES_BLOCK_SIZE;
+
+    AES_Crypt(&cipher, key, &idata);
+}
+
+/*----------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_VerifySignature                                  */
+/*                                                                            */
+/* Parameters:      key    - Block Cipher Key information [input].            */
+/*                  data   - Data information structure [input].              */
+/*                  sign   - Message authentication code [input].             */
+/* Returns:         Non-zero means verification succeeded, else failed        */
+/* Side effects:                                                              */
+/* Description:                                                               */
+/*      Verify signature pointed by sign of code pointed by data->input   */
+/*      and data->size using loaded key.                                    */
+/*----------------------------------------------------------------------------*/
+BOOLEAN CMAC_AES_VerifySignature (
+    AES_KEY_INSTANCE  *key, 
+    AES_DATA_INSTANCE *data,
+    UINT8             *sign
+)
+{
+    /* Apply the MAC generation process */
+    CMAC_AES_Signature(key, data);
+
+    /* Compare result with expected signature */
+   return (memcmp(data->output, sign, AES_BLOCK_SIZE) ? FALSE : TRUE);
+}
+
+#undef AES_CMAC_C
diff --git a/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.h b/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.h
new file mode 100755
index 0000000..4b5e965
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/cmac/cmac_aes.h
@@ -0,0 +1,49 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   cmac_aes.h                                                                                            */
+/*            This file contains CMAC module interface                                                     */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef CMAC_AES_H
+#define CMAC_AES_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_Signature                                                                     */
+/*                                                                                                         */
+/* Parameters:      key  - Block Cipher Key information [input].                                           */
+/*                  data - Data information structure [input/output].                                      */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*      AES CMAC Algorithm described in SP800-38B.                                                         */
+/*      Sign code pointed by data->input using loaded key, and put signature                             */
+/*      in memory at data->output.                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CMAC_AES_Signature (AES_KEY_INSTANCE  *key, AES_DATA_INSTANCE *data);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CMAC_AES_VerifySignature                                                               */
+/*                                                                                                         */
+/* Parameters:      key    - Block Cipher Key information [input].                                         */
+/*                  data   - Data information structure [input].                                           */
+/*                  sign   - Message authentication code [input].                                          */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*      Verify signature pointed by sign of code pointed by data->input                                */
+/*      and data->size using loaded key, and return status.                                              */
+/*      Non-zero status means verification succeeded, else failed.                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN CMAC_AES_VerifySignature (AES_KEY_INSTANCE  *key, AES_DATA_INSTANCE *data, UINT8 *sign);
+
+
+#endif //CMAC_AES_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.c b/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.c
new file mode 100755
index 0000000..409b2f2
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.c
@@ -0,0 +1,362 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   lib_crc.c                                                                                             */
+/*     The file lib_crc.c contains the private  and  public  func-                                         */
+/*     tions  used  for  the  calculation of CRC-16, CRC-CCITT and                                         */
+/*     CRC-32 cyclic redundancy values.                                                                    */
+/*  Project:  Yarkon                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define LIB_CRC_C
+
+#include "lib_crc.h"
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   Library         : lib_crc                                       *
+    *   File            : lib_crc.c                                     *
+    *   Author          : Lammert Bies  1999-2005                       *
+    *   E-mail          : info@lammertbies.nl                           *
+    *   Language        : ANSI C                                        *
+    *                                                                   *
+    *                                                                   *
+    *   Description                                                     *
+    *   ===========                                                     *
+    *                                                                   *
+    *   The file lib_crc.c contains the private  and  public  func-     *
+    *   tions  used  for  the  calculation of CRC-16, CRC-CCITT and     *
+    *   CRC-32 cyclic redundancy values.                                *
+    *                                                                   *
+    *                                                                   *
+    *   Dependencies                                                    *
+    *   ============                                                    *
+    *                                                                   *
+    *   lib_crc.h       CRC definitions and prototypes                  *
+    *                                                                   *
+    *                                                                   *
+    *   Modification history                                            *
+    *   ====================                                            *
+    *                                                                   *
+    *   Date        Version Comment                                     *
+    *                                                                   *
+    *   2005-05-14  1.12    Added CRC-CCITT with start value 0          *
+    *                                                                   *
+    *   2005-02-05  1.11    Fixed bug in CRC-DNP routine                *
+    *                                                                   *
+    *   2005-02-04  1.10    Added CRC-DNP routines                      *
+    *                                                                   *
+    *   1999-02-21  1.01    Added FALSE and TRUE mnemonics              *
+    *                                                                   *
+    *   1999-01-22  1.00    Initial source                              *
+    *                                                                   *
+    \*******************************************************************/
+
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   #define P_xxxx                                                  *
+    *                                                                   *
+    *   The CRC's are computed using polynomials. The  coefficients     *
+    *   for the algorithms are defined by the following constants.      *
+    *                                                                   *
+    \*******************************************************************/
+
+
+#ifdef CRC_16
+#define                 P_16        0xA001
+#endif /* CRC_16 */
+
+#ifdef CRC_32
+#define                 P_32        0xEDB88320L
+#endif /* CRC_32 */
+
+#ifdef CRC_CCITT 
+#define                 P_CCITT     0x1021
+#endif /* CRC_CCITT */
+
+#ifdef CRC_DNP
+#define                 P_DNP       0xA6BC
+#endif /* CRC_DNP */
+
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   static void crc...tab_val();                                   *
+    *                                                                   *
+    *   Three local functions are used  to  initialize  the  tables     *
+    *   with values for the algorithm.                                  *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_16
+static unsigned short   crc16_tab_val( unsigned short );
+#endif /* CRC_16 */
+
+#ifdef CRC_32
+static unsigned long    crc32_tab_val( unsigned long );
+#endif /* CRC_32 */
+
+#ifdef CRC_CCITT
+static unsigned short   crcccitt_tab_val( unsigned short );
+#endif /* CRC_CCITT */
+
+#ifdef CRC_DNP
+static unsigned short   crcdnp_tab_val( unsigned short );
+#endif /* CRC_DNP */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   unsigned short update_crc( unsigned long crc, char c );         *
+    *                                                                   *
+    *   The function update_crc calculates  a  new  CRC-CCITT           *
+    *   value  based  on the previous value of the CRC and the next     *
+    *   byte of the data to be checked.                                 *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_CCITT
+unsigned short update_crc( unsigned short crc, char c )
+{
+    unsigned short tmp, short_c;
+
+    short_c  = 0x00ff & (unsigned short) c;
+
+    tmp = (crc >> 8) ^ short_c;
+    crc = (crc << 8) ^ crcccitt_tab_val(tmp);
+
+    return crc;
+
+}  /* update_crc */
+#endif /* CRC_CCITT */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   unsigned short update_crc( unsigned long crc, char c );         *
+    *                                                                   *
+    *   The function update_crc calculates a  new  CRC-16  value        *
+    *   based  on  the  previous value of the CRC and the next byte     *
+    *   of the data to be checked.                                      *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_16
+unsigned short update_crc( unsigned short crc, char c ) 
+{
+    unsigned short tmp, short_c;
+
+    short_c = 0x00ff & (unsigned short) c;
+    tmp =  crc       ^ short_c;
+    crc = (crc >> 8) ^ crc16_tab_val( tmp & 0xff );
+
+    return crc;
+
+}  /* update_crc */
+#endif /* CRC_16 */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   unsigned short update_crc( unsigned long crc, char c );         *
+    *                                                                   *
+    *   The function update_crc calculates a new CRC-DNP  value         *
+    *   based  on  the  previous value of the CRC and the next byte     *
+    *   of the data to be checked.                                      *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_DNP
+unsigned short update_crc( unsigned short crc, char c )
+{
+    unsigned short tmp, short_c;
+
+    short_c = 0x00ff & (unsigned short) c;
+
+    tmp =  crc       ^ short_c;
+    crc = (crc >> 8) ^ crcdnp_tab_val(tmp & 0xff );
+
+    return crc;
+
+}  /* update_crc */
+#endif /* CRC_DNP */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   unsigned long update_crc( unsigned long crc, char c );          *
+    *                                                                   *
+    *   The function update_crc calculates a  new  CRC-32  value        *
+    *   based  on  the  previous value of the CRC and the next byte     *
+    *   of the data to be checked.                                      *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_32
+unsigned long update_crc( unsigned long crc, char c ) {
+
+    unsigned long tmp, long_c;
+
+    long_c = 0x000000ffL & (unsigned long) c;
+
+    tmp = crc ^ long_c;
+    crc = (crc >> 8) ^ crc32_tab_val( tmp & 0xff );
+
+    return crc;
+
+}  /* update_crc */
+#endif /* CRC_32 */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   static void crc16_tab_val( unsigned short );                    *
+    *                                                                   *
+    *   The function crc16_tab_val() is used  to  fill  the  array      *
+    *   for calculation of the CRC-16 with values.                      *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_16
+static unsigned short crc16_tab_val( unsigned short c ) 
+{
+
+  int j;
+  unsigned short crc;
+
+  crc = 0;
+
+  for (j=0; j<8; j++)
+  {
+    if ( (crc ^ c) & 0x0001 )
+    {
+      crc = ( crc >> 1 ) ^ P_16;
+    }
+    else
+    {
+      crc =   crc >> 1;
+    }
+
+    c = c >> 1;
+  }
+
+  return crc;
+
+}  /* crc16_tab_val */
+#endif /* CRC_16 */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   static unsigned short crcdnp_tab_val( unsigned short c );       *
+    *                                                                   *
+    *   The function crcdnp_tab_val() is used  to  fill  the  array     *
+    *   for calculation of the CRC-DNP with values.                     *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_DNP
+static unsigned short crcdnp_tab_val( unsigned short c ) 
+{
+  int j;
+  unsigned short crc;
+
+  crc = 0;
+
+  for (j=0; j<8; j++) 
+  {
+
+    if ( (crc ^ c) & 0x0001 ) 
+    {
+      crc = ( crc >> 1 ) ^ P_DNP;
+    }
+    else
+    {
+      crc =   crc >> 1;
+    }
+
+    c = c >> 1;
+  }
+
+  return crc;
+
+}  /* crcdnp_tab_val */
+#endif /* CRC_DNP */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   static unsigned long init_crc32_tab( unsigned long );           *
+    *                                                                   *
+    *   The function init_crc32_tab() is used  to  fill  the  array     *
+    *   for calculation of the CRC-32 with values.                      *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_32
+static unsigned long crc32_tab_val( unsigned long c )
+{
+
+  int  j;
+  unsigned long crc;
+
+  crc = (unsigned long) c;
+
+  for (j=0; j<8; j++)
+  {
+    if ( crc & 0x00000001L ) 
+    {
+      crc = ( crc >> 1 ) ^ P_32;
+    }
+    else
+    {
+      crc =   crc >> 1;
+    }
+  }
+
+  return crc;
+
+}  /* crc32_tab_val */
+#endif /* CRC_32 */
+
+
+    /*******************************************************************\
+    *                                                                   *
+    *   static unsigned short crcccitt_tab_val( unsigned short );       *
+    *                                                                   *
+    *   The function crcccitt_tab_val() is used to fill the  array      *
+    *   for calculation of the CRC-CCITT with values.                   *
+    *                                                                   *
+    \*******************************************************************/
+#ifdef CRC_CCITT
+static unsigned short crcccitt_tab_val( unsigned short c )
+{
+
+    int j;
+    unsigned short crc;
+
+    
+        crc = 0;
+        c   = ((unsigned short) c) << 8;
+
+        for (j=0; j<8; j++) 
+        {
+            if ( (crc ^ c) & 0x8000 )
+            {
+              crc = ( crc << 1 ) ^ P_CCITT;
+            }
+            else
+            {
+              crc =   crc << 1;
+            }
+
+            c = c << 1;
+        }
+
+        return crc;
+    
+}  /* crcccitt_tab_val */
+#endif /* CRC_CCITT */
+
+
+#undef LIB_CRC_C
diff --git a/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.h b/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.h
new file mode 100755
index 0000000..acb5db2
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/crc/lib_crc.h
@@ -0,0 +1,73 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   lib_crc.h                                                                                             */
+/*     The file lib_crc.h contains public definitions  and  proto-                                         */
+/*     types for the CRC functions present in lib_crc.c.                                                   */
+/*  Project:                                                                                               */
+/*            Yarkon                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef LIB_CRC_H
+#define LIB_CRC_H
+
+    /*******************************************************************\
+    *                                                                   *
+    *   Library         : lib_crc                                       *
+    *   File            : lib_crc.h                                     *
+    *   Author          : Lammert Bies  1999-2005                       *
+    *   E-mail          : info@lammertbies.nl                           *
+    *   Language        : ANSI C                                        *
+    *                                                                   *
+    *                                                                   *
+    *   Description                                                     *
+    *   ===========                                                     *
+    *                                                                   *
+    *   The file lib_crc.h contains public definitions  and  proto-     *
+    *   types for the CRC functions present in lib_crc.c.               *
+    *                                                                   *
+    *                                                                   *
+    *   Dependencies                                                    *
+    *   ============                                                    *
+    *                                                                   *
+    *   none                                                            *
+    *                                                                   *
+    *                                                                   *
+    *   Modification history                                            *
+    *   ====================                                            *
+    *                                                                   *
+    *   Date        Version Comment                                     *
+    *                                                                   *
+    *   2005-02-14  1.12    Added CRC-CCITT with initial value 0        *
+    *                                                                   *
+    *   2005-02-05  1.11    Fixed bug in CRC-DNP routine                *
+    *                                                                   *
+    *   2005-02-04  1.10    Added CRC-DNP routines                      *
+    *                                                                   *
+    *   2005-01-07  1.02    Changes in tst_crc.c                        *
+    *                                                                   *
+    *   1999-02-21  1.01    Added FALSE and TRUE mnemonics              *
+    *                                                                   *
+    *   1999-01-22  1.00    Initial source                              *
+    *                                                                   *
+    \*******************************************************************/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CRC library constant definitions                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CRC_VERSION     "1.12"
+#define CRC_16
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CRC library API                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+unsigned short          update_crc(    unsigned short crc, char c );
+
+
+#endif //#define _LIB_CRC_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.c b/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.c
new file mode 100755
index 0000000..bf5227c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.c
@@ -0,0 +1,490 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   serial_printf.c                                                                                       */
+/*            This file contains implementation of serial printf                                           */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../Modules/uart/uart_if.h"
+#include "stdarg.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Setting default configurations                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef SERIAL_PRINTF_UART_PORT
+#define SERIAL_PRINTF_UART_PORT   UART0_DEV
+#endif
+
+#ifndef SERIAL_PRINTF_BUFFER_SIZE
+#define SERIAL_PRINTF_BUFFER_SIZE _2KB_
+#endif
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local defines                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ZEROPAD 1       // pad with zero
+#define SIGN    2       // unsigned/signed long
+#define PLUS    4       // show plus 
+#define SPACE   8       // space if plus 
+#define LEFT    16      // left justified 
+#define SPECIAL 32      // 0x */
+#define LARGE   64      // use 'ABCDEF' instead of 'abcdef'
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local Macros                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define is_digit(c) ((c) >= '0' && (c) <= '9')
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static char buf[SERIAL_PRINTF_BUFFER_SIZE] = {0};
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_puts                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  s - input string                                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes complete string to UART                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+static void serial_puts(const char *s )
+{
+  while (*s) 
+  {
+        // Puting the char to serial
+        UART_PutC(SERIAL_PRINTF_UART_PORT, *s );
+        if (*s == '\n')
+        {
+            UART_PutC(SERIAL_PRINTF_UART_PORT, '\r');
+        }
+        
+        s++;
+  }
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_strnlen                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  count -                                                                                */
+/*                  s -                                                                                    */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates string size                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static int serial_strnlen(const char * s, int count)
+{
+    const char *sc;
+
+    for (sc = s; count-- && *sc != '\0'; ++sc)
+        /* nothing */;
+    return sc - s;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        skip_atoi                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  s -                                                                                    */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs string to interget conversion                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static int skip_atoi(const char **s)
+{
+    int i=0;
+
+    while (is_digit(**s))
+        i = i*10 + *((*s)++) - '0';
+    return i;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        do_div                                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  base -                                                                                 */
+/*                  n -                                                                                    */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs division with reminder                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static long do_div(long* n, long base) 
+{ 
+    int __res; 
+    __res = (*n) % base; 
+    *n = (*n) / base;
+    return __res;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        number                                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  base -                                                                                 */
+/*                  num -                                                                                  */
+/*                  precision -                                                                            */
+/*                  size -                                                                                 */
+/*                  str -                                                                                  */
+/*                  type -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine used for printf number conversions                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+static char * number(char * str, long num, unsigned int base, int size, int precision ,int type)
+{
+    char c,sign,tmp[66];
+    const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
+    int i;
+
+    if (type & LARGE)
+        digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    if (type & LEFT)
+        type &= ~ZEROPAD;
+    if (base < 2 || base > 36)
+        return 0;
+    c = (type & ZEROPAD) ? '0' : ' ';
+    sign = 0;
+    if (type & SIGN) {
+        if (num < 0) {
+            sign = '-';
+            num = -num;
+            size--;
+        } else if (type & PLUS) {
+            sign = '+';
+            size--;
+        } else if (type & SPACE) {
+            sign = ' ';
+            size--;
+        }
+    }
+    if (type & SPECIAL) {
+        if (base == 16)
+            size -= 2;
+        else if (base == 8)
+            size--;
+    }
+    i = 0;
+    if (num == 0)
+        tmp[i++]='0';
+    else while (num != 0)
+        tmp[i++] = digits[do_div(&num,base)];
+    if (i > precision)
+        precision = i;
+    size -= precision;
+    if (!(type&(ZEROPAD+LEFT)))
+        while(size-->0)
+            *str++ = ' ';
+    if (sign)
+        *str++ = sign;
+    if (type & SPECIAL) {
+        if (base==8)
+            *str++ = '0';
+        else if (base==16) {
+            *str++ = '0';
+            *str++ = digits[33];
+        }
+    }
+    if (!(type & LEFT))
+        while (size-- > 0)
+            *str++ = c;
+    while (i < precision--)
+        *str++ = '0';
+    while (i-- > 0)
+        *str++ = tmp[i];
+    while (size-- > 0)
+        *str++ = ' ';
+    return str;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_vsprintf                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  args -                                                                                 */
+/*                  buf -                                                                                  */
+/*                  fmt -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine parses format string and dumps the output to buffer                       */
+/*---------------------------------------------------------------------------------------------------------*/
+static int serial_vsprintf(char *buf, const char *fmt, va_list args)
+{
+    int len;
+    unsigned long num;
+    int i, base;
+    char * str;
+    const char *s;
+
+    int flags;          /* flags to number() */
+
+    int field_width;    /* width of output field */
+    int precision;      /* min. # of digits for integers; max number of chars for from string */
+    int qualifier;      /* 'h', 'l', or 'q' for integer fields */
+
+    for (str=buf ; *fmt ; ++fmt) 
+    {
+        if (*fmt != '%') 
+        {
+            *str++ = *fmt;
+            continue;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* process flags                                                                                   */
+        /*-------------------------------------------------------------------------------------------------*/
+        flags = 0;
+        repeat:
+            /*---------------------------------------------------------------------------------------------*/
+            /* this also skips first '%'                                                                   */
+            /*---------------------------------------------------------------------------------------------*/
+            ++fmt;      
+            switch (*fmt) {
+                case '-': flags |= LEFT;    goto repeat;
+                case '+': flags |= PLUS;    goto repeat;
+                case ' ': flags |= SPACE;   goto repeat;
+                case '#': flags |= SPECIAL; goto repeat;
+                case '0': flags |= ZEROPAD; goto repeat;
+                }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* get field width                                                                                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        field_width = -1;
+        if (is_digit(*fmt))
+            field_width = skip_atoi(&fmt);
+        else if (*fmt == '*') {
+            ++fmt;
+            /*---------------------------------------------------------------------------------------------*/
+            /* it's the next argument                                                                      */
+            /*---------------------------------------------------------------------------------------------*/
+            field_width = va_arg(args, int);
+            if (field_width < 0) {
+                field_width = -field_width;
+                flags |= LEFT;
+            }
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* get the precision                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        precision = -1;
+        if (*fmt == '.') {
+            ++fmt;
+            if (is_digit(*fmt))
+                precision = skip_atoi(&fmt);
+            else if (*fmt == '*') {
+                ++fmt;
+                /*-----------------------------------------------------------------------------------------*/
+                /* it's the next argument                                                                  */
+                /*-----------------------------------------------------------------------------------------*/
+                precision = va_arg(args, int);
+            }
+            if (precision < 0)
+                precision = 0;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* get the conversion qualifier                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        qualifier = -1;
+        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
+            *fmt == 'Z' || *fmt == 'z' || *fmt == 't' ||
+            *fmt == 'q' ) {
+            qualifier = *fmt;
+            if (qualifier == 'l' && *(fmt+1) == 'l') {
+                qualifier = 'q';
+                ++fmt;
+            }
+            ++fmt;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* default base                                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        base = 10;
+
+        switch (*fmt) {
+        case 'c':
+            if (!(flags & LEFT))
+                while (--field_width > 0)
+                    *str++ = ' ';
+            *str++ = (unsigned char) va_arg(args, int);
+            while (--field_width > 0)
+                *str++ = ' ';
+            continue;
+
+        case 's':
+            s = va_arg(args, char *);
+            if (!s)
+                s = "<NULL>";
+
+            len = serial_strnlen(s, precision);
+
+            if (!(flags & LEFT))
+                while (len < field_width--)
+                    *str++ = ' ';
+            for (i = 0; i < len; ++i)
+                *str++ = *s++;
+            while (len < field_width--)
+                *str++ = ' ';
+            continue;
+
+        case 'p':
+            if (field_width == -1) {
+                field_width = 2*sizeof(void *);
+                flags |= ZEROPAD;
+            }
+            str = number(str,
+                (unsigned long) va_arg(args, void *), 16,
+                field_width, precision, flags);
+            continue;
+
+
+        case 'n':
+            if (qualifier == 'l') {
+                long * ip = va_arg(args, long *);
+                *ip = (str - buf);
+            } else {
+                int * ip = va_arg(args, int *);
+                *ip = (str - buf);
+            }
+            continue;
+
+        case '%':
+            *str++ = '%';
+            continue;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* integer number formats - set up the flags and "break"                                           */
+        /*-------------------------------------------------------------------------------------------------*/
+        case 'o':
+            base = 8;
+            break;
+
+        case 'X':
+            flags |= LARGE;
+        case 'x':
+            base = 16;
+            break;
+
+        case 'd':
+        case 'i':
+            flags |= SIGN;
+        case 'u':
+            break;
+
+        default:
+            *str++ = '%';
+            if (*fmt)
+                *str++ = *fmt;
+            else
+                --fmt;
+            continue;
+        }
+        if (qualifier == 'l') {
+            num = va_arg(args, unsigned long);
+        } else if (qualifier == 'Z' || qualifier == 'z') {
+            num = va_arg(args, unsigned int);
+        } else if (qualifier == 't') {
+            num = va_arg(args, int);
+        } else if (qualifier == 'h') {
+            num = (unsigned short) va_arg(args, int);
+            if (flags & SIGN)
+                num = (short) num;
+        } else if (flags & SIGN)
+            num = va_arg(args, int);
+        else
+            num = va_arg(args, unsigned int);
+        str = number(str, num, base, field_width, precision, flags);
+    }
+    *str = '\0';
+    return str-buf;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_printf                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  fmt - format string                                                                    */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine implements printf to serial                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+int serial_printf(const char *fmt, ...)
+{
+    va_list args;
+    int i;
+    
+    va_start(args, fmt);
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parse format string into buffer                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    i=serial_vsprintf(buf,fmt,args);
+    va_end(args);
+    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Send the buffer to serial                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    serial_puts(buf);
+    
+    return i;
+}
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.h b/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.h
new file mode 100755
index 0000000..bf152db
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Apps/serial_printf/serial_printf.h
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   serial_printf.h                                                                                       */
+/*            This file contains interface to serial printf module                                         */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __SERIAL_PRINTF_H
+#define __SERIAL_PRINTF_H
+
+int serial_printf(const char *fmt, ...);
+
+#endif //__SERIAL_PRINTF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.c b/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.c
new file mode 100755
index 0000000..be159a3
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.c
@@ -0,0 +1,30 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB.c                                                                                           */
+/*            This file contains Hermon SVB implementation                                                 */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "HermonSVB.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Chip Implementation                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Chips/chip.c"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Peripherals Implementation                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.c"
+#include "../../Peripherals/eth_phy/eth_phy.c"
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.h b/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.h
new file mode 100755
index 0000000..2385b2c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/HermonSVB/HermonSVB.h
@@ -0,0 +1,50 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB.h                                                                                           */
+/*            This file contains HermonSVB definitions                                                     */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _HERMON_SVB_H_
+#define _HERMON_SVB_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Chip interface                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CHIP_NAME   wpcm450
+#include "../../Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                          Peripherals interface                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.h"
+#include "../../Peripherals/eth_phy/eth_phy.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Board dependent parameters                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PHY assignment per module                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BOARD_ETH0_PHY_OPS              DP83848C_Ops
+#define BOARD_ETH1_PHY_OPS              DP83848C_Ops
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_FLASH_BASE               FLASH_BASE_ADDR
+
+#define BOARD_FLASH_NUM_OF_DEVICES      4
+
+#define CONFIG_SYS_MAX_FLASH_SECT       64
+#define CONFIG_SYS_MAX_FLASH_BANKS      BOARD_FLASH_NUM_OF_DEVICES
+
+#endif //_HERMON_SVB_H_
diff --git a/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.c b/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.c
new file mode 100755
index 0000000..aba396a
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.c
@@ -0,0 +1,28 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB.c                                                                                           */
+/*            This file contains PolegSVB implementation                                                  */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "PolegSVB.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Chip Implementation                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Chips/chip.c"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Peripherals Implementation                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.c"
+#include "../../Peripherals/eth_phy/eth_phy.c"
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.h b/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.h
new file mode 100755
index 0000000..8c576be
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/PolegSVB/PolegSVB.h
@@ -0,0 +1,110 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB.h                                                                                           */
+/*            This file contains PolegSVB definitions                                                     */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _POLEG_SVB_H_
+#define _POLEG_SVB_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Chip interface                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CHIP_NAME   npcm750
+#include "../../Chips/chip_if.h"
+
+#ifdef __LINUX_KERNEL_ONLY__ 
+
+#undef MFT_MODULE_TYPE
+//#undef GCR_MODULE_TYPE
+//#undef UART_MODULE_TYPE
+//#undef TIMER_MODULE_TYPE
+#undef SMB_MODULE_TYPE
+#undef KCS_MODULE_TYPE
+#undef ADC_MODULE_TYPE
+#undef PWM_MODULE_TYPE
+//#undef FIU_MODULE_TYPE
+//#undef CLK_MODULE_TYPE
+#undef SHM_MODULE_TYPE
+//#undef AIC_MODULE_TYPE
+#undef EMC_MODULE_TYPE
+#undef GMAC_MODULE_TYPE
+#undef MC_MODULE_TYPE
+#undef SD_MODULE_TYPE
+#undef AES_MODULE_TYPE
+#undef DES_MODULE_TYPE
+//#undef STRP_MODULE_TYPE
+//#undef FUSE_MODULE_TYPE
+//#undef VCD_MODULE_TYPE
+#undef GFX_MODULE_TYPE
+//#undef ECE_MODULE_TYPE
+#undef VDM_MODULE_TYPE
+//#undef GPIO_MODULE_TYPE
+#undef PSPI_MODULE_TYPE
+#undef USB_MODULE_TYPE
+
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Board dependent parameters                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+//Trego - Add board specific
+
+//#define POLEG_DRB_HW         1
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PHY assignment per module                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BOARD_ETH0_PHY_OPS              BCM5221_Ops        // EMC1
+#define BOARD_ETH1_PHY_OPS              BCM5221_Ops        // EMC2
+
+#define ETH0_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x45}   // EMC1
+#define ETH1_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x46}   // EMC2
+#define ETH2_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x47}   // GMAC1
+#define ETH3_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x48}   // GMAC2
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_FLASH_BASE               FLASH_BASE_ADDR(0)
+
+#define CONFIG_SYS_MAX_FLASH_SECT       (_16MB_ / _4KB_)
+
+#define CONFIG_SPI3_ENABLE
+
+#ifdef CONFIG_SPI3_ENABLE
+#define CONFIG_SYS_MAX_FLASH_BANKS      8
+#else
+#define CONFIG_SYS_MAX_FLASH_BANKS      4
+#endif
+
+#define BOOTER_VER_ADDR                0x800002F4
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC configuration                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define BOARD_EMC_USING_GMAC_MDIO       1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                          Peripherals interface                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.h"
+#include "../../Peripherals/eth_phy/eth_phy.h"
+
+
+
+#endif //_POLEG_SVB_H_
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.c b/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.c
new file mode 100755
index 0000000..2a17510
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.c
@@ -0,0 +1,28 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   YarkonSVB.c                                                                                           */
+/*            This file contains YarkonSVB implementation                                                  */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "YarkonSVB.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Chip Implementation                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Chips/chip.c"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Peripherals Implementation                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.c"
+#include "../../Peripherals/eth_phy/eth_phy.c"
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.h b/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.h
new file mode 100755
index 0000000..0724382
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/YarkonSVB/YarkonSVB.h
@@ -0,0 +1,62 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   YarkonSVB.h                                                                                           */
+/*            This file contains HermonSVB definitions                                                     */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _YARKON_SVB_H_
+#define _YARKON_SVB_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Chip interface                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CHIP_NAME   npcm650
+#include "../../Chips/chip_if.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Board dependent parameters                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PHY assignment per module                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BOARD_ETH0_PHY_OPS              DP83848C_Ops           // EMC1
+#define BOARD_ETH1_PHY_OPS              BCM5481_Ops            // GMAC2
+
+#define ETH0_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x49}       // EMC1    -   not used in npcm650
+#define ETH1_MAC_ADDRESS {0x00,0x00,0xF7,0xA0,0x00,0x49}       // GMAC2
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_FLASH_BASE               FLASH_BASE_ADDR
+
+#define BOARD_FLASH_NUM_OF_DEVICES      4
+
+#define CONFIG_SYS_MAX_FLASH_SECT       64
+#define CONFIG_SYS_MAX_FLASH_BANKS      BOARD_FLASH_NUM_OF_DEVICES
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC configuration                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define BOARD_EMC_USING_GMAC_MDIO       1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                          Peripherals interface                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Peripherals/spi_flash/spi_flash.h"
+#include "../../Peripherals/eth_phy/eth_phy.h"
+
+
+
+#endif //_YARKON_SVB_H_
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/board.c b/board/nuvoton/common/BMC_HAL/Boards/board.c
new file mode 100755
index 0000000..d6d5ad4
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/board.c
@@ -0,0 +1,28 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   board.c                                                                                               */
+/*            This file contains Board implementation selection, based on BOARD_NAME define                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <defs.h>
+#include "board.h"
+
+#define __BOARD_C_FILE_NAME(name)        STRINGX(name/name.c)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including chip definitions                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef BOARD_NAME
+#include __BOARD_C_FILE_NAME(BOARD_NAME)
+#else
+#error "BOARD_NAME should be defined!"
+#endif
+
diff --git a/board/nuvoton/common/BMC_HAL/Boards/board.h b/board/nuvoton/common/BMC_HAL/Boards/board.h
new file mode 100755
index 0000000..01430bc
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Boards/board.h
@@ -0,0 +1,35 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   board.h                                                                                               */
+/*            This file contains Board definitions selection, based on BOARD_NAME define                   */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _BOARD_H
+#define _BOARD_H
+
+#include <defs.h>
+#include "../Common/hal_common.h"
+
+#define __BOARD_H_FILE_NAME(name)        STRINGX(name/name.h)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including chip definitions                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef BOARD_NAME
+#include __BOARD_H_FILE_NAME(BOARD_NAME)
+#else
+#error "BOARD_NAME should be defined!"
+#endif
+
+
+
+
+#endif // _BOARD_H
\ No newline at end of file
diff --git a/board/nuvoton/common/BMC_HAL/Changelog.txt b/board/nuvoton/common/BMC_HAL/Changelog.txt
new file mode 100755
index 0000000..2374e95
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Changelog.txt
@@ -0,0 +1,249 @@
+v0.3.1
+------
+- Add Poleg SPI flash fix.
+
+v0.3.0
+------
+- Add PolegSVB HW support and bring-up.
+- Port from Poleg-SWC_HAL fuse strp clk gcr mc uart modules.
+- Add support for W25Q256 spi flash.
+
+v0.2.7
+------
+- Add ethernet specific mac addresses.
+- Add support GMAC or dual EMC's per CONFIG_NPCMX50_GMAC_ETH / CONFIG_NPCMX50_EMC_ETH. 
+
+v0.2.6
+------
+- Add suport 2 GMAC and 2 EMC ethernet ports.
+- Port clk module from Poleg SWC to BMC_HAL.
+- Fix gcr port to Poleg.
+
+v0.2.5
+------
+- Chips/*                           - Fix for Poleg support in kernel.
+- Modules/clk/*                     - Fix for Poleg SD/eMMC.
+
+v0.2.4
+------
+- Modules/gcr/*                     - Fix enum regarding PSPI device num.
+- Modules/pspi/*                    - Fix enum regarding PSPI device num.  
+- Modules/clk/*                     - Add PSPI reset function.
+- Modules/aic/*                     - Add AIC_GRSR define and fix register calc.
+- Chips/*                           - Re-arrange npcm650 and npcm750 and add VDM/VDMA support.
+
+v0.2.3
+------
+- Peripheral/spi_flash/*            - Fix spi_flash read flash ID
+- Add Poleg IP                      - Add Poleg Changes to verious BMC-HAL Modules 
+
+v0.2.0
+------
+- Modules/gcr/*                     - Fix UART issue - enabling one UART disabled another
+- Modules/uart/*                    - Fix UART issue - enabling one UART disabled another
+- Modules/vcd/*                     - API change
+- Modules/sd/*                      - convert to new defs.h
+
+v0.1.9
+------
+- Modules/fuse/*                    - Added Z1 bypasses
+- Modules/gmac/*                    - Fixed 10Mbit external loopback support
+- Modules/vcd/*                     - Code cleanup
+- Modules/ece/*                     - Code cleanup
+
+v0.1.8
+------
+- Chips/*                           - Changed HAL versioning scheme to be DEFINE based rather than STRING based
+                                    - Added USB optimization definitions
+- Modules/clk/*                     - Fixed SD clock configuration
+- Modules/gcr/*                     - Added boot state functions
+- Modules/gmac/*                    - Fixed bug in ISR handler
+                                    - Added 10Mbit external loopback support for testing
+- Modules/mc/*                      - Cleanup
+- Modules/gpio/*                    - Added Init
+- Modules/ece/*                     - Fine tuning and bugfixes
+- Peripherals/eth_phy/*             - Increased timeouts for Autonegotiation
+- Modules/shm/*                     - Added new shared memory driver
+
+
+v0.1.7
+------
+- Chips/*                           - Update USB module definitions
+- Modules/clk/Yarkon/clk_drv.c      - Bug fix in USB clock configuration.
+- Modules/gcr/Yarkon/*              - Added DAC sense setting.
+- Modules/gmac/Yarkon_IP/gmac_drv.c - Separated 1Gb and 100Mb loopback scheme.
+- Peripherals/eth_phy/bcm5481/*     - Added MII STAT fields.
+
+
+v0.1.6
+------
+- Peripherals/eth_phy/bcm5481/*     - Added better handling on Auto-Negotiation
+- Modules/clk/*                     - Added handling for USB, PCI and APB clocks configurations
+- Modules/emc/*                     - Fixed handling in DCACHE enabled environment
+- Modules/gcr/*                     - Added VCD and GFX related handling
+- Modules/gmac/*                    - Fixed handling in DCACHE environment. Fixed hanging issues.
+- Modules/mc/*                      - Added ODT reconfiguration
+- Modules/sd/*                      - Added cleanups
+- Modules/strp/*                    - Added STRP 19 status read
+- Modules/vcd/*                     - Many bugfixes and performace enhancements
+- Modules/ece/*                     - Added first version of the ECE driver
+
+
+v0.1.5
+------
+- Apps/* , Peripherals/*             - Divide 'Drivers' folder to 'Apps' and 'Peripherals'
+- Boards/*                           - Add 'Boards' support (a board is a chip plus a set of peripherals)
+- Modules/sd/*                       - Add SD/MMC Flash Card module
+- Modules/emc/*                      - Modify EThernet driver to act under Linux as well
+
+
+v0.1.4
+------
+- Drivers/eth_phy/*                  - Added framework for Ethernet PHY drivers
+                                     - Added DP83848c PHY driver for Hermon SVB
+                                     - Added BCM5481 PHY driver for Yarkon SVB
+- Common/hal_ethernet.h              - Added H file for sharing definitions between EMC, GMAC and PHY drivers
+- Modules/*                          - Splitted the original Chips/chip.c file and added <MODULE>_if.c
+                                       for each module.
+- Modules/vcd/*                      - Added VCD module driver.
+- Modules/gpio/*                     - Bugfix: Incorrect configuration procedure in case of multiple 
+                                               GPIO modules
+- Modules/sd/*                       - Cleaned old driver remains
+                                     - Rewritten SD regs definitions
+                                     - Added SD clock configuration procedure
+- Modules/uart/*                     - Added Non-Blocking PutC and GetC functions
+- Modules/mc/*                       - Added Memory Port Priority configuration functions
+- Modules/emc/*                      - Redesigned to work with new PHY drivers framework
+- Modules/gmac/*                     -                         "
+- Modules/fuse/*                     - Added bypasses for Z1
+- Modules/aes/*                      -          "
+- Modules/strp/*                     -          "
+- Modules/clk/*                      - Added SD clock configuration
+
+
+v0.1.3
+------
+- Chips/*                            - Added GPIO muxing tables to each chip
+                                     - Added Interrupt Group defines for modules that need to set 
+                                       Interrupt group setting in addition to Interrupt
+- Modules/gpio/*                     - Added GPIO module
+- Modules/pspi/*                     - Added Peripherial SPI module
+- Common/hal_error.h                 - Added common HAL_STATUS type for common error handling
+- Modules/*                          - Converted all modules to use HAL_STATUS
+                                     - Changed modules function interface names to support single
+                                       naming convention
+- Modules/aic/*                      - Added support for Interrupt Group enable/disable
+- Modules/gcr/*                      - Added GPIO Mux and Internal resistor per pin settings
+                                     - Added APB Clock retrival function
+- Drivers/spi_flash/*                - Added support to BulkErase 
+                                     - Added support for 16MB flash for Yarkon SVB
+- Modules/timer/*                    - Redisinged TimerPeriodic interface to make it more useful.
+                                       Now the user can submit his own tick function into the module
+                                       that will be called instead of the default one.
+                                       
+-                                        
+
+v0.1.2
+------
+- Chips/*                            - Changed Interrupts handling: Each module defines
+                                       its own interrupt interface that is consistent
+                                       between chips (and its implementation can be changed between the chips)
+                                     - Timer base address computed with mathematical expression (instead of if-else chaining)
+                                       Leading to O(1) register access time
+- Modules/timer/*                    - Cleaned registers file. 
+                                     - Added support to new interrupts interface. 
+                                     - Bugfixes in oneShot functions
+- Modules/emc/*                      - Added support to new interrupts interface
+- Modules/gmac/*                     - Added support to new interrupts interface
+- Modues/*                           - General warnings cleanup
+
+
+v0.1.1
+------
+- Modules/fiu/Hermon/fiu_drv.c       - Cleaned the FIU driver initialization interface.
+                                     - Bug fix in FIU_set_write_window_L()  handle a case 
+                                       where high_limit and low_limit are equal.
+- Modules/gcr/Yarkon/gcr_regs.h      - Add INTCR2_CFG bit-field to INTCR2 register  Mark upper SW layers 
+                                       that chip configuration (MC, CLK, Flash, etc') is done.
+- Drivers/spi_flash/*                - Modify FIU Initialization, based on new FIU driver initialization interface.
+                                       SPI_Flash_Common_Write()  Support manual write only (Write Flash Using 256 Page EXTENDED MODE).
+
+
+v0.0.9
+-------
+- Modules/clk/Yarkon/clk_drv.c       - Configure AHB* fields in CLKDIV1 using read-modify-write operations.
+- Modules/*                          - Add SW reset function per various modules.
+
+- Modules/sd/Yarkon                  - Add SD module.
+- Modules/fiu/Hermon/fiu_drv.c       - Do not perform a SW reset on the FIU module before initiation (resets also SHM and AHB3).
+- Modules/mc/Yarkon/mc_drv.c         - Various modifications in PCTL register configuration.
+
+
+v0.0.8
+-------
+- Modules/aes/Yarkon                 - AES_crypt also reads the Previous IV register under CMAC mode, 
+                                       so only the last data block is handled outside the AES driver.
+- Modules/*                          - enumerate MEMSIZ and CKFRQ straps.
+- Modules/clk/Yarkon/clk_drv.c       - Clock Configuration: Configure GFX clock select to GFXPLL instead of CLKREF.
+- Drivers/cmac                       - Rename AES_CMAC to cmac_aes
+
+v0.0.7
+-------
+- Modules/aes/Yarkon                 - Define 'keyIndex' as AES key index in 128-bit steps. 
+                                       This allows different key sizes in the key array.
+- Modules/fuse/Yarkon/fuse_drv.c     - Clean warnings and Remove unused code.
+                                     - Define 'keyIndex' as AES key index in 128-bit steps.
+                                     - FUSE_ProgramByte() - Optimized to enable programming bits in an already programmed byte.
+                                     - FUSE_ReadKey  correct a bug in 'addr' calculation. 
+                                     - FUSE_ReadKey  added two checks to verify that APB Read Access to the Key Storage Array is allowed.
+- Drivers/aes                        - Move AES_CMAC to 'Drivers' directory.
+- Modules/clk/Yarkon/clk_drv.c       - Correct a bug in Yarkon UART clock configuration PD bypass.
+- Drivers/spi_flash/*                - Bug fixes.
+- Modules/gcr/Yarkon/gcr_drv.c       - New function GCR_PowerOn_GetMemorySize() for retrieving DDR3 memory size.
+- Tools/*                            - Add Perl-based utilities to simplify various operations on the BMC_HAL driver set.
+
+
+v0.0.6
+-------
+- Modules/des                        - Added DES module (Yarkon only)
+- Modules/aes/Yarkon                 - Macro modifications due to DES module insertion
+                                     - Wrap library dependencies under #ifdef to support no LIBC environments
+- Modules/aes/Yarkon/aes_drv.c       - Switch from configuration mode to data processing mode before read/write data operation.
+                                     - AES_Config() - Write configurable info in a single write operation.
+- Modules/fuse/Yarkon/fuse_drv.c     - FUSE_ProgramByte() - clean warnings
+- Modules/mc/Yarkon/mc_drv.c         - Fix issue #235 - IOCR values for ECC enabled and ECC disabled were mistakenly switched.
+                                     - Fix issue #234 - ROM-Code doesn't perform step 9 while in Config state.
+
+v0.0.5
+-------
+- Modules/*                 - Removed all duplications between Interface files and MODULE_drv.h files
+- Modules/clk               - Added Timer and Ethernet/GMAC clock configuration functions
+- Modules/gcr               - Added mux for RMII/GMII (for ethernet)
+- Drivers/serial_printf     - Added printf implementation that print the output using UART module
+- Modules/aes/Yarkon        - Removed library dependency
+- Modules/uart/Hermon       - Fixed bug that UART_putc can stuck forever if the line is busy
+- Modules/mc                - Unified interfaces of Hermon and Yarkon drivers
+
+
+v0.0.4
+------
+ - Modules/*                - Warning cleanup
+ - MC                       - Modify TRTW value to 0x2
+ - AES                      - Code clean-up (no functional changes)
+
+
+v0.0.3
+------
+- Modules/timer/Hermon/*    -   fixed + added NO_INTERRUPT operation mode
+- Drivers/spi_flash/*       -   all files names were renamed to have a prefix "spi_flash"
+- Modules/uart/Hermon/*     -   fixed initialization
+- Modules/clk/*             -   added palladium bypass
+- Chips/chip.h              -   Added EXTERNAL_INCLUDE_FILE feature
+
+- Added Defines.txt file that holds a list of all defines used in the HAL, both required and optional
+- Added version.h file that holds string version of the HAL
+- Added Changelog.txt file to the HAL root
+
+ 
+ 
+ 
\ No newline at end of file
diff --git a/board/nuvoton/common/BMC_HAL/Chips/chip.c b/board/nuvoton/common/BMC_HAL/Chips/chip.c
new file mode 100755
index 0000000..5d384c8
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/chip.c
@@ -0,0 +1,158 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   chip.c                                                                                                */
+/*            This file contains all modules of the chip                                                   */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../Common/hal_common.h"
+#include "chip.h"
+#include "../version.h"
+#include <defs.h>
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including external definitions if needed                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef EXTERNAL_INCLUDE_FILE
+#include __EXTERNAL_FILE(EXTERNAL_INCLUDE_FILE)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HAL version                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+volatile const char BMC_HAL_VERSION_VAR[] = { "BMC HAL v" BMC_HAL_VERSION_STR };
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined AES_MODULE_TYPE
+#include "../Modules/aes/aes_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined DES_MODULE_TYPE
+#include "../Modules/des/des_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AIC Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined AIC_MODULE_TYPE
+#include "../Modules/aic/aic_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Clock Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined CLK_MODULE_TYPE
+#include "../Modules/clk/clk_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet 100 Mac Controler                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined EMC_MODULE_TYPE
+#include "../Modules/emc/emc_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUI Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined FIU_MODULE_TYPE
+#include "../Modules/fiu/fiu_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUSE Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined FUSE_MODULE_TYPE
+#include "../Modules/fuse/fuse_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GCR Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined GCR_MODULE_TYPE
+#include "../Modules/gcr/gcr_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GMAC Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined GMAC_MODULE_TYPE
+#include "../Modules/gmac/gmac_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Control                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined MC_MODULE_TYPE
+#include "../Modules/mc/mc_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* STRAP Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined STRP_MODULE_TYPE
+#include "../Modules/strp/strp_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined TIMER_MODULE_TYPE
+#include "../Modules/timer/timer_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined UART_MODULE_TYPE
+#include "../Modules/uart/uart_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined GPIO_MODULE_TYPE
+#include "../Modules/gpio/gpio_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VCD Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined VCD_MODULE_TYPE
+#include "../Modules/vcd/vcd_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ECE Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined ECE_MODULE_TYPE
+#include "../Modules/ece/ece_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PSPI Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined PSPI_MODULE_TYPE
+#include "../Modules/pspi/pspi_if.c"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Module                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined SD_MODULE_TYPE
+#include "../Modules/sd/sd_if.c"
+#endif
+
diff --git a/board/nuvoton/common/BMC_HAL/Chips/chip.h b/board/nuvoton/common/BMC_HAL/Chips/chip.h
new file mode 100755
index 0000000..cc8f00b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/chip.h
@@ -0,0 +1,32 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   chip.h                                                                                                */
+/*            This file contains routing to given CHIP_NAME definitions file                               */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _CHIP_H
+#define _CHIP_H
+
+#include <defs.h>
+
+#define __CHIP_H_FILE_NAME(name)        STRINGX(name/name.h)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including chip definitions                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef CHIP_NAME
+#include __CHIP_H_FILE_NAME(CHIP_NAME)
+#else
+#error "CHIP_NAME should be defined!"
+#endif
+
+
+#endif // _CHIP_H
diff --git a/board/nuvoton/common/BMC_HAL/Chips/chip_if.h b/board/nuvoton/common/BMC_HAL/Chips/chip_if.h
new file mode 100755
index 0000000..3350584
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/chip_if.h
@@ -0,0 +1,100 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   chip_if.h                                                                                             */
+/*            This file contains interface for the whole chip                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _CHIP_IF_H_
+#define _CHIP_IF_H_
+
+#include "../Common/hal_common.h"
+#include "../Common/hal_error.h"
+#include "chip.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including external definitions if needed                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef EXTERNAL_INCLUDE_FILE
+#include __EXTERNAL_FILE(EXTERNAL_INCLUDE_FILE)
+#endif
+
+#if defined AES_MODULE_TYPE
+#include "../Modules/aes/aes_if.h"
+#endif
+#if defined AIC_MODULE_TYPE
+#include "../Modules/aic/aic_if.h"
+#endif
+
+#if defined CLK_MODULE_TYPE
+#include "../Modules/clk/clk_if.h"
+#endif
+
+#if defined DES_MODULE_TYPE
+#include "../Modules/des/des_if.h"
+#endif
+
+#if defined EMC_MODULE_TYPE
+#include "../Modules/emc/emc_if.h"
+#endif
+
+#if defined FIU_MODULE_TYPE
+#include "../Modules/fiu/fiu_if.h"
+#endif
+
+#if defined FUSE_MODULE_TYPE
+#include "../Modules/fuse/fuse_if.h"
+#endif
+
+#if defined GCR_MODULE_TYPE
+#include "../Modules/gcr/gcr_if.h"
+#endif
+
+#if defined GMAC_MODULE_TYPE
+#include "../Modules/gmac/gmac_if.h"
+#endif
+
+#if defined MC_MODULE_TYPE
+#include "../Modules/mc/mc_if.h"
+#endif
+
+#if defined TIMER_MODULE_TYPE
+#include "../Modules/timer/timer_if.h"
+#endif
+#if defined UART_MODULE_TYPE
+#include "../Modules/uart/uart_if.h"
+#endif
+
+
+#if defined GPIO_MODULE_TYPE
+#include "../Modules/gpio/gpio_if.h"
+#endif
+
+#if defined VCD_MODULE_TYPE
+#include "../Modules/vcd/vcd_if.h"
+#endif
+
+#if defined PSPI_MODULE_TYPE
+#include "../Modules/pspi/pspi_if.h"
+#endif
+
+#if defined SD_MODULE_TYPE
+#include "../Modules/sd/sd_if.h"
+#endif
+
+#if defined ECE_MODULE_TYPE
+#include "../Modules/ece/ece_if.h"
+#endif
+
+#if defined STRP_MODULE_TYPE
+#include "../Modules/strp/strp_if.h"
+#endif
+
+#endif //_CHIP_IF_H_
diff --git a/board/nuvoton/common/BMC_HAL/Chips/npcm650/npcm650.h b/board/nuvoton/common/BMC_HAL/Chips/npcm650/npcm650.h
new file mode 100755
index 0000000..7c7f784
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/npcm650/npcm650.h
@@ -0,0 +1,822 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   yarkon_palladium.h                                                                                    */
+/*            This file contains chip definitions for the given project                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _NPCM650_CHIP_H
+#define _NPCM650_CHIP_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Chip Name                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCM650
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip ROM                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROM_BASE_ADDR                  0xFFFF0000
+#define ROM_MEMORY_SIZE                _32KB_
+#define ROMCODE_VER_ADDR               0xFFFF0054
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip SRAM                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM_BASE_ADDR                  0x00000000
+#define SRAM_MEMORY_SIZE                _32KB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* External SDRAM Space DDR3                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SDRAM_BASE_ADDR                 0x00008000
+#define SDRAM_MAPPED_SIZE               (_1GB_ - SRAM_MEMORY_SIZE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FLASH_BASE_ADDR                 0x40000000
+#define FLASH_MAPPED_SIZE               _64MB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* XBus                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define XBUS_BASE_ADDR                  0x44000000
+#define XBUS_MAPPED_SIZE                _32MB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Mapped IO                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOMEMORY_BASE_ADDR              0xF0000000
+#define IOMEMORY_SIZE                   0x0F004000
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining IO Memory continuesly mapped blocks                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+                                    /* Map:Phisical Addr | Virtual Addr | Block Size     */
+                                    /* -----------------------------------------------    */
+#define IOMEMORY_BLOCKS             {                                                                \
+                                        {   0xF0000000, IOMEMORY(0xF0000000), 0x00040000   },        \
+                                        {   0xF0400000, IOMEMORY(0xF0400000), 0x00020000   },        \
+                                        {   0xF0440000, IOMEMORY(0xF0440000), 0x00040000   },        \
+                                        {   0xF1F00000, IOMEMORY(0xF1F00000), 0x00002000   },        \
+                                        {   0xF1FFE000, IOMEMORY(0xF1FFE000), 0x00004000   },        \
+                                        {   0xF4200000, IOMEMORY(0xF4200000), 0x00300000   },        \
+                                        {   0xF8000000, IOMEMORY(0xF8000000), 0x00003000   },        \
+                                        {   0xFF000000, IOMEMORY(0xFF000000), 0x00004000   },        \
+                                    }
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Palladium pll0 global register                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+#define PALLADIUM_PLL0_ACCESS                      MEM
+#define PALLADIUM_PLL0_PHYS_BASE_ADDR              0xffff3fc4
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PALLADIUM_PLL0_BASE_ADDR                   PALLADIUM_PLL0_PHYS_BASE_ADDR
+#else
+#define PALLADIUM_PLL0_BASE_ADDR                   PALLADIUM_PLL0_VIRT_BASE_ADDR
+#endif
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Ethernet configuration                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CHIP_NUM_OF_ETH                 2
+#define CHIP_ETH0_TYPE                  EMC
+#define CHIP_ETH1_TYPE                  GMAC
+#define CHIP_NUM_OF_EMC_ETH             1
+#define CHIP_NUM_OF_GMAC_ETH            1
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Module                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GCR_MODULE_TYPE                 Yarkon_IP
+#define GCR_ACCESS                      MEM
+#define GCR_PHYS_BASE_ADDR              0xF0400000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GCR_BASE_ADDR                   GCR_PHYS_BASE_ADDR
+#else
+#define GCR_BASE_ADDR                   GCR_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define UART_MODULE_TYPE                Hermon_IP
+#define UART_ACCESS                     MEM
+#define UART_PHYS_BASE_ADDR(module)     (0xF0001000 + ((module) * 0x1000))
+#define UART_INTERRUPT(module)          (module + UART0_INT)
+#define UART_NUM_OF_MODULES             2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define UART_BASE_ADDR(module)          UART_PHYS_BASE_ADDR(module)
+#else
+#define UART_BASE_ADDR(module)          UART_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PCI MailBox Module                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PCIMBX_ACCESS                   MEM
+#define PCIMBX_PHYS_BASE_ADDR           0xF0401000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PCIMBX_BASE_ADDR                PCIMBX_PHYS_BASE_ADDR
+#else
+#define PCIMBX_BASE_ADDR                PCIMBX_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PCTL (Memory) Module                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PCTL_ACCESS                     MEM
+#define PCTL_PHYS_BASE_ADDR             0xFF001000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PCTL_BASE_ADDR                  PCTL_PHYS_BASE_ADDR
+#else
+#define PCTL_BASE_ADDR                  PCTL_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_MODULE_TYPE               Hermon_IP
+#define TIMER_ACCESS                    MEM
+#define TIMER_PHYS_BASE_ADDR(module)    (0xF0007000 + ((module)*0x1000))
+#define TIMER_INTERRUPT(port)           (((port) <2)? T_INT0 + (port) : T_INT_GRP)
+#define TIMER_GROUP_INTERRUPT(port)     ((((port) >=2) && ((port) <5)) ? (16 + ((port)-2)) : AIC_GROUP_INTERRUPT_NONE)
+
+#define TIMER_NUM_OF_MODULES            2
+#define TIMER_NUM_OF_PORTS              10
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define TIMER_BASE_ADDR(port)           TIMER_PHYS_BASE_ADDR(port)
+#else
+#define TIMER_BASE_ADDR(port)           TIMER_VIRT_BASE_ADDR(port)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SMB Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SMB_MODULE_TYPE                 Hermon_IP
+#define SMB_ACCESS                      MEM
+#define SMB_PHYS_BASE_ADDR(module)      (0xF0020000+((module)*0x1000))
+
+#define SMB_MAX_BUSES                   8
+#define SMB_SCL_GPIOS                   114, 116, 118, 31, 29, 27, 171, 173
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SMB_BASE_ADDR(module)           SMB_PHYS_BASE_ADDR(module)
+#else
+#define SMB_BASE_ADDR(module)           SMB_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* KCS Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define KCS_MODULE_TYPE                 Yarkon_IP
+#define KCS_ACCESS                      MEM
+#define KCS_PHYS_BASE_ADDR              0xF002C000
+
+#define KCS_MAX_CHANNELS                3
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define KCS_BASE_ADDR                   KCS_PHYS_BASE_ADDR
+#else
+#define KCS_BASE_ADDR                   KCS_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ADC Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ADC_MODULE_TYPE                 Yarkon_IP
+#define ADC_ACCESS                      MEM
+#define ADC_PHYS_BASE_ADDR              0xF002D000
+
+#define ADC_MAX_CHANNELS                8
+#define ADC_GROUP_INTERRUPT             8
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define ADC_BASE_ADDR                   ADC_PHYS_BASE_ADDR
+#else
+#define ADC_BASE_ADDR                   ADC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PWM Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PWM_MODULE_TYPE                 Yarkon_IP
+#define PWM_ACCESS                      MEM
+#define PWM_PHYS_BASE_ADDR(module)      (0xF0028000 + (0x1000 * (module)))
+
+#define PWM_MAX_MODULES                 2
+#define PWM_MAX_PORTS                   8
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PWM_BASE_ADDR(module)           PWM_PHYS_BASE_ADDR(module)
+#else
+#define PWM_BASE_ADDR(module)           PWM_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUI Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FIU_MODULE_TYPE                 Hermon_IP
+#define FIU_ACCESS                      MEM
+#define FIU_PHYS_BASE_ADDR(module)      0xF8000000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define FIU_BASE_ADDR                   FIU_PHYS_BASE_ADDR(0)
+#else
+#define FIU_BASE_ADDR                   FIU_VIRT_BASE_ADDR(0)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Clock Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_MODULE_TYPE                 Yarkon_IP
+#define CLK_ACCESS                      MEM
+#define CLK_PHYS_BASE_ADDR              0xF0400200
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define CLK_BASE_ADDR                   CLK_PHYS_BASE_ADDR
+#else
+#define CLK_BASE_ADDR                   CLK_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Shared Memory (SHM) Module                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHM_MODULE_TYPE                 Yarkon_IP
+#define SHM_ACCESS                      MEM
+#define SHM_PHYS_BASE_ADDRESS           0xF8001000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SHM_BASE_ADDR                   SHM_PHYS_BASE_ADDRESS
+#else
+#define SHM_BASE_ADDR                   SHM_VIRT_BASE_ADDRESS
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AIC Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AIC_MODULE_TYPE                 Hermon_IP
+#define AIC_ACCESS                      MEM
+#define AIC_PHYS_BASE_ADDR              0xF0000000
+#define AIC_INTERRUPT_NUM               32
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define AIC_BASE_ADDR                   AIC_PHYS_BASE_ADDR
+#else
+#define AIC_BASE_ADDR                   AIC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet 100 Mac Controler                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EMC_MODULE_TYPE                 Hermon_IP
+#define EMC_ACCESS                      MEM
+#define EMC_PHYS_BASE_ADDR(module)      0xF0402000
+#define EMC_RX_INTERRUPT(module)        EMC1_RX_INT
+#define EMC_TX_INTERRUPT(module)        EMC1_TX_INT
+#define EMC_NUM_OF_MODULES              1
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define EMC_BASE_ADDR(module)           EMC_PHYS_BASE_ADDR(module)
+#else
+#define EMC_BASE_ADDR(module)           EMC_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GMAC Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GMAC_MODULE_TYPE                Yarkon_IP
+#define GMAC_ACCESS                     MEM
+#define GMAC_PHYS_BASE_ADDR(module)     0xF040A000            // Only GMAC2 on Yarkon
+#define GMAC_INTERRUPT(module)          GMAC_INT
+#define GMAC_NUM_OF_MODULES             1
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GMAC_BASE_ADDR(module)          GMAC_PHYS_BASE_ADDR(module)
+#else
+#define GMAC_BASE_ADDR(module)          GMAC_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Control                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MC_MODULE_TYPE                  Yarkon_IP
+#define MC_ACCESS                       MEM
+#define MC_PHYS_BASE_ADDR               0xFF000000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define MC_BASE_ADDR                    MC_PHYS_BASE_ADDR
+#else
+#define MC_BASE_ADDR                    MC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Module                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define SD_MODULE_TYPE                  Hermon_IP
+//#define SD_ACCESS                       MEM
+#define SD_PHYS_BASE_ADDR(module)       (0xF0407000 + (0x1000 * (module)))
+#define SD_GROUP_INTERRUPT(module)      (14 + (module))
+#define SD_INTERRUPT(module)            SDHC_INT
+#define SD_NUM_OF_MODULES               2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SD_BASE_ADDR(module)            SD_PHYS_BASE_ADDR(module)
+#else
+#define SD_BASE_ADDR(module)            SD_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AES_MODULE_TYPE                 Yarkon_IP
+#define AES_ACCESS                      MEM
+#define AES_PHYS_BASE_ADDR              0xF4200000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define AES_BASE_ADDR                   AES_PHYS_BASE_ADDR
+#else
+#define AES_BASE_ADDR                   AES_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DES_MODULE_TYPE                 Yarkon_IP
+#define DES_ACCESS                      MEM
+#define DES_PHYS_BASE_ADDR              0xF4201000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define DES_BASE_ADDR                   DES_PHYS_BASE_ADDR
+#else
+#define DES_BASE_ADDR                   DES_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* STRAP Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define STRP_MODULE_TYPE                Yarkon_IP
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUSE Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FUSE_MODULE_TYPE                Yarkon_IP
+#define FUSE_OTP_ACCESS                 MEM
+#define FUSE_PHYS_BASE_ADDR(module)     (0xF0019000 + ((module) * 0x1000))
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define FUSE_BASE_ADDR(module)          FUSE_PHYS_BASE_ADDR(module)
+#else
+#define FUSE_BASE_ADDR(module)          FUSE_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VCD Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define VCD_MODULE_TYPE                 Hermon_IP
+#define VCD_ACCESS                      MEM
+#define VCD_PHYS_BASE_ADDR              0xF0410000
+#define VCD_INTERRUPT                   VCD_INT
+#define VCD_GROUP_INTERRUPT             12
+
+#define VCD_MEM_PORT1                   3
+#define VCD_MEM_PORT2                   4
+
+#define VCD_MAX_WIDTH                   2047
+#define VCD_MAX_HIGHT                   1536
+#define USE_INTERNAL_GFX
+
+#define VCD_FRAME_A_PHYS_BASE_ADDRESS   0x6C00000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define VCD_BASE_ADDR                   VCD_PHYS_BASE_ADDR
+#else
+#define VCD_BASE_ADDR                   VCD_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFX Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GFX_MODULE_TYPE                 Hermon_IP
+#define GFX_ACCESS                      MEM
+#define GFX_PHYS_BASE_ADDR              0xF0004000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GFX_BASE_ADDR                   GFX_PHYS_BASE_ADDR
+#else
+#define GFX_BASE_ADDR                   GFX_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ECE Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ECE_MODULE_TYPE                 Yarkon_IP
+#define ECE_ACCESS                      MEM
+#define ECE_PHYS_BASE_ADDR              0xFF002000
+#define ECE_INTERRUPT                   VCD_INT
+#define ECE_GROUP_INTERRUPT             11
+
+#define ECE_ED_PHYS_BASE_ADDRESS        0x6800000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define ECE_BASE_ADDR                   ECE_PHYS_BASE_ADDR
+#else
+#define ECE_BASE_ADDR                   ECE_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VDM Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define VDM_MODULE_TYPE                Yarkon_IP
+#define VDM_ACCESS                     MEM
+#define VDM_PHYS_BASE_ADDR     		   (0xF1F01000)
+#define VDMA_PHYS_BASE_ADDR     	   (0xF1F00000)
+
+
+#ifndef DYNAMIC_BASE_ADDRESS
+	#define VDM_BASE_ADDR         		VDM_PHYS_BASE_ADDR 
+	#define VDMA_BASE_ADDR         		VDMA_PHYS_BASE_ADDR 
+#else
+	#define VDM_BASE_ADDR 		        VDM_VIRT_BASE_ADDR 
+	#define VDMA_BASE_ADDR 		        VDMA_VIRT_BASE_ADDR 
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_MODULE_TYPE                Hermon_IP
+#define GPIO_ACCESS                     MEM
+#define GPIO_PHYS_BASE_ADDR(module)     (0xF000A000 + ((module)*0x1000))
+#define GPIO_INTERRUPT(gpio)            ((gpio) < 4 ? GPIO_INT0 : (gpio) < 12 ? GPIO_INT1 : (gpio) < 26 ? GPIO_INT2 : GPIO_INT3)
+
+#define GPIO_NUM_OF_MODULES             2
+#define GPIO_NUM_OF_PORTS               13
+#define GPIO_NUM_OF_GPIOS               208
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GPIO_BASE_ADDR(module)          GPIO_PHYS_BASE_ADDR(module)
+#else
+#define GPIO_BASE_ADDR(module)          GPIO_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PSPI Module (aka SSPI)                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PSPI_MODULE_TYPE                Hermon_IP
+#define PSPI_ACCESS                     MEM
+#define PSPI_PHYS_BASE_ADDR(module)     (0xF0005000 + ((module) * 0x1000))
+#define PSPI_NUM_OF_MODULES             2
+#define PSPI_GROUP_INTERRUPT(module)    (9 + (module))
+
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PSPI_BASE_ADDR(module)          PSPI_PHYS_BASE_ADDR(module)
+#else
+#define PSPI_BASE_ADDR(module)          PSPI_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AHB2 SRAM Module                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM2_ACCESS                    MEM
+#define SRAM2_PHYS_BASE_ADDR            0xF1FFE000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SRAM2_BASE_ADDR                 SRAM2_PHYS_BASE_ADDR
+#else
+#define SRAM2_BASE_ADDR                 SRAM2_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AHB7 SRAM Module                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM7_ACCESS                    MEM
+#define SRAM7_PHYS_BASE_ADDR            0xF2000000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SRAM7_BASE_ADDR                 SRAM7_PHYS_BASE_ADDR
+#else
+#define SRAM7_BASE_ADDR                 SRAM7_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* USB Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define USB_MODULE_TYPE                 Hermon_IP
+#define USB_ACCESS                      MEM
+#define USB_PHYS_BASE_ADDR(module)      ((module == 1) ? 0xF0406000 : (module == 2) ? 0xF0405000 : (module == 3) ? 0xF0404000 : (module == 4) ? 0xF040E000 : (module == 5) ? 0xF040D000 : 0xF040C000)
+#define USB_INTERRUPT(module)           (((module == 1) || (module == 4)) ? USBD14_INT : ((module == 2) || (module == 5)) ? USBD25_INT : USBD36_INT)
+#define USB_IS_FULL_SPEED(module)       ((module) == 1 ? 1 : 0)
+#define USB_DESC_PHYS_BASE_ADDR(module) ((module % 2) ? SRAM2_PHYS_BASE_ADDR + 0x800 * (module / 2) : SRAM7_PHYS_BASE_ADDR + 0x800 * ((module-1) / 2))
+#define USB_DESC_VIRT_BASE_ADDR(module) ((module % 2) ? SRAM2_BASE_ADDR + 0x800 * (module / 2) : SRAM7_BASE_ADDR + 0x800 * ((module-1) / 2))
+#define USB_NUM_OF_MODULES              6
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define USB_BASE_ADDR(module)           USB_PHYS_BASE_ADDR(module)
+#else
+#define USB_BASE_ADDR(module)           USB_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupts                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    SWD_INT         = 0,    /* System Watch Dog and Timer Module 2 Interrupt                               */
+    WDT_INT         = 1,    /* Watch Dog Timer Interrupt                                                   */
+    GPIO_INT0       = 2,    /* GPIO Interrupt Group 0 containing GPIOE3-0                                  */
+    GPIO_INT1       = 3,    /* GPIO Interrupt Group 1 containing GPIOE11-4                                 */
+    GPIO_INT2       = 4,    /* GPIO Interrupt Group 2 containing GPIOE15-12, GPIO25-24                     */
+    GPIO_INT3       = 5,    /* GPIO Interrupt Group 3 containing GPIOE143-128, GPIOE153-152                */
+    PECI_INT        = 6,    /* PECI and VSYNC Interrupt group                                              */
+    UART0_INT       = 7,    /* UART0 Interrupt and VDMA interrupt group                                    */
+    UART1_INT       = 8,    /* UART1 Interrupt                                                             */
+    KCS_HIB_INT     = 9,    /* KCS/HIB Interrupt (from host interface)                                     */
+    FIU_SPI_INT     = 10,   /* FIU_SPI interrupt                                                           */
+    SHM_INT         = 11,   /* SHM Interrupt and PCI mailbox interrupt group                               */
+    T_INT0          = 12,   /* Timer Interrupt 0                                                           */
+    T_INT1          = 13,   /* Timer Interrupt 1                                                           */
+    T_INT_GRP       = 14,   /* Timer Interrupt Group containing Timer2, Timer3, Timer4                     */
+    EMC1_RX_INT     = 15,   /* EMC1 Rx Interrupt                                                           */
+    EMC1_TX_INT     = 16,   /* EMC1 Tx Interrupt                                                           */
+    GMAC_INT        = 17,   /* GMAC Interrupt                                                              */
+    USBD36_INT      = 18,   /* USB Device3 and USB Device6 Interrupt Interrupt                             */
+    SIOX_INT        = 19,   /* SIOX Serial GPIO Expander modules                                           */
+    USBD25_INT      = 20,   /* USB Device2 and USB Device5 Interrupt                                       */
+    USBD14_INT      = 21,   /* USB Device1 and USB Device4 Interrupt                                       */
+    VCD_INT         = 22,   /* VCD interrupt, DVC interrupt and ECE interrupt group                        */
+    SDHC_INT        = 23,   /* SDHC1 and SDHC2 Interrupt                                                   */
+    MFT03_INT       = 24,   /* Tachometer Timer 0-3 (MFT0) Interrupt                                       */
+    MFT47_INT       = 25,   /* Tachometer Timer 4-7 (MFT1) Interrupt                                       */
+    SMB_GRP1_INT    = 26,   /* SMBus Interrupt Group containing SMBus0, SMBus1, SMBus2                     */
+    SMB_GRP3_INT    = 27,   /* SMBus Interrupt Group containing SMBus6, SMBus7                             */
+    PWM_INT         = 28,   /* PWM  Interrupt Group containing PWM0-PWM7                                   */
+    SMB_GRP2_INT    = 29,   /* SMBus Interrupt Group containing SMBus3, SMBus4, SMBus5                     */
+    MCTP_INT        = 30,   /* VDMX module interrupt                                                       */
+    INT31_GRP_INT   = 31,   /* INT31 group containing ADC, PSPI1, PSPI2                                    */
+} irq_list_t;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIOs definition table                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_DEFINITION_TABLE                                                                                                                                                                       \
+{                                                                                                                                                                                                   \
+    /* Port 0: GPIO 0-15 */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 0, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(0),  GPIO_CAP_DEBOUNCE(0),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(1),  GPIO_CAP_DEBOUNCE(1),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(2),  GPIO_CAP_DEBOUNCE(2),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(3),  GPIO_CAP_DEBOUNCE(3),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(4),  GPIO_CAP_DEBOUNCE(4),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(5),  GPIO_CAP_DEBOUNCE(5),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(6),  GPIO_CAP_DEBOUNCE(6),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(7),  GPIO_CAP_DEBOUNCE(7),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(8),  GPIO_CAP_DEBOUNCE(8),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(9),  GPIO_CAP_DEBOUNCE(9),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(10), GPIO_CAP_DEBOUNCE(10), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(11), GPIO_CAP_DEBOUNCE(11), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(12), GPIO_CAP_DEBOUNCE(12), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(13), GPIO_CAP_DEBOUNCE(13), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(14), GPIO_CAP_DEBOUNCE(14), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(15), GPIO_CAP_DEBOUNCE(15), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 1: GPIO 16-31 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 1, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(0),  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(4),  GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(8),  GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(12), GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(16), GPIO_MUX_REGID_MFSL2, 24, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(20), GPIO_MUX_REGID_MFSL2, 25, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(24), GPIO_MUX_REGID_MFSL2, 26, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(28), GPIO_MUX_REGID_MFSL2, 27, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(16), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 28, 1, 0,  GPIO_MUX_REGID_MFSL3, 18, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(17), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 29, 1, 0,  GPIO_MUX_REGID_MFSL3, 18, 1, 0), \
+    GPIO_TABLE_ENTRY( 1,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 2: GPIO 32-47 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 2, 0, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 1, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  5, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 29, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 28, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 3: GPIO 48-63 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 3, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 12, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 30, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 31, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,13, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,14, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,15, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 4: GPIO 64-79 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 4, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 13, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 5: GPIO 80-94 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 5, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 17, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 19, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 15, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* GPIO 95 Undefined */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 5,15, GPIO_CAP_NO_INPUT, GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 6: GPIO 96-113 */                                                                                                                                                                       \
+    GPIO_TABLE_ENTRY( 6, 0, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 1, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 2, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 3, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 4, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 5, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 6, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 7, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 8, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 9, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,10, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,11, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,12, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,13, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,14, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,15, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,16, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,17, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 7: GPIO 114-127 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 7, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 8: GPIO 128-143 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 8, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(0),  GPIO_CAP_DEBOUNCE(0),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(1),  GPIO_CAP_DEBOUNCE(1),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(2),  GPIO_CAP_DEBOUNCE(2),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(3),  GPIO_CAP_DEBOUNCE(3),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(4),  GPIO_CAP_DEBOUNCE(4),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(5),  GPIO_CAP_DEBOUNCE(5),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(6),  GPIO_CAP_DEBOUNCE(6),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(7),  GPIO_CAP_DEBOUNCE(7),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(8),  GPIO_CAP_DEBOUNCE(8),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(9),  GPIO_CAP_DEBOUNCE(9),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(10), GPIO_CAP_DEBOUNCE(10), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(11), GPIO_CAP_DEBOUNCE(11), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(12), GPIO_CAP_DEBOUNCE(12), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(13), GPIO_CAP_DEBOUNCE(13), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(14), GPIO_CAP_DEBOUNCE(14), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(15), GPIO_CAP_DEBOUNCE(15), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 9: GPIO 144-159 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 9, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(0),  GPIO_MUX_REGID_MFSL2, 20, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(4),  GPIO_MUX_REGID_MFSL2, 21, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(8),  GPIO_MUX_REGID_MFSL2, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(12), GPIO_MUX_REGID_MFSL2, 23, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(16), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(20), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(24), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(28), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(16), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(17), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 10: GPIO 160-175 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(10, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 21, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 31, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 16, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 11: GPIO 176-191 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(11, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  8, 1, 0,  GPIO_MUX_REGID_MFSL3, 31, 1, 0), \
+    GPIO_TABLE_ENTRY(11, 8, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 9, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,10, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,11, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,12, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,13, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,14, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,15, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 12: GPIO 192-207 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(12, 0, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY(12, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+}
+
+
+#endif //_NPCM650_CHIP_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Chips/npcm750/npcm750.h b/board/nuvoton/common/BMC_HAL/Chips/npcm750/npcm750.h
new file mode 100755
index 0000000..9b6189a
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/npcm750/npcm750.h
@@ -0,0 +1,1276 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   npcm750.h                                                                                             */
+/*            This file contains chip definitions for the given project                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __NPCM750_CHIP_H_
+#define __NPCM750_CHIP_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              CHIP                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Chip Name                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCM750
+//#define _PALLADIUM_                       1       // Activate Palladium bypasses
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip POLEG NPCM750 VERSIONS                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  POLEG_Z1                0x00A92750
+#define  POLEG_Z2                0x04A92750
+#define  POLEG_A1                0x10A92750
+
+#define EXT_CLOCK_FREQUENCY_MHZ 25
+#define EXT_CLOCK_FREQUENCY_KHZ (EXT_CLOCK_FREQUENCY_MHZ*_1KHz_)
+#define EXT_CLOCK_FREQUENCY_HZ  (EXT_CLOCK_FREQUENCY_MHZ*_1MHz_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip ROM                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROM_BASE_ADDR                  0xFFFF0000
+#define ROM_MEMORY_SIZE                _64KB_
+#define ROMCODE_VER_ADDR               0xFFFF00FC
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* External SDRAM Space DDR4                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SDRAM_BASE_ADDR                 0x00000000
+#define SDRAM_MAPPED_SIZE               (_2GB_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* External Coprocessor (CR16C+) area                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define COPR_BASE_ADDR                  0xF0600000
+#define COPR_MAPPED_SIZE               (_2MB_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI0 Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SPI0CS0_BASE_ADDR               0x80000000      /* SPI0 direct access CS0  */
+#define SPI0CS1_BASE_ADDR               0x88000000      /* SPI0 direct access CS1  */
+#define SPI0CS2_BASE_ADDR               0x90000000      /* SPI0 direct access CS2  */
+#define SPI0CS3_BASE_ADDR               0x98000000      /* SPI0 direct access CS3  */
+
+#define SPI3CS0_BASE_ADDR               0xA0000000      /* SPI3 direct access CS0  */
+#define SPI3CS1_BASE_ADDR               0xA8000000      /* SPI3 direct access CS1  */
+#define SPI3CS2_BASE_ADDR               0xB0000000      /* SPI3 direct access CS2  */
+#define SPI3CS3_BASE_ADDR               0xB8000000      /* SPI3 direct access CS3  */
+
+#define FLASH_MEMORY_SIZE(device)       _128MB_
+
+#define FLASH_BASE_ADDR(device)         (SPI0CS0_BASE_ADDR + (device) * (FLASH_MEMORY_SIZE(device)))
+
+#define FIU_DEVICES_PER_MODULE           4
+#define FLASH_NUM_OF_DEVICES             8           /* Number of Chip select per FIU module ! */
+
+#define SPI0_MEMORY_SIZE                _512KB_
+#define SPI3_MEMORY_SIZE                _512KB_
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Expansion Flash                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SPIXCS0_BASE_ADDR               0xF8000000      /* SPIX direct access CS0  */
+#define SPIXCS1_BASE_ADDR               0xF9000000      /* SPIX direct access CS1  */
+#define SPIX_MEMORY_SIZE                _64KB_
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* XBus                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define XBUS_BASE_ADDR                  0xC2000000      /* XBUS direct access  */
+#define XBUS_MAPPED_SIZE                _32MB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Mapped IO                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOMEMORY_BASE_ADDR              0xF0000000
+#define IOMEMORY_SIZE                   0x0F004000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RAM3                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RAM3_BASE_ADDR                  0xC0008000      /* RAM3  */
+#define RAM3_MAPPED_SIZE                _4KB_
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OTP                                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define OTPROM_BASE_ADDR                0xF0189000      /* OTP ROM  */
+#define OTP2ROM_BASE_ADDR               0xF018A000      /* OTP2 ROM  */
+#define OTPROM_MAPPED_SIZE              _128B_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip SRAM     (SRAM2)                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RAM2_BASE_ADDR                  0xFFFD0000
+#define RAM2_MEMORY_SIZE                _128KB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SRAM2 lockable  (Lockable in 2x 1KB pieces)                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM_LOCK_BASE_ADDR                  0xFFFEF800      /* SRAM, lockable  */
+#define SRAM_LOCK_MAPPED_SIZE                _2KB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* first 256 byte in RAM2 mirrored to this address. if RAMV = 1, default 0 (ROM)                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM_VECOTR_BASE_ADDR           0xFFFF0000      /* SRAM, mapped to vector area  */
+#define SRAM_VECOTR_MAPPED_SIZE         _256B_
+
+
+/* Following modules either new to Poleg, or do not have drivers, or empty allocations on the AHB \ APB */
+#define MAIN_MEM_BASE_ADDR              0x00000000      /* DDR4 Memory Controller  */
+#define AHB1_BASE_ADDR                  0xF0000000      /* AHB1 allocation (Including APB allocations)  */
+#define AHB8_BASE_ADDR                  0xF0800000      /* AHB8 allocation  */
+#define DVC_BASE_ADDR                   0xF0808000      /* DVC (KVM) registers  */
+#define MCR_BASE_ADDR                   0xF0824000      /* Memory Controller Registers  */
+#define CRDRDR_BASE_ADDR                0xF0840000      /* SDHC1: Card reader Control registers SD Controller registers  */
+#define MMC1_BASE_ADDR                  0xF0842000      /* SDHC2: MMC registers  */
+#define GDMA0_BASE_ADDR                 0xF0850000      /* GDMA0  */
+#define GDMA1_BASE_ADDR                 0xF0851000      /* GDMA1  */
+#define GDMA2_BASE_ADDR                 0xF0852000      /* GDMA2  */
+#define GDMA3_BASE_ADDR                 0xF0853000      /* GDMA3  */
+#define SECACC_BASE_ADDR                0xF085B000      /* SECACC  */
+#define AHB18_BASE_ADDR                 0x80000000      /* AHB18 allocation  */
+#define AHB3_BASE_ADDR                  0xA0000000      /* AHB3 allocation  */
+#define XBUSR_BASE_ADDR                 0xC0002000      /* XBUS registers  */
+#define AHB14_BASE_ADDR                 0xE0000000      /* AHB14 Allocation  */
+#define APB14_BASE_ADDR                 0xE0000000      /* APB14 Allocation  */
+#define VDMX_BASE_ADDR                  0xE0800000      /* VDMX  */
+#define APBS_BASE_ADDR                  0xF0000000      /* APBs Allocation  */
+#define APB1_BASE_ADDR                  0xF0000000      /* APB1 Allocation  */
+#define RNG_BASE_ADDR                   0xF000B000      /* RNG  */
+#define BT_BASE_ADDR                    0xF000D000      /* BT (Block Transfer)  */
+#define SHRDIO_BASE_ADDR                0xF001C000      /* 16B Shared I/O (IBM)  */
+#define APB2_BASE_ADDR                  0xF0080000      /* APB2 Allocation  */
+#define APB2_BASE_ADDR                  0xF0080000      /* APB2 Allocation  */
+#define APB3_BASE_ADDR                  0xF0100000      /* APB3 Allocation  */
+#define PECI_BASE_ADDR                  0xF0100000      /* PECI registers  */
+#define SIOX1_BASE_ADDR                 0xF0101000      /* Serial GPIO Expansion 1  */
+#define SIOX2_BASE_ADDR                 0xF0102000      /* Serial GPIO Expansion 2  */
+#define APB4_BASE_ADDR                  0xF0180000      /* APB4 Allocation  */
+#define THRMS_BASE_ADDR                 0xF0188000      /* Thermal Sensor  */
+#define APB2SIB_BASE_ADDR               0xF018C000      /* APB2SIB  */
+#define APB5_BASE_ADDR                  0xF0200000      /* APB5 Allocation  */
+#define A9_BASE_ADDR                    0xF03FC000      /* Level 2 Cache Registers + A9 Peripherals Registers Allocation  */
+#define DAP_BASE_ADDR                   0xF0500000      /* Cortex A9 Debug Access Port + MCPHY Allocation  */
+#define AHB19_BASE_ADDR                 0xFFF00000      /* AHB19 allocation  */
+
+#define USBH_EHCI_BASE_ADDR             0xF0806000
+#define USBH_OHCI_BASE_ADDR             0xF0807000
+
+#define AHB_PCI_BASE_ADDR               0xF0400000      /* AHB to PCI bridge  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Palladium pll0 global register                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+#define PALLADIUM_PLL0_ACCESS                      MEM
+#define PALLADIUM_PLL0_PHYS_BASE_ADDR              0xffff3fc4
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PALLADIUM_PLL0_BASE_ADDR                   PALLADIUM_PLL0_PHYS_BASE_ADDR
+#else
+#define PALLADIUM_PLL0_BASE_ADDR                   PALLADIUM_PLL0_VIRT_BASE_ADDR
+#endif
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Multi-Function Timer Module                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MFT_MODULE_TYPE                 Poleg_IP
+#define MFT_ACCESS                      MEM
+
+#define MFT0_BASE_ADDR                  0xF0180000      /* Tachmeter MFT 0  */
+#define MFT1_BASE_ADDR                  0xF0181000      /* Tachmeter MFT 1  */
+#define MFT2_BASE_ADDR                  0xF0182000      /* Tachmeter MFT 2  */
+#define MFT3_BASE_ADDR                  0xF0183000      /* Tachmeter MFT 3  */
+#define MFT4_BASE_ADDR                  0xF0184000      /* Tachmeter MFT 4  */
+#define MFT5_BASE_ADDR                  0xF0185000      /* Tachmeter MFT 5  */
+#define MFT6_BASE_ADDR                  0xF0186000      /* Tachmeter MFT 6  */
+#define MFT7_BASE_ADDR                  0xF0187000      /* Tachmeter MFT 7  */
+
+#define MFT_PHYS_BASE_ADDR(module)      (MFT0_BASE_ADDR + ((module) * 0x1000L))
+#define MFT_INTERRUPT(module)           (MFT_INTERRUPT_1 + module)
+
+#define MFT_NUM_OF_MODULES              2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define MFT_BASE_ADDR(module)           MFT_PHYS_BASE_ADDR(module)
+#else
+#define MFT_BASE_ADDR(module)           MFT_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Ethernet configuration                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC1/2  ETH0/ETH1 - see BMC_HAL/EMC and npcmX50_eth.c code */
+#define CHIP_NUM_OF_EMC_ETH             2
+#define CHIP_NUM_OF_ETH                 CHIP_NUM_OF_EMC_ETH
+#define CHIP_ETH0_TYPE                  EMC
+#define CHIP_ETH1_TYPE                  EMC
+
+/* GMAC1/2  ETH2/ETH3 - see GMAC synopsys code */
+#define CHIP_NUM_OF_GMAC_ETH            2
+#define GMAC1_ETH2                      2
+#define GMAC2_ETH3                      3
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Module  : System Global Registers                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GCR_MODULE_TYPE                 Poleg_IP
+#define GCR_ACCESS                      MEM
+#define GCR_PHYS_BASE_ADDR              0xF0800000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GCR_BASE_ADDR                   GCR_PHYS_BASE_ADDR
+#else
+#define GCR_BASE_ADDR                   GCR_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define UART_MODULE_TYPE                Hermon_IP
+#define UART_ACCESS                     MEM
+#define UART0_BASE_ADDR                 0xF0001000      /* UART0 registers  */
+#define UART1_BASE_ADDR                 0xF0002000      /* UART1 registers  */
+#define UART2_BASE_ADDR                 0xF0003000      /* UART2 registers  */
+#define UART3_BASE_ADDR                 0xF0004000      /* UART3 registers  */
+#define UART_PHYS_BASE_ADDR(module)     (UART0_BASE_ADDR + ((module) * 0x1000))
+#define UART_INTERRUPT(module)          (UART_INTERRUPT_0 + module)
+#define UART_NUM_OF_MODULES             4
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define UART_BASE_ADDR(module)          UART_PHYS_BASE_ADDR(module)
+#else
+#define UART_BASE_ADDR(module)          UART_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PCI MailBox Module                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define PCIMBX_PHYS_BASE_ADDR           0xF0848000      /* PCI Mailbox direct mapping . Mapped till 0xEFFFFFFF. */
+
+#define PCIMBX_ACCESS                   MEM
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PCIMBX_BASE_ADDR                PCIMBX_PHYS_BASE_ADDR
+#else
+#define PCIMBX_BASE_ADDR                PCIMBX_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PCTL (Memory) Module                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PCTL_ACCESS                     MEM
+#define PCTL_PHYS_BASE_ADDR             0xFF001000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PCTL_BASE_ADDR                  PCTL_PHYS_BASE_ADDR
+#else
+#define PCTL_BASE_ADDR                  PCTL_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_MODULE_TYPE               Hermon_IP
+#define TIMER_ACCESS                    MEM
+#define TMR0_BASE_ADDR                  0xF0008000      /* Timer0  module registers  */
+#define TMR1_BASE_ADDR                  0xF0009000      /* Timer1  module registers  */
+#define TMR2_BASE_ADDR                  0xF000A000      /* Timer2  module registers  */
+#define TIMER_PHYS_BASE_ADDR(module)    (TMR0_BASE_ADDR + ((module)*0x1000))
+#define TIMER_INTERRUPT(port)           (TIMER_INTERRUPT_0 + (port))         /* (TIMER_INTERRUPT_0 to TIMER_INTERRUPT_14) */
+#define TIMER_GROUP_INTERRUPT(port)     ((((port) >=2) && ((port) <5)) ? (16 + ((port)-2)) : AIC_GROUP_INTERRUPT_NONE)
+#define WDG_INTERRUPT(port)             (WDG_INTERRUPT_0 + (port))           /* (WDG_INTERRUPT_0 to WDG_INTERRUPT_2) */
+
+#define TIMER_NUM_OF_MODULES            3
+#define TIMER_NUM_OF_PORTS              15
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define TIMER_BASE_ADDR(port)           TIMER_PHYS_BASE_ADDR(port)
+#else
+#define TIMER_BASE_ADDR(port)           TIMER_VIRT_BASE_ADDR(port)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SMB Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SMB_MODULE_TYPE                 Hermon_IP
+#define SMB_ACCESS                      MEM
+#define SMB_PHYS_BASE_ADDR(module)      (0xF0080000+((module)*0x1000))
+
+#define SMB_MAX_BUSES                   16
+#define SMB_SCL_GPIOS                   114, 116, 118, 31, 29, 27, 171, 173, 128, 130, 132, 134, 220, 222, 23, 21 
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SMB_BASE_ADDR(module)           SMB_PHYS_BASE_ADDR(module)
+#else
+#define SMB_BASE_ADDR(module)           SMB_VIRT_BASE_ADDR(module)
+#endif
+
+#define SMB_INTERRUPT(module)           (SMB_INTERRUPT_0 + module)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* KCS Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define KCS_MODULE_TYPE                 Yarkon_IP
+#define KCS_ACCESS                      MEM
+#define KCS_PHYS_BASE_ADDR              0xF0007000
+
+#define KCS_MAX_CHANNELS                3
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define KCS_BASE_ADDR                   KCS_PHYS_BASE_ADDR
+#else
+#define KCS_BASE_ADDR                   KCS_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ADC Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ADC_MODULE_TYPE                 Yarkon_IP
+#define ADC_ACCESS                      MEM
+#define ADC_PHYS_BASE_ADDR              0xF000C000
+
+#define ADC_MAX_CHANNELS                8
+#define ADC_GROUP_INTERRUPT             8
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define ADC_BASE_ADDR                   ADC_PHYS_BASE_ADDR
+#else
+#define ADC_BASE_ADDR                   ADC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PWM Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PWM_MODULE_TYPE                 Yarkon_IP
+#define PWM_ACCESS                      MEM
+#define PWM_PHYS_BASE_ADDR(module)      (0xF0103000 + (0x1000 * (module)))
+
+#define PWM_MAX_MODULES                 2
+#define PWM_MAX_PORTS                   8
+ 
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PWM_BASE_ADDR(module)           PWM_PHYS_BASE_ADDR(module)
+#else
+#define PWM_BASE_ADDR(module)           PWM_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FIU_MODULE_TYPE                 Poleg_IP
+#define FIU_ACCESS                      MEM
+
+#define FIU0_BASE_ADDR                  0xFB000000      /* SPI0 registers  */
+#define FIUX_BASE_ADDR                  0xFB001000      /* SPIX registers  */
+#define FIU3_BASE_ADDR                  0xC0000000      /* SPI3 registers  */
+
+#define FIU_PHYS_BASE_ADDR(n)           ( ( (n) == 0 ) ? FIU0_BASE_ADDR : ( (n) == 3 ) ? FIU3_BASE_ADDR : FIUX_BASE_ADDR)
+#define FIU_NUM_OF_MODULES              3
+#ifndef DYNAMIC_BASE_ADDRESS
+#define FIU_BASE_ADDR(module)           FIU_PHYS_BASE_ADDR(module)    // Use this when handle FIU for on Poleg_IP inside HAL
+#else
+#define FIU_BASE_ADDR(module)           FIU_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Clock Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_MODULE_TYPE                 Poleg_IP
+#define CLK_ACCESS                      MEM
+#define CLK_PHYS_BASE_ADDR              0xF0801000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define CLK_BASE_ADDR                   CLK_PHYS_BASE_ADDR
+#else
+#define CLK_BASE_ADDR                   CLK_VIRT_BASE_ADDR
+#endif
+
+#define EXT_CLOCK_FREQUENCY_MHZ 25
+#define EXT_CLOCK_FREQUENCY_KHZ (EXT_CLOCK_FREQUENCY_MHZ*_1KHz_)
+#define EXT_CLOCK_FREQUENCY_HZ  (EXT_CLOCK_FREQUENCY_MHZ*_1MHz_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Shared Memory (SHM) Module                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHM_MODULE_TYPE                 Yarkon_IP
+#define SHM_ACCESS                      MEM
+#define SHM_PHYS_BASE_ADDRESS           0xC0001000
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SHM_BASE_ADDR                   SHM_PHYS_BASE_ADDRESS
+#else
+#define SHM_BASE_ADDR                   SHM_VIRT_BASE_ADDRESS
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AIC/GIC A9 Peripheral Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AIC_MODULE_TYPE                 Poleg_IP      // Using AIC API only.
+#define AIC_ACCESS                      MEM
+#define AIC_PHYS_BASE_ADDR              0xF03FE000
+
+#define GIC_INTERRUPT_NUM               160           // GIC (INTC for A9) first 32 interrupts are not used (128 irq's connected)
+#define GIC_CPU_INTERFACE_OFFSET        0x0100
+#define GIC_DISTRIBUTOR_OFFSET          0x1000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define AIC_BASE_ADDR                   AIC_PHYS_BASE_ADDR
+#else
+#define AIC_BASE_ADDR                   AIC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SCU A9 Peripheral Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SCU_PHYS_BASE_ADDR              0xF03FE000
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SCU_BASE_ADDR                   SCU_PHYS_BASE_ADDR
+#else
+#define SCU_BASE_ADDR                   SCU_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TWD A9 Peripheral Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TWD_PHYS_BASE_ADDR              0xF03FE600
+#ifndef DYNAMIC_BASE_ADDRESS
+#define TWD_BASE_ADDR                   TWD_PHYS_BASE_ADDR
+#else
+#define TWD_BASE_ADDR                   TWD_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet 100 Mac Controler    (10/100 Ethernet Controller)                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EMC_MODULE_TYPE                 Hermon_IP
+#define EMC_ACCESS                      MEM
+#define EMC1_BASE_ADDR                  0xF0825000      /* EMC1 (10/100 Ethernet Controller)  */
+#define EMC2_BASE_ADDR                  0xF0826000      /* EMC2 (10/100 Ethernet Controller)  */
+#define EMC_PHYS_BASE_ADDR(module)      ((module == 0) ? EMC1_BASE_ADDR : EMC2_BASE_ADDR)
+#define EMC_RX_INTERRUPT(module)        ((module == 0) ? EMC1RX_INTERRUPT  : EMC2RX_INTERRUPT)
+#define EMC_TX_INTERRUPT(module)        ((module == 0) ? EMC1TX_INTERRUPT  : EMC2TX_INTERRUPT)
+#define EMC_NUM_OF_MODULES              2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define EMC_BASE_ADDR(module)           EMC_PHYS_BASE_ADDR(module)
+#else
+#define EMC_BASE_ADDR(module)           EMC_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GMAC Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GMAC_MODULE_TYPE                Yarkon_IP
+#define GMAC_ACCESS                     MEM
+#define GMAC1_BASE_ADDR                 0xF0802000
+#define GMAC2_BASE_ADDR                 0xF0804000
+#define GMAC_PHYS_BASE_ADDR(module)      ((module == 0) ? GMAC1_BASE_ADDR : GMAC2_BASE_ADDR)
+#define GMAC_INTERRUPT(module)           ((module == 0) ? GMAC1_INTERRUPT : GMAC2_INTERRUPT)
+#define GMAC_NUM_OF_MODULES             2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GMAC_BASE_ADDR(module)          GMAC_PHYS_BASE_ADDR(module)
+#else
+#define GMAC_BASE_ADDR(module)          GMAC_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Control                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MC_MODULE_TYPE                  Poleg_IP
+#define MC_ACCESS                       MEM
+#define MC_PHYS_BASE_ADDR               0xF0824000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define MC_BASE_ADDR                    MC_PHYS_BASE_ADDR
+#else
+#define MC_BASE_ADDR                    MC_VIRT_BASE_ADDR
+#endif
+
+#define MCPHY_ACCESS                    MEM
+#define MCPHY_PHYS_BASE_ADDR            0xF05F0000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define MCPHY_BASE_ADDR                 MCPHY_PHYS_BASE_ADDR
+#else
+#define MCPHY_BASE_ADDR                 MCPHY_VIRT_BASE_ADDR
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Module                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SD_MODULE_TYPE                  Hermon_IP
+#define SD_ACCESS                       MEM
+#define SD_PHYS_BASE_ADDR(module)       (0xF0840000 + (0x2000 * (module)))
+#define SD_GROUP_INTERRUPT(module)      (14 + (module))
+#define SD_INTERRUPT(module)            (((module) == 0)? SDRDR_INTERRUPT : MMC_INTERRUPT)
+#define SD_NUM_OF_MODULES               2
+#define SD_CLK_TARGET_FREQ_Z1           (48 * _1MHz_)
+#define SD_CLK_TARGET_FREQ_A1           (50 * _1MHz_)
+
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SD_BASE_ADDR(module)            SD_PHYS_BASE_ADDR(module)
+#else
+#define SD_BASE_ADDR(module)            SD_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AES_MODULE_TYPE                 Yarkon_IP
+#define AES_ACCESS                      MEM
+#define AES_PHYS_BASE_ADDR              0xF0858000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define AES_BASE_ADDR                   AES_PHYS_BASE_ADDR
+#else
+#define AES_BASE_ADDR                   AES_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DES_MODULE_TYPE                 Yarkon_IP
+#define DES_ACCESS                      MEM
+#define DES_PHYS_BASE_ADDR              0xF0859000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define DES_BASE_ADDR                   DES_PHYS_BASE_ADDR
+#else
+#define DES_BASE_ADDR                   DES_VIRT_BASE_ADDR
+#endif
+#define DES_INTERRUPT_POLARITY           INTERRUPT_POLARITY_LEVEL_HIGH
+#define DES_INTERRUPT_PRIORITY           0
+#define DES_INTERRUPT_PROVIDER           CHIP_INTERRUPT_PROVIDER
+#define DES_NUM_OF_INPUTS                3
+#define DES_CLK                          2000000
+#define DES_SOURCE_CLOCK                 PLL2
+#define DES_MUX(input)                   CHIP_MuxDES(input)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* STRAP Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define STRP_MODULE_TYPE                Poleg_IP
+
+#define STRP_INTERRUPT_POLARITY          INTERRUPT_POLARITY_LEVEL_HIGH
+#define STRP_INTERRUPT_PRIORITY          0
+#define STRP_INTERRUPT_PROVIDER          CHIP_INTERRUPT_PROVIDER
+#define STRP_NUM_OF_INPUTS               3
+#define STRP_CLK                         2000000
+#define STRP_SOURCE_CLOCK                PLL2
+#define STRP_MUX(input)                  CHIP_MuxSTRP(input)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUSE Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FUSE_MODULE_TYPE                Poleg_IP
+#define FUSE_OTP_ACCESS                 MEM
+#define FUSE_PHYS_BASE_ADDR(module)     (0xF0189000 + ((module) * 0x1000))
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define FUSE_BASE_ADDR(module)          FUSE_PHYS_BASE_ADDR(module)
+#else
+#define FUSE_BASE_ADDR(module)          FUSE_VIRT_BASE_ADDR(module)
+#endif
+#define FUSE_INTERRUPT_POLARITY          INTERRUPT_POLARITY_LEVEL_HIGH
+#define FUSE_INTERRUPT_PRIORITY          0
+#define FUSE_INTERRUPT_PROVIDER          CHIP_INTERRUPT_PROVIDER
+#define FUSE_NUM_OF_INPUTS               3
+#define FUSE_CLK                         2000000
+#define FUSE_SOURCE_CLOCK                PLL2
+#define FUSE_MUX(input)                  CHIP_MuxFUSE(input)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VCD Module  (VIDEO CAPTURE AND DIFFERENTIATION)                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define VCD_MODULE_TYPE                 Hermon_IP
+#define VCD_ACCESS                      MEM
+#define VCD_PHYS_BASE_ADDR              0xF0810000
+
+#define VCD_MEM_PORT1                   3
+#define VCD_MEM_PORT2                   4
+
+#define VCD_MAX_WIDTH                   2032
+#define VCD_MAX_HIGHT                   1536
+#define USE_INTERNAL_GFX
+
+#define VCD_FRAME_A_PHYS_BASE_ADDRESS   0x3E200000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define VCD_BASE_ADDR                   VCD_PHYS_BASE_ADDR
+#else
+#define VCD_BASE_ADDR                   VCD_VIRT_BASE_ADDR
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFX Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GFX_MODULE_TYPE                 Hermon_IP
+#define GFX_ACCESS                      MEM
+
+#define GFXI_BASE_ADDR                  0xF000E000      /* Graphics Core information registers  */
+#define GFXOL_BASE_ADDR                 0xF0828000      /* GFX Overlay FIFO and registers  */
+
+#define GFX_PHYS_BASE_ADDR              GFXI_BASE_ADDR
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GFX_BASE_ADDR                   GFX_PHYS_BASE_ADDR
+#else
+#define GFX_BASE_ADDR                   GFX_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ECE Module:  Video Compression map ECE                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ECE_MODULE_TYPE                 Poleg_IP
+#define ECE_ACCESS                      MEM
+#define ECE_PHYS_BASE_ADDR              0xF0820000
+#define ECE_ED_PHYS_BASE_ADDRESS        0x3E800000
+#ifndef DYNAMIC_BASE_ADDRESS
+#define ECE_BASE_ADDR                   ECE_PHYS_BASE_ADDR
+#else
+#define ECE_BASE_ADDR                   ECE_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VDM Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define VDM_MODULE_TYPE                 Yarkon_IP
+#define VDM_ACCESS                      MEM
+#define VDM_PHYS_BASE_ADDR     	        (0xE0800000)
+#define VDMA_PHYS_BASE_ADDR             (0xF0822000)
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define VDM_BASE_ADDR         	        VDM_PHYS_BASE_ADDR 
+#define VDMA_BASE_ADDR         	        VDMA_PHYS_BASE_ADDR 
+#else
+#define VDM_BASE_ADDR 	                VDM_VIRT_BASE_ADDR 
+#define VDMA_BASE_ADDR 	                VDMA_VIRT_BASE_ADDR 
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PCIE RC Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PCIERC_MODULE_TYPE                 Poleg_IP
+#define PCIERC_ACCESS                      MEM
+#define PCIERC_PHYS_BASE_ADDR     	        (0xE1000000)
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PCIERC_BASE_ADDR         	        PCIERC_PHYS_BASE_ADDR 
+#else
+#define PCIERC_BASE_ADDR 	                PCIERC_VIRT_BASE_ADDR 
+#endif
+
+#define PCIERC_NUM_OF_MSI					32
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_MODULE_TYPE                Hermon_IP
+#define GPIO_ACCESS                     MEM
+#define GPIO0_BASE_ADDR                 0xF0010000      /* GPIO0 module registers  */
+#define GPIO1_BASE_ADDR                 0xF0011000      /* GPIO1 module registers  */
+#define GPIO2_BASE_ADDR                 0xF0012000      /* GPIO2 module registers  */
+#define GPIO3_BASE_ADDR                 0xF0013000      /* GPIO3 module registers  */
+#define GPIO4_BASE_ADDR                 0xF0014000      /* GPIO4 module registers  */
+#define GPIO5_BASE_ADDR                 0xF0015000      /* GPIO5 module registers  */
+#define GPIO6_BASE_ADDR                 0xF0016000      /* GPIO6 module registers  */
+#define GPIO7_BASE_ADDR                 0xF0017000      /* GPIO7 module registers  */
+#define GPIO_PHYS_BASE_ADDR(port)       (GPIO0_BASE_ADDR + ((port)*0x1000))
+#define GPIO_INTERRUPT(gpio)            ((gpio) < 32  ? GPIO_INTERRUPT0 : (gpio) < 64  ? GPIO_INTERRUPT1 : (gpio) < 96  ? GPIO_INTERRUPT2 :   \
+                                         (gpio) < 128 ? GPIO_INTERRUPT3 : (gpio) < 160 ? GPIO_INTERRUPT4 : (gpio) < 192 ? GPIO_INTERRUPT5 :  \
+                                         (gpio) < 224 ? GPIO_INTERRUPT6 :  GPIO_INTERRUPT7)
+
+#define GPIO_NUM_OF_MODULES              1
+#define GPIO_NUM_OF_PORTS                8
+#define GPIO_NUM_OF_GPIOS                256
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GPIO_BASE_ADDR(port)           GPIO_PHYS_BASE_ADDR(port)
+#else
+#define GPIO_BASE_ADDR(port)           GPIO_VIRT_BASE_ADDR(port)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PSPI Module (aka SSPI)                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PSPI_MODULE_TYPE                Hermon_IP
+#define PSPI_ACCESS                     MEM
+#define PSPI1_BASE_ADDR                 0xF0200000      /* Peripheral SPI 1 registers  */
+#define PSPI2_BASE_ADDR                 0xF0201000      /* Peripheral SPI 2 registers  */
+
+#define ESPI_BASE_ADDR                  0xF008F000      /* eSPI registers  */
+
+
+#define PSPI_PHYS_BASE_ADDR(module)     (PSPI1_BASE_ADDR + ((module) * 0x1000))
+#define PSPI_NUM_OF_MODULES             2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PSPI_BASE_ADDR(module)          PSPI_PHYS_BASE_ADDR(module)
+#else
+#define PSPI_BASE_ADDR(module)          PSPI_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AHB2 SRAM Module (SRAM2)                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM2_ACCESS                    MEM
+#define SRAM2_PHYS_BASE_ADDR             RAM2_BASE_ADDR
+#define SRAM2_MEMORY_SIZE               RAM2_MEMORY_SIZE
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SRAM2_BASE_ADDR                 SRAM2_PHYS_BASE_ADDR
+#else
+#define SRAM2_BASE_ADDR                 SRAM2_VIRT_BASE_ADDR
+#endif
+
+#define SRAM_BASE_ADDR                  SRAM2_BASE_ADDR
+#define SRAM_MEMORY_SIZE                SRAM2_MEMORY_SIZE
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* USB Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define USB_MODULE_TYPE                 Hermon_IP
+#define USB_ACCESS                      MEM
+
+#define USB0_BASE_ADDR                  0xF0830000      /* USB (2.0) Device 0 registers  */
+#define USB1_BASE_ADDR                  0xF0831000      /* USB (2.0) Device 1 registers  */
+#define USB2_BASE_ADDR                  0xF0832000      /* USB (2.0) Device 2 registers  */
+#define USB3_BASE_ADDR                  0xF0833000      /* USB (2.0) Device 3 registers  */
+#define USB4_BASE_ADDR                  0xF0834000      /* USB (2.0) Device 4 registers  */
+#define USB5_BASE_ADDR                  0xF0835000      /* USB (2.0) Device 5 registers  */
+#define USB6_BASE_ADDR                  0xF0836000      /* USB (2.0) Device 6 registers  */
+#define USB7_BASE_ADDR                  0xF0837000      /* USB (2.0) Device 7 registers  */
+#define USB8_BASE_ADDR                  0xF0838000      /* USB (2.0) Device 8 registers  */
+#define USB9_BASE_ADDR                  0xF0839000      /* USB (2.0) Device 9 registers  */
+
+#define USB_PHYS_BASE_ADDR(module)      (USB0_BASE_ADDR + (0x1000 * module))
+
+#define USB_INTERRUPT(module)           (USB_DEV_INTERRUPT_0 + module)
+#define USB_IS_FULL_SPEED(module)       0
+#define USB_DESC_PHYS_BASE_ADDR(module) (SRAM2_PHYS_BASE_ADDR + 0x800 * (module))
+#define USB_DESC_VIRT_BASE_ADDR(module) (SRAM2_BASE_ADDR + 0x800 * (module))
+#define USB_NUM_OF_MODULES              10
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define USB_BASE_ADDR(module)           USB_PHYS_BASE_ADDR(module)
+#else
+#define USB_BASE_ADDR(module)           USB_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* L2 cache Module                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define L2_CACHE_PHYS_BASE_ADDR         A9_BASE_ADDR
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define L2_CACHE_BASE_ADDR              L2_CACHE_PHYS_BASE_ADDR
+#else
+#define L2_CACHE_BASE_ADDR              L2_CACHE_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Public Key Accelerator Module                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PKA_MODULE_TYPE                  4
+#define PKA_ACCESS                       MEM
+#define PKA_PHYS_BASE_ADDR               0xF085B000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PKA_BASE_ADDR                   PKA_PHYS_BASE_ADDR
+#else
+#define PKA_BASE_ADDR                   PKA_VIRT_BASE_ADDR
+#endif
+
+#define PKA_INT_NUM                      PKA_INTERRUPT
+#define PKA_INT_POLARITY                 INTERRUPT_POLARITY_LEVEL_HIGH
+#define PKA_INTERRUPT_PRIORITY           0
+#define PKA_INT_PROVIDER                 CHIP_INTERRUPT_PROVIDER
+#define PKA_NUM_OF_MODULES               1
+#define PKA_SOURCE_CLOCK(module)         PLL2
+#define PKA_MUX(module)                  CHIP_MuxPKA(module)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SHA-1 and SHA-256 Module                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_MODULE_TYPE                  1
+#define SHA_ACCESS                       MEM
+#define SHA_PHYS_BASE_ADDR               0xF085A000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SHA_BASE_ADDR                   SHA_PHYS_BASE_ADDR
+#else
+#define SHA_BASE_ADDR                   SHA_VIRT_BASE_ADDR
+#endif
+
+//#define SHA_INTERRUPT(module)            (SHA_INTERRUPT)
+#define SHA_INTERRUPT_POLARITY            INTERRUPT_POLARITY_LEVEL_HIGH
+#define SHA_INTERRUPT_PRIORITY           0
+#define SHA_INTERRUPT_PROVIDER           CHIP_INTERRUPT_PROVIDER
+#define SHA_NUM_OF_MODULES               1
+#define SHA_SOURCE_CLOCK(module)         PLL2
+#define SHA_MUX(module)                  CHIP_MuxSHA(module)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RNG                                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RNG_MODULE_TYPE                 2
+#define RNG_BASE_ADDR                   0xF000B000      /* RNG  */
+#define RNG_ACCESS                      MEM
+
+//#define RNG_INT_NUM                     RNG_INTERRUPT  
+//#define RNG_INT_POLARITY                INTERRUPT_POLARITY_RISING_EDGE
+//#define RNG_INT_PROVIDER                CHIP_INTERRUPT_PROVIDER
+//#define RNG_INTERRUPT_PRIORITY          0
+
+
+/* Notice: RNG does not have an intterupt. current version of RNG driver works only with interrupts. 
+   Before using the driver need to change it to do polling too */
+
+#define RNG_PRESCALER_CLOCK             CLK_GetAPBFreq(APB1)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupts                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCM750_IRQ_GIC_START 32
+
+typedef enum
+{
+	TWD_LOCALTIMER_INTERRUPT 	 = 29,
+	ADC_INTERRUPT                = 0 + NPCM750_IRQ_GIC_START,     /* ADC Module                                         */
+	COPR_INTERRUPT               = 1 + NPCM750_IRQ_GIC_START,     /* Coprocessor subsystem                              */
+	UART_INTERRUPT_0             = 2 + NPCM750_IRQ_GIC_START,     /* UART 0 Module                                      */
+	UART_INTERRUPT_1             = 3 + NPCM750_IRQ_GIC_START,     /* UART 1 Module                                      */
+	UART_INTERRUPT_2             = 4 + NPCM750_IRQ_GIC_START,     /* UART 2 Module                                      */
+	UART_INTERRUPT_3             = 5 + NPCM750_IRQ_GIC_START,     /* UART 3 Module                                      */
+	PECI_INTERRUPT               = 6 + NPCM750_IRQ_GIC_START,     /* PECI module                                        */
+	VSYNC_INTERRUPT              = 7 + NPCM750_IRQ_GIC_START,     /* Graphics module via System Manager module          */
+	PCIMBX_INTERRUPT             = 8 + NPCM750_IRQ_GIC_START,     /* PCI mailbox module                                 */
+	KCS_HIB_INTERRUPT            = 9 + NPCM750_IRQ_GIC_START,     /* KCS/HIB  (from host interface) modules             */
+	LPC_MBX_INTERRUPT            = 10 + NPCM750_IRQ_GIC_START,    /* LPC or eSPI Mailbox (new, if we do)                */
+	SHM_INTERRUPT                = 11 + NPCM750_IRQ_GIC_START,    /* SHM module                                         */
+	PS2_INTERRUPT                = 12 + NPCM750_IRQ_GIC_START,    /* PS/2 Module ???                                    */
+	BT_INTERRUPT                 = 13 + NPCM750_IRQ_GIC_START,    /* Block transfer, If we do                           */
+	GMAC1_INTERRUPT              = 14 + NPCM750_IRQ_GIC_START,    /* GMAC1 module                                       */
+	EMC1RX_INTERRUPT             = 15 + NPCM750_IRQ_GIC_START,    /* EMC1 Rx module                                     */
+	EMC1TX_INTERRUPT             = 16 + NPCM750_IRQ_GIC_START,    /* EMC1 Tx module                                     */
+	GMAC2_INTERRUPT              = 17 + NPCM750_IRQ_GIC_START,    /* GMAC2 module                                       */
+	ESPI_INTERRUPT               = 18 + NPCM750_IRQ_GIC_START,    /* eSPI Module                                        */
+	SIOX_INTERRUPT_1             = 19 + NPCM750_IRQ_GIC_START,    /* SIOX Serial GPIO Expander module 1                 */
+	SIOX_INTERRUPT_2             = 20 + NPCM750_IRQ_GIC_START,    /* SIOX Serial GPIO Expander module 2                 */
+	L2_CACHE_ERR                 = 21 + NPCM750_IRQ_GIC_START,    /* A combined interrupt on L2 Cahche errors           */
+	VCD_INTERRUPT                = 22 + NPCM750_IRQ_GIC_START,    /* VCD module                                         */
+	DVC_INTERRUPT                = 23 + NPCM750_IRQ_GIC_START,    /* DVC module                                         */
+	ECE_INTERRUPT                = 24 + NPCM750_IRQ_GIC_START,    /* ECE module                                         */
+	MC_INTERRUPT                 = 25 + NPCM750_IRQ_GIC_START,    /* Memory Controller Interrupt                        */
+	MMC_INTERRUPT                = 26 + NPCM750_IRQ_GIC_START,    /* MMC Module (SDHC2)                                 */
+	SDRDR_INTERRUPT              = 27 + NPCM750_IRQ_GIC_START,    /* SDHC1 - SD Card Reader side interface (if required)*/
+	PSPI2_INTERRUPT              = 28 + NPCM750_IRQ_GIC_START,    /* Slow Peripheral SPI2                               */
+	VDMA_INTERRUPT               = 29 + NPCM750_IRQ_GIC_START,    /* VDMA module                                        */
+	MCTP_INTERRUPT               = 30 + NPCM750_IRQ_GIC_START,    /* VDMX module. Not used if VDMA used                 */
+	PSPI1_INTERRUPT              = 31 + NPCM750_IRQ_GIC_START,    /* Slow Peripheral SPI1                               */
+	TIMER_INTERRUPT_0            = 32 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 Timer 0                             */
+	TIMER_INTERRUPT_1            = 33 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 Timer 1                             */
+	TIMER_INTERRUPT_2            = 34 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 Timer 2                             */
+	TIMER_INTERRUPT_3            = 35 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 Timer 3                             */
+	TIMER_INTERRUPT_4            = 36 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 Timer 4                             */
+	TIMER_INTERRUPT_5            = 37 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 Timer 0                             */
+	TIMER_INTERRUPT_6            = 38 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 Timer 1                             */
+	TIMER_INTERRUPT_7            = 39 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 Timer 2                             */
+	TIMER_INTERRUPT_8            = 40 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 Timer 3                             */
+	TIMER_INTERRUPT_9            = 41 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 Timer 4                             */
+	TIMER_INTERRUPT_10           = 42 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 Timer 0                             */
+	TIMER_INTERRUPT_11           = 43 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 Timer 1                             */
+	TIMER_INTERRUPT_12           = 44 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 Timer 2                             */
+	TIMER_INTERRUPT_13           = 45 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 Timer 3                             */
+	TIMER_INTERRUPT_14           = 46 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 Timer 4                             */
+	WDG_INTERRUPT_0              = 47 + NPCM750_IRQ_GIC_START,    /* Timer Module 0 watchdog (also on NMI)              */
+	WDG_INTERRUPT_1              = 48 + NPCM750_IRQ_GIC_START,    /* Timer Module 1 watchdog (also on NMI)              */
+	WDG_INTERRUPT_2              = 49 + NPCM750_IRQ_GIC_START,    /* Timer Module 2 watchdog (also on NMI)              */
+	USB_DEV_INTERRUPT_0          = 51 + NPCM750_IRQ_GIC_START,    /* USB Device 0                                       */
+	USB_DEV_INTERRUPT_1          = 52 + NPCM750_IRQ_GIC_START,    /* USB Device 1                                       */
+	USB_DEV_INTERRUPT_2          = 53 + NPCM750_IRQ_GIC_START,    /* USB Device 2                                       */
+	USB_DEV_INTERRUPT_3          = 54 + NPCM750_IRQ_GIC_START,    /* USB Device 3                                       */
+	USB_DEV_INTERRUPT_4          = 55 + NPCM750_IRQ_GIC_START,    /* USB Device 4                                       */
+	USB_DEV_INTERRUPT_5          = 56 + NPCM750_IRQ_GIC_START,    /* USB Device 5                                       */
+	USB_DEV_INTERRUPT_6          = 57 + NPCM750_IRQ_GIC_START,    /* USB Device 6                                       */
+	USB_DEV_INTERRUPT_7          = 58 + NPCM750_IRQ_GIC_START,    /* USB Device 7                                       */
+	USB_DEV_INTERRUPT_8          = 59 + NPCM750_IRQ_GIC_START,    /* USB Device 8                                       */
+	USB_DEV_INTERRUPT_9          = 60 + NPCM750_IRQ_GIC_START,    /* USB Device 9                                       */
+	USB_HST_INTERRUPT_0          = 61 + NPCM750_IRQ_GIC_START,    /* USB Host 0                                         */
+	USB_HST_INTERRUPT_1          = 62 + NPCM750_IRQ_GIC_START,    /* USB Host 1                                         */
+
+	SMB_INTERRUPT_0              = 64 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 0                             */
+	SMB_INTERRUPT_1              = 65 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 1                             */
+	SMB_INTERRUPT_2              = 66 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 2                             */
+	SMB_INTERRUPT_3              = 67 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 3                             */
+	SMB_INTERRUPT_4              = 68 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 4                             */
+	SMB_INTERRUPT_5              = 69 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 5                             */
+	SMB_INTERRUPT_6              = 70 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 6                             */
+	SMB_INTERRUPT_7              = 71 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 7                             */
+	SMB_INTERRUPT_8              = 72 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 8                             */
+	SMB_INTERRUPT_9              = 73 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 9                             */
+	SMB_INTERRUPT_10             = 74 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 10                            */
+	SMB_INTERRUPT_11             = 75 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 11                            */
+	SMB_INTERRUPT_12             = 76 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 12                            */
+	SMB_INTERRUPT_13             = 77 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 13                            */
+	SMB_INTERRUPT_14             = 78 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 14                            */
+	SMB_INTERRUPT_15             = 79 + NPCM750_IRQ_GIC_START,    /* SMBus and I2C Module 15                            */
+
+	AES_INTERRUPT                = 80 + NPCM750_IRQ_GIC_START,    /* AES Module                                         */
+	DES_INTERRUPT                = 81 + NPCM750_IRQ_GIC_START,    /* 3DES Module                                        */
+	SHA_INTERRUPT                = 82 + NPCM750_IRQ_GIC_START,    /* SHA module                                         */
+    PKA_INTERRUPT                = 83 + NPCM750_IRQ_GIC_START ,   /* (SECACC) ECC and RSA accelerator module            */
+
+	SPI_INTERRUPT_0              = 85 + NPCM750_IRQ_GIC_START,    /* FIU module 0 if required                           */
+	SPI_INTERRUPT_X              = 86 + NPCM750_IRQ_GIC_START,    /* FIU module X if required                           */
+	SPI_INTERRUPT_3              = 87 + NPCM750_IRQ_GIC_START,    /* FIU module 3 if required                           */
+	GDMA_INTERRUPT_0             = 88 + NPCM750_IRQ_GIC_START,    /* GDMA Module 0                                      */
+	GDMA_INTERRUPT_1             = 89 + NPCM750_IRQ_GIC_START,    /* GDMA Module 1                                      */
+	GDMA_INTERRUPT_2             = 90 + NPCM750_IRQ_GIC_START,    /* GDMA Module 2                                      */
+	GDMA_INTERRUPT_3             = 91 + NPCM750_IRQ_GIC_START,    /* GDMA Module 3 If required                          */
+	OTP_INTERRUPT                = 92 + NPCM750_IRQ_GIC_START,    /* Fustraps and Key arrays                            */
+	PWM_INTERRUPT_0_PWM0_3       = 93 + NPCM750_IRQ_GIC_START,    /* PWM Module 0 outputing PWM0-3                      */
+	PWM_INTERRUPT_1_PWM4_7       = 94 + NPCM750_IRQ_GIC_START,    /* PWM Module 1 outputing PWM4-7                      */
+
+	MFT_INTERRUPT_0              = 96 + NPCM750_IRQ_GIC_START,    /* MFT Module 0                                       */
+	MFT_INTERRUPT_1              = 97 + NPCM750_IRQ_GIC_START,    /* MFT Module 1                                       */
+	MFT_INTERRUPT_2              = 98 + NPCM750_IRQ_GIC_START,    /* MFT Module 2                                       */
+	MFT_INTERRUPT_3              = 99 + NPCM750_IRQ_GIC_START,    /* MFT Module 3                                       */
+	MFT_INTERRUPT_4              = 100 + NPCM750_IRQ_GIC_START,   /* MFT Module 4                                       */
+	MFT_INTERRUPT_5              = 101 + NPCM750_IRQ_GIC_START,   /* MFT Module 5                                       */
+	MFT_INTERRUPT_6              = 102 + NPCM750_IRQ_GIC_START,   /* MFT Module 6                                       */
+	MFT_INTERRUPT_7              = 103 + NPCM750_IRQ_GIC_START,   /* MFT Module 7                                       */
+	PWM_INTERRUPT_0              = 104 + NPCM750_IRQ_GIC_START,   /* PWM module 0                                       */
+	PWM_INTERRUPT_1              = 105 + NPCM750_IRQ_GIC_START,   /* PWM module 1                                       */
+	PWM_INTERRUPT_2              = 106 + NPCM750_IRQ_GIC_START,   /* PWM module 2                                       */
+	PWM_INTERRUPT_3              = 107 + NPCM750_IRQ_GIC_START,   /* PWM module 3                                       */
+	PWM_INTERRUPT_4              = 108 + NPCM750_IRQ_GIC_START,   /* PWM module 4                                       */
+	PWM_INTERRUPT_5              = 109 + NPCM750_IRQ_GIC_START,   /* PWM module 5                                       */
+	PWM_INTERRUPT_6              = 110 + NPCM750_IRQ_GIC_START,   /* PWM module 6                                       */
+	PWM_INTERRUPT_7              = 111 + NPCM750_IRQ_GIC_START,   /* PWM module 7                                       */
+
+	EMC2RX_INTERRUPT             = 114 + NPCM750_IRQ_GIC_START,   /* EMC2 Rx module                                     */
+	EMC2TX_INTERRUPT             = 115 + NPCM750_IRQ_GIC_START,   /* EMC2 Tx module                                     */
+	GPIO_INTERRUPT0              = 116 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO0-31                     */
+	GPIO_INTERRUPT1              = 117 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIONPCM750_IRQ_GIC_START-63                    */
+	GPIO_INTERRUPT2              = 118 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO64-95                    */
+	GPIO_INTERRUPT3              = 119 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO96-127                   */
+	GPIO_INTERRUPT4              = 120 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO128-159                  */
+	GPIO_INTERRUPT5              = 121 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO160-191                  */
+	GPIO_INTERRUPT6              = 122 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO192-223                  */
+	GPIO_INTERRUPT7              = 123 + NPCM750_IRQ_GIC_START,   /* GPIO module outputing GPIO224-255                  */
+
+	PCIE_RC_INTERRUPT            = 127 + NPCM750_IRQ_GIC_START,   /* PCIe Root Complex  (combined A-D and MSI)          */
+	
+	// GIC_INTERRUPT_NUM
+} irq_list_t;
+
+#define KCS_HIB_INT KCS_HIB_INTERRUPT
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIOs definition table                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_DEFINITION_TABLE                                                                                                                                                                       \
+{                                                                                                                                                                                                   \
+    /* Port 0: GPIO 0-15 */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 0, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(0),  GPIO_CAP_DEBOUNCE(0),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(1),  GPIO_CAP_DEBOUNCE(1),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(2),  GPIO_CAP_DEBOUNCE(2),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(3),  GPIO_CAP_DEBOUNCE(3),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(4),  GPIO_CAP_DEBOUNCE(4),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(5),  GPIO_CAP_DEBOUNCE(5),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(6),  GPIO_CAP_DEBOUNCE(6),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(7),  GPIO_CAP_DEBOUNCE(7),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(8),  GPIO_CAP_DEBOUNCE(8),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(9),  GPIO_CAP_DEBOUNCE(9),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(10), GPIO_CAP_DEBOUNCE(10), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(11), GPIO_CAP_DEBOUNCE(11), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(12), GPIO_CAP_DEBOUNCE(12), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(13), GPIO_CAP_DEBOUNCE(13), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(14), GPIO_CAP_DEBOUNCE(14), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(15), GPIO_CAP_DEBOUNCE(15), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 1: GPIO 16-31 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 1, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(0),  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(4),  GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(8),  GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(12), GPIO_MUX_REGID_MFSL3, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(16), GPIO_MUX_REGID_MFSL2, 24, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(20), GPIO_MUX_REGID_MFSL2, 25, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(24), GPIO_MUX_REGID_MFSL2, 26, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(28), GPIO_MUX_REGID_MFSL2, 27, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(16), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 28, 1, 0,  GPIO_MUX_REGID_MFSL3, 18, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(17), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 29, 1, 0,  GPIO_MUX_REGID_MFSL3, 18, 1, 0), \
+    GPIO_TABLE_ENTRY( 1,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 2: GPIO 32-47 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 2, 0, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 1, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  5, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 29, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 28, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 3: GPIO 48-63 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 3, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 12, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 30, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 31, 1, 0,  GPIO_MUX_REGID_MFSL3, 19, 1, 0), \
+    GPIO_TABLE_ENTRY( 3,13, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,14, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,15, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 4: GPIO 64-79 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 4, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 13, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 5: GPIO 80-94 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 5, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 17, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 19, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 15, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY( 5,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* GPIO 95 Undefined */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 5,15, GPIO_CAP_NO_INPUT, GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 6: GPIO 96-113 */                                                                                                                                                                       \
+    GPIO_TABLE_ENTRY( 6, 0, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 1, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 2, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 3, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 4, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 5, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 6, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 7, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 8, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 9, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,10, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,11, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,12, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,13, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,14, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,15, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,16, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,17, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 7: GPIO 114-127 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 7, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 8: GPIO 128-143 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 8, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(0),  GPIO_CAP_DEBOUNCE(0),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(1),  GPIO_CAP_DEBOUNCE(1),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(2),  GPIO_CAP_DEBOUNCE(2),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(3),  GPIO_CAP_DEBOUNCE(3),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(4),  GPIO_CAP_DEBOUNCE(4),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(5),  GPIO_CAP_DEBOUNCE(5),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(6),  GPIO_CAP_DEBOUNCE(6),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(7),  GPIO_CAP_DEBOUNCE(7),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(8),  GPIO_CAP_DEBOUNCE(8),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(9),  GPIO_CAP_DEBOUNCE(9),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(10), GPIO_CAP_DEBOUNCE(10), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(11), GPIO_CAP_DEBOUNCE(11), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(12), GPIO_CAP_DEBOUNCE(12), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(13), GPIO_CAP_DEBOUNCE(13), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(14), GPIO_CAP_DEBOUNCE(14), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 8,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(15), GPIO_CAP_DEBOUNCE(15), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 9: GPIO 144-159 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 9, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(0),  GPIO_MUX_REGID_MFSL2, 20, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(4),  GPIO_MUX_REGID_MFSL2, 21, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(8),  GPIO_MUX_REGID_MFSL2, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(12), GPIO_MUX_REGID_MFSL2, 23, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(16), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(20), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(24), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(28), GPIO_MUX_REGID_MFSL3, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(16), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(17), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 9,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 10: GPIO 160-175 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(10, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 21, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 31, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 26, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 16, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(10,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 11: GPIO 176-191 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(11, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  3, 2, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  8, 1, 0,  GPIO_MUX_REGID_MFSL3, 31, 1, 0), \
+    GPIO_TABLE_ENTRY(11, 8, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11, 9, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,10, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,11, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,12, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,13, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,14, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(11,15, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 12: GPIO 192-207 */                                                                                                                                                                     \
+    GPIO_TABLE_ENTRY(12, 0, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_MFSL3, 15, 1, 0), \
+    GPIO_TABLE_ENTRY(12, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 15, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY(12,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL3, 22, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* The non-cached area is not HW, we spare 32MB for linux to use it                                        */
+/* Map 32MB at the last 48MB of 2GB (since GFX takes 16MB at the end) for non-cached area,                 */
+/* since DDR is wrapping around this should work even if actual DDR is smaller                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NON_CACHED_PHYS_BASE_ADDR       0x7D000000 // _2GB_ - _16MB_ - _32MB_ = 0x7D000000
+
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define NON_CACHED_BASE_ADDR(module)    NON_CACHED_PHYS_BASE_ADDR(module)
+#else
+#define NON_CACHED_BASE_ADDR(module)    NON_CACHED_VIRT_BASE_ADDR(module)
+#endif
+
+/* Defining IO Memory continuesly mapped blocks                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+                                    /* Map:Phisical Addr | Virtual Addr | Block Size     */
+                                    /* -----------------------------------------------    */
+#define IOMEMORY_BLOCKS             {                                                                \
+                                        {   VDM_PHYS_BASE_ADDR, IOMEMORY(VDM_PHYS_BASE_ADDR), 0x00001000   },        \
+                                        {   NON_CACHED_PHYS_BASE_ADDR, IOMEMORY(NON_CACHED_PHYS_BASE_ADDR), 0x02000000   },        \
+                                        {   AHB1_BASE_ADDR, IOMEMORY(AHB1_BASE_ADDR), 0x00020000   },        \
+                                        {   APB2_BASE_ADDR, IOMEMORY(APB2_BASE_ADDR), 0x00020000   },        \
+                                        {   APB3_BASE_ADDR, IOMEMORY(APB3_BASE_ADDR), 0x00010000   },        \
+                                        {   APB4_BASE_ADDR, IOMEMORY(APB4_BASE_ADDR), 0x00010000   },        \
+                                        {   APB5_BASE_ADDR, IOMEMORY(APB5_BASE_ADDR), 0x00005000   },        \
+                                        {   A9_BASE_ADDR,   IOMEMORY(A9_BASE_ADDR),   0x00004000   },        \
+                                        {   DAP_BASE_ADDR,  IOMEMORY(DAP_BASE_ADDR),  0x00100000   },        \
+                                        {   AHB8_BASE_ADDR, IOMEMORY(AHB8_BASE_ADDR), 0x00060000   },        \
+                                        {   FIU0_BASE_ADDR, IOMEMORY(FIU0_BASE_ADDR), 0x00002000   },        \
+                                        {   FIU3_BASE_ADDR, (FIU0_BASE_ADDR + 0x3000 - 0x01000000),  0x00001000   },        \
+                                        {   RAM2_BASE_ADDR, IOMEMORY(RAM2_BASE_ADDR), 0x00030000   },        \
+                                    }
+
+
+#endif //__NPCM750_CHIP_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Chips/wpcm450/wpcm450.h b/board/nuvoton/common/BMC_HAL/Chips/wpcm450/wpcm450.h
new file mode 100755
index 0000000..32e66da
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Chips/wpcm450/wpcm450.h
@@ -0,0 +1,507 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   wpcm450.h                                                                                             */
+/*            This file contains chip definitions for the given project                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _WPCM450_CHIP_H
+#define _WPCM450_CHIP_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Chip Name                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define WPCM450
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip ROM                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROM_BASE_ADDR                  0xFFFF0000
+#define ROM_MEMORY_SIZE                _32KB_
+#define ROMCODE_VER_ADDR               0xFFFF0FFC
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* On-Chip SRAM                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SRAM_BASE_ADDR                  0x00000000
+#define SRAM_MEMORY_SIZE                _8KB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* External SDRAM Space DDR3                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SDRAM_BASE_ADDR                 0x00002000
+#define SDRAM_MAPPED_SIZE               (_512MB_ - SRAM_MEMORY_SIZE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPI Flash                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FLASH_BASE_ADDR                 0x40000000
+#define FLASH_MAPPED_SIZE               _64MB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* XBus                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define XBUS_BASE_ADDR                  0x44000000
+#define XBUS_MAPPED_SIZE                _32MB_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Mapped IO                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOMEMORY_BASE_ADDR              0xB0000000
+#define IOMEMORY_SIZE                   0x18003000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining IO Memory continuesly mapped blocks                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOMEMORY_BLOCKS             {                                                   \
+                                        /*  Block Base Address | Block Size     */      \
+                                        /*  ----------------------------------  */      \
+                                        {   0xB0000000,          0x00008000   },        \
+                                        {   0xB0010000,          0x00010000   },        \
+                                        {   0xB8000000,          0x0000C000   },        \
+                                        {   0xC0000000,          0x00012000   },        \
+                                    }
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Ethernet configuration                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CHIP_NUM_OF_ETH                 2
+#define CHIP_ETH0_TYPE                  EMC
+#define CHIP_ETH1_TYPE                  EMC
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* General Module                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GCR_MODULE_TYPE                 Hermon_IP
+#define GCR_ACCESS                      MEM
+#define GCR_PHYS_BASE_ADDR              0xB0000000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GCR_BASE_ADDR                   GCR_PHYS_BASE_ADDR
+#else
+#define GCR_BASE_ADDR                   GCR_VIRT_BASE_ADDR
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define UART_MODULE_TYPE                Hermon_IP
+#define UART_ACCESS                     MEM
+#define UART_PHYS_BASE_ADDR(module)     (0xB8000000 + ((module) * 0x1000))
+#define UART_INTERRUPT(module)          ((module) + UART0_INT)
+#define UART_NUM_OF_MODULES             2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define UART_BASE_ADDR(module)          UART_PHYS_BASE_ADDR(module)
+#else
+#define UART_BASE_ADDR(module)          UART_VIRT_BASE_ADDR(module)
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_MODULE_TYPE               Hermon_IP
+#define TIMER_ACCESS                    MEM
+#define TIMER_PHYS_BASE_ADDR(module)    0xB8001000
+#define TIMER_INTERRUPT(port)           (((port) < 2)? T_INT0 + (port) : T_INT_GRP)
+#define TIMER_GROUP_INTERRUPT(port)     ((((port) >=2) && ((port) <5)) ? (16 + ((port)-2)) : AIC_GROUP_INTERRUPT_NONE)
+
+#define TIMER_NUM_OF_MODULES            1
+#define TIMER_NUM_OF_PORTS              5
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define TIMER_BASE_ADDR(port)           TIMER_PHYS_BASE_ADDR(port)
+#else
+#define TIMER_BASE_ADDR(port)           TIMER_VIRT_BASE_ADDR(port)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SMB Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SMB_MODULE_TYPE                 Hermon_IP
+#define SMB_ACCESS                      MEM
+#define SMB_PHYS_BASE_ADDR(module)      (0xB8006000+((module)*0x100))
+
+#define SMB_MAX_BUSES                   6
+#define SMB_SCL_GPIOS                   114, 116, 118, 31, 29, 27
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SMB_BASE_ADDR(module)           SMB_PHYS_BASE_ADDR(module)
+#else
+#define SMB_BASE_ADDR(module)           SMB_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet 100 Mac Controler                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EMC_MODULE_TYPE                 Hermon_IP
+#define EMC_ACCESS                      MEM
+#define EMC_PHYS_BASE_ADDR(module)      (0xB0002000+((module)*0x1000))
+#define EMC_RX_INTERRUPT(module)        (((module)*2) + EMC1_RX_INT)
+#define EMC_TX_INTERRUPT(module)        (((module)*2) + EMC1_TX_INT)
+#define EMC_NUM_OF_MODULES              2
+
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define EMC_BASE_ADDR(module)           EMC_PHYS_BASE_ADDR(module)
+#else
+#define EMC_BASE_ADDR(module)           EMC_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Memory Control                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MC_MODULE_TYPE                  Hermon_IP
+#define MC_ACCESS                       MEM
+#define MC_PHYS_BASE_ADDR               0xB0001000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define MC_BASE_ADDR                    MC_PHYS_BASE_ADDR
+#else
+#define MC_BASE_ADDR                    MC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUI Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FIU_MODULE_TYPE                 Hermon_IP
+#define FIU_ACCESS                      MEM
+#define FIU_PHYS_BASE_ADDR(module)      0xC8000000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define FIU_BASE_ADDR                   FIU_PHYS_BASE_ADDR(0)
+#else
+#define FIU_BASE_ADDR                   FIU_VIRT_BASE_ADDR(0)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Clock Module                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_MODULE_TYPE                 Hermon_IP
+#define CLK_ACCESS                      MEM
+#define CLK_PHYS_BASE_ADDR              0xB0000200
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define CLK_BASE_ADDR                   CLK_PHYS_BASE_ADDR
+#else
+#define CLK_BASE_ADDR                   CLK_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AIC Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AIC_MODULE_TYPE                 Hermon_IP
+#define AIC_ACCESS                      MEM
+#define AIC_PHYS_BASE_ADDR              0xB8002000
+#define AIC_INTERRUPT_NUM               32
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define AIC_BASE_ADDR                   AIC_PHYS_BASE_ADDR
+#else
+#define AIC_BASE_ADDR                   AIC_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VCD Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define VCD_MODULE_TYPE                 Hermon_IP
+#define VCD_ACCESS                      MEM
+#define VCD_PHYS_BASE_ADDR              0xB0010000
+#define VCD_INTERRUPT                   VCD_INT
+
+#define VCD_MEM_PORT1                   3
+#define VCD_MEM_PORT2                   4
+
+#define VCD_MAX_WIDTH                   1280
+#define VCD_MAX_HIGHT                   1024
+#define USE_INTERNAL_GFX
+
+#define VCD_FRAME_A_PHYS_BASE_ADDRESS   0x6C00000
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define VCD_BASE_ADDR                   VCD_PHYS_BASE_ADDR
+#else
+#define VCD_BASE_ADDR                   VCD_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFX Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GFX_MODULE_TYPE                 Hermon_IP
+#define GFX_ACCESS                      MEM
+#define GFX_PHYS_BASE_ADDR              0xB8000300
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GFX_BASE_ADDR                   GFX_PHYS_BASE_ADDR
+#else
+#define GFX_BASE_ADDR                   GFX_VIRT_BASE_ADDR
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Module                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_MODULE_TYPE                Hermon_IP
+#define GPIO_ACCESS                     MEM
+#define GPIO_PHYS_BASE_ADDR(module)     0xB8003000
+#define GPIO_INTERRUPT(gpio)            ((gpio) < 4 ? GPIO_INT0 : (gpio) < 12 ? GPIO_INT1 : (gpio) < 16 ? GPIO_INT2 : GPIO_INT3)
+
+#define GPIO_NUM_OF_MODULES             1
+#define GPIO_NUM_OF_PORTS               8
+#define GPIO_NUM_OF_GPIOS               128
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define GPIO_BASE_ADDR(module)          GPIO_PHYS_BASE_ADDR(module)
+#else
+#define GPIO_BASE_ADDR(module)          GPIO_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PSPI Module (aka SSPI)                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PSPI_MODULE_TYPE                Hermon_IP
+#define PSPI_ACCESS                     MEM
+#define PSPI_PHYS_BASE_ADDR(module)     0xB8000400
+#define PSPI_NUM_OF_MODULES             1
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define PSPI_BASE_ADDR(module)          PSPI_PHYS_BASE_ADDR(module)
+#else
+#define PSPI_BASE_ADDR(module)          PSPI_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Module                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SD_MODULE_TYPE                  Hermon_IP
+#define SD_ACCESS                       MEM
+#define SD_PHYS_BASE_ADDR(module)       0xB0007000
+#define SD_GROUP_INTERRUPT(module)      AIC_GROUP_INTERRUPT_NONE
+#define SD_GPIO_INTERRUPT(module)       7
+#define SD_NUM_OF_MODULES               1
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define SD_BASE_ADDR(module)            SD_PHYS_BASE_ADDR(module)
+#else
+#define SD_BASE_ADDR(module)            SD_VIRT_BASE_ADDR(module)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* USB Module                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define USB_MODULE_TYPE                 Hermon_IP
+#define USB_ACCESS                      MEM
+#define USB_PHYS_BASE_ADDR(module)      (0xB0005000 - ((module - 1) * 0x1000))
+#define USB_INTERRUPT(module)           (USBD1_INT - (module - 1))
+#define USB_IS_FULL_SPEED(module)       ((module) == 1 ? 1 : 0)
+#define USB_NUM_OF_MODULES              2
+
+#ifndef DYNAMIC_BASE_ADDRESS
+#define USB_BASE_ADDR(module)           USB_PHYS_BASE_ADDR(module)
+#else
+#define USB_BASE_ADDR(module)           USB_VIRT_BASE_ADDR(module)
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupts                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+   WDT_INT          = 1,        /* Watch Dog Timer Interrupt                                               */
+   GPIO_INT0        = 2,        /* GPIO Interrupt Group 0 containing GPIOE3-0                              */
+   GPIO_INT1        = 3,        /* GPIO Interrupt Group 1 containing GPIOE11-4                             */
+   GPIO_INT2        = 4,        /* GPIO Interrupt Group 2 containing GPIOE15-12                            */
+   GPIO_INT3        = 5,        /* GPIO Interrupt Group 3 containing GPIO25-24                             */
+   PECI_INT         = 6,        /* PECI Interrupt                                                          */
+   UART0_INT        = 7,        /* UART0 Interrupt                                                         */
+   UART1_INT        = 8,        /* UART1 Interrupt                                                         */
+   KCS_HIB_INT      = 9,        /* KCS/HIB Interrupt (from host interface)                                 */
+   FIU_SPI_INT      = 10,       /* FIU_SPI interrupt                                                       */
+   SHM_INT          = 11,       /* SHM Interrupt                                                           */
+   T_INT0           = 12,       /* Timer Interrupt 0                                                       */
+   T_INT1           = 13,       /* Timer Interrupt 1                                                       */
+   T_INT_GRP        = 14,       /* Timer Interrupt Group containing Timer2, Timer3, Timer4                 */
+   EMC1_RX_INT      = 15,       /* EMC1 Rx Interrupt                                                       */
+   EMC1_TX_INT      = 16,       /* EMC1 Tx Interrupt                                                       */
+   EMC2_RX_INT      = 17,       /* EMC2 Rx Interrupt                                                       */
+   EMC2_TX_INT      = 18,       /* EMC2 Tx Interrupt                                                       */
+   GDMA_INT_GRP     = 19,       /* Reserved GDMA Interrupt Group containing GDMA0, GDMA1                   */
+   USBD2_INT        = 20,       /* USB Device2 Interrupt                                                   */
+   USBD1_INT        = 21,       /* USB Device1 Interrupt                                                   */
+   VCD_INT          = 22,       /* VCD interrupt                                                           */
+   SMB3_INT         = 23,       /* SMBus3 Interrupt                                                        */
+   MFT0_INT         = 24,       /* Tachometer Timer 0 (MFT0) Interrupt                                     */
+   MFT1_INT         = 25,       /* Tachometer Timer 1 (MFT1) Interrupt                                     */
+   SMB_GRP1_INT     = 26,       /* SMBus Interrupt Group containing SMBus0, SMBus1, SMBus2                 */
+   SMB4_INT         = 27,       /* SMBus4 Interrupt                                                        */
+   PWM_INT          = 28,       /* PWM Timer Interrupt Group containing PWM0, PWM1, PWM2, PWM3             */
+   SMB5_INT         = 29,       /* SMBus5 Interrupt                                                        */
+   MPG_INT          = 30,       /* Main power good indication from PWRGD_PS input pin.                     */
+   ADC_INT          = 31,       /* ADC Interrupt                                                           */
+} irq_list_t;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIOs definition table                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_DEFINITION_TABLE                                                                                                                                                                       \
+{                                                                                                                                                                                                   \
+    /* Port 0: GPIO 0-15 */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 0, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(0),  GPIO_CAP_DEBOUNCE(0),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(1),  GPIO_CAP_DEBOUNCE(1),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(2),  GPIO_CAP_DEBOUNCE(2),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(3),  GPIO_CAP_DEBOUNCE(3),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(4),  GPIO_CAP_DEBOUNCE(4),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(5),  GPIO_CAP_DEBOUNCE(5),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(6),  GPIO_CAP_DEBOUNCE(6),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(7),  GPIO_CAP_DEBOUNCE(7),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(8),  GPIO_CAP_DEBOUNCE(8),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(9),  GPIO_CAP_DEBOUNCE(9),  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(10), GPIO_CAP_DEBOUNCE(10), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 25, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(11), GPIO_CAP_DEBOUNCE(11), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 25, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 0,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(12), GPIO_CAP_DEBOUNCE(12), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_MFSL1, 31, 1, 0), \
+    GPIO_TABLE_ENTRY( 0,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(13), GPIO_CAP_DEBOUNCE(13), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_MFSL1, 31, 1, 0), \
+    GPIO_TABLE_ENTRY( 0,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(14), GPIO_CAP_DEBOUNCE(14), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_MFSL1, 31, 1, 0), \
+    GPIO_TABLE_ENTRY( 0,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(15), GPIO_CAP_DEBOUNCE(15), GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 24, 1, 0,  GPIO_MUX_REGID_MFSL1, 31, 1, 0), \
+                                                                                                                                                                                                    \
+    /* Port 1: GPIO 16-31 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 1, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(0),  GPIO_MUX_REGID_MFSL2, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(4),  GPIO_MUX_REGID_MFSL2, 23, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(8),  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(12), GPIO_MUX_REGID_MFSL1, 23, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(16), GPIO_MUX_REGID_MFSL2, 20, 1, 0,  GPIO_MUX_REGID_MFSL2, 24, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(20), GPIO_MUX_REGID_MFSL2, 21, 1, 0,  GPIO_MUX_REGID_MFSL2, 25, 1, 0), \
+    GPIO_TABLE_ENTRY( 1, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(24), GPIO_MUX_REGID_MFSL1, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_BLINK(28), GPIO_MUX_REGID_MFSL2, 27, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(16), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 28, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_EVENT(17), GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 29, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 1,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 2: GPIO 32-47 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 2, 0, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 1, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  5, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 29, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 28, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 2,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 3: GPIO 48-63 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 3, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 13, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 30, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 31, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,13, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,14, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 3,15, GPIO_CAP_NO_INPUT, GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 4: GPIO 64-79 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 4, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  0, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  1, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  2, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  3, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  4, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  5, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2,  9, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 10, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 11, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 12, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 13, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 4,15, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 5: GPIO 80-94 */                                                                                                                                                                        \
+    GPIO_TABLE_ENTRY( 5, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 17, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 18, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL2, 19, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 14, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 15, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 16, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 5,14, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 17, 1, 1,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* GPIO 95 Undefined */                                                                                                                                                                         \
+    GPIO_TABLE_ENTRY( 5,15, GPIO_CAP_NO_INPUT, GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 6: GPIO 96-113 */                                                                                                                                                                       \
+    GPIO_TABLE_ENTRY( 6, 0, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 21, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 1, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 22, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 2, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 3, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 4, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 5, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 6, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 7, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 8, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6, 9, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,10, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,11, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_NONE,   0, 0, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,12, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,13, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,14, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,15, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,16, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 6,17, GPIO_CAP_INPUT,    GPIO_CAP_NO_OUTPUT, GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+                                                                                                                                                                                                    \
+    /* Port 7: GPIO 114-127 */                                                                                                                                                                      \
+    GPIO_TABLE_ENTRY( 7, 0, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 1, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  6, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 2, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 3, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  7, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 4, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 5, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1,  8, 1, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 6, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 7, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 8, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7, 9, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,10, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,11, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,12, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+    GPIO_TABLE_ENTRY( 7,13, GPIO_CAP_INPUT,    GPIO_CAP_OUTPUT,    GPIO_CAP_NO_EVENT,  GPIO_CAP_NO_DEBOUNCE,  GPIO_CAP_NO_BLINK,  GPIO_MUX_REGID_MFSL1, 18, 3, 0,  GPIO_MUX_REGID_NONE,   0, 0, 0), \
+}
+
+
+#endif //_WPCM450_CHIP_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Common/hal_common.h b/board/nuvoton/common/BMC_HAL/Common/hal_common.h
new file mode 100755
index 0000000..a7d4b44
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Common/hal_common.h
@@ -0,0 +1,72 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   hal_common.h                                                                                          */
+/*            This file contains common HAL definitions                                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _HAL_COMMON_H_
+#define _HAL_COMMON_H_
+
+#define __EXTERNAL_FILE(name)           STRINGX(name)
+#define __MODULE_FILE_NAME(moduleType, moduleVer)        STRINGX(../moduleType/moduleVer/moduleType##_drv.c)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including defs.h                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including external definitions if needed                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef EXTERNAL_INCLUDE_FILE
+#include __EXTERNAL_FILE(EXTERNAL_INCLUDE_FILE)
+#endif
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Common definitions for the HAL                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef VIRT_TO_PHYS
+#define VIRT_TO_PHYS(x)     (x)
+#endif
+
+#ifndef PHYS_TO_VIRT
+#define PHYS_TO_VIRT(x)     (x)
+#endif
+
+#ifndef DCACHE_INV_RANGE
+#define DCACHE_INV_RANGE(start, end)
+#endif
+
+#ifndef DCACHE_CLEAN_RANGE
+#define DCACHE_CLEAN_RANGE(start, end)
+#endif
+
+#ifndef DCACHE_FLUSH_RANGE
+#define DCACHE_FLUSH_RANGE(start, end)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HAL Sleep macro                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef HAL_USLEEP
+
+#define HAL_USLEEP(timer, usec)                 \
+        {                                       \
+            TIMER_StartOneShot(timer, usec);    \
+            while(TIMER_OneShotRunning(timer)); \
+        }
+#endif
+
+#endif //_HAL_COMMON_H_
+
diff --git a/board/nuvoton/common/BMC_HAL/Common/hal_error.h b/board/nuvoton/common/BMC_HAL/Common/hal_error.h
new file mode 100755
index 0000000..f29cdcf
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Common/hal_error.h
@@ -0,0 +1,62 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   hal_error.h                                                                                           */
+/*            This file contains BMC HAL error codes                                                       */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _HAL_ERROR_H
+#define _HAL_ERROR_H
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BMC HAL Error codes list                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+
+typedef enum
+{
+    HAL_OK                          = 0x00,
+    HAL_ERROR                       = 0x01,
+    HAL_ERROR_BAD_FREQ              = 0x02,
+    HAL_ERROR_BAD_DEVNUM            = 0x03,
+    HAL_ERROR_DMA_NOT_OWNED         = 0x04,
+    HAL_ERROR_PHY                   = 0x05,
+    HAL_ERROR_LOCKED                = 0x06,
+    HAL_ERROR_ILLEGAL_SIZE          = 0x07,
+    HAL_ERROR_NOT_INITIALIZED       = 0x08,
+    HAL_ERROR_BAD_ADDRESS           = 0x09,
+    HAL_ERROR_BAD_PARAM             = 0x0A,
+    HAL_ERROR_TIMEOUT               = 0x0B,
+    HAL_ERROR_NOT_HANDLED           = 0x0C,
+    HAL_ERROR_BAD_PARITY            = 0x0D,
+    HAL_ERROR_OVERRUN_OCCURRED      = 0x0E,
+    HAL_ERROR_BREAK_OCCURRED        = 0x0F,
+    HAL_ERROR_BAD_FRAME             = 0x10,
+    HAL_ERROR_QUEUE_EMPTY           = 0x11,
+    HAL_ERROR_QUEUE_FULL            = 0x12,
+    HAL_ERROR_NO_LINK               = 0x13,
+    HAL_ERROR_ILLEGAL_CLK           = 0x14,
+    HAL_ERROR_PACKET_ABORT          = 0x15,
+    HAL_ERROR_CARRIER               = 0x16,
+    HAL_ERROR_BIG_PACKET            = 0x17,
+    HAL_ERROR_CRC                   = 0x18,
+    HAL_ERROR_SMALL_PACKET          = 0x19,
+    HAL_ERROR_FIFO_OVERFLOW         = 0x1A,
+    HAL_ERROR_BUS                   = 0x1B,
+    HAL_ERROR_BAD_ALIGNMENT         = 0x1C,
+    HAL_ERROR_NO_MEDIA              = 0x1D,
+    HAL_ERROR_WRITE_PROTECT         = 0x1E,
+    HAL_ERROR_ILLEGAL_VALUE         = 0x1F,
+    HAL_ERROR_BAD_SIZE              = 0x20,
+    HAL_ERROR_NOT_IMPLEMENTED       = 0x21
+} HAL_STATUS;
+
+
+#endif //_HAL_ERROR_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Common/hal_ethernet.h b/board/nuvoton/common/BMC_HAL/Common/hal_ethernet.h
new file mode 100755
index 0000000..8b3a72c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Common/hal_ethernet.h
@@ -0,0 +1,214 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   hal_ethernet.h                                                                                        */
+/*            This file contains Ethernet common definitions for HAL modules                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _HAL_ETHERNET_H
+#define _HAL_ETHERNET_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ETH types                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    EMC_TYPE    = 0,
+    GMAC_TYPE   = 1,
+} ETH_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Receive callback                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    void (*Rx)(ETH_T type, UINT devNum, UINT8** packet, UINT32 size, HAL_STATUS status);
+    void (*Tx)(ETH_T type, UINT devNum, UINT8*  packet, UINT32 size, HAL_STATUS status);
+    void (*Error)(ETH_T type, UINT devNum, HAL_STATUS status);
+} ETH_CALLBACK_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet speed type                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    ETH_SPEED_10    = 10,
+    ETH_SPEED_100   = 100,
+    ETH_SPEED_1000  = 1000,
+} ETH_SPEED_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet duplex type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    ETH_DUPLEX_FULL,
+    ETH_DUPLEX_HALF,
+} ETH_DUPLEX_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PHY Register read/write function types                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef UINT32  (*ETH_PHY_REG_READ_T)   (UINT devNum, UINT phyNum, UINT32 regAddr);
+typedef void    (*ETH_PHY_REG_WRITE_T)  (UINT devNum, UINT phyNum, UINT32 regAddr, UINT32 data);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy operations structure                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    const UINT32 Ident;
+
+    HAL_STATUS  (*PHY_Init)                 (ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+    UINT32      (*PHY_GetID)                (UINT devNum, UINT phyNum);
+    HAL_STATUS  (*PHY_Reset)                (UINT devNum, UINT phyNum);
+    HAL_STATUS  (*PHY_AutoNegotiate)        (UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+    HAL_STATUS  (*PHY_GetLinkCapabilities)  (UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+    HAL_STATUS  (*PHY_SetLinkCapabilities)  (UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+} ETH_PHY_OPS_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC address size                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAC_ADDR_SIZE           6
+
+
+/* EMC RMII PHY  */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Basic Mode control register fields                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HAL_BMCR_COLLISION_TEST         7, 1
+#define HAL_BMCR_DUPLEX_MODE            8, 1
+#define HAL_BMCR_RESTART_AUTONEG        9, 1
+#define HAL_BMCR_ISOLATE               10, 1
+#define HAL_BMCR_POWER_DOWN            11, 1
+#define HAL_BMCR_AUTONEG               12, 1
+#define HAL_BMCR_SPEED_SELECT          13, 1
+#define HAL_BMCR_LOOPBACK              14, 1
+#define HAL_BMCR_RESET                 15, 1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Mii Status Control Register fields                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HAL_BMSR_LINK                   2, 1
+#define HAL_BMSR_AUTONEG_COMPLETE       5, 1
+#define HAL_BMSR_10_HD                 11, 1
+#define HAL_BMSR_10_FD                 12, 1
+#define HAL_BMSR_100_HD                13, 1
+#define HAL_BMSR_100_FD                14, 1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PHY status register fields                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PHYSTS_LINK                 0, 1
+#define PHYSTS_SPEED                1, 1
+#define PHYSTS_DUPLEX               2, 1
+#define PHYSTS_LOOPBACK_STAT        3, 1
+#define PHYSTS_AUTONEG_COMPLETE     4, 1
+#define PHYSTS_JABBER               5, 1
+#define PHYSTS_PHY_RMT_FAULT        6, 1
+#define PHYSTS_PAGE_RCV             8, 1
+#define PHYSTS_DESCRAM_LOCK         9, 1
+#define PHYSTS_SIG_DETECT          10, 1
+#define PHYSTS_FALSE_CAR_SENSE     11, 1
+#define PHYSTS_POLARITY_STAT       12, 1
+#define PHYSTS_RX_ERR_LATCH        13, 1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Auto-Negotiation Advertisement Register fields                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ANAR_10_HALF                5, 1
+#define ANAR_10_FULL                6, 1
+#define ANAR_100_HALF               7, 1
+#define ANAR_100_FULL               8, 1
+
+
+/* GMAC RGMII PHY  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MII CON Fields                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MII_CON_SPEED1              6, 1
+#define MII_CON_COLLISION           7, 1
+#define MII_CON_DUPLEX              8, 1
+#define MII_CON_RESTART_AN          9, 1
+#define MII_CON_ISOLATE            10, 1
+#define MII_CON_POWER_DOWN         11, 1
+#define MII_CON_AN_ENABLE          12, 1
+#define MII_CON_SPEED2             13, 1
+#define MII_CON_INT_LB             14, 1
+#define MII_CON_RST                15, 1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MII STAT Fields                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MII_STAT_EXTENDED           0, 1
+#define MII_STAT_JABBER             1, 1
+#define MII_STAT_LINK               2, 1
+#define MII_STAT_AN_ABILITY         3, 1
+#define MII_STAT_REMOTE_FAULT       4, 1
+#define MII_STAT_AN_COMPLETED       5, 1
+#define MII_STAT_PREAMBLE_SUPPRES   6, 1
+#define MII_STAT_EXTENDED_STATUS    7, 1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AUX Status summary register                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AUX_STAT_PAUSE_TX           0, 1
+#define AUX_STAT_PAUSE_RX           1, 1
+#define AUX_STAT_LINK               2, 1
+#define AUX_STAT_NEXT_PAGE          3, 1
+#define AUX_STAT_AN_CAP             4, 1
+#define AUX_STAT_AN_PAGE            5, 1
+#define AUX_STAT_REMOTE_FLT         6, 1
+#define AUX_STAT_PARALEL_FLT        7, 1
+#define AUX_STAT_HCD                8, 3
+#define AUX_STAT_AN_NEXT_PAGE      11, 1
+#define AUX_STAT_AN_ABILITY        12, 1
+#define AUX_STAT_AN_ACK            13, 1
+#define AUX_STAT_AN_COMPLETE_ACK   14, 1
+#define AUX_STAT_AN_COMPLETE       15, 1
+
+
+typedef enum 
+{
+    AUX_STAT_HCD_10HALF     = 1,
+    AUX_STAT_HCD_10FULL     = 2,
+    AUX_STAT_HCD_100HALF    = 3,
+    AUX_STAT_HCD_100FULL    = 5,
+    AUX_STAT_HCD_1000HALF   = 6,
+    AUX_STAT_HCD_1000FULL   = 7,
+} AUX_STAT_HCD_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BASET_CON register                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BASET_CON_1000HALF          8, 1
+#define BASET_CON_1000FULL          9, 1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AN_ADV register                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AN_ADV_10HALF               5, 1
+#define AN_ADV_10FULL               6, 1
+#define AN_ADV_100HALF              7, 1
+#define AN_ADV_100FULL              8, 1
+
+#endif //_HAL_ETHERNET_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Defines.txt b/board/nuvoton/common/BMC_HAL/Defines.txt
new file mode 100755
index 0000000..fa66687
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Defines.txt
@@ -0,0 +1,20 @@
+Required defines
+----------------
+CHIP_NAME               - this define's value contain the name of the target chip of the compilation
+                          The chip name should match to one of the directory names in the Chips folder
+
+                          
+                          
+Optional defines
+-----------------
+EXTERNAL_INCLUDE_FILE   -   The value of this define specifies an external file 
+                            that will be included into the chip.c compilation
+NO_INTERNAL_IRQ_HANDLER -   The existance of this define forces the module NOT to use AIC module
+							as Interrupt handler facility.
+NO_LIBC                 -   The existance of this define prevents the inclusion of LIBC headers (such as string.h)
+
+VERBOSE_GLOBAL          -   The existance of this define switches all supported modules to a verbose mode
+VERBOSE_EMC             -   Switch EMC module to verbose mode
+VERBOSE_GMAC            -   Switch GMAC module to verbose mode
+VERBOSE_SPI_FLASH       -   Switch SPI_FLASH driver to verbose mode
+VERBOSE_GPIO			-   Switch GPIO driver to verbose mode
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aes/aes_if.h b/board/nuvoton/common/BMC_HAL/Modules/aes/aes_if.h
new file mode 100755
index 0000000..3e4b07f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aes/aes_if.h
@@ -0,0 +1,111 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Project: Yarkon Security Library                                                                        */
+/* File Name: AES_if.h                                                                                     */
+/*                                                                                                         */
+/* File Contents:                                                                                          */
+/*      This file contains Advanced Encryption Standard (AES) algorithm                                    */
+/*      driver definitions.                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef AES_IF_H
+#define AES_IF_H
+
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES module enumerations                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES Operation */
+typedef enum
+{
+    AES_ENCRYPT,
+    AES_DECRYPT
+} AES_OP_T;
+
+/* AES Mode */
+typedef enum
+{
+    AES_MODE_ECB,   /* Electronic Codebook  */
+    AES_MODE_CBC,   /* Cipher Block Chaining */
+    AES_MODE_CTR,   /* Counter */
+    AES_MODE_MAC    /* Message Authentication Code */
+} AES_MODE_T;
+
+/* AES Key Size */
+typedef enum
+{
+    AES_128,
+    AES_192,
+    AES_256
+} AES_KEY_SIZE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES module macro definitions                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+/* The bit length of supported keys for the AES algorithm */
+#define AES_KEY_BIT_SIZE(size)  (128 + (AES_KEY_SIZE_T)(size) * 64)
+
+/* The byte length of supported keys for the AES algorithm */
+#define AES_KEY_BYTE_SIZE(size) (AES_KEY_BIT_SIZE(size) / 8)
+
+/* # of bytes needed to represent a key */
+#define AES_MAX_KEY_SIZE        AES_KEY_BYTE_SIZE(AES_256)
+
+/* The byte length of a block for the AES algorithm (b = 128 bit) */
+#define AES_BLOCK_SIZE          AES_KEY_BYTE_SIZE(AES_128)
+
+/* # of bytes needed to represent an IV  */
+#define AES_MAX_IV_SIZE         AES_BLOCK_SIZE
+
+/* # of bytes needed to represent a counter  */
+#define AES_MAX_CTR_SIZE        AES_BLOCK_SIZE
+
+/* Calculate the number of blocks in the formatted message */
+#define AES_COMPLETE_BLOCKS(size)   ((size + (AES_BLOCK_SIZE - 1)) / AES_BLOCK_SIZE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* AES module structures                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*  The structure for cipher information */
+typedef struct {
+    AES_OP_T    operation;  /* Encrypt / Decrypt */
+    AES_MODE_T  mode;       /* ECB / CBC / CTR / MAC */
+    const UINT8 *IV;         /* (optional) Initialization Vector for ciphering */
+    UINT8       *CTR;        /* (optional) Counter for ciphering */
+} AES_CIPHER_INSTANCE;
+
+/*  The structure for key information */
+typedef struct {
+    AES_KEY_SIZE_T  keyLen; /* Bit length of the key - 128 / 192 / 256  */
+    UINT8           index;  /* Key address in the fuse array in 128-bit steps (for loading a key from OTP) */
+    UINT8          *key;    /* Raw key data */
+} AES_KEY_INSTANCE;
+
+/*  The structure for data information */
+typedef struct {
+    UINT32       size;      /* Byte length of input data */
+    const UINT8 *input;     /* Input data */
+    UINT8       *output;    /* Output data */
+} AES_DATA_INSTANCE;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AES_Crypt                                                                              */
+/*                                                                                                         */
+/* Parameters:      cipher - The structure for cipher information [input].                                 */
+/*                  key    - The structure for key information    [input].                                 */
+/*                  data   - The structure for data information   [input].                                 */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*      Encrypt/Decrypt a message AES                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void AES_Crypt (AES_CIPHER_INSTANCE *cipher, AES_KEY_INSTANCE *key, AES_DATA_INSTANCE *data);
+
+#endif //AES_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.c b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.c
new file mode 100755
index 0000000..c97f351
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.c
@@ -0,0 +1,347 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   aic_drv.c                                                                                             */
+/*            This file contains implementation of AIC module                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "aic_drv.h"
+#include "aic_regs.h"
+
+#include "../../../Chips/chip_if.h"
+
+
+#define GIC_PRI_LOWEST     0xf0
+#define GIC_PRI_IRQ        0xa0
+#define GIC_PRI_IPI        0x90 /* IPIs must preempt normal interrupts */
+#define GIC_PRI_HIGHEST    0x80 /* Higher priorities belong to Secure-World */
+
+#define GICC_CTL_EOI (0x1 << 9)
+#define GICD_CTL_ENABLE 0x1
+#define GICC_CTL_ENABLE 0x1
+
+#define GICD_TYPE_LINES 0x01f
+#define GICD_TYPE_CPUS  0x0e0
+#define GICD_TYPE_SEC   0x400
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt Handler Table                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+typedef struct
+{
+    AIC_Isr_T   func;
+    UINT32      param;
+}   AIC_IsrEntry_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function forward declaration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+static AIC_IsrEntry_T AIC_handler_table[GIC_INTERRUPT_NUM];
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_Initialize                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs AIC initialization                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_Initialize (void)
+{
+    UINT i;
+	volatile UINT32 * reg_address;
+	UINT32 cpumask;
+	//UINT32 gic_type;
+	//UINT32 gic_iidr;
+    //UINT32 gic_lines;
+    //UINT32 gic_cpus;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* clean interrupt handler function pointers table                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(i=0; i<GIC_INTERRUPT_NUM; i++)
+    {
+        AIC_handler_table[i].func = NULL;
+        AIC_handler_table[i].param = 0;
+    }
+
+    cpumask = REG_READ(GICD_ITARGETSR) & 0xff;
+    cpumask |= cpumask << 8;
+    cpumask |= cpumask << 16;
+
+    REG_WRITE(GICD_CTLR, (UINT32)0x00);    // Disable GIC Distributor
+
+    
+	
+
+#ifndef __LINUX_KERNEL_ONLY__
+//    gic_type = REG_READ(GICD_TYPER);
+//    gic_iidr = REG_READ(GICD_IIDR);
+//    gic_lines = 32 * ((gic_type & GICD_TYPE_LINES) + 1);
+//    gic_cpus = 1 + ((gic_type & GICD_TYPE_CPUS) >> 5);
+
+//    No Console at this point.
+//    printf("GIC: %d lines, %d cpu%s%s (IID %8.8x).\n",
+//           gic_lines, gic_cpus, (gic_cpus == 1) ? "" : "s",
+//           (gic_type & GICD_TYPE_SEC) ? ", secure" : "",
+//           gic_iidr);
+#endif
+
+
+    /*
+     * Set all global interrupts to be level triggered, active High.
+     */
+    for (i = 32; i < GIC_INTERRUPT_NUM; i += 16)
+	{
+	    reg_address = (volatile UINT32 *)(REG_ADDR(GICD_ICFGR) + ((i/16) * 4));
+        *reg_address = (UINT32)0x00;	
+    }	
+    /*
+     * Set all global interrupts to this CPU only (CPU0).
+     */
+    for (i = 32; i < GIC_INTERRUPT_NUM; i += 4)
+	{
+	    reg_address = (volatile UINT32 *)(REG_ADDR(GICD_ITARGETSR) + ((i/4) * 4));
+        *reg_address = cpumask;	
+    }	
+			
+    /*
+     * Set priority on all interrupts.
+     */
+    for (i = 32; i < GIC_INTERRUPT_NUM; i += 4)
+	{
+	    reg_address = (volatile UINT32 *)(REG_ADDR(GICD_IPRIORITYR) + ((i/4) * 4));
+        *reg_address =  (GIC_PRI_IRQ<<24) | (GIC_PRI_IRQ<<16) | (GIC_PRI_IRQ<<8) | (GIC_PRI_IRQ);	
+    }	
+
+    /*
+     * Disable all interrupts.
+     */
+    for (i = 32; i < GIC_INTERRUPT_NUM; i += 32)
+	{
+	    reg_address = (volatile UINT32 *)(REG_ADDR(GICD_ICENABLER) + ((i/32) * 4));
+        *reg_address = 0xFFFFFFFF;	
+    }	
+
+
+    REG_WRITE(GICD_CTLR, (UINT32)GICD_CTL_ENABLE);                   // Enable GIC Distributor
+
+    REG_WRITE(GICD_ICENABLER, 0xFFFFFFFF);                           // Disable all SGI + PPI
+   
+    REG_WRITE(GICC_PMR, (UINT32)0xFF);                               // Set Priority Mask
+
+    REG_WRITE(GICC_CTLR, (UINT32)GICC_CTL_ENABLE | GICC_CTL_EOI);    // Enable GIC CPU Interface
+    
+    return HAL_OK;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_RegisterHandler                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func -                                                                                 */
+/*                  int_num -                                                                              */
+/*                  param -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs interrup registration                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_RegisterHandler(UINT32 int_num, AIC_Isr_T func, UINT32 param)
+{
+    if((int_num >= GIC_INTERRUPT_NUM) || (int_num < 32))
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    AIC_handler_table[int_num].func = func;
+    AIC_handler_table[int_num].param = param;
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EnableInt                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enable given interrupt                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EnableInt(UINT32 int_num)
+{
+	volatile UINT32 * reg_address;
+    UINT32 mask = 1 << (int_num % 32);
+	
+    if ((int_num >= GIC_INTERRUPT_NUM) || (int_num < 32))
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+	
+
+	reg_address = (volatile UINT32 *)(REG_ADDR(GICD_ISENABLER) + ((int_num/32) * 4));
+    *reg_address = mask;	
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_DisableInt                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disable given interrupt                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_DisableInt(UINT32 int_num)
+{
+	volatile UINT32 * reg_address;
+    UINT32 mask = 1 << (int_num % 32);
+	
+    if ((int_num >= GIC_INTERRUPT_NUM) || (int_num < 32))
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+	
+	reg_address = (volatile UINT32 *)(REG_ADDR(GICD_ICENABLER) + ((int_num/32) * 4));
+    *reg_address = mask;
+    return HAL_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EnableGroupInt                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enable given interrupt in group                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EnableGroupInt(UINT32 group_bit_num)
+{
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_DisableGroupInt                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disable given interrupt in group                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_DisableGroupInt(UINT32 group_bit_num)
+{
+
+    return HAL_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_IsGroupIntEnabled                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns true is group_bit_num is set                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN AIC_IsGroupIntEnabled(UINT32 group_bit_num)
+{
+    return 1;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EndOfService                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine acknowledges that IRQ is served                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EndOfService(UINT32 int_num)
+{
+    REG_WRITE(GICC_EOIR, int_num);
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_Isr                                                                                */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main IRQ handler                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void AIC_Isr(void)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading the highest priority unhandled interrupt                                                    */
+    /* IPER returns the interrupt number multipled by 4 (for easier table lookup)                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 irq_num;
+
+	
+    while (1)
+	{
+        irq_num = REG_READ(GICC_IAR);
+		irq_num &= (UINT32)0x03FF;
+		
+		
+		if ((irq_num >= 32) && (irq_num < GIC_INTERRUPT_NUM))
+		{		
+           /*-------------------------------------------------------------------------------------------------*/
+           /* If handler installed, execute it                                                                */
+           /*-------------------------------------------------------------------------------------------------*/
+           if (AIC_handler_table[irq_num].func)
+           {
+               AIC_handler_table[irq_num].func(AIC_handler_table[irq_num].param);
+           }
+		   
+		   
+           AIC_EndOfService(irq_num);
+		   continue;
+		}
+		break;		
+    }
+	
+}
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.h b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.h
new file mode 100755
index 0000000..5d80bf1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_drv.h
@@ -0,0 +1,19 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   aic_drv.h                                                                                             */
+/*            This file contains AIC driver interface                                                      */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _AIC_DRV_H
+#define _AIC_DRV_H
+
+#include "../aic_if.h"
+
+#endif //_AIC_DRV_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_regs.h b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_regs.h
new file mode 100755
index 0000000..6e3e7e4
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aic/Poleg_IP/aic_regs.h
@@ -0,0 +1,35 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   aic_regs.h                                                                                            */
+/*            This file contains definitions of AIC registers                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _AIC_REGS_H
+#define _AIC_REGS_H
+
+#include "../../../Chips/chip.h"
+
+
+#define GICC_CTLR              (AIC_BASE_ADDR + GIC_CPU_INTERFACE_OFFSET + 0x0000), AIC_ACCESS, 32
+#define GICC_PMR               (AIC_BASE_ADDR + GIC_CPU_INTERFACE_OFFSET + 0x0004), AIC_ACCESS, 32
+#define GICC_IAR               (AIC_BASE_ADDR + GIC_CPU_INTERFACE_OFFSET + 0x000C), AIC_ACCESS, 32
+#define GICC_EOIR              (AIC_BASE_ADDR + GIC_CPU_INTERFACE_OFFSET + 0x0010), AIC_ACCESS, 32
+
+
+#define GICD_CTLR              (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0000), AIC_ACCESS, 32
+#define GICD_TYPER             (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0004), AIC_ACCESS, 32
+#define GICD_IIDR              (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0008), AIC_ACCESS, 32
+#define GICD_ISENABLER         (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0100), AIC_ACCESS, 32
+#define GICD_ICENABLER         (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0180), AIC_ACCESS, 32
+#define GICD_IPRIORITYR        (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0400), AIC_ACCESS, 32
+#define GICD_ITARGETSR         (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0800), AIC_ACCESS, 32
+#define GICD_ICFGR             (AIC_BASE_ADDR + GIC_DISTRIBUTOR_OFFSET + 0x0C00), AIC_ACCESS, 32
+
+#endif // _AIC_REGS_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.c b/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.c
new file mode 100755
index 0000000..fe13f8d
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.c
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   aic_if.c                                                                                              */
+/*            This file contains AIC module driver selector                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(AIC_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(aic, AIC_MODULE_TYPE)
+#endif    
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.h b/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.h
new file mode 100755
index 0000000..dfda5a7
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/aic/aic_if.h
@@ -0,0 +1,158 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   aic_if.h                                                                                              */
+/*            This file contains AIC driver interface                                                      */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _AIC_IF_H
+#define _AIC_IF_H
+
+#include "../../Common/hal_error.h"
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt handler function prototype                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef HAL_STATUS (*AIC_Isr_T)(UINT32 param);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt Group related defines                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AIC_GROUP_INTERRUPT_NONE            0xFF
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_initialize                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs AIC initialization                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_Initialize (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_RegisterHandler                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func -                                                                                 */
+/*                  int_num -                                                                              */
+/*                  param -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs interrup registration                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_RegisterHandler(UINT32 int_num, AIC_Isr_T func, UINT32 param);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EnableInt                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enable given interrupt                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EnableInt(UINT32 int_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_DisableInt                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disable given interrupt                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_DisableInt(UINT32 int_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EnableGroupInt                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enable given interrupt in group.                                          */
+/*                  if the function receives AIC_GROUP_INTERRUPT_NONE it exists without action             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EnableGroupInt(UINT32 group_bit_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_DisableGroupInt                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disable given interrupt in group                                          */
+/*                  if the function receives AIC_GROUP_INTERRUPT_NONE it exists without action             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_DisableGroupInt(UINT32 group_bit_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_IsGroupIntEnabled                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  group_bit_num - Number of the bit in the AIC GROUP Enable register                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns true is group_bit_num is set                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN AIC_IsGroupIntEnabled(UINT32 group_bit_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_EndOfService                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  int_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine acknowledges that IRQ is served                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS AIC_EndOfService(UINT32 int_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        AIC_Isr                                                                                */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main IRQ handler                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void AIC_Isr(void);
+
+
+
+#endif //_AIC_IF_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.c b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.c
new file mode 100755
index 0000000..11d6109
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.c
@@ -0,0 +1,1999 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   clk_drv.c                                                                                             */
+/*            This file contains CLK module implementation                                                 */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../../Chips/chip.h"
+#include "../../../Common/hal_common.h"
+
+
+#include "clk_drv.h"
+#include "clk_regs.h"
+
+
+//#define CLK_DEBUG
+
+#ifdef CLK_DEBUG
+#ifdef __LINUX_KERNEL_ONLY__
+  #define CLOCK_DEBUG(fmt,args...)   printk(fmt ,##args)
+ #else
+  #define CLOCK_DEBUG(fmt,args...)   printf(fmt ,##args)
+ #endif
+#else
+ #define CLOCK_DEBUG(fmt,args...)
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* Spec predefined values                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PLLCON 0 possible values:                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_333MHZ_PLLCON0_REG_CFG    0x00A02403
+#define CLK_500MHZ_PLLCON0_REG_CFG    0x00282201
+#define CLK_600MHZ_PLLCON0_REG_CFG    0x00302201
+#define CLK_666MHZ_PLLCON0_REG_CFG    0x00A02203
+#define CLK_700MHZ_PLLCON0_REG_CFG    0x001C2101
+#define CLK_720MHZ_PLLCON0_REG_CFG    0x00902105
+#define CLK_750MHZ_PLLCON0_REG_CFG    0x001E2101
+#define CLK_800MHZ_PLLCON0_REG_CFG    0x00202101  /* PLL1 setting for 800 MHz in Z2 and later will have to be 0040_2101h (instead of 0040_2201h for Z1). */
+#define CLK_825MHZ_PLLCON0_REG_CFG    0x00212101
+#define CLK_850MHZ_PLLCON0_REG_CFG    0x00222101
+#define CLK_888MHZ_PLLCON0_REG_CFG    0x03782119
+#define CLK_900MHZ_PLLCON0_REG_CFG    0x00242101
+#define CLK_950MHZ_PLLCON0_REG_CFG    0x00262101
+#define CLK_1000MHZ_PLLCON0_REG_CFG   0x00282101
+#define CLK_1066MHZ_PLLCON0_REG_CFG   0x00802103
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PLLCON 1 possible values (notice that PLL1 in Z2 has a divider /2, so OTDV1 is smaller in half          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_333MHZ_PLLCON1_REG_CFG    0x00A02203
+#define CLK_444MHZ_PLLCON1_REG_CFG       0x00A02303
+#define CLK_500MHZ_PLLCON1_REG_CFG       0x00282101
+#define CLK_600MHZ_PLLCON1_REG_CFG       0x00302101
+#define CLK_666MHZ_PLLCON1_REG_CFG_Z1    0x00A02203 /* for Z1 */
+#define CLK_666MHZ_PLLCON1_REG_CFG    0x00A02103 /* change OTDV1 */
+#define CLK_700MHZ_PLLCON1_REG_CFG    0x00382101
+#define CLK_720MHZ_PLLCON1_REG_CFG    0x01202105
+#define CLK_750MHZ_PLLCON1_REG_CFG    0x003C2101 /* change FBDV */
+#define CLK_800MHZ_PLLCON1_REG_CFG    0x00402101 /* change OTDV1 : PLL1 setting for 800 MHz in Z2 and later will have to be 0040_2101h (instead of 0040_2201h for Z1). */
+#define CLK_825MHZ_PLLCON1_REG_CFG    0x00422101 /* change FBDV */
+#define CLK_850MHZ_PLLCON1_REG_CFG    0x00442101 /* change FBDV */
+#define CLK_900MHZ_PLLCON1_REG_CFG    0x00482101 /* change FBDV */
+#define CLK_950MHZ_PLLCON1_REG_CFG    0x004C2101 /* change FBDV */
+#define CLK_1000MHZ_PLLCON1_REG_CFG   0x00502101 /* change FBDV */
+#define CLK_1066MHZ_PLLCON1_REG_CFG   0x01002103
+
+#define CLK_800MHZ_PLLCON0_REG_CFG_BB  0x00402201
+/*---------------------------------------------------------------------------------------------------------*/
+/* PLLCON 2 possible values                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_960MHZ_PLLCON2_REG_CFG    0x00C02105
+
+
+#define LOK_TIMEOUT  100000  /* 4ms if 25 MHz */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Clock Target frequency */
+#define SU60_DESIRED_FREQUENCY      60  // MHz (dont use _1MHz_)
+#define SU_DESIRED_FREQUENCY        30  // MHz (dont use _1MHz_)
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local Functions                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  CLK_CalculatePLLFrequency (UINT32 pllVal);
+static UINT32  CLK_GetPll0Freq (void);
+static UINT32  CLK_GetPll1Freq (void);
+static UINT32  CLK_GetPll2Freq (void);
+//static UINT32  CLK_GetPll2Freq (void);
+//static UINT32  CLK_GetGfxPllFreq (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Functions Implementation                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+
+HAL_STATUS WaitForPllLock (UINT32 pll)
+{
+    volatile UINT32 loki_bit = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read LOKI till PLL is locked or timeout expires                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (1)
+    {
+
+        switch (pll)
+        {
+            case PLL0:
+                loki_bit = READ_REG_FIELD(PLLCON0, PLLCONn_LOKI);
+                break;
+            case PLL1:
+                loki_bit = READ_REG_FIELD(PLLCON1, PLLCONn_LOKI);
+                break;
+            case PLL2:
+                loki_bit = READ_REG_FIELD(PLLCON2, PLLCONn_LOKI);
+                break;
+            case PLL_GFX:
+                loki_bit = READ_REG_FIELD(PLLCONG, PLLCONG_LOKI);
+                break;
+            default:
+                return HAL_ERROR_BAD_PARAM;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* PLL is locked, clear and break                                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (loki_bit == 1)
+        {
+
+            switch (pll)
+            {
+                case PLL0:
+                    SET_REG_FIELD(PLLCON0, PLLCONn_LOKS, 1);
+                    break;
+                case PLL1:
+                    SET_REG_FIELD(PLLCON1, PLLCONn_LOKS, 1);
+                    break;
+                case PLL2:
+                    SET_REG_FIELD(PLLCON2, PLLCONn_LOKS, 1);
+                    break;
+                case PLL_GFX:
+                    SET_REG_FIELD(PLLCONG, PLLCONG_LOKS, 1);
+                    break;
+                default:
+                    return HAL_ERROR_BAD_PARAM;
+            }
+
+            break;
+        }
+
+
+    }
+
+    return HAL_OK;
+
+}
+
+#if defined (CODE_OF_BB_ONLY) /* not updated */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureClocks                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  straps -  strap values from the PWRON register (flipped according to FUSTRAP register) */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures the chip PLLs and selects clock sources for modules            */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ConfigureClocks (void)
+{
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* pll configuration local values                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32  PLLCON0_l  = 0;
+    UINT32  PLLCON1_l  = 0;
+    UINT32  PLLCON2_l  = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* clk diveiders local values                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32  CLKDIV1_l  = 0;
+    UINT32  CLKDIV2_l  = 0;
+    UINT32  CLKDIV3_l  = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* clk mux local values                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32  CLKSEL_l   = 0;
+
+    UINT32 CLKSEL_CLKREF_l = 0;
+
+    UINT32 polegVersion = GCR_Get_Chip_Version();
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Z2:                                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* 2   1   0   DDR     CORE    AXI     AHB     AHB3    SPI0    APB5     APB2,3    APB1,4     PCI     GFX  */
+    /* Straps                                                                                                 */
+    /* 3   2   1                                                                                              */
+    /* 0   0   0   MCBPCK  FT      FT/2    FT/4    FT/4    FT/4    FT/4     FT/4      FT/4       PLL0/5  PLL0/4 */
+    /* 0   0   1   25      25      12.5    6.25    3.1     6.25    3.125    1.5       1.5        4.17    5    */
+    /* 0   1   0   1066    1000    500     250     19.23   19.23   125      62.5      31.25      142.8   167  */
+    /* 0   1   1   667     500     250     125     17.85   17.85   62.5     62.5      31.25      166.7   167  */
+    /* 1   0   0   850     800     400     200     20      20      100      50        25         133     160  */
+    /* 1   0   1   900     888     444     222     18.5    18.5    111      55.5      27.75      148     177.6 */
+    /* 1   1   0   800     850     425     212.5   19.3    19.3    106.25   53.125    26.6       170     170  */
+    /* 1   1   1   800     800     400     200     20      20      100      50        25         133     160  */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Common configurations for the clk mux. will be changes later according to straps 1-3                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLKSEL_l           = REG_READ(CLKSEL);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read CLKDIV default configuration                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLKDIV1_l          = REG_READ(CLKDIV1);
+    CLKDIV2_l          = REG_READ(CLKDIV2);
+    CLKDIV3_l          = REG_READ(CLKDIV3);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Spec: PLL0 is the system clock PLL. Output frequency range is 800 to 1000 (800) MHz.               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_CPUCKSEL,  CLKSEL_CPUCKSEL_PLL0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Spec: PLL1 is the Memory Controller clock PLL. Output frequency range is 667 to 1066 (800) MHz.    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_MCCKSEL,   CLKSEL_MCCKSEL_PLL1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* PLL2 is for UARTs, timers, USB. Output frequency is 960 MHz.                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_DVCSSEL,   CLKSEL_DVCSSEL_PLL2);
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_UARTCKSEL, CLKSEL_UARTCKSEL_PLL2);
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_CLKOUTSEL, CLKSEL_CLKOUTSEL_PLL2);
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_SUCKSEL,   CLKSEL_SUCKSEL_PLL2);
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_SDCKSEL,   CLKSEL_SDCKSEL_PLL2);
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL0); //TODO: check
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXMSEL,   CLKSEL_GFXMSEL_PLL2);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* GFX PLL used for graphics                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_GPRFSEL,   CLKSEL_GPRFSEL_CLKREF);  // PLLG source clock can be clkref (like other plls)\ GFXBPCK \ USB OHCI
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_PIXCKSEL,  CLKSEL_GPRFSEL_GFXBYPCK);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clock configuration - TIMER connection should change in spec to allow timer to be connected to the  */
+    /* external reference clock by defaultm                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKSEL_l, CLKSEL_TIMCKSEL,  CLKSEL_TIMCKSEL_CLKREF);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting the Timer divisor to 2                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_TIMCKDIV, CLKDIV1_TIMCK_DIV(1));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read clock speed from straps                                                                        */
+    /* Values interpretation is according to FUSTRAP spec and not PWRON spec                               */
+    /* STRP_Init() must be run prior to calling this function                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+ 	if ( polegVersion == POLEG_VERSION_Z1)
+    {
+	    switch (STRP_Ckfrq_Get())
+		{
+			case STRP_CLKFRQ_OPTION0:   /* DDR=MCBPCK  CORE=FT       AXI=FT/2  AHB=FT/4      AHB3=FT/2   SPI0=FT/2     APB5=FT/4     APB2,3=FT/4       APB1,4=FT/4     PCI=FT/5    GFX=FT/4 */
+
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;     // Configure PLL0 with value divided by 24 for UART
+				PLLCON1_l  = CLK_800MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* clk selection is for this bypass: */
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_CPUCKSEL, CLKSEL_CPUCKSEL_SYSBPCK);
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_MCCKSEL,  CLKSEL_MCCKSEL_MCBPCK);
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(1));  /* AHB3 clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(5));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(4));  /* GFX to PLL0/4 */
+
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(1));  /* SPI clock div = 4, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPI0CKDV_DIV(1));  /* SPI clock div = 4. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION2:   /* DDR=1066    CORE=1000     AXI=500   AHB=250       AHB3=19.23  SPI0=19.23    APB5=125      APB2,3=62.5       APB1,4=31.25    PCI=142.8   GFX=167 */
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_500MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(13));  /* AHB3 clock div = 13*2  */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(7));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(6));  /* GFX to PLL0/6 */
+
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(13));  /* SPI clock div = 13, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION3:   /* DDR=667     CORE=500      AXI=250   AHB=125       AHB3=17.85  SPI0=17.85    APB5=62.5     APB2,3=62.5       APB1,4=31.25    PCI=166.7   GFX=167 */
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(7));  /* AHB3 clock div = 7*2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(3));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 2, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(3));  /* GFX to PLL0/3 */
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(7));  /* SPI clock div = 7, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION4:   /* DDR=850     CORE=800      AXI=400   AHB=200       AHB3=20     SPI0=20       APB5=100      APB2,3=50         APB1,4=25       PCI=133     GFX=160 */
+				 /* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_666MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(10));  /* AHB3 clock div = 10*2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(6));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(5));  /* GFX to PLL0/5 */
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(10));  /* SPI clock div = 10, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION5:   /* DDR=900     CORE=888      AXI=444   AHB=222       AHB3=18.5   SPI0=18.5     APB5=111      APB2,3=55.5       APB1,4=27.75    PCI=148     GFX=177.6 */
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_720MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(12));  /* AHB3 clock div = 12*2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(6));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(5));  /* GFX to PLL0/5 */
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(12));  /* SPI clock div = 12, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION6:   /* DDR=800     CORE=850      AXI=425   AHB=212.5     AHB3=19.3   SPI0=19.3     APB5=106.25   APB2,3=53.125     APB1,4=26.6     PCI=170     GFX=170 */
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_800MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(11)); /* AHB3 clock div = 11*2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(5));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(5));  /* GFX to PLL0/5 */
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(11));  /* SPI clock div = 11, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION1:   /* DDR=25      CORE=25       AXI=12.5  AHB=6.25      AHB3=3.1    SPI0=6.25     APB5=3.125    APB2,3=3.125      APB1,4=1.5      PCI=4.17    GFX=5 */
+			case STRP_CLKFRQ_OPTION7:   /* DDR=800     CORE=800      AXI=400   AHB=200       AHB3=20     SPI0=20       APB5=100      APB2,3=50         APB1,4=25       PCI=133     GFX=160 */
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_600MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_800MHZ_PLLCON0_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				/* since CORE == DDR clock. connect them both to same PLL */
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_CPUCKSEL, CLKSEL_CPUCKSEL_PLL1);
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL1); // move to PLL1 too.
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(10));  /* AHB3 clock div = 10*2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(6));  /* PCI clock div = 5  */
+
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(5));  /* GFX to PLL0/5 */
+
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(10));  /* SPI clock div = 10, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			default:
+				ASSERT(0);
+		}
+		
+	}
+	
+	
+	//-------------------------------------------------------	
+	//          Z2 and above: 
+	else
+	{
+		switch (STRP_Ckfrq_Get())
+		{
+			case STRP_CLKFRQ_OPTION0:   /** Z1: DDR=MCBPCK  CORE=FT       AXI=FT/2  AHB=FT/4     AHB3=FT/2   SPI0=FT/2   APB5=FT/4   APB2,3=FT/4     APB1,4=FT/4     PCI=FT/5    GFX=FT/4 */
+										/** Z2: DDR=MCBPCK  CORE=FT       AXI=FT/2  AHB=FT/4	 AHB3=FT/4	 SPI0=FT/4	 APB5=FT/4	 APB2,3=FT/4	 APB1,4=FT/4	 PCI=PLL0/5	 GFX=PLL0/4	*/
+			    /* PLLs on default values: */
+
+				PLLCON0_l  = CLK_800MHZ_PLLCON0_REG_CFG;     // Configure PLL0 with value divided by 24 for UART
+				PLLCON1_l  = CLK_800MHZ_PLLCON1_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(5)); 
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(4));
+
+				/* clk selection is for this bypass: */
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_CPUCKSEL, CLKSEL_CPUCKSEL_SYSBPCK);
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_MCCKSEL,  CLKSEL_MCCKSEL_MCBPCK);
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(1));  /* AHB3 clock div = 4 */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV1);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(1));  /* SPI clock div = 4, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(1));  /* SPI clock div = 4. take it slow.  */
+
+				break;
+
+			case STRP_CLKFRQ_OPTION2:   /** Z1: DDR=1066   CORE=1000   AXI=500   AHB=250   AHB3=19.23  SPI0=19.23    APB5=125      APB2,3=62.5      APB1,4=31.25    PCI=142.8   GFX=167 */
+										/** Z2: DDR=667	   CORE=500	   AXI=250	 AHB=125   AHB3=17.85  SPI0=17.85    APB5=62.5	   APB2,3=62.5	    APB1,4=31.25	PCI=120	    GFX=160	*/
+
+			case STRP_CLKFRQ_OPTION3:   /** Z1: DDR=667    CORE=500    AXI=250   AHB=125   AHB3=17.85  SPI0=17.85    APB5=62.5     APB2,3=62.5      APB1,4=31.25    PCI=166.7   GFX=167 */
+										/** Z2: DDR=667	   CORE=500	   AXI=250	 AHB=125   AHB3=17.85  SPI0=17.85	 APB5=62.5	   APB2,3=62.5	    APB1,4=31.25	PCI=120	    GFX=160	*/
+
+			case STRP_CLKFRQ_OPTION4:   /** Z1: DDR=850    CORE=800    AXI=400   AHB=200   AHB3=20     SPI0=20       APB5=100      APB2,3=50        APB1,4=25       PCI=133     GFX=160 */
+										/** Z2: DDR=667	   CORE=500	   AXI=250	 AHB=125   AHB3=17.85  SPI0=17.85	 APB5=62.5	   APB2,3=62.5	    APB1,4=31.25	PCI=120	    GFX=160	 */
+			
+			case STRP_CLKFRQ_OPTION5:   /** Z1: DDR=900    CORE=888    AXI=444   AHB=222   AHB3=18.5   SPI0=18.5     APB5=111      APB2,3=55.5      APB1,4=27.75    PCI=148     GFX=177.6 */
+										/** Z2: DDR=667	   CORE=500	   AXI=250	 AHB=125   AHB3=17.85  SPI0=17.85	 APB5=62.5	   APB2,3=62.5	    APB1,4=31.25	PCI=120	    GFX=160	 */
+			
+			case STRP_CLKFRQ_OPTION6:   /** Z1: DDR=800    CORE=850    AXI=425   AHB=212.5 AHB3=19.3   SPI0=19.3     APB5=106.25   APB2,3=53.125    APB1,4=26.6     PCI=170     GFX=170 */
+										/** Z2: DDR=667	   CORE=500	   AXI=250	 AHB=125   AHB3=17.85  SPI0=17.85	 APB5=62.5	   APB2,3=62.5	    APB1,4=31.25	PCI=120	    GFX=160	*/
+
+				PLLCON0_l  = CLK_500MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_666MHZ_PLLCON1_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL2);
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(4));
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(3));
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(7));  /* AHB3 clock div = 7*2 */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 4, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 2, it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(7));  /* SPI clock div = 7, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+
+			case STRP_CLKFRQ_OPTION1:   /** Z1: DDR=25      CORE=25     AXI=12.5    AHB=6.25    AHB3=3.1    SPI0=6.25   APB5=3.125  APB2,3=3.125    APB1,4=1.5      PCI=4.17    GFX=5 */
+										/** Z2: DDR=25	    CORE=25	    AXI=12.5	AHB=6.25	AHB3=3.1	SPI0=6.25	APB5=3.125	APB2,3=1.5	    APB1,4=1.5	    PCI=4.167	GFX=5			*/
+
+			case STRP_CLKFRQ_OPTION7:   /** Z1:  DDR=800    CORE=800    AXI=400     AHB=200     AHB3=20     SPI0=20     APB5=100    APB2,3=50       APB1,4=25       PCI=133     GFX=160 */
+										/** Z2:  DDR=800	CORE=800	AXI=400 	AHB=200     AHB3=20	    SPI0=20	    APB5=100	APB2,3=50	    APB1,4=25	    PCI=133	    GFX=160							*/
+
+				/* PLLs on difault values: */
+				PLLCON0_l  = CLK_800MHZ_PLLCON0_REG_CFG;
+				PLLCON1_l  = CLK_800MHZ_PLLCON1_REG_CFG;
+				PLLCON2_l  = CLK_960MHZ_PLLCON2_REG_CFG;
+
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL0);
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(6));
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_GFXCKDIV,  CLKDIV2_GFXCKDIV_DIV(5));
+
+				/* since CORE == DDR clock. connect them both to same PLL */
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_CPUCKSEL, CLKSEL_CPUCKSEL_PLL1);
+				SET_VAR_FIELD(CLKSEL_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL1); // move to PLL1 too.
+
+				/* clk dividers */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK2DIV,   CLKDIV1_CLK2DIV2);  /* AXI  clock div = 2 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_CLK4DIV,   CLKDIV1_CLK4DIV2);  /* AHBn clock div = 4 */
+				SET_VAR_FIELD(CLKDIV1_l, CLKDIV1_AHB3CKDIV, CLKDIV1_AHB3CK_DIV(10));  /* AHB3 clock div = 10*2 */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB3CKDIV, CLKDIV2_APBxCKDIV4);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB4CKDIV, CLKDIV2_APBxCKDIV8);  /* APB clock div = 8,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB5CKDIV, CLKDIV2_APBxCKDIV2);  /* APB clock div = 4,  it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPI0CKDV,  CLKDIV3_SPI0CKDV_DIV(10));  /* SPI clock div = 10, but it's after AXI div(2) and APBn div(2) */
+				SET_VAR_FIELD(CLKDIV3_l, CLKDIV3_SPIXCKDV,  CLKDIV3_SPIXCKDV_DIV(32));  /* SPI clock div = 32. take it slow.  */
+
+				break;
+
+			default:
+				ASSERT(0);
+		}
+	}
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* in Z1 APB1 must be identical to APB2                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (polegVersion == POLEG_VERSION_Z1)
+    {
+        SET_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB1CKDIV, READ_VAR_FIELD(CLKDIV2_l, CLKDIV2_APB2CKDIV));
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Switch clock sources to external clock for all muxes (while initing the PLLs)                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // Switch the clock source to another PLL or external clock (25 MHz)
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_DVCSSEL,   CLKSEL_DVCSSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_CPUCKSEL,  CLKSEL_CPUCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_MCCKSEL,   CLKSEL_MCCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_UARTCKSEL, CLKSEL_UARTCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_CLKOUTSEL, CLKSEL_CLKOUTSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_TIMCKSEL,  CLKSEL_TIMCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_SUCKSEL,   CLKSEL_SUCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_SDCKSEL,   CLKSEL_SDCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_GFXMSEL,   CLKSEL_GFXMSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_GPRFSEL,   CLKSEL_GPRFSEL_CLKREF);
+    SET_VAR_FIELD(CLKSEL_CLKREF_l, CLKSEL_PIXCKSEL,  CLKSEL_PIXCKSEL_CLKREF);
+
+    REG_WRITE(CLKSEL, CLKSEL_CLKREF_l);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Change PLL configuration (leave PLL in reset mode):                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // Set PWDEN bit
+    SET_VAR_FIELD(PLLCON0_l, PLLCONn_PWDEN, PLLCONn_PWDEN_POWER_DOWN);
+    SET_VAR_FIELD(PLLCON1_l, PLLCONn_PWDEN, PLLCONn_PWDEN_POWER_DOWN);
+    SET_VAR_FIELD(PLLCON2_l, PLLCONn_PWDEN, PLLCONn_PWDEN_POWER_DOWN);
+
+    /* set to power down == 1 */
+    REG_WRITE(PLLCON0, PLLCON0_l);
+    REG_WRITE(PLLCON1, PLLCON1_l);
+    REG_WRITE(PLLCON2, PLLCON2_l);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait 10usec for PLL:                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    //3. Wait 2 s or more;
+    CLK_Delay_MicroSec(10);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable PLLs after configuring. Delays to prevent power issues.                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(PLLCON0, PLLCONn_PWDEN, PLLCONn_PWDEN_NORMAL);
+    CLK_Delay_MicroSec(10);
+    SET_REG_FIELD(PLLCON1, PLLCONn_PWDEN, PLLCONn_PWDEN_NORMAL);
+    CLK_Delay_MicroSec(10);
+    SET_REG_FIELD(PLLCON2, PLLCONn_PWDEN, PLLCONn_PWDEN_NORMAL);
+    CLK_Delay_MicroSec(10);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait 750usec for PLL to stabilize:                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* TODO : check return value */
+    WaitForPllLock(PLL0);
+    WaitForPllLock(PLL1);
+    WaitForPllLock(PLL2);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Change CLKDIV configuration:                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(CLKDIV1, CLKDIV1_l);
+    REG_WRITE(CLKDIV2, CLKDIV2_l);
+    REG_WRITE(CLKDIV3, CLKDIV3_l);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for 200 clock cycles between clkDiv change and clkSel change:                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_Delay_Cycles(400);
+
+    /*----------------------------------------------------------------------------------------------------*/
+    /* Change clock source according to configuration:                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* in Z1 clksel all at once: REG_WRITE(CLKSEL, CLKSEL_l);                                              */
+    /*                                                                                                     */
+    /* in z2 in order to avoid power surge clksel is st gradualy, according to this scema:                 */
+    /* [ brackets] mean do it in the same step                                                             */
+    /*                                                                                                     */
+    /* MC, [DVC,   CPU], GFXMSEL, GPRFSEL,  GFXCKSEL, [PIXCKSEL, CLKOUTSEL, SUCKSEL, TIMCKSEL, UARTCKSEL,  */
+    /* SDCKSEL]                                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_MCCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_MCCKSEL));
+    CLK_Delay_MicroSec(20);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_DVCSSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_DVCSSEL));
+    SET_REG_FIELD(CLKSEL, CLKSEL_CPUCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_CPUCKSEL));
+    CLK_Delay_MicroSec(20);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_GFXMSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_GFXMSEL));
+    CLK_Delay_MicroSec(20);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_GPRFSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_GPRFSEL ));
+    CLK_Delay_MicroSec(20);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_GFXCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_GFXCKSEL));
+    CLK_Delay_MicroSec(20);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_PIXCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_PIXCKSEL));
+    SET_REG_FIELD(CLKSEL, CLKSEL_CLKOUTSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_CLKOUTSEL ));
+    SET_REG_FIELD(CLKSEL, CLKSEL_SUCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_SUCKSEL ));
+    SET_REG_FIELD(CLKSEL, CLKSEL_TIMCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_TIMCKSEL ));
+    SET_REG_FIELD(CLKSEL, CLKSEL_UARTCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_UARTCKSEL ));
+    SET_REG_FIELD(CLKSEL, CLKSEL_SDCKSEL, READ_VAR_FIELD(CLKSEL_l,  CLKSEL_SDCKSEL ));
+    CLK_Delay_MicroSec(20);
+
+
+    /* Wait 10usec for PLL:   */
+    CLK_Delay_MicroSec(10);
+
+    /* Now we can init the fuse clock */
+    FUSE_Init();
+}
+#endif // defined (CODE_OF_BB_ONLY)
+
+
+#if defined (USB_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureUSBClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the USB clock to 60MHz by checking which PLL is                             */
+/*                  dividable by 60 and setting correct SEL and DIV values.                                */
+/*                  Assumes that one of the PLLs is dividable by 60                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  CLK_ConfigureUSBClock(void)
+{
+    UINT32  pll0Freq;   // In Hz
+    UINT32  pll1Freq;   // In Hz
+    UINT32  choosenPllFreq;
+    UINT32  su60Divider = 0;
+    UINT32  suDivider = 0;
+
+    pll0Freq = CLK_GetPll0Freq();
+    pll1Freq = CLK_GetPll1Freq();
+
+    if (pll0Freq % SU60_DESIRED_FREQUENCY == 0)
+    {
+        SET_REG_FIELD(CLKSEL, CLKSEL_SUCKSEL,   CLKSEL_SUCKSEL_PLL0);
+        choosenPllFreq = pll0Freq;
+    }
+    else if (pll1Freq % SU60_DESIRED_FREQUENCY == 0)
+    {
+        SET_REG_FIELD(CLKSEL, CLKSEL_SUCKSEL,   CLKSEL_SUCKSEL_PLL1);
+        choosenPllFreq = pll1Freq;
+    }
+    else
+    {
+        return HAL_ERROR_BAD_FREQ;
+    }
+
+    su60Divider = choosenPllFreq / (SU60_DESIRED_FREQUENCY*_1MHz_);
+    suDivider   = choosenPllFreq / (SU_DESIRED_FREQUENCY*_1MHz_);
+    SET_REG_FIELD(CLKDIV2, CLKDIV2_SU48CKDIV, su60Divider - 1);
+    CLK_Delay_Cycles(200);
+    SET_REG_FIELD(CLKDIV2, CLKDIV2_SUCKDIV, suDivider - 1);
+    CLK_Delay_Cycles(200);
+
+    return HAL_OK;
+
+}
+#endif // defined (USB_MODULE_TYPE)
+
+
+#if defined (UART_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureUartClock                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures the Uart clock source to be closest to 24MHz by                */
+/*                  modifying the UART divider.                                                            */
+/*                  In _PALLADIUM_ bypass mode the UART input frequency is set to be highest possible -    */
+/*                  same as APB frequency                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_ConfigureUartClock(void)
+{
+    UINT32 uart_clk; //Hz
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Set UART to 24MHz. Source is PLL2 (960Mhz), which is divided by 2, so we get 24Mhz = 960/2/20   */
+    /*-------------------------------------------------------------------------------------------------*/
+    UINT32 uartDesiredFreq  = 24*_1MHz_; //Hz
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Normal configuration - UART from PLL0 with divider calculated from PLL0 configuration to get 24MHz  */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Calculate the divider given PLL2 output and desired frequency:                                  */
+    /*-------------------------------------------------------------------------------------------------*/
+    UINT32 pllFreq = CLK_GetPll2Freq();
+    UINT32 uartDiv = pllFreq/uartDesiredFreq;
+    uart_clk = pllFreq / uartDiv;
+
+    /*----------------------------------------------------[]---------------------------------------------*/
+    /* Set divider:                                                                                    */
+    /*-------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(CLKDIV1, CLKDIV1_UARTDIV, CLKDIV1_UART_DIV(uartDiv));
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Choose PLL0 as a source:                                                                        */
+    /*-------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(CLKSEL, CLKSEL_UARTCKSEL, CLKSEL_UARTCKSEL_PLL2);
+ 
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for 200 clock cycles between clkDiv change and clkSel change:                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_Delay_Cycles(200);
+
+    return uart_clk;
+
+}
+#endif // defined (UART_MODULE_TYPE)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetPLL0toAPBdivisor                                                                */
+/*                                                                                                         */
+/* Parameters:      apb: number of APB                                                                     */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the value achieved by dividing PLL0 frequency to APB frequency    */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetPLL0toAPBdivisor(UINT32 apb)
+{
+    volatile UINT32 apb_divisor = 1;
+
+    apb_divisor = apb_divisor * (READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV) + 1);       // AXI divider ( div by 1\2)
+    apb_divisor = apb_divisor * (READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV) + 1);       // AHBn divider (div by 1\2\3\4)
+
+    switch (apb)
+    {
+        case APB1:
+            apb_divisor = apb_divisor * (1 << READ_REG_FIELD(CLKDIV2, CLKDIV2_APB1CKDIV));     // APB divider
+            break;
+        case APB2:
+            apb_divisor = apb_divisor * (1 << READ_REG_FIELD(CLKDIV2, CLKDIV2_APB2CKDIV));     // APB divider
+            break;
+        case APB3:
+            apb_divisor = apb_divisor * (1 << READ_REG_FIELD(CLKDIV2, CLKDIV2_APB3CKDIV));     // APB divider
+            break;
+        case APB4:
+            apb_divisor = apb_divisor * (1 << READ_REG_FIELD(CLKDIV2, CLKDIV2_APB4CKDIV));     // APB divider
+            break;
+        case APB5:
+            apb_divisor = apb_divisor * (1 << READ_REG_FIELD(CLKDIV2, CLKDIV2_APB5CKDIV));     // APB divider
+            break;
+        case SPI0:
+            apb_divisor = apb_divisor * (READ_REG_FIELD(CLKDIV3, CLKDIV3_SPI0CKDV) + 1);       // SPI0 divider
+            break;
+        case SPI3:
+            apb_divisor = apb_divisor * (READ_REG_FIELD(CLKDIV1, CLKDIV1_AHB3CKDIV) + 1);       // SPI0 divider
+            break;
+        default:
+            apb_divisor = 0xFFFFFFFF;
+            break;
+    }
+
+    return apb_divisor;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_Cycles                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cycles -  num of cycles to delay                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs delay in number of cycles (delay in C code).                     */
+/*                  For a more accurate delay, use : CLK_Delay_MicroSec                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_Delay_Cycles (UINT32 cycles)
+{
+    UINT            cacheState = 0;
+    volatile UINT   i          = 0;
+    volatile UINT32 iterations = 0;
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The measurements were done on PD over 50 cycles, fetches from ROM:                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    const UINT CYCLES_IN_ONE_ITERATION_CACHE_DISABLED  =   145;
+	// const UINT CYCLES_IN_ONE_ITERATION_CACHE_ENABLED      6
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate number of iterations                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    iterations = cycles/CYCLES_IN_ONE_ITERATION_CACHE_DISABLED + 1;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The actual wait loop:                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    ICACHE_SAVE_DISABLE(cacheState);
+    for (i = 0; i < iterations; i++);
+    ICACHE_RESTORE(cacheState);
+
+    return iterations;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetTimeStamp                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         Current time stamp                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void  CLK_GetTimeStamp (UINT32 time_quad[2])
+{
+    UINT32 Seconds;
+    UINT32 RefClocks;
+
+    do
+    {
+        Seconds = REG_READ(SECCNT);
+        RefClocks = REG_READ(CNTR25M);
+    } while (REG_READ(SECCNT) != Seconds);
+
+    time_quad[0] = RefClocks;
+    time_quad[1] = Seconds;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_MicroSec                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSec -  number of microseconds to delay                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs a busy delay (empty loop)                                        */
+/*                  the number of iterations is based on current CPU clock calculation and cache           */
+/*                  enabled/disabled                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_Delay_MicroSec(UINT32 microSec)
+{
+#if 0 /* _USE_CLK_ITERATION_ */
+    UINT            cacheState  = 0;
+    UINT32          FOUT        = 0;
+    UINT32          part1       = 0;
+    UINT32          part2       = 0;
+    volatile UINT   i           = 0;
+    volatile UINT32 iterations  = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate CPU frequency (in KHz)                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FOUT = CLK_GetCPUFreq() / 1000;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* FOUT/cyclesPerIteration - iterations in each millisecond (FOUT is in KHz)                           */
+    /* FOUT/(cyclesPerIteration*1000) - iterations in each uSec                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+//    iterations = (microSec*FOUT)/(CYCLES_IN_ONE_ITERATION_CACHE_DISABLED*1000);
+    part1 = microSec/CYCLES_IN_ONE_ITERATION_CACHE_DISABLED;
+    part1 = MAX(1, part1);
+    part2 = FOUT/1000;
+    part2 = MAX(1, part2);
+    iterations = part1*part2;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The actual wait loop:                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    ICACHE_SAVE_DISABLE(cacheState);
+    for (i = 0; i < iterations; i++);
+    ICACHE_RESTORE(cacheState);
+
+    return iterations;
+
+#else  /* use the new clk counter */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* This register is reset by only VSB power-up reset. The value of this register                           */
+/* represents a counter with a 25 MHz clock, used to update the SECCNT register. This field is updated every*/
+/* 640ns. The 4 LSB of this field are always 0. When this field reaches a value of 25,000,000 it goes to 0 */
+/* and SEC_CNT field is updated.                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+    /* not testing that microSec < 33 sec (2^25bit) us */
+
+    UINT32 iUsCnt1[2], iUsCnt2[2];
+    UINT32 delay;  // Acctual delay generated by FW
+    UINT32 minimum_delay = (microSec * EXT_CLOCK_FREQUENCY_MHZ) + CNTR25M_ACCURECY; /* this is equivalent to microSec/0.64 + minimal tic length.*/
+
+    CLK_GetTimeStamp(iUsCnt1);
+
+    do
+    {
+        CLK_GetTimeStamp(iUsCnt2);
+        delay =  ((EXT_CLOCK_FREQUENCY_MHZ * _1MHz_) * (iUsCnt2[1] - iUsCnt1[1])) + (iUsCnt2[0] - iUsCnt1[0]);
+    }
+    while(delay < minimum_delay);
+
+
+    return (UINT32)(delay / EXT_CLOCK_FREQUENCY_MHZ);
+
+
+#endif
+
+
+
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_Since                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSecDelay -  number of microseconds to delay since t0_time. if zero: no delay.     */
+/*                  t0_time       - start time , to measure time from.                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  get a time stamp, delay microSecDelay from it. If microSecDelay has already passed     */
+/*                  since the time stamp , then no delay is executed. returns the time that elapsed since  */
+/*                  t0_time .                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_Delay_Since (UINT32 microSecDelay, UINT32 t0_time[2])
+{
+
+    UINT32 iUsCnt2[2];
+    UINT32 timeElapsedSince;  // Acctual delay generated by FW
+    UINT32 minimum_delay = (microSecDelay * EXT_CLOCK_FREQUENCY_MHZ) + CNTR25M_ACCURECY; /* this is equivalent to microSec/0.64 + minimal tic length.*/
+
+
+    do
+    {
+        CLK_GetTimeStamp(iUsCnt2);
+        timeElapsedSince =  ((EXT_CLOCK_FREQUENCY_MHZ * _1MHz_) * (iUsCnt2[1] - t0_time[1])) + (iUsCnt2[0] - t0_time[0]);
+    }
+    while(timeElapsedSince < minimum_delay);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* return elapsed time                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return (UINT32)(timeElapsedSince / EXT_CLOCK_FREQUENCY_MHZ);
+}
+
+
+
+#if defined (TIMER_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureTimerClock                                                                */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Timer clock configuration                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_ConfigureTimerClock (void)
+{
+
+    SET_REG_FIELD(CLKEN1, CLKEN1_TIMER0_4, 1);
+    SET_REG_FIELD(CLKEN1, CLKEN1_TIMER5_9, 1);
+    SET_REG_FIELD(CLKEN3, CLKEN3_TIMER10_14, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for 200 clock cycles between clkDiv or clkSel change:                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_Delay_Cycles(200);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting the Timer divisor to 1                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(CLKDIV1, CLKDIV1_TIMCKDIV, CLKDIV1_TIMCK_DIV(1));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for 200 clock cycles between clkDiv or clkSel change:                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_Delay_Cycles(200);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Sellecting 25MHz clock source                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(CLKSEL, CLKSEL_TIMCKSEL, CLKSEL_TIMCKSEL_CLKREF);
+
+    /* Wait 10usec for PLL:   */
+    CLK_Delay_MicroSec(10);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Returning the clock frequency                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return EXT_CLOCK_FREQUENCY_MHZ*_1MHz_;
+}
+#endif // defined (TIMER_MODULE_TYPE)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureEMCClock                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ethNum -  ethernet module number                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures EMC clocks                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ConfigureEMCClock(UINT32 ethNum)
+{
+    if (ethNum == 0)                          // ETH0 - EMC1
+    {
+       SET_REG_FIELD(CLKEN1, CLKEN1_EMC1, 1);
+    }
+    else if (ethNum == 1)                     // ETH1 - EMC2
+    {
+       SET_REG_FIELD(CLKEN1, CLKEN1_EMC2, 1);
+    }
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureGMACClock                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ethNum -  ethernet module number                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures GMAC clocks                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ConfigureGMACClock(UINT32 ethNum)
+{
+    if (ethNum == 2)                          // ETH2 - GMAC1
+    {
+        SET_REG_FIELD(CLKEN2, CLKEN2_GMAC1, 1);
+    }
+    else if (ethNum == 3)                     // ETH3 - GMAC2
+    {
+        SET_REG_FIELD(CLKEN2, CLKEN2_GMAC2, 1);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureSDClock                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum -  SD module number                                                              */
+/*                                                                                                         */
+/* Returns:         SD clock frequency                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the SD clock to frequency closest to 48MHz from beneath                     */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_ConfigureSDClock(UINT32 sdNum)
+{
+    UINT32  divider;
+    UINT32  pll0Freq;   //In Hz
+    UINT32  sdhci_clock;   //In Hz
+    UINT32  target_freq;   //In Hz
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (sdNum >= SD_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure Clock Enable Register                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (sdNum == SD1_DEV)
+    {
+        SET_REG_FIELD(CLKEN2, CLKEN2_SDHC, 1);
+    }
+    else if (sdNum == SD2_DEV)
+    {
+        SET_REG_FIELD(CLKEN2, CLKEN2_MMC, 1);
+    }
+
+    pll0Freq = CLK_GetPll0Freq();
+    CLOCK_DEBUG("clk_drv: %s pll0Freq =%d \n",__FUNCTION__, pll0Freq); 
+
+#ifndef _PALLADIUM_
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate rounded up divider to produce closest to Target output clock                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (GCR_Get_Chip_Version() == POLEG_VERSION_Z1)
+    {
+        target_freq = SD_CLK_TARGET_FREQ_Z1;
+    }
+    else
+    {
+        target_freq = SD_CLK_TARGET_FREQ_A1;
+    }
+    divider = (pll0Freq % target_freq == 0) ? (pll0Freq / target_freq) :          \
+                                              (pll0Freq / target_freq) + 1;
+#endif
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting clock divider                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (sdNum == SD1_DEV)  // SD Card
+    {
+#ifdef _PALLADIUM_
+        divider = 2;     /* Set maximum freq for Palladium (in reality around 600KHz) */
+#endif
+        SET_REG_FIELD(CLKDIV2, CLKDIV2_SD1CKDIV, (divider/2)-1);
+        CLOCK_DEBUG("clk_drv: %s CLKDIV2_SD1CKDIV =%d sdhci =%d\n",__FUNCTION__, READ_REG_FIELD(CLKDIV2, CLKDIV2_SD1CKDIV), sdNum); 
+    }
+    else if (sdNum == SD2_DEV)  // eMMC
+    {
+#ifdef _PALLADIUM_
+        divider = 1;     /* Set maximum freq for Palladium (in reality around 600KHz) */
+#endif
+        SET_REG_FIELD(CLKDIV1, CLKDIV1_MMCCKDIV, divider-1);
+        CLOCK_DEBUG("clk_drv: %s CLKDIV1_MMCCKDIV =%d sdhci =%d\n",__FUNCTION__, READ_REG_FIELD(CLKDIV1, CLKDIV1_MMCCKDIV),sdNum); 
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait to the divider to stabilize (according to spec)                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_Delay_Cycles(200);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SD clock uses always PLL0                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(CLKSEL, CLKSEL_SDCKSEL, CLKSEL_SDCKSEL_PLL0);
+
+    sdhci_clock = pll0Freq/divider;
+    CLOCK_DEBUG("clk_drv: %s sdhci_clock =%d sdhci =%d\n",__FUNCTION__, sdhci_clock, sdNum); 
+
+    return sdhci_clock;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetEth                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of EMC module                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetEMC(UINT32 deviceNum)
+{
+    if (deviceNum == 0)
+    {
+        SET_REG_FIELD(IPSRST1, IPSRST1_EMC1, 1);
+        SET_REG_FIELD(IPSRST1, IPSRST1_EMC1, 0);
+    }
+    else if (deviceNum == 1)
+    {
+        SET_REG_FIELD(IPSRST1, IPSRST1_EMC2, 1);
+        SET_REG_FIELD(IPSRST1, IPSRST1_EMC2, 0);
+    }
+}
+
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetFIU                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of FIU                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetFIU (void)
+{
+    SET_REG_FIELD(IPSRST1, IPSRST1_SPI0, 1);
+    SET_REG_FIELD(IPSRST1, IPSRST1_SPI0, 0);
+
+    SET_REG_FIELD(IPSRST1, IPSRST1_SPI3, 1);
+    SET_REG_FIELD(IPSRST1, IPSRST1_SPI3, 0);
+
+    SET_REG_FIELD(IPSRST3, IPSRST3_SPIX, 1);
+    SET_REG_FIELD(IPSRST3, IPSRST3_SPIX, 0);
+}
+#endif //#if defined (FIU_MODULE_TYPE)
+
+#if defined (UART_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetUART                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of UART                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetUART(UINT32 deviceNum)
+{
+    SET_REG_FIELD(IPSRST1, IPSRST1_UART01, 1);
+    SET_REG_FIELD(IPSRST1, IPSRST1_UART01, 0);
+
+    SET_REG_FIELD(IPSRST1, IPSRST1_UART23, 1);
+    SET_REG_FIELD(IPSRST1, IPSRST1_UART23, 0);
+}
+#endif // #if defined (UART_MODULE_TYPE)
+
+
+#if defined (AES_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetAES                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of AES                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetAES (void)
+{
+    SET_REG_FIELD(IPSRST1, IPSRST1_AES, 1);
+    SET_REG_FIELD(IPSRST1, IPSRST1_AES, 0);
+}
+#endif //if defined (AES_MODULE_TYPE)
+
+
+#if defined (MC_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetMC                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of MC                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetMC (void)
+{
+    SET_REG_FIELD(IPSRST1, IPSRST1_MC, 1);
+    CLK_Delay_MicroSec(100);
+    SET_REG_FIELD(IPSRST1, IPSRST1_MC, 0);
+    CLK_Delay_MicroSec(100);
+
+    
+    /* Force re-training of DDR (because DDR module is reinitialized*/
+    SET_REG_FIELD(INTCR2, INTCR2_MC_INIT, 0);
+}
+#endif // #if defined (MC_MODULE_TYPE)
+
+
+#if defined (TIMER_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetTIMER                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of Timer                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetTIMER (UINT32 deviceNum)
+{
+    if (deviceNum <= 4)
+    {
+        SET_REG_FIELD(IPSRST1, IPSRST1_TIM0_4, 1);
+        SET_REG_FIELD(IPSRST1, IPSRST1_TIM0_4, 0);
+    }
+    else if (deviceNum <= 9)
+    {
+        SET_REG_FIELD(IPSRST1, IPSRST1_TIM5_9, 1);
+        SET_REG_FIELD(IPSRST1, IPSRST1_TIM5_9, 0);
+    }
+    else
+    {
+        SET_REG_FIELD(IPSRST3, IPSRST3_TIMER10_14, 1);
+        SET_REG_FIELD(IPSRST3, IPSRST3_TIMER10_14, 0);
+    }
+
+}
+#endif // #if defined (TIMER_MODULE_TYPE)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetSD                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum -  SD module number                                                              */
+/*                                                                                                         */
+/* Returns:         BMC HAL Error code                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of SD                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ResetSD(UINT32 sdNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (sdNum >= SD_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (sdNum == SD1_DEV)
+    {
+        SET_REG_FIELD(IPSRST2, IPSRST2_SDHC, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_SDHC, 0);
+    }
+    else if (sdNum == SD2_DEV)
+    {
+        SET_REG_FIELD(IPSRST2, IPSRST2_MMC, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_MMC, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetGMAC                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of GMAC                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetGMAC(UINT32 deviceNum)
+{
+    if (deviceNum == 2)
+	{
+        SET_REG_FIELD(IPSRST2, IPSRST2_GMAC1, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_GMAC1, 0);
+	}
+	else if (deviceNum == 3)
+	{
+        SET_REG_FIELD(IPSRST2, IPSRST2_GMAC2, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_GMAC2, 0);
+	}
+
+}
+
+#if defined (PSPI_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetPSPI                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of PSPI                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ResetPSPI(UINT32 deviceNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (deviceNum >= PSPI_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (deviceNum == PSPI1_DEV)
+    {
+        SET_REG_FIELD(IPSRST2, IPSRST2_PSPI1, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_PSPI1, 0);
+    }
+    else if (deviceNum == PSPI2_DEV)
+    {
+        SET_REG_FIELD(IPSRST2, IPSRST2_PSPI2, 1);
+        SET_REG_FIELD(IPSRST2, IPSRST2_PSPI2, 0);
+    }
+
+    return HAL_OK;
+}
+#endif // #if defined (PSPI_MODULE_TYPE)
+
+//Calculates the PLL frequency in Hz given PLL register value
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_CalculatePLLFrequency                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  pllVal    -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the PLL frequency in Hz                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  CLK_CalculatePLLFrequency (UINT32 pllVal)
+{
+    UINT32  FIN         = EXT_CLOCK_FREQUENCY_KHZ; // 25MHz in KHz units
+    UINT32  FOUT        = 0;
+    UINT32  NR          = 0;
+    UINT32  NF          = 0;
+    UINT32  NO          = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Extract PLL fields:                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    NR = READ_VAR_FIELD(pllVal, PLLCONn_INDV);   /* PLL Input Clock Divider */
+    NF = READ_VAR_FIELD(pllVal, PLLCONn_FBDV);   /* PLL VCO Output Clock Feedback Divider). */
+    NO = (READ_VAR_FIELD(pllVal, PLLCONn_OTDV1)) * (READ_VAR_FIELD(pllVal, PLLCONn_OTDV2));   /* PLL Output Clock Divider 1 */
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate PLL frequency in Hz:                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FOUT = ((10*FIN*NF)/(NO*NR));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Notice: for better accurecy we multiply the "MONE" in 10, and later in 100 to get to Hz units.      */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Returning value in Hertz:                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return  FOUT*100 ;
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetPll0Freq                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns the frequency of PLL0 in Hz                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  CLK_GetPll0Freq (void)
+{
+    UINT32  pllVal      = 0;
+
+    pllVal = REG_READ(PLLCON0);
+    return CLK_CalculatePLLFrequency(pllVal);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetPll1Freq                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns the frequency of PLL1 in Hz                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  CLK_GetPll1Freq(void)
+{
+    UINT32  pllVal      = 0;
+
+    pllVal = REG_READ(PLLCON1);
+    if (GCR_Get_Chip_Version() == POLEG_VERSION_Z1)
+    {
+        return CLK_CalculatePLLFrequency(pllVal);
+    }
+    else
+    {
+        return (CLK_CalculatePLLFrequency(pllVal)/2);
+    }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetPll2Freq                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns the frequency of PLL2 in Hz                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  CLK_GetPll2Freq(void)
+{
+    UINT32  pllVal      = 0;
+
+    pllVal = REG_READ(PLLCON2);
+    return (CLK_CalculatePLLFrequency(pllVal)/2);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetMemoryFreq                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates Memory frequency in Hz                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetMemoryFreq (void)
+{
+    UINT32  FOUT        = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate CPU clock:                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_REG_FIELD(CLKSEL, CLKSEL_MCCKSEL) == CLKSEL_MCCKSEL_PLL1)
+    {
+        FOUT = CLK_GetPll1Freq();
+    }
+    else if (READ_REG_FIELD(CLKSEL, CLKSEL_MCCKSEL) == CLKSEL_MCCKSEL_CLKREF)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Reference clock 25MHz:                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        FOUT = EXT_CLOCK_FREQUENCY_MHZ; //FOUT is specified in MHz
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* External clock, assume low freq ref clock (25MHz):                                              */
+        /*-------------------------------------------------------------------------------------------------*/
+        FOUT = EXT_CLOCK_FREQUENCY_MHZ; //FOUT is specified in MHz
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Returing value in Hertz                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return FOUT;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetCPUFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates CPU frequency in Hz                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetCPUFreq (void)
+{
+    UINT32  FOUT        = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculate CPU clock:                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_REG_FIELD(CLKSEL, CLKSEL_CPUCKSEL) == CLKSEL_CPUCKSEL_PLL0)
+    {
+        FOUT = CLK_GetPll0Freq();
+    }
+    else if (READ_REG_FIELD(CLKSEL, CLKSEL_CPUCKSEL) == CLKSEL_CPUCKSEL_PLL1)
+    {
+        FOUT = CLK_GetPll1Freq();
+    }
+    else if (READ_REG_FIELD(CLKSEL, CLKSEL_CPUCKSEL) == CLKSEL_CPUCKSEL_CLKREF)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Reference clock 25MHz:                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        FOUT = EXT_CLOCK_FREQUENCY_MHZ; //FOUT is specified in MHz
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* External clock, assume low freq ref clock (25MHz):                                              */
+        /*-------------------------------------------------------------------------------------------------*/
+        FOUT = EXT_CLOCK_FREQUENCY_MHZ; //FOUT is specified in MHz
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Returing value in Hertz                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return FOUT;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetSPIFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      apb number,1 to 5                                                                      */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns SPI frequency  in Hz                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetSPIFreq (UINT32 spi)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Avalilable APBs between 1 to 5                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+     if (spi == 0)
+     {
+         return  CLK_GetCPUFreq()  / CLK_GetPLL0toAPBdivisor(SPI0);  // UINT32  CLK_GetPLL0toAPBdivisor (APB_CLK apb)
+     }     
+     if (spi == 3)
+     {
+         return  CLK_GetCPUFreq()  / CLK_GetPLL0toAPBdivisor(SPI3);  // UINT32  CLK_GetPLL0toAPBdivisor (APB_CLK apb)
+     }
+     else
+        return HAL_ERROR_BAD_PARAM;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetAPBFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      apb number,1 to 5                                                                      */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns APB frequency  in Hz                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetAPBFreq (UINT32 apb)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Avalilable APBs between 1 to 5                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+     if ((apb > APB5) && (apb < APB1))
+        return HAL_ERROR_BAD_PARAM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* In Yarkon APB frequency is CPU frequency divided by AHB0 Clock dividor, AHB1 Clock dividor and APB  */
+    /* Clock divider                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    return  CLK_GetCPUFreq()  / CLK_GetPLL0toAPBdivisor(apb);  // UINT32  CLK_GetPLL0toAPBdivisor (APB_CLK apb)
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetCPFreq                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns CP frequency in Hz                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetCPFreq (void)
+{
+    UINT32  clk2Div = 0;
+
+    UINT32  clk4Div = 0;
+
+    clk2Div = (READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV) + 1);
+
+    clk4Div = (READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV) + 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* In Poleg APB frequency is CPU frequency divided by AHB0 Clock dividor, AHB1 Clock dividor and APB   */
+    /* Clock divider                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return  (CLK_GetCPUFreq()  / (clk2Div * clk4Div)) ; 
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_SetCPFreq                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets CP frequency in Hz                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_SetCPFreq (UINT32  cpFreq)
+{
+    UINT32  clkDiv = CLK_GetCPUFreq() / cpFreq;
+
+    switch (clkDiv)
+    {
+        case 1:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV1);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV1);
+            break;
+        case 2:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV2);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV1);
+            break;
+        case 3:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV3);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV1);
+            break;
+        case 4:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV2);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV2);
+            break;
+        case 6:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV3);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV2);
+            break;
+        case 8:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV, CLKDIV1_CLK4DIV4);
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV, CLKDIV1_CLK2DIV2);
+            break;
+        default:
+		{
+            return HAL_ERROR;
+		}
+    }
+
+    CLK_Delay_MicroSec(20);
+
+    return  HAL_OK;
+
+    
+}
+
+
+
+
+#if defined (SD_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetSDClock                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum -  SD module number                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns the SD base clock frequency in Hz                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetSDClock (UINT32 sdNum)
+{
+    UINT32  divider;
+    UINT32  pll0Freq;   //In Hz
+
+    pll0Freq = CLK_GetPll0Freq();
+    if ((SD_DEV_NUM_T)sdNum == SD1_DEV)
+    {
+        divider = 1 + READ_REG_FIELD(CLKDIV2, CLKDIV2_SD1CKDIV);
+    }
+    else if (sdNum == SD2_DEV)
+    {
+        divider = 1 + READ_REG_FIELD(CLKDIV1, CLKDIV1_MMCCKDIV);
+    }
+    else
+    {
+	    return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    return (pll0Freq/divider);
+}
+#endif  //#if defined (SD_MODULE_TYPE)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigurePCIClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs configuration of PCI clock depending on                          */
+/*                  presence of VGA BIOS as specified by STRAP13                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ConfigurePCIClock(void)
+{
+    UINT32 PLLCON1_l = 0;
+
+    // Need to pgm the PCI clock to 96 MHz.
+
+    // Done in following steps:
+    // 1.  Delay 2us
+    // 2.  Change CLKSEL1.GFXCKSEL ( bits 17-16)  from 1h to 3h (select PLL2)
+    // 3.  Delay 2 us
+    // 4.  Change CLKDIV1.PCICKDIV (bits 5-2) from 02h to 04h (divide by 5)
+    // 5.  Delay 2us
+
+    PLLCON1_l  = CLK_333MHZ_PLLCON1_REG_CFG;
+
+    SET_VAR_FIELD(PLLCON1_l, PLLCONn_PWDEN, PLLCONn_PWDEN_NORMAL);
+
+    REG_WRITE(PLLCON1, PLLCON1_l);
+
+
+    CLK_Delay_MicroSec(2);
+
+    SET_REG_FIELD(CLKSEL, CLKSEL_GFXCKSEL,  CLKSEL_GFXCKSEL_PLL2); // changed to workaroung PCI issue
+
+    CLK_Delay_MicroSec(2);
+
+    SET_REG_FIELD(CLKDIV1, CLKDIV1_PCICKDIV,  CLKDIV1_PCICK_DIV(5));  /* PCI clock div = 5  */
+
+    CLK_Delay_MicroSec(2);
+
+
+//    1.  PLL1 change to 33MHz -> PLLCON1 = A02403
+//    2.  PCI Clock = 96 MHz ->  CLKSEL.GFXCKSEL selects PLL2/2
+//                                              CLKDIV1.PCICKDIV = 4   (480/5 = 96)
+//
+//
+//    3.  DRAM reference (in MR6: bits 5-0 = 0Ah)
+//    4.  Poleg VREF = 0Ah   F05F01c8h bits 9-4
+//    5.  Reftersh period. MC CTL_51 value should be divide by 2
+}
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureFIUClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      UINT8  fiu, UINT8 clkDiv                                                                                */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine config the FIU clock (according to the header )                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ConfigureFIUClock(UINT8  fiu, UINT8 clkDiv)
+{
+
+     /*----------------------------------------------------------------------------------------------------*/
+     /* Defines the clock divide ratio from AHB to FIU0 clock.                                             */
+     /*----------------------------------------------------------------------------------------------------*/
+     UINT32  ratio = 0;
+
+     /*----------------------------------------------------------------------------------------------------*/
+     /* Ignored if FIU_Clk_Divider is either 0 or 0FFh.                                                    */
+     /*----------------------------------------------------------------------------------------------------*/
+     if ((clkDiv == 0) || (clkDiv == 0xFF))
+        return HAL_ERROR_BAD_PARAM;
+
+     /* set SPIn clk div */
+     switch (fiu)
+     {
+        case FIU_MODULE_0:
+            SET_REG_FIELD(CLKDIV3, CLKDIV3_SPI0CKDV,  (CLKDIV3_SPI0CKDV_DIV(clkDiv) & 0x1F));
+            break;
+        case  FIU_MODULE_3:
+            SET_REG_FIELD(CLKDIV1, CLKDIV1_AHB3CKDIV, (CLKDIV1_AHB3CK_DIV(clkDiv)   & 0x1F));
+            break;
+        case  FIU_MODULE_X:
+            SET_REG_FIELD(CLKDIV3, CLKDIV3_SPIXCKDV,  (CLKDIV3_SPIXCKDV_DIV(clkDiv) & 0x1F));
+            break;
+        default:
+            return HAL_ERROR_BAD_DEVNUM;
+
+
+     }
+
+     /*----------------------------------------------------------------------------------------------------*/
+     /* After changing this field, ensure a delay of 25 SPI0 clock cycles before changing CPUCKSEL field in*/
+     /* CLKSEL register or accessing the AHB18 bus.                                                        */
+     /*----------------------------------------------------------------------------------------------------*/
+     ratio = READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK2DIV) * READ_REG_FIELD(CLKDIV1, CLKDIV1_CLK4DIV) * clkDiv;
+
+     /* delay is according to ratio. Take some buffer too */
+     CLK_Delay_Cycles(50 * ratio);
+
+     return HAL_OK;
+}
+#endif //  defined (FIU_MODULE_TYPE)
+
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetFIUClockDiv                                                                     */
+/*                                                                                                         */
+/* Parameters:      UINT8  fiu                                                                                   */
+/* Returns:         CLKDIV                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine config the FIU clock (according to the header )                           */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT8 CLK_GetFIUClockDiv(UINT8  fiu)
+{
+
+     /*----------------------------------------------------------------------------------------------------*/
+     /* Defines the clock divide ratio from AHB to FIU0 clock.1                                            */
+     /*----------------------------------------------------------------------------------------------------*/
+     switch (fiu)
+     {
+        case FIU_MODULE_0:
+            return READ_REG_FIELD(CLKDIV3, CLKDIV3_SPI0CKDV) + 1;
+        case  FIU_MODULE_3:
+            return READ_REG_FIELD(CLKDIV1, CLKDIV1_AHB3CKDIV) + 1;
+        case  FIU_MODULE_X:
+            return READ_REG_FIELD(CLKDIV3, CLKDIV3_SPIXCKDV) + 1;
+        default:
+            return 0xFF;
+     }
+
+
+}
+#endif// defined (FIU_MODULE_TYPE)
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.h b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.h
new file mode 100755
index 0000000..d669b51
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_drv.h
@@ -0,0 +1,19 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   clk_drv.h                                                                                             */
+/*            This file contains CLK (clock, plls)  module interface                                       */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef CLK_DRV_H
+#define CLK_DRV_H
+
+#include "../clk_if.h"
+
+#endif
diff --git a/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_regs.h b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_regs.h
new file mode 100755
index 0000000..d43a9e0
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/clk/Poleg_IP/clk_regs.h
@@ -0,0 +1,770 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   clk_regs.h                                                                                            */
+/*            This file contains definitions of CLK registers                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef CLK_REGS_H
+#define CLK_REGS_H
+
+#include "../../../Chips/chip.h"
+
+#define  POLEG_CHRID                     0xA92750
+#define  POLEG_VERSION_Z1                0x00
+#define  POLEG_VERSION_Z2                0x04
+#define  POLEG_VERSION_A1                0x10
+
+
+enum
+{
+    APB1  = 1,
+    APB2  = 2,
+    APB3  = 3,
+    APB4  = 4,
+    APB5  = 5,
+    SPI0  = 10,
+    SPI3  = 13,
+};
+
+enum
+{
+    PLL0    = 0,
+    PLL1    = 1,
+    PLL2    = 2,
+    PLL_GFX = 3,
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Registers definitions                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifdef _PALLADIUM_
+#define  PALLADIUM_PLL0                 (PALLADIUM_PLL0_BASE_ADDR) , PALLADIUM_PLL0_ACCESS, 32
+#endif
+
+/**************************************************************************************************************************/
+/*   Clock Enable 1 Register (CLKEN1) (Changed in )                                                                       */
+/**************************************************************************************************************************/
+#define  CLKEN1                         (CLK_BASE_ADDR + 0x00) , CLK_ACCESS, 32
+#define  CLKEN1_SMB1                     31 , 1              /* 31 SMB1 (SMBus Interface 1 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB0                     30 , 1              /* 30 SMB0 (SMBus Interface 0 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB7                     29 , 1              /* 29 SMB7 (SMBus Interface 7 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB6                     28 , 1              /* 28 SMB6 (SMBus Interface 6 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_ADC                      27 , 1              /* 27 ADC (ADC Clock Enable Bit). Eng. note: uses APB1 clock and ADC clock (24 MHz).                                     */
+#define  CLKEN1_WDT                      26 , 1              /* 26 WDT (All Watchdog Timers Clock Enable Bit). Eng. note: uses APB1 clock and Timer clock (24 MHz).                   */
+#define  CLKEN1_USBDEV3                  25 , 1              /* 25 USBDEV3 (USB Device 3 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN1_USBDEV6                  24 , 1              /* 24 USBDEV6 (USB Device 6 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN1_USBDEV5                  23 , 1              /* 23 USBDEV5 (USB Device 5 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN1_USBDEV4                  22 , 1              /* 22 USBDEV4 (USB Device 4 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN1_EMC2                     21 , 1              /* 21 EMC2 (EMC2 Clock Enable Bit). Eng. note: uses AHB8 clock and RMII2 clock.                                          */
+#define  CLKEN1_TIMER5_9                 20 , 1              /* 20 TIMER5-9 (Timer 5 to Timer 9 and Watchdog 1 (Timer Module 1) Clock Enable Bit). Eng. note: uses APB1               */
+#define  CLKEN1_TIMER0_4                 19 , 1              /* 19 TIMER0-4 (Timer 0 to Timer 4 and Watchdog 0 (Timer Module 0) Clock Enable Bit). Eng. note: uses APB1               */
+#define  CLKEN1_PWM0                     18 , 1              /* 18 PWM0 (PWM0 module Clock Enable Bit). Eng. note: uses APB3 clock.                                                   */
+#define  CLKEN1_HUART                    17 , 1              /* 17 HUART (HUART Clock Enable Bit). Eng. note: uses UART clock (24/48MHz).                                             */
+#define  CLKEN1_SMB5                     16 , 1              /* 16 SMB5 (SMBus Interface 5 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB4                     15 , 1              /* 15 SMB4 (SMBus Interface 4 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB3                     14 , 1              /* 14 SMB3 (SMBus Interface 3 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_SMB2                     13 , 1              /* 13 SMB2 (SMBus Interface 2 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN1_MC                       12 , 1              /* 12 MC (DDR4 Memory Controller Clock Enable Bit). Eng. note: uses MC-PHY clock and MC clock.                           */
+#define  CLKEN1_UART01                   11 , 1              /* 11 UART01 (UART0 and UART1 Clock Enable Bit). Eng. note: uses UART clock (24/48 MHz).                                 */
+#define  CLKEN1_AES                      10 , 1              /* 10 AES (AES Clock Enable Bit). Eng. note: uses AHB8 clock.                                                            */
+#define  CLKEN1_PECI                     9 , 1               /* 9 PECI (PECI Clock Enable Bit). Eng. note: uses APB3 clock.                                                           */
+#define  CLKEN1_USBDEV2                  8 , 1               /* 8 USBDEV2 (USB Device 2 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                     */
+#define  CLKEN1_UART23                   7 , 1               /* 7 UART23 (UART2 and UART3 Clock Enable Bit). Eng. note: uses UART clock (24/48 MHz).                                  */
+#define  CLKEN1_EMC1                     6 , 1               /* 6 EMC1 (EMC1 Clock Enable Bit). Eng. note: uses AHB8 clock and RMII1 clock.                                           */
+#define  CLKEN1_USBDEV1                  5 , 1               /* 5 USBDEV1 (USB Device 1 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                     */
+#define  CLKEN1_SHM                      4 , 1               /* 4 SHM (SHM Clock Enable Bit). Eng. note: uses AHB3 clock.                                                             */
+#define  CLKEN1_GDMA0                    3 , 1               /* 3 GDMA0 (GDMA0 Clock Enable Bit). Eng. note: uses AHB8 clock and AHB17 clock.                                         */
+#define  CLKEN1_KCS                      2 , 1               /* 2 KCS (KCS Clock Enable Bit). Eng. note: uses APB1 clock.                                                             */
+#define  CLKEN1_SPI3                     1 , 1               /* 1 SPI3 (FIU3 Clock Enable Bit). Eng. note: uses AHB3 clock and SPI3 divided clock.                                    */
+#define  CLKEN1_SPI0                     0 , 1               /* 0 SPI0 (FIU0 Clock Enable Bit). Eng. note: uses AHB18 clock and SPI0 divided clock.                                   */
+
+/**************************************************************************************************************************/
+/*   Clock Enable 2 Register (CLKEN2) (Changed in )                                                                       */
+/**************************************************************************************************************************/
+#define  CLKEN2                         (CLK_BASE_ADDR + 0x28) , CLK_ACCESS, 32
+#define  CLKEN2_CP                       31 , 1              /* 31 CP (Coprocessor Clock Enable Bit). Eng. note: uses AHB9 clock.                                                     */
+#define  CLKEN2_TOCK                     30 , 1              /* 30 TOCK (TOCK Clock Enable Bit). Eng. note: uses its own divider.                                                     */
+#define  CLKEN2_GMAC1                    28 , 1              /* 28 GMAC1 (Gigabit MAC 1 Module Clock Enable Bit). Eng. note: uses AHB8 clock, AHB12 and RGMII1 clocks.                */
+#define  CLKEN2_USBIF                    27 , 1              /* 27 USBIF (HUB, UTMI and OHCI Clock Enable Bit). When this bit is low, USB devices 0-9 and USB Host clocks             */
+#define  CLKEN2_USBHOST                  26 , 1              /* 26 USBHOST (USB Host Clock Enable Bit). Eng. note: uses AHB8 clock, AHB7 clock and UTMI clock.                        */
+#define  CLKEN2_GMAC2                    25 , 1              /* 25 GMAC2 (Gigabit MAC 2 Module Clock Enable Bit). Eng. note: uses AHB8 clock, AHB13 and RGMII2 clocks.                */
+#define  CLKEN2_PSPI2                    23 , 1              /* 23 PSPI2 (Peripheral SPI 2 Clock Enable Bit). Eng. note: uses APB5 clock.                                             */
+#define  CLKEN2_PSPI1                    22 , 1              /* 22 PSPI1 (Peripheral SPI 1 Clock Enable Bit). Eng. note: uses APB5 clock.                                             */
+#define  CLKEN2_SIOX2                    19 , 1              /* 19 SIOX2 (Serial GPIO Expander 2 Clock Enable Bit). Eng. note: uses APB3 clock                                        */
+#define  CLKEN2_SIOX1                    18 , 1              /* 18 SIOX1 (Serial GPIO Expander 1 Clock Enable Bit). Eng. note: uses APB3 clock                                        */
+#define  CLKEN2_FUSE                     16 , 1              /* 16 FUSE (Fuse Module Clock Enable Bit). Eng. note: uses APB4 clock                                                    */
+#define  CLKEN2_VCD                      14 , 1              /* 14 VCD (Video Capture and Differentiate Module Clock Enable Bit). Eng. note: uses AHB8, AHB4 and AHB5                 */
+#define  CLKEN2_ECE                      13 , 1              /* 13 ECE (Encoding Compression Module Clock Enable Bit). Eng. note: uses AHB8 and AHB6 clocks.                          */
+#define  CLKEN2_VDMA                     12 , 1              /* 12 VDMA (VDM DMA Clock Enable Bit). Eng. note: uses AHB8 and AHB17 clocks.                                            */
+#define  CLKEN2_AHBPCIBRG                11 , 1              /* 11 AHBPCIBRG (AHB-to-PCI Bridge Clock Enable Bit).                                                                    */
+#define  CLKEN2_GFXSYS                   10 , 1              /* 10 GFXSYS (Graphics System Clock Enable Bit).                                                                         */
+#define  CLKEN2_SDHC                     9 , 1               /* 9 SDHC (SD Host Controller Clock Enable Bit). Eng. note: uses AHB8 and AHB7 clocks and interface clock.               */
+#define  CLKEN2_MMC                      8 , 1               /* 8 MMC (Multimedia Card Host Controller Clock Enable Bit). Eng. note: uses AHB8 and AHB2 clocks and                    */
+#define  CLKEN2_MFT7_0                   0 , 8              /* 7-0 MFT7-0 (Tachometer Module 7-0 Clock Enable Bits). Eng. note: uses APB4 clock                                      */
+
+/**************************************************************************************************************************/
+/*   Clock Enable 3 Register (CLKEN3) (New in )                                                                           */
+/**************************************************************************************************************************/
+#define  CLKEN3                         (CLK_BASE_ADDR + 0x30) , CLK_ACCESS, 32
+#define  CLKEN3_GPIOM7                   31 , 1              /* 31 GPIOM7 (GPIO Module 7 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM6                   30 , 1              /* 30 GPIOM6 (GPIO Module 6 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM5                   29 , 1              /* 29 GPIOM5 (GPIO Module 5 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM4                   28 , 1              /* 28 GPIOM4 (GPIO Module 4 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM3                   27 , 1              /* 27 GPIOM3 (GPIO Module 3 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM2                   26 , 1              /* 26 GPIOM2 (GPIO Module 2 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM1                   25 , 1              /* 25 GPIOM1 (GPIO Module 1 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_GPIOM0                   24 , 1              /* 24 GPIOM0 (GPIO Module 0 Clock Enable Bit). Eng. note: uses APB1 clock                                                */
+#define  CLKEN3_ESPI                     23 , 1              /* 23 ESPI (ESPI Module Clock Enable Bit). Eng. note: uses APB2 clock                                                    */
+#define  CLKEN3_SMB11                    22 , 1              /* 22 SMB11 (SMBus Interface 11 Clock Enable Bit). Eng. note: uses APB2 clock.                                           */
+#define  CLKEN3_SMB10                    21 , 1              /* 21 SMB10 (SMBus Interface 10 Clock Enable Bit). Eng. note: uses APB2 clock.                                           */
+#define  CLKEN3_SMB9                     20 , 1              /* 20 SMB9 (SMBus Interface 9 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN3_SMB8                     19 , 1              /* 19 SMB8 (SMBus Interface 8 Clock Enable Bit). Eng. note: uses APB2 clock.                                             */
+#define  CLKEN3_SMB15                    18 , 1              /* 18 SMB15 (SMBus Interface 15 Clock Enable Bit). Eng. note: uses APB2 clock.                                           */
+#define  CLKEN3_RNG                      17 , 1              /* 17 RNG (Random Number Generator Clock Enable Bit). Eng. note: uses APB1 clock.                                        */
+#define  CLKEN3_TIMER10_14               16 , 1              /* 16 TIMER10-14 (Timer 10 to Timer 14 and Watchdog 2 (Timer module 2) Clock Enable Bit). Eng. note: uses                */
+#define  CLKEN3_PCIERC                   15 , 1              /* 15 PCIERC (PCI Express Root Complex Clock Enable Bit). Eng. note: uses AHB14 clock, PIPE clock and MC                 */
+#define  CLKEN3_SECECC                   14 , 1              /* 14 SECECC. (RAS, ECC and MODP accelerator Clock Enable Bit). Eng. note: use AHB8 clock.                               */
+#define  CLKEN3_SHA                      13 , 1              /* 13 SHA. (SHA-1 and SHA-256 Module Clock Enable Bit). Eng. note: use AHB8 clock.                                       */
+#define  CLKEN3_SMB14                    12 , 1              /* 12 SMB14 (SMBus Interface 14 Clock Enable Bit). Eng. note: uses APB2 clock.                                           */
+#define  CLKEN3_GDMA2                    11 , 1              /* 11 GDMA2. (General Purpose DMA 2 Clock Enable bit). Eng. note: uses AHB8 clock and AHB17 clock.                       */
+#define  CLKEN3_GDMA1                    10 , 1              /* 10 GDMA1. (General Purpose DMA 1 Clock Enable Bit). Eng. note: uses AHB8 clock and AHB17 clock.                       */
+#define  CLKEN3_PCIMBX                   9 , 1               /* 9 PCIMBX. (PCI Mailbox Clock Enable Bit). Eng. note: use AHB8 clock and PCI clock.                                    */
+#define  CLKEN3_USBDEV9                  7 , 1               /* 7 USBDEV9. (USB Device 9 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN3_USBDEV8                  6 , 1               /* 6 USBDEV8. (USB Device 8 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN3_USBDEV7                  5 , 1               /* 5 USBDEV7. (USB Device 7 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN3_USBDEV0                  4 , 1               /* 4 USBDEV0. (USB Device 0 Clock Enable Bit). Eng. note: uses AHB8 clock, AHB2 clock and UTMI clock.                    */
+#define  CLKEN3_SMB13                    3 , 1               /* 3 SMB13 (SMBus Interface 13 Clock Enable Bit). Eng. note: uses APB2 clock.                                            */
+#define  CLKEN3_SPIX                     2 , 1               /* 2 SPIX (SPIX Clock Enable Bit). Eng. note: uses AHB18 clock and SPIX divided clock.                                   */
+#define  CLKEN3_SMB12                    1 , 1               /* 1 SMB12 (SMBus Interface 12 Clock Enable Bit). Eng. note: uses APB2 clock.                                            */
+#define  CLKEN3_PWM1                     0 , 1               /* 0 PWM1. (PWM1 Module Clock Enable Bit). Eng. note: uses APB3 clock.                                                   */
+
+/**************************************************************************************************************************/
+/*   Clock Select Register (CLKSEL) (Changed in Poleg)                                                                    */
+/**************************************************************************************************************************/
+#define  CLKSEL                         (CLK_BASE_ADDR + 0x04) , CLK_ACCESS, 32
+#define  CLKSEL_DVCSSEL                  23 , 2             /* 24-23 DVCSSEL (DVC System Clock Source Select Bit). Typically, a divided PLL2 (by 4): 240 MHz.                        */
+#define  CLKSEL_GFXMSEL                  21 , 2             /* 22-21 GFXMSEL (Graphics Memory Clock Source Select Bit). Typically, a divided PLL2 (by 3): 320 MHz.                   */
+#define  CLKSEL_CLKOUTSEL                18 , 3             /* 20-18 CLKOUTSEL (CLKOUT signal Clock Source Select Bit).                                                              */
+#define  CLKSEL_GFXCKSEL                 16 , 2             /* 17-16 GFXCKSEL (Graphics System Clock Source Select Bit). Typically, the same source of the CPU clock.                */
+#define  CLKSEL_TIMCKSEL                 14 , 2             /* 15-14 TIMCKSEL (Timer Clock Source Select Bit).                                                                       */
+#define  CLKSEL_MCCKSEL                  12 , 2             /* 13-12 MCCKSEL (Memory Controller Clock Source Select Bit).                                                            */
+#define  CLKSEL_SUCKSEL                  10 , 2             /* 11-10 SUCKSEL (USB Serial Clock Source Select Bit). For UTMI2UTMI and OHCI logic. Should select a clock of            */
+#define  CLKSEL_UARTCKSEL                8 , 2              /* 9-8 UARTCKSEL (Core and Host UART Clock Source Select Bit).                                                           */
+#define  CLKSEL_SDCKSEL                  6 , 2              /* 7-6 SDCKSEL (SDHC Clock Source Select Bit).                                                                           */
+#define  CLKSEL_PIXCKSEL                 4 , 2              /* 5-4 PIXCKSEL (Pixel Clock Source Select Bit).                                                                         */
+#define  CLKSEL_GPRFSEL                  2 , 2              /* 3-2 GPRFSEL (Graphics PLL Reference Clock Source Select Bit).                                                         */
+#define  CLKSEL_CPUCKSEL                 0 , 2              /* 1-0 CPUCKSEL (CPU/AMBA/MC Clock Source Select Bit).                                                                   */
+
+/**************************************************************************************************************************/
+/*   Clock Divider Control Register 1 (CLKDIV1) (Changed in )                                                             */
+/**************************************************************************************************************************/
+#define  CLKDIV1                        (CLK_BASE_ADDR + 0x08) , CLK_ACCESS, 32
+#define  CLKDIV1_ADCCKDIV                28 , 3             /* 30-28 ADCCKDIV (ADC CLK2ADC Clock Divider Control). Sets the division factor from the Timer clock (24 MHz). The       */
+#define  CLKDIV1_CLK4DIV                 26 , 2             /* 27-26 CLK4DIV (AMBA AHB Clock Divider Control).                                                                       */
+#define  CLKDIV1_TIMCKDIV                21 , 5             /* 25-21 TIMCKDIV (Timer Clock Source Divider Control). Default is divide by 1. The division factor is                   */
+#define  CLKDIV1_UARTDIV                 16 , 5             /* 20-16 UARTDIV (UART Clock Source Divider Control). This resulting clock must be 24 MHz for UARTs proper operation.    */
+#define  CLKDIV1_MMCCKDIV                11 , 5             /* 15-11 MMCCKDIV (MMC Controller (SDHC2) Clock Divider Control). Sets the division factor from the clock selected       */
+#define  CLKDIV1_AHB3CKDIV               6 , 5              /* 10-6 AHB3CKDIV (SPI3 Clock Divider Control). Sets the division factor from AHB clock (CLK4) to AHB3 and SPI3          */
+#define  CLKDIV1_PCICKDIV                2 , 4              /* 5-2 PCICKDIV (Internal PCI Clock Divider Control). Sets the division factor from the clock selected by the CLKSEL.    */
+#define  CLKDIV1_CLK2DIV                 0 , 1               /* 0 CLK2DIV (AMBA AXI Clock Divider Control).                                                                           */
+
+/**************************************************************************************************************************/
+/*   Clock Divider Control Register 2 (CLKDIV2) (Changed in )                                                             */
+/**************************************************************************************************************************/
+#define  CLKDIV2                        (CLK_BASE_ADDR + 0x2C) , CLK_ACCESS, 32
+#define  CLKDIV2_APB4CKDIV               30 , 2             /* 31-30 APB4CKDIV (AMBA APB4 Clock Divider Control). APB4 clock frequency is up to 67 MHz.                              */
+#define  CLKDIV2_APB3CKDIV               28 , 2             /* 29-28 APB3CKDIV (AMBA APB3 Clock Divider Control). APB3 clock frequency is up to 67 MHz.                              */
+#define  CLKDIV2_APB2CKDIV               26 , 2             /* 27-26 APB2CKDIV (AMBA APB2 Clock Divider Control). APB2 clock frequency is up to 67 MHz.                              */
+#define  CLKDIV2_APB1CKDIV               24 , 2             /* 25-24 APB1CKDIV (AMBA APB1 Clock Divider Control). APB clock must be at least 24 MHz, for UARTs to function.          */
+#define  CLKDIV2_APB5CKDIV               22 , 2             /* 23-22 APB5CKDIV (AMBA APB5 Clock Divider Control). APB5 clock must be high to enable PSPI1-2 high SPI clock           */
+#define  CLKDIV2_CLKOUTDIV               16 , 5             /* 20-16 CLKOUTDIV (CLKOUT Pin Divider Control). Sets the division factor from the clock selected by CLKOUTSEL to        */
+#define  CLKDIV2_GFXCKDIV                13 , 3             /* 15-13 GFXCKDIV (Graphics System Clock Divider Control). Sets the division factor from the clock selected by the       */
+#define  CLKDIV2_SUCKDIV                 8 , 5              /* 12-8 SUCKDIV (Serial USB UTMI Bridge Clock Divider Control). Sets the division factor from the clock selected by    */
+#define  CLKDIV2_SU48CKDIV               4 , 4              /* 7-4 SU48CKDIV (USB Host TBD OHCI Clock Divider Control). Sets the division factor from the clock selected by          */
+#define  CLKDIV2_SD1CKDIV                0 , 4              /* 3-0 SD1CKDIV (SDHC1 Clock Divider Control). Sets the division factor from the clock selected by SDCKSEL. The          */
+
+/**************************************************************************************************************************/
+/*   Clock Divider Control Register 3 (CLKDIV3) (Added in )                                                               */
+/**************************************************************************************************************************/
+#define  CLKDIV3                        (CLK_BASE_ADDR + 0x58) , CLK_ACCESS, 32
+#define  CLKDIV3_SPI0CKDV                6 , 5              /* 10-6 SPI0CKDV (SPI0 Clock Divider Control). Sets the division factor from AHB clock to SPI0 clock. The division factor*/
+#define  CLKDIV3_SPIXCKDV                1 , 5              /* 5-1 SPIXCKDV (SPIX Clock Divider Control). Sets the division factor from AHB clock to SPIX clock. The division factor */
+
+/**************************************************************************************************************************/
+/*   PLL Control Register 0 (PLLCON0) PLL Section Assumes Silicon Creation PLLGF40LPFRAC                                  */
+/**************************************************************************************************************************/
+#define  PLLCON0                        (CLK_BASE_ADDR + 0x0C) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   PLL Control Register 1 (PLLCON1)                                                                                     */
+/**************************************************************************************************************************/
+#define  PLLCON1                        (CLK_BASE_ADDR + 0x10) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   PLL Control Register 2 (PLLCON2) (New in Poleg)                                                                      */
+/**************************************************************************************************************************/
+#define  PLLCON2                        (CLK_BASE_ADDR + 0x54) , CLK_ACCESS, 32
+#define  PLLCONn_LOKI                    31 , 1              /* 31 LOKI (Lock Indication ).                                                                                           */
+#define  PLLCONn_LOKS                    30 , 1              /* 30 LOKS (Unlock Indication Sticky bit ).                                                                              */
+#define  PLLCONn_FBDV                    16 , 12            /* 27-16 FBDV (PLL VCO Output Clock Feedback Divider). The feedback divider divides the output clock from                */
+#define  PLLCONn_OTDV2                   13 , 3             /* 15-13 OTDV2 (PLL Output Clock Divider 2). The output divider divides the VCO clock output. The divide value           */
+#define  PLLCONn_PWDEN                   12 , 1              /* 12 PWDEN (Power-Down Mode Enable).                                                                                    */
+#define  PLLCONn_OTDV1                   8 , 3              /* 10-8 OTDV1 (PLL Output Clock Divider 1). The output divider divides the VCO clock output. The divide value            */
+#define  PLLCONn_INDV                    0 , 6              /* 5-0 INDV (PLL Input Clock Divider). The input divider divides the input reference clock into the PLL. The di-         */
+
+/**************************************************************************************************************************/
+/*   Software Reset Register (SWRSTR) (Changed in )                                                                       */
+/**************************************************************************************************************************/
+#define  SWRSTR                         (CLK_BASE_ADDR + 0x14) , CLK_ACCESS, 32
+#define  SWRSTR_SWRST4                   6 , 1               /* 6 SWRST4 (Software Reset Control Bit 4). Generates an internal reset pulse to the modules defined in                  */
+#define  SWRSTR_SWRST3                   5 , 1               /* 5 SWRST3 (Software Reset Control Bit 3). Generates an internal reset pulse to the modules defined in                  */
+#define  SWRSTR_SWRST2                   4 , 1               /* 4 SWRST2 (Software Reset Control Bit 2). Generates an internal reset pulse to the modules defined in                  */
+#define  SWRSTR_SWRST1                   3 , 1               /* 3 SWRST1 (Software Reset Control Bit 1). Generates an internal reset pulse to the modules defined in                  */
+
+/**************************************************************************************************************************/
+/*   IRQ Wake-Up Control Register (IRQWAKECON)                                                                            */
+/**************************************************************************************************************************/
+#define  IRQWAKECON                     (CLK_BASE_ADDR + 0x18) , CLK_ACCESS, 32
+#define  IRQWAKECON_IRQWAKEUPPOL         16 , 16            /* 31-16 IRQWAKEUPPOL (IRQ Wake-Up Polarity for GPIOE15-0).                                                              */
+#define  IRQWAKECON_IRQWAKEUPEN          0 , 16             /* 15-0 IRQWAKEUPEN (Wake-Up Enable for GPIOE15-0).                                                                      */
+
+/**************************************************************************************************************************/
+/*   IRQ Wake-Up Flag Register (IRQWAKEFLAG)                                                                              */
+/**************************************************************************************************************************/
+#define  IRQWAKEFLAG                    (CLK_BASE_ADDR + 0x1C) , CLK_ACCESS, 32
+#define  IRQWAKEFLAG_IRQWAKEFLAG         0 , 16             /* 15-0 IRQWAKEFLAG (Wake-Up Flag for GPIOE15-0).                                                                        */
+
+/**************************************************************************************************************************/
+/*   IP Software Reset Register 1 (IPSRST1) (Changed in )                                                          */
+/**************************************************************************************************************************/
+#define  IPSRST1                        (CLK_BASE_ADDR + 0x20) , CLK_ACCESS, 32
+#define  IPSRST1_SMB1                    31 , 1              /* 31 SMB1 (SMBus1 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB0                    30 , 1              /* 30 SMB0 (SMBus0 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB7                    29 , 1              /* 29 SMB7 (SMBus7 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB6                    28 , 1              /* 28 SMB6 (SMBuS6 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_ADC                     27 , 1              /* 27 ADC (ADC Software Reset Control Bit).                                                                              */
+#define  IPSRST1_USBDEV3                 25 , 1              /* 25 USBDEV3 (USB Device 3 Controller Software Reset Control Bit).                                                      */
+#define  IPSRST1_USBDEV6                 24 , 1              /* 24 USBDEV6 (USB Device 6 Controller Software Reset Control Bit).                                                      */
+#define  IPSRST1_USBDEV5                 23 , 1              /* 23 USBDEV5 (USB Device 5 Controller Software Reset Control Bit).                                                      */
+#define  IPSRST1_USBDEV4                 22 , 1              /* 22 USBDEV4 (USB Device 4 Controller Software Reset Control Bit).                                                      */
+#define  IPSRST1_EMC2                    21 , 1              /* 21 EMC2 (EMC2 Software Reset Control Bit).                                                                            */
+#define  IPSRST1_TIM5_9                  20 , 1              /* 20 TIM5-9 (Timer 5-9 and Watchdog 1 (Timer module 1) Software Reset Control Bit).                                     */
+#define  IPSRST1_TIM0_4                  19 , 1              /* 19 TIM0-4 (Timer 0-4 and Watchdog 0 (Timer module 0) Software Reset Control Bit).                                     */
+#define  IPSRST1_PWM                     18 , 1              /* 18 PWM (PWM Modules Software Reset Control Bit).                                                                      */
+#define  IPSRST1_SMB5                    16 , 1              /* 16 SMB5 (SMBus5 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB4                    15 , 1              /* 15 SMB4 (SMBus4 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB3                    14 , 1              /* 14 SMB3 (SMBus3 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_SMB2                    13 , 1              /* 13 SMB2 (SMBus2 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST1_MC                      12 , 1              /* 12 MC (DDR4 Memory Controller Software Reset Control Bit).                                                            */
+#define  IPSRST1_UART01                  11 , 1              /* 11 UART01 (UARTs 0 and 1 Software Reset Control Bit).                                                                 */
+#define  IPSRST1_AES                     10 , 1              /* 10 AES (AES Module Software Reset Control Bit).                                                                       */
+#define  IPSRST1_PECI                    9 , 1               /* 9 PECI (PECI Module Software Reset Control Bit).                                                                      */
+#define  IPSRST1_USBDEV2                 8 , 1               /* 8 USBDEV2 (USB Device 2 Controller Software Reset Control Bit).                                                       */
+#define  IPSRST1_UART23                  7 , 1               /* 7 UART23 (UART 2 and UART 3 Software Reset Control Bit).                                                              */
+#define  IPSRST1_EMC1                    6 , 1               /* 6 EMC1 (EMC1 Software Reset Control Bit).                                                                             */
+#define  IPSRST1_USBDEV1                 5 , 1               /* 5 USBDEV1 (USB Device 1 Controller Software Reset Control Bit).                                                       */
+#define  IPSRST1_GDMA0                   3 , 1               /* 3 GDMA0 (GDMA0 Software Reset Control Bit).                                                                           */
+#define  IPSRST1_SPI3                    1 , 1               /* 1 SPI3 (FIU3 and AHB3 (including SHM part connected to AHB3) Software Reset Control Bit).                             */
+#define  IPSRST1_SPI0                    0 , 1               /* 0 SPI0 (FIU0 Software Reset Control Bit).                                                                             */
+
+/**************************************************************************************************************************/
+/*   IP Software Reset Register 2 (IPSRST2) (Changed in )                                                                 */
+/**************************************************************************************************************************/
+#define  IPSRST2                        (CLK_BASE_ADDR + 0x24) , CLK_ACCESS, 32
+#define  IPSRST2_CP                      31 , 1              /* 31 CP (Coprocessor Reset Control Bit).  This bit resets the CP registers but not registers that are marked as         */
+                                                             /* reset only by VSB power-up reset. Before setting this bit, the BMC CPU should reset the CP2BST register, and          */
+                                                             /* check bit 31 after the reset, that indicates if the CP had a watchdog reset at the same time.                         */
+                                                             /* BMC ROM Code clears this bit according to inverted value of CP_FUSTRAP1.                                              */
+#define  IPSRST2_GMAC1                   28 , 1              /* 28 GMAC1 (Gigabit MAC 1 Software Reset Control Bit)                                                                   */
+#define  IPSRST2_USBHOST                 26 , 1              /* 26 USBHOST (USB Host Software Reset Control Bit)                                                                      */
+#define  IPSRST2_GMAC2                   25 , 1              /* 25 GMAC2 (Gigabit MAC 2 Software Reset Control Bit)                                                                   */
+#define  IPSRST2_PSPI2                   23 , 1              /* 23 PSPI2 (Peripheral SPI 2 Software Reset Control Bit)                                                                */
+#define  IPSRST2_PSPI1                   22 , 1              /* 22 PSPI1 (Peripheral SPI 1 Software Reset Control Bit)                                                                */
+#define  IPSRST2_SIOX2                   19 , 1              /* 19 SIOX2 (Serial GPIO Expander 2 Reset Control Bit)                                                                   */
+#define  IPSRST2_SIOX1                   18 , 1              /* 18 SIOX1 (Serial GPIO Expander 1 Reset Control Bit)                                                                   */
+#define  IPSRST2_OTP                     16 , 1              /* 16 OTP (One Time Programmable Module Reset Control Bit). Resets the state machines and registers.                     */
+#define  IPSRST2_VCD                     14 , 1              /* 14 VCD (Video Capture and Differentiate Module Reset Control Bit).                                                    */
+#define  IPSRST2_ECE                     13 , 1              /* 13 ECE (Encoding Compression Module Reset Control Bit).                                                               */
+#define  IPSRST2_VDMA                    12 , 1              /* 12 VDMA (VDM DMA Module Reset Control Bit).                                                                           */
+#define  IPSRST2_AHBPCIBRG               11 , 1              /* 11 AHBPCIBRG (AHB-to-PCI Bridge Reset Control Bit).                                                                   */
+#define  IPSRST2_GFXSYS                  10 , 1              /* 10 GFXSYS (Graphics System Reset Control Bit). Should be used only if graphics system is under BMC control.           */
+#define  IPSRST2_SDHC                    9 , 1               /* 9 SDHC (SD Host Controller Reset Control Bit).                                                                        */
+#define  IPSRST2_MMC                     8 , 1               /* 8 MMC (Multimedia Card Host Controller Reset Control Bit).                                                            */
+#define  IPSRST2_MFT7_0                  0 , 8              /* 7-0 MFT7-0 (Tachometer Module 7-0 Reset Control Bits).                                                                */
+
+/**************************************************************************************************************************/
+/*   IP Software Reset Register 3 (IPSRST3) (New in )                                                                     */
+/**************************************************************************************************************************/
+#define  IPSRST3                        (CLK_BASE_ADDR + 0x34) , CLK_ACCESS, 32
+#define  IPSRST3_USBPHY2                 25 , 1              /* 25 USBPHY2 (USB PHY 2 Software Reset Control Bit). Must be used before initializing USB port 2 (Host/Device).         */
+#define  IPSRST3_USBPHY1                 24 , 1              /* 24 USBPHY1 (USB PHY 1 Software Reset Control Bit). Must be used before initializing USB port 1 (Hub).                 */
+#define  IPSRST3_ESPI                    23 , 1              /* 23 ESPI (eSPI Module Software Reset Control Bit). Must not be used when eSPI is active.                               */
+#define  IPSRST3_SMB11                   22 , 1              /* 22 SMB11 (SMBus11 Interface Software Reset Control Bit).                                                              */
+#define  IPSRST3_SMB10                   21 , 1              /* 21 SMB10 (SMBus10 Interface Software Reset Control Bit).                                                              */
+#define  IPSRST3_SMB9                    20 , 1              /* 20 SMB9 (SMBus9 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST3_SMB8                    19 , 1              /* 19 SMB8 (SMBus8 Interface Software Reset Control Bit).                                                                */
+#define  IPSRST3_SMB15                   18 , 1              /* 18 SMB15 (SMBus15 Interface Software Reset Control Bit).                                                              */
+#define  IPSRST3_RNG                     17 , 1              /* 17 RNG (Random Number Generator Software Reset Control Bit).                                                          */
+#define  IPSRST3_TIMER10_14              16 , 1              /* 16 TIMER10-14 (Timers 10-14 and Watchdog 2 (Timer module 2) Software Reset Control Bit).                              */
+#define  IPSRST3_PCIERC                  15 , 1              /* 15 PCIERC (PCI Express Root Complex Reset Control Bit.                                                                */
+#define  IPSRST3_SECECC                  14 , 1              /* 14 SECECC (RAS, ECC and MODP Accelerator Module Reset Control Bit).                                                   */
+#define  IPSRST3_SHA                     13 , 1              /* 13 SHA (SHA-1 and SHA-256 Module Reset Control Bit).                                                                  */
+#define  IPSRST3_SMB14                   12 , 1              /* 12 SMB14 (SMBus14 Interface Software Reset Control Bit).                                                              */
+#define  IPSRST3_GDMA2                   11 , 1              /* 11 GDMA2 (General Purpose DMA Module 2 Reset Control Bit).                                                            */
+#define  IPSRST3_GDMA1                   10 , 1              /* 10 GDMA1 (General Purpose DMA Module 1 Reset Control Bit).                                                            */
+#define  IPSRST3_SPCIMBX                 9 , 1               /* 9 SPCIMBX (PCI Mailbox Reset Control Bit).                                                                            */
+#define  IPSRST3_USBHUB                  8 , 1               /* 8 USBHUB. (USB Hub)                                                                                                   */
+#define  IPSRST3_USBDEV9                 7 , 1               /* 7 USBDEV9 (USB Device 9 Reset Control Bits).                                                                          */
+#define  IPSRST3_USBDEV8                 6 , 1               /* 6 USBDEV8 (USB Device 8 Reset Control Bits).                                                                          */
+#define  IPSRST3_USBDEV7                 5 , 1               /* 5 USBDEV7 (USB Device 7 Reset Control Bits).                                                                          */
+#define  IPSRST3_USBDEV0                 4 , 1               /* 4 USBDEV0 (USB Device 0 Reset Control Bits).                                                                          */
+#define  IPSRST3_SMB13                   3 , 1               /* 3 SMB13 (SMBus13 Interface Software Reset Control Bit).                                                               */
+#define  IPSRST3_SPIX                    2 , 1               /* 2 SPIX (SOIX Reset Control Bits).                                                                                     */
+#define  IPSRST3_SMB12                   1 , 1               /* 1 SMB12 (SMBus12 Interface Software Reset Control Bit).                                                               */
+#define  IPSRST3_PWM1                    0 , 1               /* 0 PWM1 (PWM Module 1 Reset Control Bits).                                                                             */
+
+/**************************************************************************************************************************/
+/*   Watchdog 0 Reset Control Register (WD0RCR) (New in )                                                                 */
+/**************************************************************************************************************************/
+#define  WD0RCR                         (CLK_BASE_ADDR + 0x38) , CLK_ACCESS, 32
+#define  WD0RCR_LPCESPI                  31 , 1              /* 31 LPCESPI (LPC or ESPI Watchdog Reset Control Bit). All eSPI or LPC modules, eSPI interface.                         */
+#define  WD0RCR_PCIE                     30 , 1              /* 30 PCIE (PCI Express and PCI Peripherals Watchdog Reset Control Bit). All PCI modules.                                */
+#define  WD0RCR_SHMKCS                   29 , 1              /* 29 SHMKCS (SHM and KCS modules Watchdog Reset Control Bit). SHM, KCS0-3, Post Code FIFO modules.                      */
+#define  WD0RCR_PWM                      28 , 1              /* 28 PWM (PWM Modules Watchdog Reset Control Bit). PWM0-1 modules.                                                      */
+#define  WD0RCR_SPER                     27 , 1              /* 27 SPER (Slow Peripherals Watchdog Reset Control Bit). UART0-3, SMB0-11, PECI, ADC modules.                           */
+#define  WD0RCR_SPI                      26 , 1              /* 26 SPI (SPI interfaces Watchdog Reset Control Bit). FIU0, FIU3, FIUX, PSPI1-2, MFT0-7 modules.                        */
+#define  WD0RCR_SIOX2                    25 , 1              /* 25 SIOX2 (Serial IO Expander 2 Watchdog Reset Control Bit).                                                           */
+#define  WD0RCR_SIOX1                    24 , 1              /* 24 SIOX1 (Serial IO Expander 1 Watchdog Reset Control Bit).                                                           */
+#define  WD0RCR_GPIOM7                   23 , 1              /* 23 GPIOM7 (GPIO Module 7 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM6                   22 , 1              /* 22 GPIOM6 (GPIO Module 6 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM5                   21 , 1              /* 21 GPIOM5 (GPIO Module 5 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM4                   20 , 1              /* 20 GPIOM4 (GPIO Module 4 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM3                   19 , 1              /* 19 GPIOM3 (GPIO Module 3 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM2                   18 , 1              /* 18 GPIOM2 (GPIO Module 2 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM1                   17 , 1              /* 17 GPIOM1 (GPIO Module 1 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_GPIOM0                   16 , 1              /* 16 GPIOM0 (GPIO Module 0 Watchdog Reset Control Bit).                                                                 */
+#define  WD0RCR_TIMER                    15 , 1              /* 15 TIMER (Timer Modules Watchdog Reset Control Bit).                                                                  */
+#define  WD0RCR_PCIMBX                   14 , 1              /* 14 PCIMBX (PCI Mailbox Watchdog Reset Control Bit).                                                                   */
+#define  WD0RCR_AHB2PCI                  13 , 1              /* 13 AHB2PCI (AHB to PCI Bridge Watchdog Reset Control Bit).                                                            */
+#define  WD0RCR_SD                       12 , 1              /* 12 SD (SD Host Controller Watchdog Reset Control Bit). modules.                                                       */
+#define  WD0RCR_MMC                      11 , 1              /* 11 MMC (Multimedia Card Controller Watchdog Reset Control Bit).                                                       */
+#define  WD0RCR_DMA                      10 , 1              /* 10 DMA (DMA Modules Watchdog Reset Control Bit). GDMA0-2, VDMA modules.                                               */
+#define  WD0RCR_USBHST                   9 , 1               /* 9 USBHST (USB Host Watchdog Reset Control Bit).                                                                       */
+#define  WD0RCR_USBDEV                   8 , 1               /* 8 USBDEV (USB Devices Watchdog Reset Control Bit). USBDEV0-9 modules.                                                 */
+#define  WD0RCR_ETH                      7 , 1               /* 7 ETH (Ethernet Controllers Watchdog Reset Control Bit). GMAC1, GMAC2, EMC1-2 modules.                                */
+#define  WD0RCR_CLKS                     6 , 1               /* 6 CLKS (Clock Control Watchdog Reset Control Bit). Resets the clock control to power-on reset values.                 */
+#define  WD0RCR_MC                       5 , 1               /* 5 MC (DDR4 Memory Controller Watchdog Reset Control Bit).                                                             */
+#define  WD0RCR_RV                       4 , 1               /* 4 RV (Remote Video Watchdog Reset Control Bit). ECE, VCD, DVC modules                                                 */
+#define  WD0RCR_SEC                      3 , 1               /* 3 SEC (Security Peripherals Watchdog Reset Control Bit). SECECC, 3DES, AES, RNG, SHA, OTP modules.                    */
+#define  WD0RCR_CP                       2 , 1               /* 2 CP (Coprocessor Watchdog Reset Control Bit).                                                                        */
+#define  WD0RCR_A9DBG                    1 , 1               /* 1 A9DBG (Cortex A9 Debugger (CoreSight) Watchdog Reset Control Bit).                                                  */
+#define  WD0RCR_CA9C                     0 , 1               /* 0 CA9C (Cortex A9 Cores Watchdog Reset Control Bit).                                                                  */
+
+/**************************************************************************************************************************/
+/*   Watchdog 1 Reset Control Register (WD1RCR) (New in )                                                                 */
+/**************************************************************************************************************************/
+#define  WD1RCR                         (CLK_BASE_ADDR + 0x3C) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   Watchdog 2 Reset Control Register (WD2RCR) (New in )                                                                 */
+/**************************************************************************************************************************/
+#define  WD2RCR                         (CLK_BASE_ADDR + 0x40) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   Software Reset Control Register 1 (SWRSTC1) (New in )                                                                */
+/**************************************************************************************************************************/
+#define  SWRSTC1                        (CLK_BASE_ADDR + 0x44) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   Software Reset Control Register 2 (SWRSTC2) (New in )                                                                */
+/**************************************************************************************************************************/
+#define  SWRSTC2                        (CLK_BASE_ADDR + 0x48) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   Software Reset Control Register 3 (SWRSTC3) (New in )                                                                */
+/**************************************************************************************************************************/
+#define  SWRSTC3                        (CLK_BASE_ADDR + 0x4C) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   Software Reset Control Register 4 (SWRSTC4) (New in )                                                                */
+/**************************************************************************************************************************/
+#define  SWRSTC4                        (CLK_BASE_ADDR + 0x50) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   CORST Control Register (CORSTC) (New in )                                                                            */
+/**************************************************************************************************************************/
+#define  CORSTC                         (CLK_BASE_ADDR + 0x5C) , CLK_ACCESS, 32
+
+/**************************************************************************************************************************/
+/*   PLL Control Register GFX (PLLCONG) (New in )                                                                         */
+/**************************************************************************************************************************/
+#define  PLLCONG                        (CLK_BASE_ADDR + 0x60) , CLK_ACCESS, 32
+#define  PLLCONG_LOKI                    31 , 1              /* 31 LOKI (Lock Indication ).                                                                                           */
+#define  PLLCONG_LOKS                    30 , 1              /* 30 LOKS (Unlock Indication Sticky Bit ).                                                                              */
+#define  PLLCONG_GPLLTST                 29 , 1              /* 29 GPLLTST (Graphics PLL Test Mode).                                                                                  */
+#define  PLLCONG_FBDV                    16 , 12            /* 27-16 FBDV (PLL VCO Output Clock Feedback Divider). The feedback divider divides the output clock from                */
+#define  PLLCONG_OTDV2                   13 , 3             /* 15-13 OTDV2 (PLL Output Clock Divider 2). The output divider divides the VCO clock output. The divide value           */
+#define  PLLCONG_PWDEN                   12 , 1              /* 12 PWDEN (Power-Down Mode Enable).                                                                                    */
+#define  PLLCONG_OTDV1                   8 , 3              /* 10-8 OTDV1 (PLL Output Clock Divider 1). The output divider divides the VCO clock output. The divide value            */
+#define  PLLCONG_INDV                    0 , 6              /* 5-0 INDV (PLL Input Clock Divider). The input divider divides the input reference clock into the PLL. The divide      */
+
+/**************************************************************************************************************************/
+/*   AHB Clock Frequency Information Register (AHBCKFI)                                                                   */
+/**************************************************************************************************************************/
+#define  AHBCKFI                        (CLK_BASE_ADDR + 0x64) , CLK_ACCESS, 32
+#define  AHBCKFI_TST1S                   31 , 1              /* 31 TST1S (Test Seconds Counter). Defines the test mode for the SECCNT register when set. In this mode, the            */
+#define  AHBCKFI_AHB_CLK_FRQ             0 , 8              /* 7-0 AHB_CLK_FRQ (AHB Clock Frequency). Defines the AHB clock frequency in MHz. The configuration software             */
+
+/**************************************************************************************************************************/
+/*   Seconds Counter Register (SECCNT)                                                                                    */
+/**************************************************************************************************************************/
+#define  SECCNT                         (CLK_BASE_ADDR + 0x68) , CLK_ACCESS, 32
+#define  SECCNT_SEC_CNT                  0 , 32             /* 31-0 SEC_CNT (Seconds Count). This register is reset by only VSB power-up reset. The value of this register is        */
+
+/**************************************************************************************************************************/
+/*   25M Counter Register (CNTR25M)                                                                                        */
+/**************************************************************************************************************************/
+#define  CNTR25M                         (CLK_BASE_ADDR + 0x6C) , CLK_ACCESS, 32
+#define  CNTR25M_COUNT                    0 , 25   /* 25MCNT (25 MHz Count). This register is reset by only VSB power-up reset. The value of this register
+                                                        represents a counter with a 25 MHz clock, used to update the SECCNT register. This field is updated every
+                                                        640ns. The 4 LSB of this field are always 0. When this field reaches a value of 25,000,000 it goes to 0 and
+                                                        SEC_CNT field is updated.*/
+#define  CNTR25M_ACCURECY                 EXT_CLOCK_FREQUENCY_MHZ  /* minimum accurecy 1us which is 5 cycles */
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFXMSEL                                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_GFXMSEL_CLKREF             0x02          /*  1 0    : CLKREF clock (25 MHz, default).      */
+#define CLK_SEL_GFXMSEL_PLL2               0x03          /*  1 1    : PLL2 clock, frequency divided by 3.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKOUTSEL                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_CLKOUTSEL_PLL0             0x00          /*   0 0 0 : PLL0 clock.                            */
+#define CLK_SEL_CLKOUTSEL_PLL1             0x01          /*   0 0 1 : PLL1 clock.                            */
+#define CLK_SEL_CLKOUTSEL_CLKREF           0x02          /*   0 1 0 : CLKREF input (25 MHz, default).        */
+#define CLK_SEL_CLKOUTSEL_PLLG             0x03          /*   0 1 1  Graphics PLL output clock, divided by 2 */
+#define CLK_SEL_CLKOUTSEL_PLL2             0x04          /*   1 0 0 : PLL2 clock divided by 2.               */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFXCKSEL                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_GFXCKSEL_PLL0              0x00          /*   0 0   : PLL0 clock.                            */
+#define CLK_SEL_GFXCKSEL_PLL1              0x01          /*   0 1   : PLL1 clock.                            */
+#define CLK_SEL_GFXCKSEL_CLKREF            0x02          /*   1 0   : CLKREF clock (25 MHz, default).        */
+#define CLK_SEL_GFXCKSEL_PLL2              0x03          /*   1 1   : PLL2 clock divided by 2.               */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TIMCKSEL                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_TIMCKSEL_PLL0              0x00          /*   0 0   : PLL0 clock.                            */
+#define CLK_SEL_TIMCKSEL_PLL1              0x01          /*   0 1   : PLL1 clock.                            */
+#define CLK_SEL_TIMCKSEL_CLKREF            0x02          /*   1 0   : CLKREF clock (25 MHz, default).        */
+#define CLK_SEL_TIMCKSEL_PLL2              0x03          /*   1 1   : PLL2 clock divided by 2.               */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MCCKSEL                                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_MCCKSEL_PLL1               0x00          /*  0 0    : PLL1 clock.                            */
+#define CLK_SEL_MCCKSEL_CLKREF             0x02          /*  1 0    : CLKREF clock (25 MHz, default).        */
+#define CLK_SEL_MCCKSEL_MCBPCK             0x03          /*  1 1    : MCBPCK clock input.                    */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SUCKSEL                                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_SUCKSEL_PLL0               0x00          /*  0 0    : PLL0 clock.                            */
+#define CLK_SEL_SUCKSEL_PLL1               0x01          /*  0 1    : PLL1 clock.                            */
+#define CLK_SEL_SUCKSEL_CLKREF             0x02          /*  1 0    : CLKREF clock (25 MHz, default).        */
+#define CLK_SEL_SUCKSEL_PLL2               0x03          /*  1 1    : PLL2 clock divided by 2.               */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UARTCKSEL                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_UARTCKSEL_PLL0             0x00          /*  0 0    : PLL0 clock.                          */
+#define CLK_SEL_UARTCKSEL_PLL1             0x01          /*  0 1    : PLL1 clock.                          */
+#define CLK_SEL_UARTCKSEL_CLKREF           0x02          /*  1 0    : CLKREF clock (25 MHz, default).      */
+#define CLK_SEL_UARTCKSEL_PLL2             0x03          /*  1 1    : PLL2 clock divided by 2.             */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SDCKSEL                                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_SDCKSEL_PLL0               0x00          /*   0 0   : PLL0 clock.                          */
+#define CLK_SEL_SDCKSEL_PLL1               0x01          /*   0 1   : PLL1 clock.                          */
+#define CLK_SEL_SDCKSEL_CLKREF             0x02          /*   1 0   : CLKREF clock (25 MHz, default).      */
+#define CLK_SEL_SDCKSEL_PLL2               0x03          /*   1 1   : PLL2 clock divided by 2.             */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PIXCKSEL                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_PIXCKSEL_PLLG              0x00          /*   0 0   : PLL GFX clock after divide to 2.     */
+#define CLK_SEL_PIXCKSEL_CLKOUT            0x01          /*   0 1   : CLKOUT/GPIO160 pin as input (MFSEL1.21 and GPIO160 controls should be left at default state).*/
+#define CLK_SEL_PIXCKSEL_CLKREF            0x02          /*   1 0   : CLKREF input. (default)              */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPRFSEL                                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_GPRFSEL_GFXBYPCK           0x00          /*   0 0   : GFXBYPCK pin.                        */
+#define CLK_SEL_GPRFSEL_USB                0x01          /*   0 1   : USB OHCI Clock (48 MHz).             */
+#define CLK_SEL_GPRFSEL_CLKREF             0x02          /*   1 0   : CLKREF input. (default)              */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CPUCKSEL                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_CPUCKSEL_PLL0              0x00          /*   0 0   : PLL0 clock.                          */
+#define CLK_SEL_CPUCKSEL_PLL1              0x01          /*   0 1   : PLL1 clock.                          */
+#define CLK_SEL_CPUCKSEL_CLKREF            0x02          /*   1 0   : CLKREF input (25 MHz, default).      */
+#define CLK_SEL_CPUCKSEL_SYSBPCK           0x03          /*   1 1   : Bypass clock from pin SYSBPCK.       */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ADCCKDIV                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_ADCCKDIV1              0x00          /*    0 0 0: /1 (should not be used).             */
+#define CLK_SEL_ADCCKDIV2              0x01          /*    0 0 1: /2.                                  */
+#define CLK_SEL_ADCCKDIV4              0x02          /*    0 1 0: /4.                                  */
+#define CLK_SEL_ADCCKDIV8              0x03          /*    0 1 1: /8.                                  */
+#define CLK_SEL_ADCCKDIV16             0x04          /*    1 0 0: /16                                  */
+#define CLK_SEL_ADCCKDIV32             0x05          /*    1 0 1: /32 (default)                        */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* APBxCKDIV                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CLK_SEL_APB_DIV1                   0x00          /*     0 0 : AHB1CLK/1.                           */
+#define CLK_SEL_APB_DIV2                   0x01          /*     0 1 : AHB1CLK/2. (default for APB5 )       */
+#define CLK_SEL_APB_DIV4                   0x02          /*     1 0 : AHB1CLK/4. (default, except APB5)    */
+#define CLK_SEL_APB_DIV8                   0x03          /*     1 1 : AHB1CLK/8.                           */
+
+
+
+
+
+/***********************************************************************/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DVCSSEL (DVC System Clock Source Select Bit). Typically, a divided PLL2 (by 4): 240 MHz.                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_DVCSSEL_CLKREF       0x02   /*   1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_DVCSSEL_PLL2         0x03   /*   1 1: PLL2 clock, frequency divided by 4.  */
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFXMSEL (Graphics Memory Clock Source Select Bit). Typically it would be divided PLL2, 320MHz.          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_GFXMSEL_CLKREF       0x02   /*   1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_GFXMSEL_PLL2         0x03   /*   1 1: PLL2    clock, frequency divided by 3.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKOUTSEL (CLKOUT signal Clock Source Select Bit).                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_CLKOUTSEL_PLL0       0x00   /*  0 0 0: PLL0    clock.  */
+#define   CLKSEL_CLKOUTSEL_PLL1       0x01   /*  0 0 1: PLL1    clock.  */
+#define   CLKSEL_CLKOUTSEL_CLKREF     0x02   /*  0 1 0: CLKREF input (25 MHz, default).  */
+#define   CLKSEL_CLKOUTSEL_PLLG       0x03   /*  0 1 1: Graphics PLL output clock, divided by 2 .  */
+#define   CLKSEL_CLKOUTSEL_PLL2       0x04   /*  1 0 0: PLL2    clock divided by 2.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFXCKSEL (Graphics System Clock Source Select Bit). Typically it would be the same source of the CPU    */
+/* clock.                                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_GFXCKSEL_PLL0       0x00   /*  0 0: PLL0    clock.  */
+#define   CLKSEL_GFXCKSEL_PLL1       0x01   /*  0 1: PLL1    clock.  */
+#define   CLKSEL_GFXCKSEL_CLKREF     0x02   /*  1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_GFXCKSEL_PLL2       0x03   /*  1 1: PLL2    clock divided by 2.  */
+/* Note: Before changing this field, assure a delay of 200 clock cycles from last change of GSCKDIV and PCICKDIV fields in CLKDIVx register.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TIMCKSEL (Timer Clock Source Select Bit).                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_TIMCKSEL_PLL0       0x00   /*  0 0: PLL0    clock.  */
+#define   CLKSEL_TIMCKSEL_PLL1       0x01   /*  0 1: PLL1    clock.  */
+#define   CLKSEL_TIMCKSEL_CLKREF     0x02   /*  1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_TIMCKSEL_PLL2       0x03   /*  1 1: PLL2    clock divided by 2.  */
+/* Note: Before changing this field, assure a delay of 200 clock cycles from last change of TIMCKDIV field in CLKDIV register.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MCCKSEL (Memory Controller Clock Source Select Bit).                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_MCCKSEL_PLL1        0x00   /*  0 0: PLL1    clock.  */
+#define   CLKSEL_MCCKSEL_CLKREF      0x02   /*  1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_MCCKSEL_MCBPCK      0x03   /*  1 1: MCBPCK clock input.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SUCKSEL (USB Serial Clock Source Select Bit). For UTMI2UTMI and OHCI logic. Should select a clock of 480*/
+/* MHZ.                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_SUCKSEL_PLL0        0x00   /*  0 0: PLL0    clock.  */
+#define   CLKSEL_SUCKSEL_PLL1        0x01   /*  0 1: PLL1    clock.  */
+#define   CLKSEL_SUCKSEL_CLKREF      0x02   /*  1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_SUCKSEL_PLL2        0x03   /*  1 1: PLL2    clock divided by 2.  */
+/* Note: Before changing this field, assure a delay of 200 clock cycles from the last change of SUCKDIV field in CLKDIV register.  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UARTCKSEL (Core and Host UART Clock Source Select Bit).                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_UARTCKSEL_PLL0      0x00   /*  0 0: PLL0    clock.  */
+#define   CLKSEL_UARTCKSEL_PLL1      0x01   /*  0 1: PLL1    clock.  */
+#define   CLKSEL_UARTCKSEL_CLKREF    0x02   /*  1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_UARTCKSEL_PLL2      0x03   /*  1 1: PLL2    clock divided by 2.  */
+/* Note: Before changing this field, assure a delay of 200 clock cycles from last change of UARTDIV field in CLKDIV register.  */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SDCKSEL (SDHC Clock Source Select Bit).                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_SDCKSEL_PLL0        0x00   /* 0 0: PLL0    clock.  */
+#define   CLKSEL_SDCKSEL_PLL1        0x01   /* 0 1: PLL1    clock.  */
+#define   CLKSEL_SDCKSEL_CLKREF      0x02   /* 1 0: CLKREF clock (25 MHz, default).  */
+#define   CLKSEL_SDCKSEL_PLL2        0x03   /* 1 1: PLL2    clock divided by 2.  */
+/* Note: Before changing this field, assure a delay of 200 clock cycles from last change of SDCKDIV field in CLKDIV register. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PIXCKSEL (Pixel Clock Source Select Bit).                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_PIXCKSEL_PLLG       0x00   /* 0 0: PLL GFX clock after divide to 2.  */
+#define   CLKSEL_PIXCKSEL_CLKOUT     0x01   /* 0 1: CLKOUT/GPIO160 pin as input (MFSEL1.21 and GPIO160 controls should be left at default state).  */
+#define   CLKSEL_PIXCKSEL_CLKREF     0x02   /* 1 0: CLKREF input. (default)  */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPRFSEL (Graphics PLL Reference Clock Source Select Bit).                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_GPRFSEL_GFXBYPCK     0x00   /* 0 0: GFXBYPCK pin.  */
+#define   CLKSEL_GPRFSEL_USB_OHCI     0x01   /* 0 1: USB OHCI Clock (48 MHz).  */
+#define   CLKSEL_GPRFSEL_CLKREF       0x02   /* 1 0: CLKREF input. (default)  */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CPUCKSEL (CPU/AMBA/MC Clock Source Select Bit).                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   CLKSEL_CPUCKSEL_PLL0        0x00   /* 0 0: PLL0    clock.  */
+#define   CLKSEL_CPUCKSEL_PLL1        0x01   /* 0 1: PLL1    clock.  */
+#define   CLKSEL_CPUCKSEL_CLKREF      0x02   /* 1 0: CLKREF input (25 MHz, default).  */
+#define   CLKSEL_CPUCKSEL_SYSBPCK     0x03   /* 1 1: Bypass clock from pin SYSBPCK.  */
+/* Note: Before changing this field, assure a delay of 200 (selected) clock cycles from last change of CLKDIV register. */
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* clock division field values:                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_ADCCKDIV                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_ADCCKDIV1     0 /* 0 0 0: /1 (should not be used). */
+#define  CLKDIV1_ADCCKDIV2     1 /* 0 0 1: /2. */
+#define  CLKDIV1_ADCCKDIV4     2 /* 0 1 0: /4. */
+#define  CLKDIV1_ADCCKDIV8     3 /* 0 1 1: /8. */
+#define  CLKDIV1_ADCCKDIV16    4 /* 1 0 0: /16 */
+#define  CLKDIV1_ADCCKDIV32    5 /* 1 0 1: /32 (default) */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_CLK4DIV (AMBA AHB Clock Divider Control)                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_CLK4DIV1    0 /* 0: CLK2 Clock is used for CLK4. */
+#define  CLKDIV1_CLK4DIV2    1 /* 1: CLK2 Clock is divided by 2 for CLK4 (default). */
+#define  CLKDIV1_CLK4DIV3    2 /* 2: CLK2 Clock is divided by 3 for CLK4. */
+#define  CLKDIV1_CLK4DIV4    3 /* 3: CLK2 Clock is divided by 4 for CLK4. */
+ /* After changing this field, assure a delay of 200 clock cycles before changing CPUCKSEL field in CLKSEL register. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_TIMCKDIV (Timer Clock Source Divider Control). Default is divide by 20. The division factor is  */
+/* (TIMCKDIV +1), where TIMCKDIV value is 0-31.                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_TIMCK_DIV(n)   ( (n) - 1)     /*  TIMCKDIV value is 0-31. */
+/* Note: After changing this field, assure a delay of 200 selected clock cycles before the timer is used. */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_UARTDIV (UART Clock Source Divider Control). This resulting clock must be 24 MHz for UARTs proper*/
+/* operation                                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_UART_DIV(n)   ( (n) - 1)     /* Default is divide by 20. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_MMCCKDIV (MMC Controller (SDHC2) Clock Divider Control). Sets the division factor from the clock*/
+/* selected by SDCKSEL.                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_MMCCK_DIV(n)   ( (n) - 1)     /* The division factor is (MMCCKDIV+1), where MMCCKDIV is 0 to 31. Default is to divide by 32. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_AHB3CKDIV (SPI3 Clock Divider Control). Sets the division factor from AHB clock (CLK4) to AHB3  */
+/* and SPI3                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_AHB3CK_DIV(n)   ( (n) - 1)     /* clock. The division factor is (AHB3CKDIV+1), where AHB3CKDIV is 0 to 31. Default is to divide by 2. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_PCICKDIV (Internal PCI Clock Divider Control). Sets the division factor from the clock selected */
+/* by the CLKSEL                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_PCICK_DIV(n)   ( (n) - 1)     /* GFXCKSEL field. The division factor is (PCICKDIV+1), where PCICKDIV is 0 to 15. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV1_CLK2DIV (AMBA AXI Clock Divider Control).                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV1_CLK2DIV1    0 /* 0: CPU Clock is used for AXI16 (CLK2). */
+#define  CLKDIV1_CLK2DIV2    1 /* 1: CPU Clock is divided by 2 for AXI16 (CLK2)(default). */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV2_APBxCKDIV (AMBA APBx Clock Divider Control).                                                    */
+/* APB1 clock must be at least 24 MHz, for UARTs to function. APB clock frequency is up to 67 MHz          */
+/* APB2 clock frequency is up to 67 MHz.                                                                   */
+/* APB3 clock frequency is up to 67 MHz                                                                    */
+/* APB4 clock frequency is up to 67 MHz                                                                    */
+/* APB5 clock must be high to enable PSPI1-2 high SPI clock rate. The preferred setting is divide by 2     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV2_APBxCKDIV1    0 /* 0 0: AHB1CLK/1. */
+#define  CLKDIV2_APBxCKDIV2    1 /* 0 1: AHB1CLK/2. */
+#define  CLKDIV2_APBxCKDIV4    2 /* 1 0: AHB1CLK/4 (default). */
+#define  CLKDIV2_APBxCKDIV8    3 /* 1 1: AHB1CLK/8. */
+ /* Note: After changing this field, assure a delay of 200 clock cycles before changing CPUCKSEL field in CLKSEL */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFXCKDIV (Graphics System Clock Divider Control). Sets the division factor from the clock selected by the*/
+/* CLKSEL.GFXCKSEL field. The division factor is (GFXCKDIV+1), where GFXCKDIV is 0 to 7.                   */
+/* Default is divide by 5.                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV2_GFXCKDIV_DIV(n)   ( (n) - 1)     /* is (SPI0CKDIV+1), where SPI0CKDIV is 0 to 31. Default is to divide by 1. */
+/* After changing this field, ensure a delay of 200 selected clock cycles before changing GFXCKSEL field in CLKSEL register. */
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV3_SPI0CKDV (SPI0 Clock Divider Control). Sets the division factor from AHB clock to SPI0 clock. The*/
+/* division factor   is (SPI0CKDIV+1)                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV3_SPI0CKDV_DIV(n)   ( (n) - 1)     /* is (SPI0CKDIV+1), where SPI0CKDIV is 0 to 31. Default is to divide by 1. */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CLKDIV3_SPIXCKDV (SPIX Clock Divider Control). Sets the division factor from AHB clock to SPIX clock. The*/
+/* division factor    is (SPIXCKDIV+1)                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  CLKDIV3_SPIXCKDV_DIV(n)   ( (n) - 1)     /* is (SPIXCKDIV+1), where SPIXCKDIV is 0 to 31. Default is to divide by 1. */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PWDEN:  PLL power down values                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  PLLCONn_PWDEN_NORMAL            0
+#define  PLLCONn_PWDEN_POWER_DOWN        1
+
+
+
+#endif // CLK_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.c b/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.c
new file mode 100755
index 0000000..e1f0891
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   clk_if.c                                                                                              */
+/*            This file contains CLK module driver selector                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(CLK_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(clk, CLK_MODULE_TYPE)
+#endif    
+   
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.h b/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.h
new file mode 100755
index 0000000..13b53f1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/clk/clk_if.h
@@ -0,0 +1,462 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   clk_if.h                                                                                              */
+/*            This file contains CLK (clock) module interface                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef CLK_IF_H
+#define CLK_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+
+#if defined (CODE_OF_BB_ONLY)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureClocks                                                                    */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs general clocks configuration                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ConfigureClocks(void);
+#endif // defined (STRP_MODULE_TYPE)
+
+#if defined (UART_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureUartClock                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs UART clock configuration                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_ConfigureUartClock (void);
+#endif // defined (UART_MODULE_TYPE)
+
+#if defined (USB_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureUSBClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the USB clock to 60MHz by checking which PLL is                             */
+/*                  dividable by 60 and setting correct SEL and DIV values.                                */
+/*                  Assumes that one of the PLLs is dividable by 60                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  CLK_ConfigureUSBClock(void);
+#endif //  defined (USB_MODULE_TYPE)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureAPBClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         APB freq in Hz                                                                         */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures APB divider to 2, return the frequency of APB in Hz                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_ConfigureAPBClock (UINT32 apb);
+
+#if defined (TIMER_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureTimerClock                                                                */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Timer clock configuration                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_ConfigureTimerClock (void);
+#endif // defined (TIMER_MODULE_TYPE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureEMCClock                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ethNum -  ethernet module number                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures EMC clocks                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ConfigureEMCClock (UINT32 ethNum);
+
+#if defined (GMAC_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureGMACClock                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ethNum -  ethernet module number                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures GMAC clocks                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ConfigureGMACClock (UINT32 ethNum);
+#endif //#if defined (GMAC_MODULE_TYPE)
+
+#if defined (SD_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureSDClock                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum       -  SD module number                                                        */
+/*                                                                                                         */
+/* Returns:         SD clock frequency                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the SD clock to frequency closest to the target clock from beneath          */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_ConfigureSDClock (UINT32 sdNum);
+#endif  //#if defined (SD_MODULE_TYPE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetEMC                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of EMC module                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetEMC (UINT32 deviceNum);
+
+#if defined (GMAC_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetGMAC                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of GMAC                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetGMAC (UINT32 deviceNum);
+#endif // #if defined (GMAC_MODULE_TYPE)
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetFIU                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of FIU                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetFIU (void);
+#endif //#if defined (FIU_MODULE_TYPE)
+
+#if defined (UART_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetUART                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of UART                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ResetUART(UINT32 deviceNum);
+#endif // #if defined (UART_MODULE_TYPE)
+
+#if defined (AES_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetAES                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of AES                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ResetAES(void);
+#endif //if defined (AES_MODULE_TYPE)
+
+#if defined (MC_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetMC                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of MC                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void    CLK_ResetMC(void);
+#endif // #if defined (MC_MODULE_TYPE)
+
+#if defined (TIMER_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetTIMER                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -                                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of Timer                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ResetTIMER (UINT32 deviceNum);
+#endif // #if defined (TIMER_MODULE_TYPE)
+
+#if defined (SD_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetSD                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum -  SD module number                                                              */
+/*                                                                                                         */
+/* Returns:         BMC HAL Error code                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of SD                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ResetSD(UINT32 sdNum);
+#endif // #if defined (SD_MODULE_TYPE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ResetPSPI                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  deviceNum -  PSPI module number                                                        */
+/*                                                                                                         */
+/* Returns:         BMC HAL Error code                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of PSPI                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ResetPSPI(UINT32 deviceNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetPLL0toAPBdivisor                                                                */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the value achieved by dividing PLL0 frequency to APB frequency    */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetPLL0toAPBdivisor (UINT32 apb);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_MicroSec                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSec -  number of microseconds to delay                                            */
+/*                                                                                                         */
+/* Returns:         Number of iterations executed                                                          */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs a busy delay (empty loop)                                        */
+/*                  the number of iterations is based on current CPU clock calculation and cache           */
+/*                  enabled/disabled                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_Delay_MicroSec (UINT32 microSec);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_Since                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSec -  number of microseconds to delay                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  get a time stamp, delay microSec from it. If microSec has allready passed since the    */
+/*                  time stamp , then no delay is needed.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_Delay_Since (UINT32 microSec, UINT32 time_quad[2]);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Time_MicroSec                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         Current time stamp                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void  CLK_GetTimeStamp (UINT32 time_quad[2]);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_Delay_Cycles                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cycles -                                                                               */
+/*                                                                                                         */
+/* Returns:         Number of iterations executed                                                          */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs delay in number of cycles                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_Delay_Cycles(UINT32 cycles);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetMemoryFreq                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates Memory frequency in Hz                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetMemoryFreq (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetCPUFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates CPU frequency                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  CLK_GetCPUFreq(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetAPBFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns APB frequency                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetAPBFreq (UINT32 apb);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetCPFreq                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns CP frequency                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetCPFreq (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_SetCPFreq                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets CP frequency                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_SetCPFreq (UINT32  cpFreq);
+
+
+
+#if defined (SD_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetSDClock                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  sdNum -  SD module number                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns the SD base clock frequency in Hz                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetSDClock (UINT32 sdNum);
+#endif  //#if defined (SD_MODULE_TYPE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigurePCIClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs configuration of PCI clock depending on                          */
+/*                  presence of VGA BIOS as specified by STRAP13                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void CLK_ConfigurePCIClock(void);
+
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_ConfigureFIUClock                                                                  */
+/*                                                                                                         */
+/* Parameters:      fiu - module (0, 3, X).                                                                */
+/*                  clkDiv - actual number to write to reg. The value is clkdDiv + 1)                      */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine config the FIU clock (according to the header )                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS CLK_ConfigureFIUClock (UINT8  fiu, UINT8 clkDiv);
+#endif // #if defined (FIU_MODULE_TYPE)
+
+#if defined (FIU_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetFIUClockDiv                                                                     */
+/*                                                                                                         */
+/* Parameters:      fiu - module (0, 3, X).                                                                                  */
+/* Returns:         clkDiv - actual number read from reg                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine config the FIU clock (according to the header )                           */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT8 CLK_GetFIUClockDiv (UINT8  fiu);
+#endif // defined (FIU_MODULE_TYPE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetTimeStamp                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         Current time stamp                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void  CLK_GetTimeStamp (UINT32 time_quad[2]);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        CLK_GetSPIFreq                                                                         */
+/*                                                                                                         */
+/* Parameters:      apb number,1 to 5                                                                      */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns SPI frequency  in Hz                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 CLK_GetSPIFreq (UINT32 spi);
+
+
+#endif // CLK_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/des/des_if.h b/board/nuvoton/common/BMC_HAL/Modules/des/des_if.h
new file mode 100755
index 0000000..52d84a7
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/des/des_if.h
@@ -0,0 +1,104 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Project: Yarkon Security Library                                                                        */
+/* File Name: des_if.h                                                                                     */
+/*                                                                                                         */
+/* File Contents:                                                                                          */
+/*      This file contains Data Encryption Standard (DES) algorithm                                        */
+/*      driver definitions.                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef DES_IF_H
+#define DES_IF_H
+
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES module enumerations                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES Operation */
+typedef enum
+{
+    DES_ENCRYPT,
+    DES_DECRYPT
+} DES_OP_T;
+
+/* DES Mode */
+typedef enum
+{
+    DES_MODE_ECB,   /* Electronic Codebook  */
+    DES_MODE_CBC    /* Cipher Block Chaining */
+} DES_MODE_T;
+
+/* Number of DES Keys */
+typedef enum
+{
+    DES_1KEY,       /*  64 bit */
+    DES_2KEY,       /* 128 bit */
+    DES_3KEY        /* 192 bit */
+} DES_KEY_NUM_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES module macro definitions                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+/* The bit length of supported keys for the DES algorithm */
+#define DES_KEY_BIT_SIZE(num)  (64 + (DES_KEY_NUM_T)(num) * 64)
+
+/* The byte length of supported keys for the DES algorithm */
+#define DES_KEY_BYTE_SIZE(num) (DES_KEY_BIT_SIZE(num) / 8)
+
+/* # of bytes needed to represent a key */
+#define DES_MAX_KEY_SIZE        DES_KEY_BYTE_SIZE(DES_3KEY)
+
+/* The byte length of a block for the DES algorithm (b = 64 bit) */
+#define DES_BLOCK_SIZE          DES_KEY_BYTE_SIZE(DES_1KEY)
+
+/* # of bytes needed to represent an IV  */
+#define DES_MAX_IV_SIZE         DES_BLOCK_SIZE
+
+/* Calculate the number of blocks in the formatted message */
+#define DES_COMPLETE_BLOCKS(size)   ((size + (DES_BLOCK_SIZE - 1)) / DES_BLOCK_SIZE)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DES module structures                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*  The structure for cipher information */
+typedef struct {
+    DES_OP_T    operation;  /* Encrypt / Decrypt */
+    DES_MODE_T  mode;       /* ECB / CBC */
+    const UINT8 *IV;        /* (optional) Initialization Vector for ciphering */
+} DES_CIPHER_INSTANCE;
+
+/*  The structure for key information */
+typedef struct {
+    DES_KEY_NUM_T  keyNum;  /* Number of DES keys: 1 (64 bit) / 2 (128 bit) / 3 (192 bit)  */
+    UINT8          *key;    /* Raw key data */
+} DES_KEY_INSTANCE;
+
+/*  The structure for data information */
+typedef struct {
+    UINT32       size;      /* Byte length of input data */
+    const UINT8 *input;     /* Input data */
+    UINT8       *output;    /* Output data */
+} DES_DATA_INSTANCE;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DES_Crypt                                                                              */
+/*                                                                                                         */
+/* Parameters:      cipher - The structure for cipher information [input].                                 */
+/*                  key    - The structure for key information    [input].                                 */
+/*                  data   - The structure for data information   [input].                                 */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*      Encrypt/Decrypt a message using 3DES                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void DES_Crypt           (DES_CIPHER_INSTANCE *cipher, DES_KEY_INSTANCE *key, DES_DATA_INSTANCE *data);
+
+#endif /* DES_IF_H */
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/ece/ece_if.h b/board/nuvoton/common/BMC_HAL/Modules/ece/ece_if.h
new file mode 100755
index 0000000..ff8b3d1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/ece/ece_if.h
@@ -0,0 +1,278 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   ece_if.h                                                                                              */
+/*            This file contains Interface for ENCODING COMPRESSION ENGINE (ECE) block.                    */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _ECE_IF_H
+#define _ECE_IF_H
+
+#include "defs.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS API Class                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_Initialise                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  uSleep - optional uSleep from OS (can be NULL)                                         */
+/*                  WaitForECEDoneInterrupt - optional wait for interrup from OS (can be NULL)             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Initialise the ECE block and interface library.                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int ECE_Initialise(int (*uSleep) (unsigned int uSec), int (*WaitForECEDoneInterrupt) (UINT32 msTimeout));
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_HWIsPresent                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Test whether the ECE block is present.                                                 */
+/*                  There is no ID or version register, so test the writable bits in                       */
+/*                  some of the registers.                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int ECE_HWIsPresent(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Stop and reset the ECE state machine.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_Reset(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_EncodeRectangle                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  RectOffset_X -                                                                         */
+/*                  RectOffset_Y -                                                                         */
+/*                  Rect_Height -                                                                          */
+/*                  Rect_Width -                                                                           */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Encode the desired rectangle                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_EncodeRectangle(UINT32 RectOffset_X, UINT32 RectOffset_Y, UINT32 Rect_Width, UINT32 Rect_Height);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_Done                                                                               */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return true if the last encodig operation has completed.                               */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN ECE_Done(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_ClearDataReadyStatus                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  CDREADY (Rectangle Compressed Data Ready in DDR Memory)                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_ClearDataReadyStatus(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_GetStatus                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return the current ECE status.                                                         */
+/*                  This is the raw hardware register, with bits as defined in ece.h.                      */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 ECE_GetStatus(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_IsRectangleCompressed                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return TRUE if a rectangle finished to be compressed                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN ECE_IsRectangleCompressed(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_IsStatusBusy                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return TRUE if ECE is busy                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN ECE_IsStatusBusy(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_SetLinePitch                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  pitch -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set the line pitch (in bytes) for the frame buffers.                                   */
+/*                  Can be on of those values: 512, 1024, 2048, 2560 or 4096 bytes                         */
+/*---------------------------------------------------------------------------------------------------------*/
+int ECE_SetLinePitch(UINT32 pitch);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_GetLinePitch                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Get the line pitch (in bytes) for the frame buffer                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 ECE_GetLinePitch(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_GetNextEncodedDataAddress                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  EncodedSize - Size of the encoded data                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the next Encoded rectangle address                                */
+/*                  The size of the encoded data will be put in EncodedSize                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 ECE_GetNextEncodedDataAddress(UINT32 *EncodedSize);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_InterruptEnable                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  enable -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Enables or disable ECE interrupts                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_InterruptEnable(BOOLEAN enable);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_IsInterruptEnabled                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns true if ECE interrupt is enabled                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN ECE_IsInterruptEnabled(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_SetFrameBufferBaseAddress                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  address -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the Frame Buffer base address                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_SetFrameBufferBaseAddress(UINT32 address);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_SetEncodedDataBaseAddress                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ED_PhysicalBaseAddress - Encoded Data Physical base address                            */
+/*                  ED_VirtualBaseAddress - optional Encoded Data Virtual base address from OS             */
+/*                                          (can be 0 if OS is not with virtual memory)                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the Encoded Data base address                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void ECE_SetEncodedDataBaseAddress(UINT32 ED_PhysicalBaseAddress, UINT32 ED_VirtualBaseAddress);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_WaitUntilDataIsReady                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  nTiles - number of tiles to wait for                                                   */
+/*                                                                                                         */
+/* Returns:         0 - on succss                                                                          */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine waits until all encoded data is ready                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+INT32 ECE_WaitUntilDataIsReady(UINT32 nTiles);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        ECE_CheckIfFifoIsFull                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine true if FIFO is full                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN ECE_CheckIfFifoIsFull(void);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //_ECE_IF_H
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.c b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.c
new file mode 100755
index 0000000..bf9301b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.c
@@ -0,0 +1,1622 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   EMC_drv.c                                                                                             */
+/*            This file contains Ehternet 100 module implementation                                        */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include "../../../Common/hal_common.h"
+#include "../../../Common/hal_ethernet.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Chips/chip.h"
+
+#include "../../aic/aic_if.h"
+
+#include "emc_regs.h"
+#include "emc_drv.h"
+
+#if !defined(NO_LIBC)
+#include <string.h>
+#endif
+
+//#define VERBOSE_EMC
+/*---------------------------------------------------------------------------------------------------------*/
+/* Debug messages                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(VERBOSE_GLOBAL) || defined(VERBOSE_EMC)
+#ifndef __LINUX_KERNEL_ONLY__
+#define EMC_DEBUG_MSG(fmt,args...) printf ("EMC: " fmt ,##args)
+#else
+#define EMC_DEBUG_MSG(fmt,args...) printk ("EMC: " fmt ,##args)
+#endif
+#else
+#define EMC_DEBUG_MSG(fmt,args...)
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                         Descritors definitions                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TX Mode fields                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TX_MODE_PADEN       0, 1
+#define TX_MODE_CRCAPP      1, 1
+#define TX_MODE_INTEN       2, 1
+#define TX_MODE_OWNER      31, 1
+
+enum TX_MODE_OWNER_T
+{
+    TX_MODE_OWNER_CPU   = 0,
+    TX_MODE_OWNER_DMA   = 1,
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TX Status Fields                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TX_STAT_TBC         0, 16
+#define TX_STAT_TXINTR     16, 1
+#define TX_STAT_DEF        17, 1
+#define TX_STAT_TXCP       19, 1
+#define TX_STAT_EXDEF      20, 1
+#define TX_STAT_NCS        21, 1
+#define TX_STAT_TXBT       22, 1
+#define TX_STAT_LC         23, 1
+#define TX_STAT_TXHA       24, 1
+#define TX_STAT_PAU        25, 1
+#define TX_STAT_SQE        26, 1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RX Status Fields                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RX_STAT_RBC         0, 16
+#define RX_STAT_RXINTR     16, 1
+#define RX_STAT_CRCE       17, 1
+#define RX_STAT_PTLE       19, 1
+#define RX_STAT_RXGD       20, 1
+#define RX_STAT_ALIE       21, 1
+#define RX_STAT_RP         22, 1
+#define RX_STAT_OWNER      30, 2
+
+
+enum RX_STAT_OWNER_T
+{
+    RX_STAT_OWNER_CPU   = 0x0,
+    RX_STAT_OWNER_DMA   = 0x2,
+};
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              Common Masks                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default MAC control values                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFAULT_MCMDR_MASK                              \
+                (                                       \
+                    MASK_FIELD(MCMDR_FDUP)      |       \
+                    MASK_FIELD(MCMDR_SPCRC)     |       \
+                    MASK_FIELD(MCMDR_EnMDC)     |       \
+                    MASK_FIELD(MCMDR_AEP)       |       \
+                    MASK_FIELD(MCMDR_ACP)       |       \
+                    MASK_FIELD(MCMDR_ARP)       |       \
+                    MASK_FIELD(MCMDR_EnRMII)            \
+                )
+
+#define TXRX_GO                                         \
+        (                                               \
+                    MASK_FIELD(MCMDR_RXON)      |       \
+                    MASK_FIELD(MCMDR_TXON)              \
+        )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default Enabled interrupts                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFAULT_MIEN_MASK                               \
+                (                                       \
+                    MASK_FIELD(MIEN_EnTXINTR)   |       \
+                    MASK_FIELD(MIEN_EnTXCP)     |       \
+                    MASK_FIELD(MIEN_EnRXINTR)   |       \
+                    MASK_FIELD(MIEN_EnTDU)      |       \
+                    MASK_FIELD(MIEN_EnRXGD)     |       \
+                    MASK_FIELD(MIEN_EnCRCE)     |       \
+                    MASK_FIELD(MIEN_EnRP)       |       \
+                    MASK_FIELD(MIEN_EnPTLE)     |       \
+                    MASK_FIELD(MIEN_EnRXOV)     |       \
+                    MASK_FIELD(MIEN_EnLC)       |       \
+                    MASK_FIELD(MIEN_EnTXABT)    |       \
+                    MASK_FIELD(MIEN_EnNCS)      |       \
+                    MASK_FIELD(MIEN_EnEXDEF)    |       \
+                    MASK_FIELD(MIEN_EnTXEMP)    |       \
+                    MASK_FIELD(MIEN_EnTxBErr)   |       \
+                    MASK_FIELD(MIEN_EnRxBErr)   |       \
+                    MASK_FIELD(MIEN_EnRDU)      |       \
+                    MASK_FIELD(MIEN_EnCFR)              \
+                )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default CAM settings                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFAULT_CAMCMR_MASK                             \
+                (                                       \
+                    MASK_FIELD(CAMCMR_ECMP)     |       \
+                    MASK_FIELD(CAMCMR_AMP)      |       \
+                    MASK_FIELD(CAMCMR_AUP)      |       \
+                    MASK_FIELD(CAMCMR_ABP)              \
+                )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default TX Mode setting                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFAULT_TXMODE_MASK                             \
+                (                                       \
+                        MASK_FIELD(TX_MODE_PADEN)   |   \
+                        MASK_FIELD(TX_MODE_CRCAPP)  |   \
+                        MASK_FIELD(TX_MODE_INTEN)       \
+                )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                            Local Structures                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RX Cycled buffer                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    UINT32  statRBC;        // RX - Ownership(2bits),RxStatus(14bits),Length(16bits)
+    UINT32  buffer;
+    UINT32  reserved;       // RX - NAT Information/Reserved(32bits)
+    UINT32  next;
+}RX_DESC_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TX cycled buffer                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    UINT32 mode;            // TX - Ownership(1bits),Control bits(3bits),Reserved(28bits)
+    UINT32 buffer;
+    UINT32 statTBC;         // TX - TxStatus(16bits),Length(16bits)
+    UINT32 next;
+}TX_DESC_T;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Private data for each Ethernet module                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Desciptors buffers                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    RX_DESC_T   rxDesc[EMC_NUM_OF_RX_DESC];
+    TX_DESC_T   txDesc[EMC_NUM_OF_TX_DESC];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Rx Buffers pointer array                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    const UINT8* rxBufferArray[EMC_NUM_OF_RX_DESC];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Rx Buffer size                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 rxBufferSize;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Device number                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT devNum;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy address                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT phyNum;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Pointer to the next to process descriptor                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 txNextToProcess;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Pointer to received descriptor                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 rxReceivedPtr;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Callbacks                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    const ETH_CALLBACK_T* Callback;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy callbacks                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    const ETH_PHY_OPS_T*  phyOps;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* MAC address                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT8 mac_address[MAC_ADDR_SIZE];
+} EMC_dev_t;
+
+EMC_dev_t device_state[EMC_NUM_OF_MODULES];
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                  Local Functions Forward declarations                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS   EMC_PhyReset_L          (UINT devNum);
+static HAL_STATUS   EMC_CAM_SetEntry_L      (UINT devNum, UINT32 entry, const UINT8* mac_addr);
+static HAL_STATUS   EMC_Send_L              (UINT devNum, UINT8* packet, UINT32 length);
+static HAL_STATUS   EMC_EnableInt_L         (UINT devNum);
+static HAL_STATUS   EMC_DisableInt_L        (UINT devNum);
+static HAL_STATUS   EMC_TxGo_L              (UINT devNum);
+static HAL_STATUS   EMC_TxDescInit_L        (UINT devNum);
+static HAL_STATUS   EMC_RxDescInit_L        (UINT devNum, const UINT8** RxBuffersArray);
+static HAL_STATUS   EMC_Reset_L             (UINT devNum);
+
+#ifdef BOARD_EMC_USING_GMAC_MDIO
+extern UINT32       GMAC_ReadPhyReg_L       (UINT devNum, UINT phyNum, UINT32 regAddr);
+extern void         GMAC_WritePhyReg_L      (UINT devNum, UINT phyNum, UINT32 regAddr, UINT32 data);
+#else
+static UINT32       EMC_PhyRead_L           (UINT devNum, UINT phy, UINT32 reg);
+static void         EMC_PhyWrite_L          (UINT devNum, UINT phy, UINT32 reg, UINT32 data);
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Interface functions                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Initialize                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Initialize MAC Controller                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Initialize(          UINT            devNum,
+                            const   UINT8*          mac_addr,
+                            const   ETH_CALLBACK_T* callbacks,
+                            const   ETH_PHY_OPS_T*  phyOps,
+                            const   UINT8**         RxBuffersArray,
+                            const   UINT32          buffersSize)
+{
+    EMC_dev_t* dev = &device_state[devNum];
+    HAL_STATUS ret = HAL_OK;
+
+    EMC_DEBUG_MSG("EMC_Initialize executed \n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters verification                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((devNum >= EMC_NUM_OF_MODULES) || (mac_addr == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Cleaning the device structure                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    memset(dev, 0, sizeof(EMC_dev_t));
+    
+	dev->devNum = devNum;
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing receive callback                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev->Callback = callbacks;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting PHY ops                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev->phyOps = phyOps;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing the phy driver                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (dev->phyOps)
+    {
+        #ifdef BOARD_EMC_USING_GMAC_MDIO
+            dev->phyOps->PHY_Init(GMAC_ReadPhyReg_L, GMAC_WritePhyReg_L);
+        #else
+            dev->phyOps->PHY_Init(EMC_PhyRead_L, EMC_PhyWrite_L);
+        #endif
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling clocks                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ConfigureEMCClock(devNum);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Muxing RMII MDIO                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GCR_Mux_RMII(devNum);
+
+#ifdef BOARD_EMC_USING_GMAC_MDIO
+    GCR_Mux_GMII(devNum);
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset EMC module                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ResetEMC(devNum);
+
+ 
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting the HW                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_Reset_L(devNum)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure Maximug Rx buffer size                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev->rxBufferSize = buffersSize;
+
+    if (buffersSize <= DMARFC_MAX_SIZE)
+        REG_WRITE(DMARFC(devNum), buffersSize);
+    else
+        return HAL_ERROR_BAD_SIZE;
+
+
+#if !defined(NO_INTERNAL_IRQ_HANDLER)
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* MAC interrupt vector setup.                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    AIC_RegisterHandler(EMC_TX_INTERRUPT(devNum), EMC_TxIsr,(UINT32)devNum);
+    AIC_RegisterHandler(EMC_RX_INTERRUPT(devNum), EMC_RxIsr,(UINT32)devNum);
+
+    AIC_EnableInt(EMC_TX_INTERRUPT(devNum));
+    AIC_EnableInt(EMC_RX_INTERRUPT(devNum));
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the Tx and Rx Frame Descriptor                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_TxDescInit_L(devNum)) != HAL_OK)
+        return ret;
+
+    if ((ret = EMC_RxDescInit_L(devNum, RxBuffersArray)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the CAM Control register and the MAC address value                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_SetMacAddr(devNum, mac_addr)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure the MAC control registers.                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(MCMDR(devNum), DEFAULT_MCMDR_MASK);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure FIFO thresholds                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FFTCR(devNum) ,0x00100200);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable MAC interrupts                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_EnableInt_L(devNum)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset PHY                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_PhyReset_L(devNum)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Start Rx/Tx state machine                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_MASK(MCMDR(devNum), TXRX_GO);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Halt                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ETH device                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Halt(UINT devNum)
+{
+    HAL_STATUS ret;
+
+    EMC_DEBUG_MSG("EMC_halt executed \n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters verification                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disable interrupts                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_DisableInt_L(devNum)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling the TX/RX                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MCMDR(devNum), MCMDR_TXON, 0);
+    SET_REG_FIELD(MCMDR(devNum), MCMDR_RXON, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* reset RX machine from Halt if inserted                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(RSDR(devNum), 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset TX machine from halt if inserted                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(TSDR(devNum), 0);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Send                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ETH device                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Send(UINT devNum, UINT8* packet, UINT32 length)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters verification                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((devNum >= EMC_NUM_OF_MODULES) || (packet == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    EMC_DEBUG_MSG("EMC_send executed \n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Making sure the cache and memory consistent                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DCACHE_FLUSH_RANGE(packet, length);
+
+    return EMC_Send_L(devNum, packet, length);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_SetMacAddr                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - Device Number                                                            */
+/*                  mac_addr    - MAC address to set                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Set MAC Address                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_SetMacAddr(UINT devNum, const UINT8* mac_addr)
+{
+    HAL_STATUS ret = HAL_OK;
+    EMC_dev_t* dev = &device_state[devNum];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters verification                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((devNum >= EMC_NUM_OF_MODULES) || (mac_addr == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Preserving MAC address                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    memcpy((void*)dev->mac_address, (void*)mac_addr, MAC_ADDR_SIZE);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting MAC address to the first CAM entry                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((ret = EMC_CAM_SetEntry_L(dev->devNum, 0, mac_addr)) != HAL_OK)
+        return ret;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring the CAM                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(CAMCMR(devNum), DEFAULT_CAMCMR_MASK);
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_TxIsr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is Interrupt Service Routine Tx Interrupt request                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_TxIsr(UINT32 devNum)
+{
+    TX_DESC_T*      tx_fd_ptr       = NULL;
+    TX_DESC_T*      next_bd_ptr     = NULL;
+    EMC_dev_t*      dev             = NULL;
+    UINT32          int_status      = 0;
+    BOOLEAN         txRestartNeeded = FALSE;
+    BOOLEAN         txCompleted     = FALSE;
+    HAL_STATUS      txStatus        = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting device structure                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev = &device_state[devNum];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading interrupt status                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    int_status = REG_READ(MISTA(devNum));
+
+    EMC_DEBUG_MSG("Tx ISR! 0x%08X\n", int_status);
+
+    EMC_DEBUG_MSG("Current Tx 0x%08X, Next to Process 0x%08X\n", PHYS_TO_VIRT(REG_READ(CTXDSA(devNum))), dev->txNextToProcess);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clearing all Tx Interrupts                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(MISTA(devNum) , int_status & 0xffff0000);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If Tx Bus Error occurred, we return error                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_VAR_FIELD(int_status, MISTA_TxBErr))
+    {
+        if (dev->Callback)
+        {
+            if(dev->Callback->Error)
+            {
+                dev->Callback->Error(EMC_TYPE, devNum, HAL_ERROR_BUS);
+            }
+        }
+
+        return HAL_ERROR_BUS;
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Reading last transmited packet                                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        tx_fd_ptr = (TX_DESC_T*)(dev->txNextToProcess);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Making the cache consistent                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        DCACHE_FLUSH_RANGE(tx_fd_ptr, sizeof(TX_DESC_T));
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Checking successful completition                                                                */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (READ_VAR_FIELD(tx_fd_ptr->statTBC, TX_STAT_TXCP))
+        {
+            txCompleted = TRUE;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Checking Carrier errors                                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (READ_VAR_FIELD(tx_fd_ptr->statTBC, TX_STAT_NCS))
+        {
+            txStatus = HAL_ERROR_CARRIER;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Checking Abort errors                                                                           */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (READ_VAR_FIELD(tx_fd_ptr->statTBC, TX_STAT_TXBT))
+        {
+            txStatus = HAL_ERROR_PACKET_ABORT;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Sending the finished packet to upper layer                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+        if ((dev->Callback) && txCompleted)
+        {
+            if(dev->Callback->Tx)
+            {
+                /*-----------------------------------------------------------------------------------------*/
+                /* Making the buffer cache-coherent                                                        */
+                /*-----------------------------------------------------------------------------------------*/
+                DCACHE_FLUSH_RANGE((UINT8*)tx_fd_ptr->buffer, (dev->rxBufferSize));
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Invoking the callback                                                                   */
+                /*-----------------------------------------------------------------------------------------*/
+                dev->Callback->Tx(  EMC_TYPE, devNum,                                                   \
+                                    (UINT8*)PHYS_TO_VIRT(tx_fd_ptr->buffer),                            \
+                                    (UINT32)(READ_VAR_FIELD(tx_fd_ptr->statTBC, TX_STAT_TBC)),          \
+                                    txStatus);
+            }
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If transaction completed                                                                        */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (txCompleted)
+        {
+            EMC_DEBUG_MSG("Packet was sent. %08lx, %08lx, %08lx, %08lx\n", (UINT32)tx_fd_ptr, tx_fd_ptr->buffer, tx_fd_ptr->mode, tx_fd_ptr->statTBC);
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Clear processed discriptor                                                                  */
+            /*---------------------------------------------------------------------------------------------*/
+            tx_fd_ptr->mode     = (UINT32)0x0;
+            tx_fd_ptr->buffer   = (UINT32)NULL;
+
+            DCACHE_FLUSH_RANGE(tx_fd_ptr, sizeof(TX_DESC_T));
+
+            dev->txNextToProcess = (UINT32)PHYS_TO_VIRT(tx_fd_ptr->next);
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Fetching next descriptor in the queue                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            next_bd_ptr = (TX_DESC_T*)dev->txNextToProcess;
+            EMC_DEBUG_MSG("Next = %08x, %08x, %08x\n", next_bd_ptr->mode, next_bd_ptr->statTBC, next_bd_ptr->buffer);
+
+            DCACHE_FLUSH_RANGE(next_bd_ptr, sizeof(TX_DESC_T));
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* If next packet is empty, no need to restart the Tx                                          */
+            /*---------------------------------------------------------------------------------------------*/
+            if (next_bd_ptr->buffer == (UINT32)NULL)
+            {
+                txRestartNeeded = FALSE;
+            }
+            /*-----------------------------------------------------------------------------------------------------*/
+            /* If more Tx descriptors left, we need to restart the Tx State machine in the future                  */
+            /*-----------------------------------------------------------------------------------------------------*/
+            else if (READ_VAR_FIELD(int_status, MISTA_TDU))
+            {
+                txRestartNeeded = TRUE;
+            }
+
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Making sure that the packet didn't stay in DMA mode                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        SET_VAR_FIELD(tx_fd_ptr->mode, TX_MODE_OWNER, TX_MODE_OWNER_CPU);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If restart of Tx State Machine needed, we make Tx Go                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (txRestartNeeded)
+    {
+        EMC_TxGo_L(devNum);
+    }
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_RxIsr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is Interrupt Service Routine for Rx interrupt request                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_RxIsr(UINT32 devNum)
+{
+    RX_DESC_T*      CurrentRxPtr    = NULL;
+    RX_DESC_T*      LastRxPtr       = NULL;
+    RX_DESC_T*      FirstRxPtr      = NULL;
+    UINT32          int_status      = 0;
+    EMC_dev_t*      dev             = NULL;
+    HAL_STATUS      rxStatus        = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting device structure                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev = &device_state[devNum];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read Interrupt status                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    int_status = REG_READ(MISTA(devNum));
+
+    EMC_DEBUG_MSG("Rx ISR! 0x%08X\n", int_status);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clear all Rx interrupts                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(MISTA(devNum) , int_status & 0x0000ffff);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If Bus Error occurred, we returning error. The upper layer should reset the on that error           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_VAR_FIELD(int_status, MISTA_RxBErr))
+    {
+        if (dev->Callback)
+        {
+            if(dev->Callback->Error)
+            {
+                dev->Callback->Error(EMC_TYPE, devNum, HAL_ERROR_BUS);
+            }
+        }
+
+        return HAL_ERROR_BUS;
+    }
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If any interrupt that is not from the ignore list occur, we process it                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Get the Last frame descriptor from the HW                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        LastRxPtr = (RX_DESC_T *)PHYS_TO_VIRT(REG_READ(CRXDSA(devNum)));
+        if (REG_READ(CRXDSA(devNum)) == 0)
+        {
+            LastRxPtr = dev->rxDesc;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Making the cache consistent                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        DCACHE_FLUSH_RANGE((UINT8*)dev->rxDesc, (sizeof(RX_DESC_T)*EMC_NUM_OF_RX_DESC));
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Searching first frame to start the process from                                                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        FirstRxPtr = (RX_DESC_T *)PHYS_TO_VIRT(LastRxPtr->next);
+        while ((READ_VAR_FIELD(FirstRxPtr->statRBC, RX_STAT_OWNER) != RX_STAT_OWNER_CPU) && (FirstRxPtr != LastRxPtr))
+        {
+            FirstRxPtr = (RX_DESC_T *)PHYS_TO_VIRT(FirstRxPtr->next);
+        }
+
+        EMC_DEBUG_MSG("Found First and Last ptrs. 0x%08X 0x%08X\n", FirstRxPtr, LastRxPtr);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If the only unprocessed packet is the last packet, we handle it correctly                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (FirstRxPtr == LastRxPtr)
+        {
+            LastRxPtr = (RX_DESC_T *)PHYS_TO_VIRT(LastRxPtr->next);
+        }
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Iterating over all Rx frames                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        for (CurrentRxPtr = FirstRxPtr; CurrentRxPtr != LastRxPtr; CurrentRxPtr = (RX_DESC_T *)PHYS_TO_VIRT(CurrentRxPtr->next))
+        {
+            EMC_DEBUG_MSG("Current Rx = 0x%08X, Status = 0x%08X\n", CurrentRxPtr, CurrentRxPtr->statRBC);
+
+            if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_OWNER) == RX_STAT_OWNER_CPU)
+            {
+                rxStatus = HAL_OK;
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Checking Various Error conditions                                                       */
+                /*-----------------------------------------------------------------------------------------*/
+                if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_CRCE))
+                {
+                    rxStatus = HAL_ERROR_CRC;
+                }
+
+                if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_PTLE))
+                {
+                    rxStatus = HAL_ERROR_BIG_PACKET;
+                }
+
+                if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_ALIE))
+                {
+                    rxStatus = HAL_ERROR_BAD_ALIGNMENT;
+                }
+
+                if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_RP))
+                {
+                    rxStatus = HAL_ERROR_SMALL_PACKET;
+                }
+                EMC_DEBUG_MSG(" EMC_RxIsr -1 Current Rx = 0x%08X, rxStatus = 0x%08X\n", CurrentRxPtr, rxStatus);
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* If Rx frame is good, then process received frame                                        */
+                /*-----------------------------------------------------------------------------------------*/
+                if (READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_RXGD))
+                {
+                    if (dev->Callback)
+                    {
+                        if(dev->Callback->Rx)
+                        {
+                            UINT32 virt_ptr = (UINT32)PHYS_TO_VIRT(CurrentRxPtr->buffer);
+
+                            /*-----------------------------------------------------------------------------*/
+                            /* Making buffer cache consistent with the memory                              */
+                            /*-----------------------------------------------------------------------------*/
+                            EMC_DEBUG_MSG(" EMC_RxIsr -2 CurrentRxPtr->buffer = 0x%08X, virt_ptr = 0x%08X\n", (UINT8*)CurrentRxPtr->buffer, virt_ptr);
+                            EMC_DEBUG_MSG(" EMC_RxIsr -3 CurrentRxPtr->buffer = 0x%08X, dev->rxBufferSize = 0x%08X\n", (UINT8*)CurrentRxPtr->buffer, dev->rxBufferSize);
+                            DCACHE_FLUSH_RANGE((UINT8*)CurrentRxPtr->buffer, dev->rxBufferSize);
+                            EMC_DEBUG_MSG(" EMC_RxIsr -4 CurrentRxPtr->buffer = 0x%08X, dev->rxBufferSize = 0x%08X\n", (UINT8*)CurrentRxPtr->buffer, dev->rxBufferSize);
+
+                            /*-----------------------------------------------------------------------------*/
+                            /* Activating the callback                                                     */
+                            /*-----------------------------------------------------------------------------*/
+                            dev->Callback->Rx(      EMC_TYPE,  devNum,                                  \
+                                                    (UINT8**)&virt_ptr,                                 \
+                                                    READ_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_RBC), \
+                                                    rxStatus);
+
+                            /*-----------------------------------------------------------------------------*/
+                            /* Updating the pointer if needed                                              */
+                            /*-----------------------------------------------------------------------------*/
+                            CurrentRxPtr->buffer = (UINT32)VIRT_TO_PHYS((UINT8*)virt_ptr);
+                        }
+                    }
+                }
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Change ownership to DMA for next use                                                    */
+                /*-----------------------------------------------------------------------------------------*/
+                CurrentRxPtr->statRBC = 0;
+                SET_VAR_FIELD(CurrentRxPtr->statRBC, RX_STAT_OWNER, RX_STAT_OWNER_DMA);
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Making the Cache consistent                                                             */
+                /*-----------------------------------------------------------------------------------------*/
+                DCACHE_FLUSH_RANGE(CurrentRxPtr, (sizeof(RX_DESC_T)));
+            }
+
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If Rx state machine stopped, restart it (as we have available space now)                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_VAR_FIELD(int_status, MISTA_RDU))
+    {
+        REG_WRITE(RSDR(devNum) , 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Local Functions                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_PhyReset_L                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Reset PHY, Auto-Negotiation Enable                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_PhyReset_L(UINT devNum)
+{
+    EMC_dev_t*              dev     = &device_state[devNum];
+    const ETH_PHY_OPS_T*    phyOps  = dev->phyOps;
+    UINT32                  i       = 0;
+    ETH_SPEED_T             speed   = ETH_SPEED_100;
+    ETH_DUPLEX_T            duplex  = ETH_DUPLEX_FULL;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* if no PHY nothing to do                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (phyOps == NULL)
+    {
+        return HAL_OK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* auto scan PHY number                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<32; ++i)
+    {
+        if ((phyOps->PHY_GetID(devNum, i) & (0xfffffff0)) == ((phyOps->Ident) & (0xfffffff0)))
+            break;
+    }
+
+    if (i==32)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* if we reached the end, Auto scan failed                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        EMC_DEBUG_MSG("Auto-scan for PHY FAILED\n");
+        return HAL_ERROR_PHY ;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Auto scan PHYAD completed, PHY address = i                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    dev->phyNum = i;
+    EMC_DEBUG_MSG("Auto-scan for PHY completed. Dev# =%d Found PHY%d with ID 0x%X\n", devNum, dev->phyNum, phyOps->Ident);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting the PHY                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (phyOps->PHY_Reset(devNum, dev->phyNum) != HAL_OK)
+    {
+        EMC_DEBUG_MSG("PHY reset FAILED\n");
+        return HAL_ERROR_PHY;
+    }
+
+    EMC_DEBUG_MSG("PHY reset completed\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Executing auto-negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (phyOps->PHY_AutoNegotiate(devNum, dev->phyNum, ETH_SPEED_100, ETH_DUPLEX_FULL) != HAL_OK)
+    {
+        EMC_DEBUG_MSG("PHY Auto-negotiation FAILED\n");
+        return HAL_ERROR_PHY;
+    }
+
+    EMC_DEBUG_MSG("PHY Auto-negotiation completed\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting PHY capabilities                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (phyOps->PHY_GetLinkCapabilities(devNum, dev->phyNum, &speed, &duplex) != HAL_OK)
+    {
+        EMC_DEBUG_MSG("Failed retriving capabilities\n");
+        return HAL_ERROR_PHY;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* 10/100 MB                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        EMC_DEBUG_MSG("Speed = 10 Mbit\n");
+        SET_REG_FIELD(MCMDR(dev->devNum), MCMDR_OPMOD, 0);
+    }
+    else
+    {
+        EMC_DEBUG_MSG("Speed = 100 Mbit\n");
+        SET_REG_FIELD(MCMDR(dev->devNum), MCMDR_OPMOD, 1);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Full/Half Duplex                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        EMC_DEBUG_MSG("Full Duplex\n");
+        SET_REG_FIELD(MCMDR(dev->devNum), MCMDR_FDUP, 1);
+    }
+    else
+    {
+        EMC_DEBUG_MSG("Half Duplex\n");
+        SET_REG_FIELD(MCMDR(dev->devNum), MCMDR_FDUP, 0);
+    }
+
+
+    return HAL_OK;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_PhyWrite_L                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  reg -                                                                                  */
+/*                  phy -                                                                                  */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write to an MII register via SMI                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void EMC_PhyWrite_L(UINT devNum, UINT phy,  UINT32 reg, UINT32 data)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting data                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(MIID(devNum), data);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Address                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYRAD, reg);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYAD, phy);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYWR, 1);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYPreSP, 0);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_MDCON, 0);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_MDCCR, MIIDA_MDCCR_60);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Writing and waiting for finish                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYBUSY, 1);
+    while ( (READ_REG_FIELD(MIIDA(devNum), MIIDA_PHYBUSY)) );
+
+    REG_WRITE(MIID(devNum) , 0 );
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_PhyRead_L                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  phy -                                                                                  */
+/*                  reg -                                                                                  */
+/*                  val -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine read from an MII register via SMI                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 EMC_PhyRead_L(UINT devNum, UINT phy, UINT32 reg)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting register address                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYRAD, reg);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYAD, phy);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYWR, 0);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_PHYPreSP, 0);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_MDCON, 0);
+    SET_REG_FIELD(MIIDA(devNum), MIIDA_MDCCR, MIIDA_MDCCR_60);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading the register                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MIIDA(devNum) , MIIDA_PHYBUSY, 1);
+    while( (READ_REG_FIELD(MIIDA(devNum), MIIDA_PHYBUSY)) );
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Collecting the data                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return (UINT32)REG_READ(MIID(devNum));
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_CAM_SetEntry_L                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - device number                                                            */
+/*                  entry       - entry number                                                             */
+/*                  mac_addr    - MAC addr                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine fills CAM entry                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_CAM_SetEntry_L(UINT devNum, UINT32 entry, const UINT8* mac_addr)
+{
+    UINT32  i       = 0;
+    UINT32  gCam0M  = 0;
+    UINT32  gCam0L  = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Split MAC Address to CamOM and CamOL                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<4; ++i)
+    {
+        gCam0M = (gCam0M << 8) | mac_addr[i];
+    }
+
+    for (i=4; i<6; ++i)
+    {
+        gCam0L = (gCam0L << 8) | mac_addr[i];
+    }
+
+    gCam0L <<= 16;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Write CAM entry                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(CAMxM_Reg(devNum, entry), gCam0M);
+    REG_WRITE(CAMxL_Reg(devNum, entry), gCam0L);
+
+    SET_REG_BIT(CAMEN(devNum), entry);
+
+    return HAL_OK;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Send_L                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev    - device control structure ptr                                                  */
+/*                  packet - packet data ptr                                                               */
+/*                  length - packet size                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs interrupt driven packet sending on the given ETH                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Send_L(UINT devNum, UINT8* packet, UINT32 length)
+{
+    TX_DESC_T* tx_fd_ptr        = NULL;
+    TX_DESC_T* txNextFreePtr    = NULL;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+
+    EMC_DEBUG_MSG("EMC_Send_L. Length = %x\n", length);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting the descriptor for sending                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    tx_fd_ptr = (TX_DESC_T*)PHYS_TO_VIRT(REG_READ(CTXDSA(devNum)));
+    if ((void*)VIRT_TO_PHYS(tx_fd_ptr) == NULL)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If no 'current' descriptor we take the first                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        tx_fd_ptr = (TX_DESC_T*)PHYS_TO_VIRT(REG_READ(TXDLSA(devNum)));
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if we the buffer is not in sending progress by DMA                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if(READ_VAR_FIELD(tx_fd_ptr->mode, TX_MODE_OWNER) == TX_MODE_OWNER_DMA)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If current descriptor is busy, find the first empty descriptor that follows                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        txNextFreePtr = (TX_DESC_T*)PHYS_TO_VIRT(tx_fd_ptr->next);
+
+        while ((txNextFreePtr != tx_fd_ptr) && (READ_VAR_FIELD(txNextFreePtr->mode, TX_MODE_OWNER) == TX_MODE_OWNER_DMA))
+        {
+            txNextFreePtr = (TX_DESC_T*)PHYS_TO_VIRT(txNextFreePtr->next);
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If all TX descriptors full, report overflow and exit                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (txNextFreePtr == tx_fd_ptr)
+        {
+            return HAL_ERROR_FIFO_OVERFLOW;
+        }
+
+        tx_fd_ptr = txNextFreePtr;
+
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting the packet for sending                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    tx_fd_ptr->buffer = (UINT32)VIRT_TO_PHYS(packet);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set TX Frame flag & Length Field                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    tx_fd_ptr->statTBC = 0;
+    SET_VAR_FIELD(tx_fd_ptr->statTBC, TX_STAT_TBC, length);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Descriptor default mode mask                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    tx_fd_ptr->mode = DEFAULT_TXMODE_MASK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Change ownership to DMA                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(tx_fd_ptr->mode, TX_MODE_OWNER, TX_MODE_OWNER_DMA);
+
+    EMC_DEBUG_MSG("Adding packet to Tx queue. %08lx, %08lx, %08lx\n", (UINT32)tx_fd_ptr, PHYS_TO_VIRT(tx_fd_ptr->buffer), tx_fd_ptr->mode);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Flushing the descriptor from the cache to memory                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DCACHE_FLUSH_RANGE(tx_fd_ptr, sizeof(TX_DESC_T));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable MAC Tx control register                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    EMC_TxGo_L(devNum);
+
+    return HAL_OK;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_TxDescInit_L                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Initialize Tx frame descriptor area-buffers                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_TxDescInit_L(UINT devNum)
+{
+    EMC_dev_t*  dev             = &device_state[devNum];
+    TX_DESC_T*  curr_bd_ptr     = NULL;
+    TX_DESC_T*  last_bd_ptr     = NULL;
+    TX_DESC_T*  start_bd_ptr    = NULL;
+    UINT32      i               = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Get Frame descriptor's base address.                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    curr_bd_ptr = (TX_DESC_T *)dev->txDesc;
+
+    dev->txNextToProcess = (UINT32)curr_bd_ptr;
+    REG_WRITE(TXDLSA(devNum) , (UINT32)(VIRT_TO_PHYS(curr_bd_ptr)));
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Generate linked list.                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    start_bd_ptr = curr_bd_ptr;
+
+    for(i=0; i<EMC_NUM_OF_TX_DESC; ++i)
+    {
+        if (last_bd_ptr == NULL)
+        {
+            last_bd_ptr = (TX_DESC_T*)(((UINT32)curr_bd_ptr));
+        }
+        else
+        {
+            last_bd_ptr->next = ((UINT32)VIRT_TO_PHYS(curr_bd_ptr));
+        }
+
+        curr_bd_ptr->mode       = 0;
+        SET_VAR_MASK (curr_bd_ptr->mode, DEFAULT_TXMODE_MASK);
+        SET_VAR_FIELD(curr_bd_ptr->mode, TX_MODE_OWNER, TX_MODE_OWNER_CPU);
+
+        curr_bd_ptr->buffer     = (UINT32)NULL;
+        curr_bd_ptr->statTBC    = (UINT32)0x0;
+        curr_bd_ptr->next       = (UINT32)NULL;
+
+        last_bd_ptr = curr_bd_ptr;
+        curr_bd_ptr++;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Make Frame descriptor to ring buffer type.                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    curr_bd_ptr--;
+    curr_bd_ptr->next = (UINT32)VIRT_TO_PHYS(start_bd_ptr);
+
+    return HAL_OK;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_RxDescInit_L                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Initialize Rx frame descriptor area-buffers                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_RxDescInit_L(UINT devNum, const UINT8** RxBuffersArray)
+{
+    EMC_dev_t*  dev             = &device_state[devNum];
+    RX_DESC_T*  curr_bd_ptr     = NULL;
+    RX_DESC_T*  start_bd_ptr    = NULL;
+    RX_DESC_T*  last_bd_ptr     = NULL;
+    UINT32      i               = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Get Frame descriptor's base address.                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    curr_bd_ptr = (RX_DESC_T *)dev->rxDesc;
+
+    dev->rxReceivedPtr = (UINT32)curr_bd_ptr;
+    REG_WRITE(RXDLSA(devNum), (UINT32)(VIRT_TO_PHYS(curr_bd_ptr)));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Generate linked list.                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    curr_bd_ptr = (RX_DESC_T*)dev->rxReceivedPtr;
+    start_bd_ptr = curr_bd_ptr;
+
+    for (i=0; i<EMC_NUM_OF_RX_DESC; ++i)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Preserving Rx Buffers array                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        dev->rxBufferArray[i] = RxBuffersArray[i];
+
+        if (last_bd_ptr == NULL)
+            last_bd_ptr = (RX_DESC_T *)(((UINT32)curr_bd_ptr));
+        else
+            last_bd_ptr->next = (UINT32)VIRT_TO_PHYS(curr_bd_ptr);
+
+        curr_bd_ptr->statRBC    = 0;
+        SET_VAR_FIELD(curr_bd_ptr->statRBC, RX_STAT_OWNER, RX_STAT_OWNER_DMA);
+
+        curr_bd_ptr->buffer     = (UINT32)(VIRT_TO_PHYS((UINT8*)RxBuffersArray[i]));
+        curr_bd_ptr->reserved   = (UINT32)0x0;
+        curr_bd_ptr->next       = (UINT32)NULL;
+
+        last_bd_ptr= curr_bd_ptr;
+        curr_bd_ptr++;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Make Frame descriptor to ring buffer type.                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    curr_bd_ptr--;
+    curr_bd_ptr->next = (UINT32)VIRT_TO_PHYS(start_bd_ptr);
+
+    return HAL_OK;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_TxGo_L                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine MAC Transfer Start for interactive mode                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_TxGo_L(UINT devNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If Tx is not ON we turn it ON                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!(READ_REG_FIELD(MCMDR(devNum), MCMDR_TXON)))
+    {
+        SET_REG_FIELD(MCMDR(devNum), MCMDR_TXON, 1);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Start Tx if Tx State machine is halted                                                              */
+    /* (if the state machine is not halted, the following line have no effect)                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(TSDR(devNum) , 0);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_EnableInt_L                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enables MAC interrupts                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_EnableInt_L(UINT devNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    REG_WRITE(MIEN(devNum), DEFAULT_MIEN_MASK);
+
+    return HAL_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_DisableInt_L                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disables MAC interrupts                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_DisableInt_L(UINT devNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    REG_WRITE(MIEN(devNum), 0x0);
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Reset_L                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SW reset of the EMC module                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Reset_L(UINT devNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameter Check                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= EMC_NUM_OF_MODULES)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting the module externally                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ResetEMC(devNum);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset the module internally                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(MCMDR(devNum), MCMDR_SWR, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till EMC get out from reset                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(MCMDR(devNum), MCMDR_SWR));
+
+    return HAL_OK;
+}
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.h b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.h
new file mode 100755
index 0000000..611f0e8
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_drv.h
@@ -0,0 +1,20 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   emc_drv.h                                                                                             */
+/*            This file contains EMC interface                                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _EMC_DRV_H
+#define _EMC_DRV_H
+
+#include "../emc_if.h"
+
+#endif //_EMC_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_regs.h b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_regs.h
new file mode 100755
index 0000000..7cf765d
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/emc/Hermon_IP/emc_regs.h
@@ -0,0 +1,226 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   emc_regs.h                                                                                            */
+/*            This file contains definitions of EMC registers                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _EMC_REGS_H
+#define _EMC_REGS_H
+
+#include "../../../Chips/chip.h"
+
+
+#define CAM0M_Base(port)    (EMC_BASE_ADDR(port)+0x08)
+#define CAM0L_Base(port)    (EMC_BASE_ADDR(port)+0x0c)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                REGISTERS                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC Control Registers                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CAMCMR(port)       ((EMC_BASE_ADDR(port)+0x00)), EMC_ACCESS, 32     // CAM Registers
+#define CAMEN(port)        ((EMC_BASE_ADDR(port)+0x04)), EMC_ACCESS, 32
+#define CAMxM_Reg(port,x)  ((CAM0M_Base(port)+(x)*0x8)), EMC_ACCESS, 32
+#define CAMxL_Reg(port,x)  ((CAM0L_Base(port)+(x)*0x8)), EMC_ACCESS, 32
+
+#define TXDLSA(port)       ((EMC_BASE_ADDR(port)+0x88)), EMC_ACCESS, 32     // Transmit Descriptor Link List Start Address Register
+#define RXDLSA(port)       ((EMC_BASE_ADDR(port)+0x8C)), EMC_ACCESS, 32     // Receive Descriptor Link List Start Address Register
+#define MCMDR(port)        ((EMC_BASE_ADDR(port)+0x90)), EMC_ACCESS, 32     // MAC Command Register
+#define MIID(port)         ((EMC_BASE_ADDR(port)+0x94)), EMC_ACCESS, 32     // MII Management Data Register
+#define MIIDA(port)        ((EMC_BASE_ADDR(port)+0x98)), EMC_ACCESS, 32     // MII Management Control and Address Register
+#define FFTCR(port)        ((EMC_BASE_ADDR(port)+0x9C)), EMC_ACCESS, 32     // FIFO Threshold Control Register
+#define TSDR(port)         ((EMC_BASE_ADDR(port)+0xa0)), EMC_ACCESS, 32     // Transmit Start Demand Register
+#define RSDR(port)         ((EMC_BASE_ADDR(port)+0xa4)), EMC_ACCESS, 32     // Receive Start Demand Register
+#define DMARFC(port)       ((EMC_BASE_ADDR(port)+0xa8)), EMC_ACCESS, 32     // Maximum Receive Frame Control Register
+#define MIEN(port)         ((EMC_BASE_ADDR(port)+0xac)), EMC_ACCESS, 32     // MAC Interrupt Enable Register
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC Status Registers                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MISTA(port)        ((EMC_BASE_ADDR(port)+0xb0)), EMC_ACCESS, 32     // MAC Interrupt Status Register
+#define MGSTA(port)        ((EMC_BASE_ADDR(port)+0xb4)), EMC_ACCESS, 32     // MAC General Status Register
+#define MPCNT(port)        ((EMC_BASE_ADDR(port)+0xb8)), EMC_ACCESS, 32     // Missed Packet Count Register
+#define MRPC(port)         ((EMC_BASE_ADDR(port)+0xbc)), EMC_ACCESS, 32     // MAC Receive Pause Count Register
+#define MRPCC(port)        ((EMC_BASE_ADDR(port)+0xc0)), EMC_ACCESS, 32     // MAC Receive Pause Current Count Register
+#define MREPC(port)        ((EMC_BASE_ADDR(port)+0xc4)), EMC_ACCESS, 32     // MAC Remote Pause Count Register
+#define DMARFS(port)       ((EMC_BASE_ADDR(port)+0xc8)), EMC_ACCESS, 32     // DMA Receive Frame Status Register
+#define CTXDSA(port)       ((EMC_BASE_ADDR(port)+0xcc)), EMC_ACCESS, 32     // Current Transmit Descriptor Start Address Register
+#define CTXBSA(port)       ((EMC_BASE_ADDR(port)+0xd0)), EMC_ACCESS, 32     // Current Transmit Buffer Start Address Register
+#define CRXDSA(port)       ((EMC_BASE_ADDR(port)+0xd4)), EMC_ACCESS, 32     // Current Receive Descriptor Start Address Register
+#define CRXBSA(port)       ((EMC_BASE_ADDR(port)+0xd8)), EMC_ACCESS, 32     // Current Receive Buffer Start Address Register
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* EMC Diagnostic Registers                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RXFSM(port)        ((EMC_BASE_ADDR(port)+0x200)), EMC_ACCESS, 32    // Receive Finite State Machine Register
+#define TXFSM(port)        ((EMC_BASE_ADDR(port)+0x204)), EMC_ACCESS, 32    // Transmit Finite State Machine Register
+#define FSM0(port)         ((EMC_BASE_ADDR(port)+0x208)), EMC_ACCESS, 32    // Finite State Machine Register 0
+#define FSM1(port)         ((EMC_BASE_ADDR(port)+0x20c)), EMC_ACCESS, 32    // Finite State Machine Register 1
+#define DCR(port)          ((EMC_BASE_ADDR(port)+0x210)), EMC_ACCESS, 32    // Debug Configuration Register
+#define DMMIR(port)        ((EMC_BASE_ADDR(port)+0x214)), EMC_ACCESS, 32    // Debug Mode MAC Information Register
+#define BISTR(port)        ((EMC_BASE_ADDR(port)+0x300)), EMC_ACCESS, 32    // BIST Mode Register
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Register Fields                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC Command Register(MCMDR)                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MCMDR_RXON          0, 1        // Receive ON
+#define MCMDR_ALP           1, 1        // Accept Long Packet
+#define MCMDR_ARP           2, 1        // Accept Runt Packet
+#define MCMDR_ACP           3, 1        // Accept Control Packet
+#define MCMDR_AEP           4, 1        // Accept Error Packet
+#define MCMDR_SPCRC         5, 1        // Accept Strip CRC Value
+#define MCMDR_TXON          8, 1        // Transmit On
+#define MCMDR_NDEF          9, 1        // No defer
+#define MCMDR_SDPZ         16, 1        // Send Pause
+#define MCMDR_EnSQE        17, 1        // Enable SQE test
+#define MCMDR_FDUP         18, 1        // Full Duplex
+#define MCMDR_EnMDC        19, 1        // Enable MDC signal
+#define MCMDR_OPMOD        20, 1        // Operation Mode
+#define MCMDR_LBK          21, 1        // Loop Back
+#define MCMDR_EnRMII       22, 1        // Enable RMII
+#define MCMDR_LAN          23, 1        // LAN Port Setting Mode
+#define MCMDR_SWR          24, 1        // Software Reset
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC Interrupt Status Register(MISTA)                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MISTA_RXINTR        0, 1        // Interrupt on Receive
+#define MISTA_CRCE          1, 1        // CRC Error
+#define MISTA_RXOV          2, 1        // Receive FIFO Overflow error
+#define MISTA_PTLE          3, 1        // Packet Too Long Error
+#define MISTA_RXGD          4, 1        // Receive Good
+#define MISTA_ALIE          5, 1        // Alignment Error
+#define MISTA_RP            6, 1        // Runt Packet
+#define MISTA_MMP           7, 1        // More Missed Packets than miss rolling over counter flag
+#define MISTA_DFOI          8, 1        // DMA receive frame over maximum size interrupt
+#define MISTA_DENI          9, 1        // DMA early notification interrupt
+#define MISTA_RDU          10, 1        // Receive Descriptor Unavailable interrupt
+#define MISTA_RxBErr       11, 1        // Receive Bus Error interrupt
+#define MISTA_NATOK        12, 1        // NAT Processing OK
+#define MISTA_NATErr       13, 1        // NAT Processing Error
+#define MISTA_CFR          14, 1        // Control Frame Receive
+#define MISTA_TXINTR       16, 1        // Interrupt on Transmit
+#define MISTA_TXEMP        17, 1        // Transmit FIFO Empty
+#define MISTA_TXCP         18, 1        // Transmit Completion
+#define MISTA_EXDEF        19, 1        // Defer
+#define MISTA_NCS          20, 1        // No Carrier Sense
+#define MISTA_TXABT        21, 1        // Transmit Abort
+#define MISTA_LC           22, 1        // Late Collision
+#define MISTA_TDU          23, 1        // Transmit Descriptor Unavailable interrupt
+#define MISTA_TxBErr       24, 1        // Transmit Bus Error interrupt
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC General Status Register(MGSTA)                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MGSTA_CFR           0, 1        // Control Frame Received
+#define MGSTA_RXHA          1, 1        // Reception Halted
+#define MGSTA_RFFull        2, 1        // RxFIFO is full
+#define MGSTA_CCNT          4, 4        // Collision Count
+#define MGSTA_DEF           8, 1        // Deferred transmission
+#define MGSTA_PAU           9, 1        // Pause Bit
+#define MGSTA_SQE          10, 1        // Signal Quality Error
+#define MGSTA_TXHA         11, 1        // Transmission Halted
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC MII Management Data Control and Address Register(MIIDA)                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MIIDA_PHYRAD        0, 5        // PHY Register address
+#define MIIDA_PHYAD         8, 5        // PHY address
+#define MIIDA_PHYWR        16, 1        // Write Operation
+#define MIIDA_PHYBUSY      17, 1        // Busy Bit
+#define MIIDA_PHYPreSP     18, 1        // Preamble Suppress
+#define MIIDA_MDCON        19, 1        // MDC Clock ON always
+#define MIIDA_MDCCR        20, 4        // MDC clock rating
+
+enum MIIDA_MDCCR_T
+{
+    MIIDA_MDCCR_4       = 0x00,
+    MIIDA_MDCCR_6       = 0x01,
+    MIIDA_MDCCR_8       = 0x02,
+    MIIDA_MDCCR_12      = 0x03,
+    MIIDA_MDCCR_16      = 0x04,
+    MIIDA_MDCCR_20      = 0x05,
+    MIIDA_MDCCR_24      = 0x06,
+    MIIDA_MDCCR_28      = 0x07,
+    MIIDA_MDCCR_30      = 0x08,
+    MIIDA_MDCCR_32      = 0x09,
+    MIIDA_MDCCR_36      = 0x0A,
+    MIIDA_MDCCR_40      = 0x0B,
+    MIIDA_MDCCR_44      = 0x0C,
+    MIIDA_MDCCR_48      = 0x0D,
+    MIIDA_MDCCR_54      = 0x0E,
+    MIIDA_MDCCR_60      = 0x0F,
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CAM Command Register(CAMCMR)                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CAMCMR_AUP          0, 1        // Accept Packets with Unicast Address
+#define CAMCMR_AMP          1, 1        // Accept Packets with Multicast Address
+#define CAMCMR_ABP          2, 1        // Accept Packets with Broadcast Address
+#define CAMCMR_CCAM         3, 1        // 0: Accept Packets CAM Recognizes and Reject Others
+                                        // 1: Reject Packets CAM Recognizes and Accept Others
+#define CAMCMR_ECMP         4, 1        // Enable CAM Compare
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MAC Interrupt Enable Register(MIEN)                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MIEN_EnRXINTR       0, 1        // Enable Interrupt on Receive Interrupt
+#define MIEN_EnCRCE         1, 1        // Enable CRC Error Interrupt
+#define MIEN_EnRXOV         2, 1        // Enable Receive FIFO Overflow Interrupt
+#define MIEN_EnPTLE         3, 1        // Enable Packet Too Long Interrupt
+#define MIEN_EnRXGD         4, 1        // Enable Receive Good Interrupt
+#define MIEN_EnALIE         5, 1        // Enable Alignment Error Interrupt
+#define MIEN_EnRP           6, 1        // Enable Runt Packet on Receive Interrupt
+#define MIEN_EnMMP          7, 1        // Enable More Missed Packets Interrupt
+#define MIEN_EnDFO          8, 1        // Enable DMA receive frame over maximum size Interrupt
+#define MIEN_EnDEN          9, 1        // Enable DMA early notification Interrupt
+#define MIEN_EnRDU         10, 1        // Enable Receive Descriptor Unavailable Interrupt
+#define MIEN_EnRxBErr      11, 1        // Enable Receive Bus ERROR interrupt
+#define MIEN_EnNATOK       12, 1        // Enable NAT Processing OK Interrupt
+#define MIEN_EnNATErr      13, 1        // Enable NAT Processing Error Interrupt
+#define MIEN_EnCFR         14, 1        // Enable Control Frame Receive Interrupt
+#define MIEN_EnTXINTR      16, 1        // Enable Interrupt on Transmit Interrupt
+#define MIEN_EnTXEMP       17, 1        // Enable Transmit FIFO Empty Interrupt
+#define MIEN_EnTXCP        18, 1        // Enable Transmit Completion Interrupt
+#define MIEN_EnEXDEF       19, 1        // Enable Defer Interrupt
+#define MIEN_EnNCS         20, 1        // Enable No Carrier Sense Interrupt
+#define MIEN_EnTXABT       21, 1        // Enable Transmit Abort Interrupt
+#define MIEN_EnLC          22, 1        // Enable Late Collision Interrupt
+#define MIEN_EnTDU         23, 1        // Enable Transmit Descriptor Unavailable Interrupt
+#define MIEN_EnTxBErr      24, 1        // Enable Transmit Bus ERROR Interrupt
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DMARFC                                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DMARFC_MAX_SIZE     0xFFFF
+
+
+#endif // _EMC_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.c b/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.c
new file mode 100755
index 0000000..2ed72c5
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   emc_if.c                                                                                              */
+/*            This file contains EMC module driver selector                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(EMC_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(emc, EMC_MODULE_TYPE)
+#endif    
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.h b/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.h
new file mode 100755
index 0000000..813d82f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/emc/emc_if.h
@@ -0,0 +1,123 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   emc_if.h                                                                                              */
+/*            This file contains EMC interface                                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _EMC_IF_H
+#define _EMC_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_common.h"
+#include "../../Common/hal_error.h"
+#include "../../Common/hal_ethernet.h"
+
+
+#ifndef EMC_NUM_OF_RX_DESC
+#define EMC_NUM_OF_RX_DESC   32
+#endif
+
+#ifndef EMC_NUM_OF_TX_DESC
+#define EMC_NUM_OF_TX_DESC   32
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Initialize                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Initialize MAC Controller                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Initialize(          UINT            devNum,
+                            const   UINT8*          mac_addr,
+                            const   ETH_CALLBACK_T* callbacks,
+                            const   ETH_PHY_OPS_T*  phyOps,
+                            const   UINT8**         RxBuffersArray,
+                            const   UINT32          buffersSize);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Halt                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ETH device                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Halt(UINT devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_Send                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Send data to ETH device                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_Send(UINT devNum, UINT8* packet, UINT32 length);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_SetMacAddr                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - Device Number                                                            */
+/*                  mac_addr    - MAC address to set                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Set MAC Address                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_SetMacAddr(UINT devNum, const UINT8* mac_addr);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_TxIsr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is Interrupt Service Routine Tx Interrupt request                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_TxIsr(UINT32 devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        EMC_RxIsr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is Interrupt Service Routine for Rx interrupt request                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS EMC_RxIsr(UINT32 devNum);
+
+
+
+#endif
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_defs.h b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_defs.h
new file mode 100755
index 0000000..196fa3a
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_defs.h
@@ -0,0 +1,180 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fiu_defs.h                                                                                            */
+/*            This file contains FIU definitions                                                           */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _FIU_DEFS_H
+#define _FIU_DEFS_H
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defines                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define FIU_CAPABILITY_QUAD_READ
+#define FIU_CAPABILITY_SUPPORT_128MB_FLASH
+#define FIU_CAPABILITY_CHIP_SELECT
+#define FIU_CAPABILITY_SPI_X
+
+#define WIN_LIMIT_4K_SHIFT  12
+#define BITS_7_0            0xFF
+#define BITS_15_8           0xFF00
+#define BITS_23_16          0xFF0000
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Typedef Definitions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum _spi_w_burst_t 
+{
+    FIU_W_BURST_ONE_BYTE        = 0,
+//    FIU_W_BURST_FOUR_BYTE       = 2,
+    FIU_W_BURST_SIXTEEN_BYTE    = 3
+} SPI_w_burst_t;
+
+typedef enum _spi_r_burst_t 
+{
+    FIU_R_BURST_ONE_BYTE        = 0,
+//    FIU_R_BURST_FOUR_BYTE       = 2,
+    FIU_R_BURST_SIXTEEN_BYTE    = 3
+} SPI_r_burst_t;
+
+typedef enum _spi_w_protect_int_t 
+{
+  SPI_W_PROTECT_INT_DISABLE = 0,
+  SPI_W_PROTECT_INT_ENABLE  = 1
+} SPI_w_protect_int_t;
+
+typedef enum _spi_incorect_access_int_t 
+{
+  SPI_INCORECT_ACCESS_INT_DISABLE   = 0,
+  SPI_INCORECT_ACCESS_INT_ENABLE    = 1
+} SPI_incorect_access_int_t;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Read Mode                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum _spi_read_mode_t 
+{
+    FIU_NORMAL_READ             = 0,
+    FIU_FAST_READ               = 1,
+    FIU_FAST_READ_DUAL_OUTPUT   = 2,
+    FIU_FAST_READ_DUAL_IO       = 3,
+#ifdef FIU_CAPABILITY_QUAD_READ
+    FIU_FAST_READ_QUAD_IO       = 4,
+#endif
+#ifdef FIU_CAPABILITY_SPI_X
+    FIU_FAST_READ_SPI_X         = 5,
+#endif
+    FIU_READ_MODE_NUM
+
+} SPI_read_mode_t;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Device Size                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum _spi_dev_size_t
+{
+    FIU_DEV_SIZE_128KB          = 1,
+    FIU_DEV_SIZE_256KB          = 2,
+    FIU_DEV_SIZE_512KB          = 4,
+    FIU_DEV_SIZE_1MB            = 8,
+    FIU_DEV_SIZE_2MB            = 16,
+    FIU_DEV_SIZE_4MB            = 32,
+#if defined FIU_CAPABILITY_SUPPORT_128MB_FLASH || defined FIU_CAPABILITY_SUPPORT_64MB_FLASH || defined FIU_CAPABILITY_SUPPORT_16MB_FLASH || defined FIU_CAPABILITY_SUPPORT_8MB_FLASH
+    FIU_DEV_SIZE_8MB            = 64,
+#if defined FIU_CAPABILITY_SUPPORT_128MB_FLASH || defined FIU_CAPABILITY_SUPPORT_64MB_FLASH || defined FIU_CAPABILITY_SUPPORT_16MB_FLASH
+    FIU_DEV_SIZE_16MB           = 128,
+#if defined FIU_CAPABILITY_SUPPORT_128MB_FLASH || defined FIU_CAPABILITY_SUPPORT_64MB_FLASH
+    FIU_DEV_SIZE_32MB           = 256,
+    FIU_DEV_SIZE_64MB           = 512,
+#if defined FIU_CAPABILITY_SUPPORT_128MB_FLASH
+    FIU_DEV_SIZE_128MB          = 1024
+#endif
+#endif
+#endif
+#endif
+} SPI_dev_size_t;
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU UMA data size                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum _spi_uma_data_size_t
+{
+    FIU_UMA_DATA_SIZE_0         = 0,
+    FIU_UMA_DATA_SIZE_1         = 1,
+    FIU_UMA_DATA_SIZE_2         = 2,
+    FIU_UMA_DATA_SIZE_3         = 3,
+    FIU_UMA_DATA_SIZE_4         = 4,
+	FIU_UMA_DATA_SIZE_5         = 5,
+    FIU_UMA_DATA_SIZE_6         = 6,
+    FIU_UMA_DATA_SIZE_7         = 7,
+    FIU_UMA_DATA_SIZE_8         = 8,
+    FIU_UMA_DATA_SIZE_9         = 9,
+    FIU_UMA_DATA_SIZE_10         = 10,
+    FIU_UMA_DATA_SIZE_11         = 11,
+    FIU_UMA_DATA_SIZE_12         = 12,
+    FIU_UMA_DATA_SIZE_13         = 13,
+    FIU_UMA_DATA_SIZE_14         = 14,
+	FIU_UMA_DATA_SIZE_15         = 15,
+    FIU_UMA_DATA_SIZE_16         = 16
+
+} SPI_uma_data_size_t;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Field value enumeration                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum _spi_drd_cfg_addsiz_t
+{
+    FIU_DRD_CFG_ADDSIZE_24BIT = 0,   /* 0 0: 24 bits (3 bytes) (default).  */
+    FIU_DRD_CFG_ADDSIZE_32BIT = 1    /* 0 1: 32 bits (4 bytes)             */
+}  SPI_drd_cfg_addsiz_t;
+
+
+typedef enum _spi_trans_status_t
+{
+    FIU_TRANS_STATUS_DONE        = 0,
+    FIU_TRANS_STATUS_IN_PROG     = 1
+} SPI_trans_status_t;
+
+
+#if 0
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Chip Select                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum  FIU_CS_T_tag
+{
+    FIU_CS_0 = 0,
+    FIU_CS_1 = 1,
+    FIU_CS_2 = 2,
+    FIU_CS_3 = 3
+} FIU_CS_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Illegal Address (IAD) trap generation                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FIU_IAD_TRAP_T_tag
+{
+  FIU_IAD_TRAP_DISABLE          = 0,
+  FIU_IAD_TRAP_ENABLE           = 1
+} FIU_IAD_TRAP_T;
+
+#endif
+
+
+
+#endif //_FIU_DEFS_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.c b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.c
new file mode 100755
index 0000000..55ebafd
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.c
@@ -0,0 +1,529 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fui_drv.c                                                                                             */
+/*            This file contains interface to Flash Interface Unit (FUI)                                   */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../../Chips/chip_if.h"
+
+#include "fiu_regs.h"
+#include "fiu_drv.h"
+#include "fiu_defs.h"
+
+#define WRITE_TRANSFER_16_BYTES
+
+#ifdef WRITE_TRANSFER_16_BYTES      // command=1  data=15
+#define CHUNK_SIZE  16
+#endif
+
+#ifdef WRITE_TRANSFER_17_BYTES      // command=1 data=16
+#define CHUNK_SIZE  17
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Global define:  FIU_module holds the FIU current module number. It is selected using FIU_Select.        */
+/*                 This is written like this as to not to change the IF for chips with a single FIU module.*/
+/*---------------------------------------------------------------------------------------------------------*/
+void *memcpy(void *dest, const void *src, UINT32 n);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local functions declarations                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_ConfigReadMode                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  num_device       - number of flash devices connected to the chip                       */
+/*                  read_mode - FIU read mode                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures the FIU read mode.                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void FIU_ConfigReadMode (UINT num_device, 
+                         SPI_read_mode_t read_mode)
+{
+    FIU_MODULE_T FIU_module = (num_device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_EXEC_DONE, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Change the access type. Warning: Once you go QUAD, you can't go back                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( read_mode == FIU_FAST_READ)
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module),  FIU_DRD_CFG_ACCTYPE, 0);
+    }
+    else if ( (read_mode == FIU_FAST_READ_DUAL_IO)  ||  (read_mode == FIU_FAST_READ_DUAL_OUTPUT) )
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module),  FIU_DRD_CFG_ACCTYPE, 1);
+    }
+#ifdef FIU_CAPABILITY_QUAD_READ
+    else if (read_mode == FIU_FAST_READ_QUAD_IO)
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module),  FIU_DRD_CFG_ACCTYPE, 2);
+    }
+#endif
+#ifdef FIU_CAPABILITY_SPI_X
+    else if (read_mode == FIU_FAST_READ_SPI_X)
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module),  FIU_DRD_CFG_ACCTYPE, 3);
+    }
+#endif
+    else
+    {
+        ASSERT(FALSE);
+    }
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_ConfigFlashSize                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  num_device       - number of flash devices connected to the chip                       */
+/*                  flash_size - Flash size to configure                                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures FIU flash size                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void FIU_ConfigFlashSize(UINT num_device, 
+                         SPI_dev_size_t flash_size)
+{
+    FIU_MODULE_T FIU_module = (num_device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure flash address                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( flash_size <= FIU_DEV_SIZE_16MB )
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module) ,  FIU_DRD_CFG_ADDSIZ,  FIU_DRD_CFG_ADDSIZE_24BIT) ;
+        SET_REG_FIELD( FIU_DWR_CFG(FIU_module) ,  FIU_DWR_CFG_ADDSIZ,  FIU_DRD_CFG_ADDSIZE_24BIT) ;
+    }
+    else
+    {
+        SET_REG_FIELD( FIU_DRD_CFG(FIU_module) ,  FIU_DRD_CFG_ADDSIZ,  FIU_DRD_CFG_ADDSIZE_32BIT) ;
+        SET_REG_FIELD( FIU_DWR_CFG(FIU_module) ,  FIU_DWR_CFG_ADDSIZ,  FIU_DRD_CFG_ADDSIZE_32BIT) ;
+    }
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_ConfigBurstSize                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  num_device       - number of flash devices connected to the chip                       */
+/*                  read_burst_size     - FIU read burst size                                              */
+/*                  write_burst_size    - FIU write burst size                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures read/write burst size                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void FIU_ConfigBurstSize (UINT num_device, 
+                          SPI_r_burst_t read_burst_size,
+                          SPI_w_burst_t write_burst_size)
+{
+    FIU_MODULE_T FIU_module = (num_device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure write burst size                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD( FIU_DWR_CFG(FIU_module),  FIU_DWR_CFG_W_BURST, write_burst_size);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure read burst size                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD( FIU_DRD_CFG(FIU_module),  FIU_DRD_CFG_R_BURST, read_burst_size);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  num_device       - number of flash devices connected to the chip                       */
+/*                  max_dev_size     - Size of the biggest device connected in bytes                       */
+/*                  total_flash_size - The total flash size in bytes                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configs the FUI                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_Init(UINT num_device, UINT32 max_dev_size, UINT32 total_flash_size)
+{
+// TODO: currently we don't change FIU modes    
+#if 0    
+    SPI_dev_size_t              flash_size          = FIU_DEV_SIZE_128KB;
+    SPI_read_mode_t             read_mode           = FIU_FAST_READ;
+    SPI_w_burst_t               write_burst_size    = FIU_W_BURST_ONE_BYTE;
+    SPI_r_burst_t               read_burst_size     = FIU_R_BURST_ONE_BYTE;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* config total flash size - if not 1(MB) align, align to 1(MB)                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (total_flash_size & (_512KB_ - 1))
+    {
+        total_flash_size = ROUND_UP(total_flash_size, _512KB_);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* convert from bytes to enum                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    flash_size = total_flash_size / _1MB_;
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure Flash Size                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FIU_ConfigFlashSize(num_device, flash_size);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure read mode                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FIU_ConfigReadMode(num_device, read_mode);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure burst sizes                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FIU_ConfigBurstSize(num_device, read_burst_size, write_burst_size);
+
+#endif
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_UMA_Read                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                device           - Select the flash device (0 or 1) to be accessed                       */
+/*                transaction_code - Specify the SPI UMA transaction code                                  */
+/*                address          - Location on the flash , in the flash address space                    */
+/*                address_size     - if TRUE, 3 bytes address, to be placed in FIU_UMA_AB0-2                   */
+/*                                   else (FALSE), no address for this SPI UMA transaction                 */
+/*                data             - a pointer to a data buffer to hold the read data.                     */
+/*                data_size        - buffer size. Legal sizes are 1,2,3,4                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Read up to 4 bytes from the flash. using the FIU User Mode Access (UMA)   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_UMA_Read(UINT     device,
+                        UINT8    transaction_code,
+                        UINT32   address,
+                        BOOLEAN  is_address_size,
+                        UINT8 *  data,
+                        UINT32   data_size)
+{
+
+	UINT32 data_reg[4];
+    UINT32 uma_cfg = 0x0;
+    HAL_STATUS ret = HAL_OK;
+    UINT32 address_size = 0;
+
+    FIU_MODULE_T FIU_module = (device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* set device number - DEV_NUM in FIU_UMA_CTS                                                          */
+    /* legal device numbers are 0,1,2,3                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    device = device % FIU_DEVICES_PER_MODULE;
+    switch(device)
+    {
+        case 0 :
+        case 1 :
+        case 2 :
+        case 3 :
+            SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_DEV_NUM, (UINT32)device);
+            break;
+        default:
+            return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* set transaction code in FIU_UMA_CODE                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CMD(FIU_module), FIU_UMA_CMD_CMD, transaction_code);
+    SET_VAR_FIELD(uma_cfg, FIU_UMA_CFG_CMDSIZ, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set address size bit                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (is_address_size)
+	    address_size = 3;
+
+    SET_VAR_FIELD(uma_cfg, FIU_UMA_CFG_ADDSIZ, address_size);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the UMA address registers                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FIU_UMA_ADDR(FIU_module), address);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set data size and direction                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(uma_cfg, FIU_UMA_CFG_RDATSIZ, data_size);
+    SET_VAR_FIELD(uma_cfg, FIU_UMA_CFG_WDATSIZ, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set UMA CFG                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FIU_UMA_CFG(FIU_module), uma_cfg);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initiate the read                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_EXEC_DONE, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait for indication that transaction has terminated                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_EXEC_DONE) == FIU_TRANS_STATUS_IN_PROG){}
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* copy read data from FIU_UMA_DB0-3 regs to data buffer                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the UMA data registers - FIU_UMA_DB0-3                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (data_size >= FIU_UMA_DATA_SIZE_1)
+    {
+		data_reg[0] = REG_READ(FIU_UMA_DR0(FIU_module));
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_5)
+    {
+		data_reg[1] = REG_READ(FIU_UMA_DR1(FIU_module));
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_9)
+    {
+		data_reg[2] = REG_READ(FIU_UMA_DR2(FIU_module));
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_13)
+    {
+		data_reg[3] = REG_READ(FIU_UMA_DR3(FIU_module));
+    }
+
+    memcpy(data,data_reg,data_size);
+	
+    return ret;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_UMA_Write                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*              device           - Select the flash device (0 or 1) to be accessed                         */
+/*              transaction_code - Specify the SPI UMA transaction code                                    */
+/*              address          - Location on the flash, in the flash address space                       */
+/*              address_size     - if TRUE, 3 bytes address, to be placed in FIU_UMA_AB0-2                     */
+/*                                 else (FALSE), no address for this SPI UMA transaction                   */
+/*              data             - a pointer to a data buffer (buffer of bytes)                            */
+/*              data_size        - data buffer size in bytes. Legal sizes are 0,1,2,3,4                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*           This routine write up to 4 bytes to the flash using the FIU User Mode Access (UMA)            */
+/*           which allows the core an indirect access to the flash, bypassing FIU flash write              */
+/*           protection.                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_UMA_Write(
+           UINT device,
+           UINT8 transaction_code,
+           UINT32 address,
+           BOOLEAN is_address_size,
+           UINT8 * data,
+           UINT32 data_size)
+{
+
+	UINT32 data_reg[4] = {0};
+    UINT32 uma_reg   = 0x0;
+    HAL_STATUS ret = HAL_OK;
+    UINT32 address_size = 0;
+
+    FIU_MODULE_T FIU_module = (device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* set device number - DEV_NUM in FIU_UMA_CTS                                                          */
+    /* legal device numbers are 0,1,2,3                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    device = device % FIU_DEVICES_PER_MODULE;
+    switch(device)
+    {
+        case 0 :
+        case 1 :
+        case 2 :
+        case 3 :
+            SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_DEV_NUM, (UINT32)device);
+            break;
+        default:
+            return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set transaction code (command byte source)                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CMD(FIU_module), FIU_UMA_CMD_CMD, transaction_code);
+    SET_VAR_FIELD(uma_reg, FIU_UMA_CFG_CMDSIZ, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set address size bit                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (is_address_size)
+	    address_size = 3;
+	   
+    SET_VAR_FIELD(uma_reg, FIU_UMA_CFG_ADDSIZ, address_size);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the UMA address registers                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FIU_UMA_ADDR(FIU_module), address);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the UMA data registers - FIU_UMA_DB0-3                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    memcpy(data_reg,data,data_size);
+
+    if (data_size >= FIU_UMA_DATA_SIZE_1)
+    {
+        REG_WRITE(FIU_UMA_DW0(FIU_module), data_reg[0]);
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_5)
+    {
+        REG_WRITE(FIU_UMA_DW1(FIU_module), data_reg[1]);
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_9)
+    {
+        REG_WRITE(FIU_UMA_DW2(FIU_module), data_reg[2]);
+    }
+    if (data_size >= FIU_UMA_DATA_SIZE_13)
+    {
+        REG_WRITE(FIU_UMA_DW3(FIU_module), data_reg[3]);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set data size and direction                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(uma_reg, FIU_UMA_CFG_WDATSIZ, data_size);
+    SET_VAR_FIELD(uma_reg, FIU_UMA_CFG_RDATSIZ, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set UMA status                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FIU_UMA_CFG(FIU_module), uma_reg);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initiate the read                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_EXEC_DONE, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait for indication that transaction has terminated                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_EXEC_DONE) == FIU_TRANS_STATUS_IN_PROG){}
+
+    return ret;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_ManualWrite                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*              device           - Select the flash device (0 or 1) to be accessed                         */
+/*              transaction_code - Specify the SPI UMA transaction code                                    */
+/*              address          - Location on the flash, in the flash address space                       */
+/*              data             - a pointer to a data buffer (buffer of bytes)                            */
+/*              data_size        - data buffer size in bytes. Legal sizes are 0-256                        */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine "manual" page programming without using UMA.                              */
+/*                  The data can be programmed upto the size of the whole page in a single SPI transaction */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_ManualWrite(UINT device, UINT8 transaction_code, UINT32 address, UINT8 * data, UINT32 data_size)
+{
+    UINT8   uma_cfg  = 0x0;
+    UINT32  num_data_chunks;
+    UINT32  remain_data;
+    UINT32  idx = 0;
+
+    FIU_MODULE_T FIU_module = (device < FIU_DEVICES_PER_MODULE) ? FIU_MODULE_0 : FIU_MODULE_3;
+	
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Constructing var for FIU_UMA_CFG register status                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_VAR_FIELD(uma_cfg, FIU_UMA_CFG_WDATSIZ, 16);        // Setting Write Data size
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculating relevant data                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    num_data_chunks  = data_size / CHUNK_SIZE;
+    remain_data  = data_size % CHUNK_SIZE;	
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* First we activate Chip Select (CS) for the given flash device                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_DEV_NUM, (UINT32)(device % FIU_DEVICES_PER_MODULE));
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_SW_CS, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Writing the transaction code and the address to the bus                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FIU_UMA_Write(device, transaction_code, address, TRUE, NULL, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Starting the data writing loop in multiples of 8                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(idx=0; idx<num_data_chunks; ++idx)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* first byte command and follow 3 bytes address used as DATA                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+		FIU_UMA_Write(device, data[0], (UINT32)NULL, FALSE, &data[1], CHUNK_SIZE-1);
+		
+        data += CHUNK_SIZE;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Handling chunk remains                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (remain_data > 0)
+    {
+		FIU_UMA_Write(device, data[0], (UINT32)NULL, FALSE, &data[1], remain_data-1);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Finally we de-activating the Chip select and returning to "automatic" CS control                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(FIU_UMA_CTS(FIU_module), FIU_UMA_CTS_SW_CS, 1);
+
+    return HAL_OK;
+}
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.h b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.h
new file mode 100755
index 0000000..224b249
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_drv.h
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fui_drv.c                                                                                             */
+/*            This file contains interface to Flash Interface Unit (FUI)                                   */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __FUI_DRV_H
+#define __FUI_DRV_H
+
+#include "../fiu_if.h"
+
+#endif //__FUI_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_regs.h b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_regs.h
new file mode 100755
index 0000000..9cdc662
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/Poleg_IP/fiu_regs.h
@@ -0,0 +1,245 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fiu_regs.h                                                                                            */
+/*            This file contains definitions of FIU registers                                              */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _FIU_REGS_H
+#define _FIU_REGS_H
+
+#include "../../../Chips/chip.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                  Flash Interface Unit (FIU) Registers                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/**************************************************************************************************************************/
+/*   FIU Direct Read Configuration Register (FIU_DRD_CFG)                                                                 */
+/**************************************************************************************************************************/
+#define  FIU_DRD_CFG(n)                 (FIU_BASE_ADDR(n) + 0x00) , FIU_ACCESS , 32
+/* Location: SPIn_BA + 00h */
+#define  FIU_DRD_CFG_R_BURST             24 , 2
+/* 25-24 R_BURST (Read Burst). Sets the maximum length of a valid read burst. This value must be set                     */
+#define  FIU_DRD_CFG_ADDSIZ              16 , 2
+/* 17-16 ADDSIZ (Address Size). Selects the SPI address size. This field must be set according to the command            */
+#define  FIU_DRD_CFG_DBW                 12 , 2
+/* 13-12 DBW (Dummy Bytes Wait). Selects the SPI byte time to wait until the data is returned from the flash.            */
+#define  FIU_DRD_CFG_ACCTYPE             8 , 2
+/* 9-8 ACCTYPE (Access Type). Selects the SPI access type. This field must be set according to the access                */
+#define  FIU_DRD_CFG_RDCMD               0 , 8
+/* 7-0 RDCMD (Read command). Controls the value of the SPI command byte. Default is 0BH, fast read with                  */
+
+/**************************************************************************************************************************/
+/*   FIU Direct Write Configuration Register (FIU_DWR_CFG)                                                                */
+/**************************************************************************************************************************/
+#define  FIU_DWR_CFG(n)                    (FIU_BASE_ADDR(n) + 0x04) , FIU_ACCESS , 32
+/* Offset: 04h */
+#define  FIU_DWR_CFG_LCK                 31 , 1
+/* 31 LCK (Lock). When the bit is set, writing to this register is ignored. This bit is not reset by setting the         */
+#define  FIU_DWR_CFG_W_BURST             24 , 2
+/* 25-24 W_BURST (Write Burst). Sets the maximum length of a valid write burst. This value must be set                   */
+#define  FIU_DWR_CFG_ADDSIZ              16 , 2
+/* 17-16 ADDSIZ (Address Size). Selects the SPI address size. This field must be set according to the                    */
+#define  FIU_DWR_CFG_ABPCK               10 , 2
+/* 11-10 ABPCK (Address Bits per Clock). Selects how many address bits are transferred per clock. This field             */
+#define  FIU_DWR_CFG_DBPCK               8 , 2
+/* 9-8 DBPCK (Data Bits per Clock). Selects how many data bits are transferred per clock. This field must                */
+#define  FIU_DWR_CFG_WRCMD               0 , 8
+/* 7-0 WRCMD (Write command). Controls the value of the SPI command byte. Default is 02H: write with a                   */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Configuration Register (FIU_UMA_CFG)                                                                         */
+/**************************************************************************************************************************/
+#define  FIU_UMA_CFG(n)                   (FIU_BASE_ADDR(n) + 0x08) , FIU_ACCESS , 32            /* Offset: 08h */
+#define  FIU_UMA_CFG_LCK                 31 , 1              /* 31 LCK (Lock). When the bit is set, writing to this register is ignored. This bit is not reset by setting the         */
+#define  FIU_UMA_CFG_CMMLCK              30 , 1              /* 30 CMMLCK (Command Mode Lock). When the bit is set, writing to this bit and to the CMBPCK and                         */
+#define  FIU_UMA_CFG_RDATSIZ             24 , 5             /* 28-24 RDATSIZ (Read Data Size). Selects how many read data bytes are read during the SPI transaction.                 */
+#define  FIU_UMA_CFG_DBSIZ               21 , 3             /* 23-21 DBSIZ (Dummy Byte Size). Selects how many dummy bytes are present during the SPI transaction.                   */
+#define  FIU_UMA_CFG_WDATSIZ             16 , 5             /* 20-16 WDATSIZ (Write Data Size). Selects how many write data bytes are sent during the SPI transaction.               */
+#define  FIU_UMA_CFG_ADDSIZ              11 , 3             /* 13-11 ADDSIZ (Address Size). Selects how many address bytes are sent during the SPI transaction. This                 */
+#define  FIU_UMA_CFG_CMDSIZ              10 , 1              /* 10 CMDSIZ (Command Size). Selects how many command bytes are sent during the SPI transaction.                         */
+#define  FIU_UMA_CFG_RDBPCK              8 , 2              /* 9-8 RDBPCK (Read Data Bits per Clock). Selects how many read data bits are transferred per clock. This                */
+#define  FIU_UMA_CFG_DBPCK               6 , 2              /* 7-6 DBPCK (Dummy Bytes Bits per Clock). Selects how many dummy bytes bits are transferred per                         */
+#define  FIU_UMA_CFG_WDBPCK              4 , 2              /* 5-4 WDBPCK (Write Data Bits per Clock). Selects how many write data bits are transferred per clock.                   */
+#define  FIU_UMA_CFG_ADBPCK              2 , 2              /* 3-2 ADBPCK (Address Bits per Clock). Selects how many address bits are transferred per clock. This                    */
+#define  FIU_UMA_CFG_CMBPCK              0 , 2              /* 1-0 CMBPCK (Command Bits per Clock). Selects how many command bits are transferred per clock. This                    */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Control and Status Register (FIU_UMA_CTS)                                                                    */
+/**************************************************************************************************************************/
+#define  FIU_UMA_CTS(n)                    (FIU_BASE_ADDR(n) + 0x0C) , FIU_ACCESS , 32            /* Offset: 0Ch */
+#define  FIU_UMA_CTS_RDYIE               25 , 1              /* 25 RDYIE (UMA Ready Interrupt Enable). Enables an interrupt if the RDYST bit is set.                                  */
+#define  FIU_UMA_CTS_RDYST               24 , 1              /* 24 RDYST (UMA Ready Status). Indicates the UMA state machine has finished a transaction. This bit is                  */
+#define  FIU_UMA_CTS_SW_CS               16 , 1              /* 16 SW_CS (Software-Controlled Chip Select). When set to 0, activates the flash chip-select (F_CSx)                    */
+#define  FIU_UMA_CTS_DEV_NUM             8 , 2              /* 9-8 DEV_NUM (Device Number). Selects the chip select to be used in the following UMA transaction.                     */
+#define  FIU_UMA_CTS_EXEC_DONE           0 , 1               /* 0 EXEC_DONE (Operation Execute/Done). Writing 1 triggers a UMA flash transaction.                                     */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Command Register (FIU_UMA_CMD)                                                                               */
+/**************************************************************************************************************************/
+#define  FIU_UMA_CMD(n)                    (FIU_BASE_ADDR(n) + 0x10) , FIU_ACCESS , 32               /* Offset: 10h */
+#define  FIU_UMA_CMD_DUM3                24 , 8             /* 31-24 DUM3 (Third Dummy Byte). Source of the data output during third and subsequent dummy bytes (if                  */
+#define  FIU_UMA_CMD_DUM2                16 , 8             /* 23-16 DUM2 (Second Dummy Byte). Source of the data output during second dummy byte (if DBDSIZ > 1).                   */
+#define  FIU_UMA_CMD_DUM1                8 , 8              /* 15-8 DUM1 (First Dummy Byte). Source of the data output during first dummy byte (if DBDSIZ > 0). This                 */
+#define  FIU_UMA_CMD_CMD                 0 , 8              /* 7-0 CMD (Command Byte). Source of the command byte sent in the UMA SPI transaction (if CMDSIZ is                      */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Address Register (FIU_UMA_ADDR)                                                                              */
+/**************************************************************************************************************************/
+#define  FIU_UMA_ADDR(n)                   (FIU_BASE_ADDR(n) + 0x14) , FIU_ACCESS , 32 		/* Offset: 14h */
+#define  FIU_UMA_ADDR_UMA_ADDR           0 , 32             /* 31-0 UMA_ADDR (UMA address). Source of the address bytes sent in the UMA SPI transaction. Bits 31-24                 */
+#define  FIU_UMA_ADDR_AB3                 24 , 8             /* 31-24 AB3 (Address Byte 3). Source of the address bytes sent in the UMA SPI transaction (if ADDSIZ = 4).             */
+#define  FIU_UMA_ADDR_AB2                 16 , 8             /* 23-16 AB2 (Address Byte 2). Source of the address bytes sent in the UMA SPI transaction (if ADDSIZ > 2).             */
+#define  FIU_UMA_ADDR_AB1                 8 , 8              /* 15-8 AB1 (Address Byte 1). Source of the address bytes sent in the UMA SPI transaction (if ADDSIZ > 1).              */
+#define  FIU_UMA_ADDR_AB0                 0 , 8              /* 7-0 AB0 (Address Byte 0). Source of the address bytes sent in the UMA SPI transaction (if ADDSIZ > 0).               */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Write Data Bytes 0-3 Register (FIU_UMA_DW0)                                                                  */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DW0(n)                    (FIU_BASE_ADDR(n) + 0x20) , FIU_ACCESS , 32 		/* Offset: 20h */
+#define  FIU_UMA_DW0_WB3                 24 , 8             /* 31-24 WB3 (Write Byte 3). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >3).             */
+#define  FIU_UMA_DW0_WB2                 16 , 8             /* 23-16 WB2 (Write Byte 2). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >2).             */
+#define  FIU_UMA_DW0_WB1                 8 , 8              /* 15-8 WB1 (Write Byte 1). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >1).              */
+#define  FIU_UMA_DW0_WB0                 0 , 8              /* 7-0 WB0 (Write Byte 0). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >0).               */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Write Data Bytes 4-7 Register (FIU_UMA_DW1)                                                                  */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DW1(n)                    (FIU_BASE_ADDR(n) + 0x24) , FIU_ACCESS , 32 		/* Offset: 24h */
+#define  FIU_UMA_DW1_WB7                 24 , 8             /* 31-24 WB7 (Write Byte 7). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >7).             */
+#define  FIU_UMA_DW1_WB6                 16 , 8             /* 23-16 WB6 (Write Byte 6). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >6).             */
+#define  FIU_UMA_DW1_WB5                 8 , 8              /* 15-8 WB5 (Write Byte 5). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >5).              */
+#define  FIU_UMA_DW1_WB4                 0 , 8              /* 7-0 WB4 (Write Byte 4). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >4).               */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Write Data Bytes 8-11 Register (FIU_UMA_DW2)                                                                 */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DW2(n)                    (FIU_BASE_ADDR(n) + 0x28) , FIU_ACCESS , 32 		/* Offset: 28h */
+#define  FIU_UMA_DW2_WB11                24 , 8             /* 31-24 WB11 (Write Byte 11). Source of the write data bytes sent in the UMA SPI transaction                            */
+#define  FIU_UMA_DW2_WB10                16 , 8             /* 23-16 WB10 (Write Byte 10). Source of the write data bytes sent in the UMA SPI transaction                            */
+#define  FIU_UMA_DW2_WB9                 8 , 8              /* 15-8 WB9 (Write Byte 9). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >9).              */
+#define  FIU_UMA_DW2_WB8                 0 , 8              /* 7-0 WB8 (Write Byte 8). Source of the write data bytes sent in the UMA SPI transaction (if WDATSIZ >8).               */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Write Data Bytes 12-15 Register (FIU_UMA_DW3)                                                                */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DW3(n)                    (FIU_BASE_ADDR(n) + 0x2C) , FIU_ACCESS , 32 		/* Offset: 2Ch */
+#define  FIU_UMA_DW3_WB15                24 , 8             /* 31-24 WB15 (Write Byte 15). Source of the write data bytes sent in the UMA SPI transaction                            */
+#define  FIU_UMA_DW3_WB14                16 , 8             /* 23-16 WB14 (Write Byte 14). Source of the write data bytes sent in the UMA SPI transaction                            */
+#define  FIU_UMA_DW3_WB13                8 , 8              /* 15-8 WB13 (Write Byte 13). Source of the write data bytes sent in the UMA SPI transaction                             */
+#define  FIU_UMA_DW3_WB12                0 , 8              /* 7-0 WB12 (Write Byte 12). Source of the write data bytes sent in the UMA SPI transaction                              */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Read Data Bytes 0-3 Register (FIU_UMA_DR0)                                                                   */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DR0(n)                    (FIU_BASE_ADDR(n) + 0x30) , FIU_ACCESS , 32 		/* Offset: 30h */
+#define  FIU_UMA_DR0_RB3                 24 , 8             /* 31-24 RB3 (Read Byte 3). Destination of the read data bytes received in the UMA SPI transaction                       */
+#define  FIU_UMA_DR0_RB2                 16 , 8             /* 23-16 RB2 (Read Byte 2). Destination of the read data bytes received in the UMA SPI transaction                       */
+#define  FIU_UMA_DR0_RB1                 8 , 8              /* 15-8 RB1 (Read Byte 1). Destination of the read data bytes received in the UMA SPI transaction                        */
+#define  FIU_UMA_DR0_RB0                 0 , 8              /* 7-0 RB0 (Read Byte 0). Destination of the read data bytes received in the UMA SPI transaction                         */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Read Data Bytes 4-7 Register (FIU_UMA_DR1)                                                                   */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DR1(n)                    (FIU_BASE_ADDR(n) + 0x34) , FIU_ACCESS , 32 		/* Offset: 34h */
+#define  FIU_UMA_DR1_RB15                24 , 8             /* 31-24 RB15 (Read Byte 7). Destination of the read data bytes received in the UMA SPI transaction                      */
+#define  FIU_UMA_DR1_RB14                16 , 8             /* 23-16 RB14 (Read Byte 6). Destination of the read data bytes received in the UMA SPI transaction                      */
+#define  FIU_UMA_DR1_RB13                8 , 8              /* 15-8 RB13 (Read Byte 5). Destination of the read data bytes received in the UMA SPI transaction                       */
+#define  FIU_UMA_DR1_RB12                0 , 8              /* 7-0 RB12 (Read Byte 4). Destination of the read data bytes received in the UMA SPI transaction                        */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Read Data Bytes 8-11 Register (FIU_UMA_DR2)                                                                  */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DR2(n)                    (FIU_BASE_ADDR(n) + 0x38) , FIU_ACCESS , 32 		/* Offset: 38h */
+#define  FIU_UMA_DR2_RB15                24 , 8             /* 31-24 RB15 (Read Byte 11). Destination of the read data bytes received in the UMA SPI transaction                     */
+#define  FIU_UMA_DR2_RB14                16 , 8             /* 23-16 RB14 (Read Byte 10). Destination of the read data bytes received in the UMA SPI transaction                     */
+#define  FIU_UMA_DR2_RB13                8 , 8              /* 15-8 RB13 (Read Byte 9). Destination of the read data bytes received in the UMA SPI transaction                       */
+#define  FIU_UMA_DR2_RB12                0 , 8              /* 7-0 RB12 (Read Byte 8). Destination of the read data bytes received in the UMA SPI transaction                        */
+
+/**************************************************************************************************************************/
+/*   FIU UMA Read Data Bytes 12-15 Register (FIU_UMA_DR3)                                                                 */
+/**************************************************************************************************************************/
+#define  FIU_UMA_DR3(n)                    (FIU_BASE_ADDR(n) + 0x3C) , FIU_ACCESS , 32 		/* Offset: 3Ch */
+#define  FIU_UMA_DR3_RB15                24 , 8             /* 31-24 RB15 (Read Byte 15). Destination of the read data bytes received in the UMA SPI transaction                     */
+#define  FIU_UMA_DR3_RB14                16 , 8             /* 23-16 RB14 (Read Byte 14). Destination of the read data bytes received in the UMA SPI transaction                     */
+#define  FIU_UMA_DR3_RB13                8 , 8              /* 15-8 RB13 (Read Byte 13). Destination of the read data bytes received in the UMA SPI transaction                      */
+#define  FIU_UMA_DR3_RB12                0 , 8              /* 7-0 RB12 (Read Byte 12). Destination of the read data bytes received in the UMA SPI transaction                       */
+
+/**************************************************************************************************************************/
+/*   FIU Protection Configuration Register (FIU_PRT_CFG)                                                                  */
+/**************************************************************************************************************************/
+#define  FIU_PRT_CFG(n)                    (FIU_BASE_ADDR(n) + 0x18) , FIU_ACCESS , 32 		/* Offset: 18h */
+#define  FIU_PRT_CFG_LCK                 31 , 1              /* 31 LCK (Lock). When the bit is set, writing to this register is ignored. This bit is not reset by setting the         */
+#define  FIU_PRT_CFG_PEN                 30 , 1              /* 30 PEN (Protection Enable). Enables the protection mechanism.                                                         */
+#define  FIU_PRT_CFG_DEVSIZ              8 , 3              /* 10-8 DEVSIZ (Device Size). Defines the size of the devices on CS0 and CS1. When protection is enabled,                */
+#define  FIU_PRT_CFG_OCALWD              4 , 1               /* 4 OCALWD (Other Commands Allowed). Defines if commands not defined in the FIU_PRT_CMD9-0                              */
+#define  FIU_PRT_CFG_PRTASIZ             0 , 2              /* 1-0 PRTASIZ (Protected Area Size). Selects the size of the area protected by the protection mechanism.                */
+
+/**************************************************************************************************************************/
+/*   FIU Protection Command Register (FIU_PRT_CMD0-9)                                                                     */
+/**************************************************************************************************************************/
+#define  FIU_PRT_CMD0(n)                   (FIU_BASE_ADDR(n) + 0x40) , FIU_ACCESS , 32 		/* Offset: FIU_PRT_CMD0: 40h */
+#define  FIU_PRT_CMD1(n)                   (FIU_BASE_ADDR(n) + 0x44) , FIU_ACCESS , 32 		/* FIU_PRT_CMD1: 44h  */
+#define  FIU_PRT_CMD2(n)                   (FIU_BASE_ADDR(n) + 0x48) , FIU_ACCESS , 32 		/* FIU_PRT_CMD2: 48h  */
+#define  FIU_PRT_CMD3(n)                   (FIU_BASE_ADDR(n) + 0x4C) , FIU_ACCESS , 32 		/* FIU_PRT_CMD3: 4Ch  */
+#define  FIU_PRT_CMD4(n)                   (FIU_BASE_ADDR(n) + 0x50) , FIU_ACCESS , 32 		/* FIU_PRT_CMD4: 50h  */
+#define  FIU_PRT_CMD5(n)                   (FIU_BASE_ADDR(n) + 0x54) , FIU_ACCESS , 32 		/* FIU_PRT_CMD5: 54h  */
+#define  FIU_PRT_CMD6(n)                   (FIU_BASE_ADDR(n) + 0x58) , FIU_ACCESS , 32 		/* FIU_PRT_CMD6: 58h  */
+#define  FIU_PRT_CMD7(n)                   (FIU_BASE_ADDR(n) + 0x5C) , FIU_ACCESS , 32 		/* FIU_PRT_CMD7: 5Ch  */
+#define  FIU_PRT_CMD8(n)                   (FIU_BASE_ADDR(n) + 0x60) , FIU_ACCESS , 32 		/* FIU_PRT_CMD8: 60h  */
+#define  FIU_PRT_CMD9(n)                   (FIU_BASE_ADDR(n) + 0x64) , FIU_ACCESS , 32 		/* FIU_PRT_CMD9: 64h  */
+#define  FIU_PRT_CMD9_ADBPCKB            29 , 2             /* 30-29 ADBPCKB (Address B Bits per Clock). Selects how many address B bits are checked per clock.                      */
+#define  FIU_PRT_CMD9_CMBPCKB            27 , 2             /* 28-27 CMBPCKB (Command B Bits per Clock). Selects how many command B bits are checked per clock.                      */
+#define  FIU_PRT_CMD9_ADDSZB             26 , 1              /* 26 ADDSZB (Address Size for limiting command B). Defines the address size of command B for limit                      */
+#define  FIU_PRT_CMD9_FRBDCB             24 , 2             /* 25-24 FRBDCB (Forbid Command B). Defines if Command B is forbidden.                                                   */
+#define  FIU_PRT_CMD9_CMDB               16 , 8             /* 23-16 CMDB (Command B). Sets the value of command B.                                                                  */
+#define  FIU_PRT_CMD9_ADBPCKA            13 , 2             /* 14-13 ADBPCKA (Address A Bits per Clock). Selects how many address A bits are checked per clock.                      */
+#define  FIU_PRT_CMD9_CMBPCKA            11 , 2             /* 12-11 CMBPCKA (Command Bits per Clock A). Selects how many command A bits are checked per clock.                      */
+#define  FIU_PRT_CMD9_ADDSZA             10 , 1              /* 10 ADDSZA (Address Size for limiting command A). Defines the address size of command A for limit                      */
+#define  FIU_PRT_CMD9_FRBDCA             8 , 2              /* 9-8 FRBDCA (Forbid Command A). Defines if Command A is forbidden.                                                     */
+#define  FIU_PRT_CMD9_CMDA               0 , 8              /* 7-0 CMDA (Command A). Sets the value of a command A.                                                                  */
+
+/**************************************************************************************************************************/
+/*   FIU Status Polling Configuration Register (FIU_STPL_CFG)                                                             */
+/**************************************************************************************************************************/
+#define  FIU_STPL_CFG(n)                   (FIU_BASE_ADDR(n) + 0x1C) , FIU_ACCESS , 32 		/* Offset: 1Ch */
+#define  FIU_STPL_CFG_LCK                31 , 1              /* 31 LCK (Lock). When the bit is set, writing to this register is ignored, except for ENPOL, RDY and BUST               */
+#define  FIU_STPL_CFG_BUST               30 , 1              /* 30 BUST (Busy Status). Represents the status of the flash after a direct write. This bit is set by hardware           */
+#define  FIU_STPL_CFG_RDYIE              29 , 1              /* 29 RDYIE (Ready Interrupt Enable). Enables an interrupt request when RDY bit is set.                                  */
+#define  FIU_STPL_CFG_RDY                28 , 1              /* 28 RDY (Ready Status). A status bit for interrupt generation. It is set by detection of ready status by the           */
+#define  FIU_STPL_CFG_SPDWR              27 , 1              /* 27 SPDWR (Start Polling on Direct Write). Enables setting the ENPOL bit after a direct write to the flash.            */
+#define  FIU_STPL_CFG_POLLPER            16 , 11            /* 26-16 POLLPER (Polling Period). Sets the period of the Read Status command sent to the SPI flash, in SPI              */
+#define  FIU_STPL_CFG_ENPOL              12 , 1              /* 12 ENPOL (Enable Polling). Enables sending periodic Read Status commands. This bit is cleared by                      */
+#define  FIU_STPL_CFG_BUSYPOL            11 , 1              /* 11 BUSYPOL (Busy bit Polarity). Defines the polarity of the selected bit.                                             */
+#define  FIU_STPL_CFG_BUSYBS             8 , 3              /* 10-8 BUSYBS (Busy Bit Select). Selects which of the bits of the read value from the status register is the            */
+#define  FIU_STPL_CFG_CMD                0 , 8              /* 7-0 CMD (Command). Sets the value of the Status Read command. The default is 05h.                                     */
+
+/**************************************************************************************************************************/
+/*   FIU Configuration Register (FIU_CFG)                                                                                 */
+/**************************************************************************************************************************/
+#define  FIU_CFG(n)                        (FIU_BASE_ADDR(n) + 0x78) , FIU_ACCESS , 32 		/* Offset: 78h */
+#define  FIU_CFG_SPI_CS_INACT            1 , 3              /* 3-1 SPI_CS_INACT (SPI Chip Select, Inactive Time). Selects the minimum number of FCLK cycles during                   */
+#define  FIU_CFG_INCRSING                0 , 1               /* 0 INCRSING (INCR as Singles). Defines treating INCR burst as single beats on the bus. Each beat on                    */
+
+/**************************************************************************************************************************/
+/*   FIU Version Register (FIU_VER) updated                                                                               */
+/**************************************************************************************************************************/
+#define  FIU_VER(n)                        (FIU_BASE_ADDR(n) + 0x7C) , FIU_ACCESS , 32 		/* Offset: 7Ch */
+#define  FIU_VER_FIU_VER                 0 , 8              /* 7-0 FIU_VER (FIU Version). Indicates the current version of the FIU module. In the , its value is 40h.                */
+
+
+
+
+#endif // _FIU_REGS_H 
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.c b/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.c
new file mode 100755
index 0000000..f4998d8
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fiu_if.c                                                                                              */
+/*            This file contains FIU module driver selector                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(FIU_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(fiu, FIU_MODULE_TYPE)
+#endif     
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.h b/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.h
new file mode 100755
index 0000000..16ec1a0
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fiu/fiu_if.h
@@ -0,0 +1,118 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fiu_if.h                                                                                              */
+/*            This file contains FIU interface                                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _FIU_IF_H
+#define _FIU_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FIU Modules                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FIU_MODULE_T_tag
+{
+    FIU_MODULE_0 = 0,
+    FIU_MODULE_1 = 1,
+    FIU_MODULE_2 = 2,
+    FIU_MODULE_3 = 3,
+    FIU_MODULE_X = 4
+} FIU_MODULE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  num_device       - number of flash devices connected to the chip                       */
+/*                  max_dev_size     - Size of the biggest device connected                                */
+/*                  total_flash_size - The total flash size in Kbytes                                      */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configs the FUI                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_Init(UINT num_device, UINT32 max_dev_size, UINT32 total_flash_size);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_uma_read                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                device           - Select the flash device (0 or 1) to be accessed                       */
+/*                transaction_code - Specify the SPI UMA transaction code                                  */
+/*                address          - Location on the flash , in the flash address space                    */
+/*                address_size     - if TRUE, 3 bytes address, to be placed in UMA_AB0-2                   */
+/*                                   else (FALSE), no address for this SPI UMA transaction                 */
+/*                data             - a pointer to a data buffer to hold the read data.                     */
+/*                data_size        - buffer size. Legal sizes are 1,2,3,4                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Read up to 4 bytes from the flash. using the FIU User Mode Access (UMA)   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_UMA_Read(UINT device, UINT8 transaction_code, UINT32 address, BOOLEAN address_size, UINT8 * data, UINT32 data_size);
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_uma_write                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*              device           - Select the flash device (0 or 1) to be accessed                         */
+/*              transaction_code - Specify the SPI UMA transaction code                                    */
+/*              address          - Location on the flash, in the flash address space                       */
+/*              address_size     - if TRUE, 3 bytes address, to be placed in UMA_AB0-2                     */
+/*                                 else (FALSE), no address for this SPI UMA transaction                   */
+/*              data             - a pointer to a data buffer (buffer of bytes)                            */
+/*              data_size        - data buffer size in bytes. Legal sizes are 0,1,2,3,4                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*           This routine write up to 4 bytes to the flash using the FIU User Mode Access (UMA)            */
+/*           which allows the core an indirect access to the flash, bypassing FIU flash write              */
+/*           protection.                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_UMA_Write(UINT device, UINT8 transaction_code, UINT32 address, BOOLEAN address_size, UINT8 * data, UINT32 data_size);
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FIU_manual_write                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*              device           - Select the flash device (0 or 1) to be accessed                         */
+/*              transaction_code - Specify the SPI UMA transaction code                                    */
+/*              address          - Location on the flash, in the flash address space                       */
+/*              data             - a pointer to a data buffer (buffer of bytes)                            */
+/*              data_size        - data buffer size in bytes. Legal sizes are 0-256                        */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine "manual" page programming without using UMA.                              */
+/*                  The data can be programmed upto the size of the whole page (256 bytes) in a single     */
+/*                  SPI transaction                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FIU_ManualWrite(UINT device, UINT8 transaction_code, UINT32 address, UINT8 * data, UINT32 data_size);
+
+#endif //_FIU_IF_H
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.c b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.c
new file mode 100755
index 0000000..462ec36
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.c
@@ -0,0 +1,986 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fuse_drv.c                                                                                            */
+/*            This file contains FUSE module routines                                                      */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../../Common/hal_common.h"
+#include "../../../Chips/chip.h"
+
+#include "../../aes/aes_if.h"
+#include "../../clk/Poleg_IP/clk_regs.h"
+
+#include "fuse_drv.h"
+#include "fuse_regs.h"
+
+//#define CONFIG_FUSE_EMULATE
+#ifdef CONFIG_FUSE_EMULATE
+    UINT8 *fuse_array_mem = (UINT8 *)0x2000000;
+    #define FUSE_ARR_SIZE 1024
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse module constant definitions                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+// Read cycle initiation value:
+#define READ_INIT                   0x02
+
+// Program cycle initiation values (a sequence of two adjacent writes is required):
+#define PROGRAM_ARM                 0x1
+#define PROGRAM_INIT                0xBF79E5D0
+
+// Value to clean FDATA contents:
+#define FDATA_CLEAN_VALUE           0x01
+
+// Default APB Clock Rate (in MHz):
+#define DEFAULT_APB_RATE            0x30
+
+#define MIN_PROGRAM_PULSES          4
+#define MAX_PROGRAM_PULSES          20
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse module local macro definitions                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+// #define STORAGE_ARRAY_READY(sa)   READ_REG_FIELD(FST(sa),     FST_RDY)
+#define KEY_IS_VALID()            READ_REG_FIELD(FKEYIND,     FKEYIND_KVAL)
+#define DISABLE_KEY_ACCESS()      SET_REG_FIELD(FCFG(KEY_SA), FCFG_FDIS, 1)      /* Lock OTP module access  */
+
+static BOOLEAN FUSE_IsInitialized = FALSE;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Internal functions for this module                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_WaitForOTPReadyWithTimeout                                                                              */
+/*                                                                                                         */
+/* Parameters:      array - fuse array to wait for                                                       */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     Initialize the Fuse HW module.                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS FUSE_WaitForOTPReadyWithTimeout(FUSE_STORAGE_ARRAY_T array, UINT32 timeout)
+{
+    volatile UINT32 time = timeout;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* check parameters validity                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (array > FUSE_SA)
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }    
+
+    while (--time > 1)
+    {
+        if (READ_REG_FIELD(FST(array), FST_RDY))
+        {
+            /* fuse is ready, clear the status. */
+            SET_REG_FIELD(FST(array), FST_RDST, 1);
+
+            return HAL_OK;
+        }
+    }
+    /* try to clear the status in case it was set */
+    SET_REG_FIELD(FST(array), FST_RDST, 1);
+
+    return HAL_ERROR;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_Init                                                                              */
+/*                                                                                                         */
+/* Parameters:      APBclock - APB clock rate in MHz                                                       */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     Initialize the Fuse HW module.                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_Init (void)
+{
+
+    // APBRT (APB Clock Rate). Informs the fuse array state machine on the APB clock rate in MHz. The
+    // software must update this field before writing the OTP, and before APB4 actual clock rate change. The
+    // state machine contains an internal copy of this field, sampled at the beginning of every read or program
+    // operation. Software should not write this field with 0. The reset value of this field is 1Fh (31 MHz). The
+    // accuracy of the setting should be 10%.
+    // Note: The minimum APB allowed frequency for accessing the fuse arrays is 10 MHz.
+
+    UINT8 APBclock = CLK_GetAPBFreq(APB4)/1000000 + 1;
+
+    /* Configure the Key Storage Array APB Clock Rate */
+    SET_REG_FIELD(FCFG(KEY_SA), FCFG_APBRT, APBclock & 0x3F);
+
+    /* Configure the Fuse Storage Array APB Clock Rate */
+    SET_REG_FIELD(FCFG(FUSE_SA), FCFG_APBRT, APBclock & 0x3F);
+
+    FUSE_IsInitialized = TRUE;
+
+    return HAL_OK;
+
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_Read                                                                              */
+/*                                                                                                         */
+/* Parameters:      arr  - Storage Array type [input].                                                     */
+/*                  addr - Byte-address to read from [input].                                              */
+/*                  data - Pointer to result [output].                                                     */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     Read 8-bit data from an OTP storage array.                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void FUSE_Read (FUSE_STORAGE_ARRAY_T arr,
+                UINT16               addr,
+                UINT8               *data
+)
+{
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+#ifdef CONFIG_FUSE_EMULATE
+     *data = fuse_array_mem[(arr*FUSE_ARR_SIZE)+addr];
+#else
+    /* Wait for the Fuse Box Idle */
+    FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+    /* Configure the byte address in the fuse array for read operation */
+    SET_REG_FIELD(FADDR(arr), FADDR_BYTEADDR, addr);
+
+    /* Initiate a read cycle from the byte in the fuse array, pointed by FADDR */
+    REG_WRITE(FCTL(arr),  READ_INIT);
+
+    /* Wait for read operation completion */
+    FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+    /* Read the result */
+    *data = READ_REG_FIELD(FDATA(arr), FDATA_FDATA);
+
+    /* Clean FDATA contents to prevent unauthorized software from reading sensitive information */
+    SET_REG_FIELD(FDATA(arr), FDATA_FDATA, FDATA_CLEAN_VALUE);
+#endif
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_BitIsProgrammed                                                                   */
+/*                                                                                                         */
+/* Parameters:      arr     - Storage Array type [input].                                                  */
+/*                  byteNum - Byte offset in array [input].                                                */
+/*                  bitNum  - Bit offset in byte [input].                                                  */
+/* Returns:         Nonzero if bit is programmed, zero otherwise.                                          */
+/* Side effects:                                                                                           */
+/* Description:     Check if a bit is programmed in an OTP storage array.                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN FUSE_BitIsProgrammed (
+    FUSE_STORAGE_ARRAY_T  arr,
+    UINT16                byteNum,
+    UINT8                 bitNum
+)
+{
+    UINT8 data;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    /* Read the entire byte you wish to program */
+    FUSE_Read(arr, byteNum, &data);
+
+    /* Check whether the bit is already programmed */
+    if (READ_VAR_BIT(data, bitNum))
+    {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_ProgramBit                                                                        */
+/*                                                                                                         */
+/* Parameters:      arr     - Storage Array type [input].                                                  */
+/*                  byteNum - Byte offset in array [input].                                                */
+/*                  bitNum  - Bit offset in byte [input].                                                  */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     Program (set to 1) a bit in an OTP storage array.                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_ProgramBit (
+    FUSE_STORAGE_ARRAY_T arr,
+    UINT16               byteNum,
+    UINT8                bitNum
+)
+{
+    HAL_STATUS status = HAL_OK;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    /* Wait for the Fuse Box Idle */
+    FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+    /* Make sure the bit is not already programmed */
+    if (! FUSE_BitIsProgrammed(arr, byteNum, bitNum))
+    {
+        
+#ifdef CONFIG_FUSE_EMULATE
+        fuse_array_mem[(arr*FUSE_ARR_SIZE)+byteNum] |= 1<<bitNum;
+#else
+        UINT8 read_data;
+        int count;
+        
+        /* Configure the bit address in the fuse array for program operation */
+        SET_REG_FIELD(FADDR(arr), FADDR_BYTEADDR, byteNum);
+
+        SET_REG_FIELD(FADDR(arr), FADDR_BITPOS, bitNum);
+
+        // program up to MAX_PROGRAM_PULSES
+        for (count=1; count<=MAX_PROGRAM_PULSES; count++)
+        {
+            /* Arm the program operation */
+            REG_WRITE(FCTL(arr), PROGRAM_ARM);
+
+        /* Initiate a program cycle to the bit in the fuse array, pointed by FADDR */
+        REG_WRITE(FCTL(arr), PROGRAM_INIT);
+
+        /* Wait for program operation completion */
+        FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+            // after MIN_PROGRAM_PULSES start verifying the result
+            if (count >= MIN_PROGRAM_PULSES)
+            {
+                /* Initiate a read cycle from the byte in the fuse array, pointed by FADDR */
+                REG_WRITE(FCTL(arr),  READ_INIT);
+
+                /* Wait for read operation completion */
+                FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+                /* Read the result */
+                read_data = READ_REG_FIELD(FDATA(arr), FDATA_FDATA);
+
+                /* If the bit is set the sequence ended correctly */
+                if (read_data & (1 << bitNum))
+                    break;
+            }
+        }
+        
+        // check if programmking failed
+        if (count > MAX_PROGRAM_PULSES)
+        {
+            status = HAL_ERROR;
+        }
+
+        /* Clean FDATA contents to prevent unauthorized software from reading sensitive information */
+        SET_REG_FIELD(FDATA(arr), FDATA_FDATA, FDATA_CLEAN_VALUE);        
+#endif
+    }
+
+    return status;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_ProgramByte                                                                       */
+/*                                                                                                         */
+/* Parameters:      arr     - Storage Array type [input].                                                  */
+/*                  byteNum - Byte offset in array [input].                                                */
+/*                  value   - Byte to program [input].                                                     */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     Program (set to 1) a given byte's relevant bits in an OTP                              */
+/*                  storage array.                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_ProgramByte (
+    FUSE_STORAGE_ARRAY_T  arr,
+    UINT16                byteNum,
+    UINT8                 value
+)
+{
+    UINT  i;
+
+    UINT8 data;
+    HAL_STATUS status = HAL_OK;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    /* Wait for the Fuse Box Idle */
+    FUSE_WaitForOTPReadyWithTimeout(arr, 0xDEADBEEF ); // TODO: decide proper timeout
+
+    /* Read the entire byte you wish to program */
+    FUSE_Read(arr, byteNum, &data);
+
+    /* In case all relevant bits are already programmed - nothing to do */
+    if ((~data & value) == 0)
+        return status;
+
+    /* Program unprogrammed bits. */
+    for (i = 0; i < 8; i++)
+    {
+        if (READ_VAR_BIT(value, i) == 1)
+        {
+            /* Program (set to 1) the relevant bit */
+            HAL_STATUS last_status = FUSE_ProgramBit(arr, byteNum, (UINT8)i);
+            if (last_status != HAL_OK)
+            {
+                status = last_status;
+            }
+        }
+    }
+
+    return status;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_SelectKey                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  keyIndex - AES key index in the key array (in 128-bit steps) [input].                  */
+/* Returns:         HAL_OK on successful read completion, HAL_STATUS_ERROR* otherwise.            */
+/* Side effects:                                                                                           */
+/* Description:     Select a key from the key storage array.                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_SelectKey (
+    UINT8            keyIndex  )
+{
+
+    UINT32  fKeyInd = 0;
+    volatile UINT32 time = 0xDAEDBEEF;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    if (keyIndex >= 4 )
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /* Do not destroy ECCDIS bit */
+    fKeyInd = REG_READ(FKEYIND);
+
+    /* Configure the key size */
+    SET_VAR_FIELD(fKeyInd, FKEYIND_KSIZE, FKEYIND_KSIZE_VALUE_256);
+
+    /* Configure the key index (0 to 3) */
+    SET_VAR_FIELD(fKeyInd, FKEYIND_KIND, keyIndex);
+
+    REG_WRITE(FKEYIND, fKeyInd);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for selection completetion                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (--time > 1)
+    {
+        if (READ_REG_FIELD(FKEYIND, FKEYIND_KVAL))
+            return HAL_OK;
+    }
+
+    return HAL_ERROR;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_ReadKey                                                                           */
+/*                                                                                                         */
+/* Parameters:      keySize  - AES key size [input].                                                       */
+/*                  keyIndex - AES key index in the key array (in 128-bit steps) [input].                  */
+/*                  output   - Byte-array to hold the key [output].                                        */
+/* Returns:         HAL_OK on successful read completion, HAL_ERROR_* otherwise.                   */
+/* Side effects:                                                                                           */
+/* Description:     Read a key from the key storage array.                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_ReadKey (
+    FUSE_KEY_TYPE_T  keyType,
+    UINT8            keyIndex,
+    UINT8            *output)
+{
+    UINT  i;
+    UINT16 addr = 0 ;
+    UINT16 keySizeByte = 0;
+    UINT8 fuseReadLock, keyBlockMask = 0;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    /* Read the Fuse Read Lock field */
+    fuseReadLock = READ_REG_FIELD(FCFG(KEY_SA), FCFG_FRDLK);
+
+    //AES_KEY_SIZE_256
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* keyType can be either AES (4 keys, 32 bytes - AES_KEY_SIZE_256) or RSA (2 keys , 256 bytes)         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( keyType == FUSE_KEY_AES)
+    {
+        keyBlockMask = 3;
+        keySizeByte = AES_KEY_BYTE_SIZE(AES_256);
+    }
+    else if (keyType == FUSE_KEY_RSA)
+    {
+        keyBlockMask = 3;
+        keySizeByte = RSA_KEY_BYTE_SIZE;
+    }
+
+    /* Build the key block mask based on key index */
+    keyBlockMask <<= keyIndex;
+
+    /* Verify that APB Read Access to the Key Storage Array is allowed */
+    if (READ_REG_FIELD(FUSTRAP, FUSTRAP_oAESKEYACCLK) ||
+        READ_VAR_MASK(fuseReadLock, keyBlockMask))
+    {
+        return HAL_ERROR_LOCKED;
+    }
+
+    /* Calculate key size in bytes */
+    //TODO:   keySizeByte = AES_KEY_BYTE_SIZE(keySize);
+
+    /* Calculate key start address in Key Storage Array -
+       Note that a key always starts on a 128-bit (i.e., a complete block) boundary */
+    //TODO:   addr = keyIndex * AES_BLOCK_SIZE;
+
+    /* Read Key */
+    for (i = 0; i < keySizeByte; i++, addr++)
+    {
+        FUSE_Read(KEY_SA, addr, &output[i]);
+    }
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_DisableKeyAccess                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine disables read and write accees to key array                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void FUSE_DisableKeyAccess ()
+{
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+    DISABLE_KEY_ACCESS();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_LockAccess                                                                        */
+/*                                                                                                         */
+/* Parameters:      lockForRead: bitwise, which block to lock for reading                                  */
+/* Parameters:      lockForWrite: bitwise, which block to lock for program                                 */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine lock the otp blocks                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_LockAccess (FUSE_STORAGE_ARRAY_T array, UINT8 lockForRead, UINT8 lockForWrite, BOOLEAN lockRegister)
+{
+    UINT32 FCFG_VAR = 0;
+    
+    if (!FUSE_IsInitialized)
+    {
+        FUSE_Init();
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* check parameters validity                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (array > FUSE_SA)
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read reg for modify all fields apart APBRT                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FCFG_VAR = REG_READ(FCFG(array));
+
+
+    SET_VAR_FIELD(FCFG_VAR, FCFG_FRDLK,  lockForRead & 0x00FF);
+
+    SET_VAR_FIELD(FCFG_VAR, FCFG_FPRGLK, lockForWrite & 0x00FF);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Lock any access to this register (until next POR)                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( lockRegister == TRUE)
+    {
+        SET_VAR_FIELD(FCFG_VAR, FCFG_FCFGLK, (lockForWrite | lockForRead) & 0x00FF);
+    }
+
+     /*----------------------------------------------------------------------------------------------------*/
+     /* Lock the side band in case it's a key array, and read is locked                                    */
+     /*----------------------------------------------------------------------------------------------------*/
+    if ( array == KEY_SA)
+    {
+        /* Set FDIS bit if oKAP bit 7 is set, to disable the side-band key loading. */
+        if ( (lockForRead & 0x80) > 0 )
+        {
+            SET_VAR_FIELD(FCFG_VAR, FCFG_FDIS, 1);  // 1: Access to the first 2048 bits of the fuse array is disabled.
+        }
+    }
+
+#ifdef _DEBUG_
+    if (array == KEY_SA)
+    {
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x10)  = FCFG_VAR;                /* ROM_MAILBOX_DEBUG9 */
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x14)  = (UINT32)lockForWrite;    /* ROM_MAILBOX_DEBUG10 */
+    }
+    else if (array == FUSE_SA)
+    {
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x18)  = FCFG_VAR;                /* ROM_MAILBOX_DEBUG11 */
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x1C)  = (UINT32)lockForWrite;    /* ROM_MAILBOX_DEBUG12 */
+    }
+    else
+    {
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x18)  = FCFG_VAR;                /* ROM_MAILBOX_DEBUG11 */
+        *(UINT32*)(PCIMBX_PHYS_BASE_ADDR+0x1C)  = 0xDEADDEAD;              /* ROM_MAILBOX_DEBUG12 */
+    }
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Return the moified value                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(FCFG(array), FCFG_VAR);
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Logical level functions                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_NibParEccDecode                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  datain -       pointer to encoded data buffer (buffer size should be 2 x dataout)      */
+/*                  dataout -      pointer to decoded data buffer                                          */
+/*                  encoded_size - size of encoded data (decoded data x 2)                                 */
+/*                                                                                                         */
+/* Returns:         HAL_STATUS                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Decodes the data according to nibble parity ECC scheme.                                */
+/*                  Size specifies the encoded data size.                                                  */
+/*                  Decodes whole bytes only                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_NibParEccDecode (
+    UINT8  *datain,
+    UINT8  *dataout,
+    UINT32  encoded_size
+)
+{
+    UINT32 i;
+    UINT8 BER;
+    UINT8 src_re_calc;
+    UINT8 dst;
+    UINT8 E0;
+    UINT8 E1;
+    UINT8 E2;
+    UINT8 E3;
+    UINT8 E4;
+    UINT8 E5;
+    UINT8 E6;
+    UINT8 E7;
+    HAL_STATUS status = HAL_OK;
+
+//Define the Bit Field macros in order to use the SET_VAR_FIELD macro:
+#define BITF0   0, 1
+#define BITF1   1, 1
+#define BITF2   2, 1
+#define BITF3   3, 1
+#define BITF4   4, 1
+#define BITF5   5, 1
+#define BITF6   6, 1
+#define BITF7   7, 1
+
+#define LSNF    0, 4
+#define MSNF    4, 4
+
+    for (i = 0; i < encoded_size; i++)
+    {
+        E0 = READ_VAR_FIELD(datain[i], BITF0);
+        E1 = READ_VAR_FIELD(datain[i], BITF1);
+        E2 = READ_VAR_FIELD(datain[i], BITF2);
+        E3 = READ_VAR_FIELD(datain[i], BITF3);
+        E4 = READ_VAR_FIELD(datain[i], BITF4);
+        E5 = READ_VAR_FIELD(datain[i], BITF5);
+        E6 = READ_VAR_FIELD(datain[i], BITF6);
+        E7 = READ_VAR_FIELD(datain[i], BITF7);
+
+        if (i % 2)
+        {//Decode higher nibble
+            SET_VAR_FIELD(dataout[i/2], BITF4, ((E0 & (E1 ^ E4)) | (E0 & (E2 ^ E6)) | ((E1 ^ E4) & (E2 ^ E6))));
+            SET_VAR_FIELD(dataout[i/2], BITF5, ((E1 & (E0 ^ E4)) | (E1 & (E3 ^ E7)) | ((E0 ^ E4) & (E3 ^ E7))));
+            SET_VAR_FIELD(dataout[i/2], BITF6, ((E2 & (E0 ^ E6)) | (E2 & (E3 ^ E5)) | ((E0 ^ E6) & (E3 ^ E5))));
+            SET_VAR_FIELD(dataout[i/2], BITF7, ((E3 & (E2 ^ E5)) | (E3 & (E1 ^ E7)) | ((E2 ^ E5) & (E1 ^ E7))));
+
+            dst = MSN( dataout[i/2] );
+        }
+        else
+        {//Decode lower nibble
+            SET_VAR_FIELD(dataout[i/2], BITF0, ((E0 & (E1 ^ E4)) | (E0 & (E2 ^ E6)) | ((E1 ^ E4) & (E2 ^ E6))));
+            SET_VAR_FIELD(dataout[i/2], BITF1, ((E1 & (E0 ^ E4)) | (E1 & (E3 ^ E7)) | ((E0 ^ E4) & (E3 ^ E7))));
+            SET_VAR_FIELD(dataout[i/2], BITF2, ((E2 & (E0 ^ E6)) | (E2 & (E3 ^ E5)) | ((E0 ^ E6) & (E3 ^ E5))));
+            SET_VAR_FIELD(dataout[i/2], BITF3, ((E3 & (E2 ^ E5)) | (E3 & (E1 ^ E7)) | ((E2 ^ E5) & (E1 ^ E7))));
+
+            dst = LSN( dataout[i/2] );
+        }
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* calculate the encoded value back from the decoded value and compare the original value for      */
+        /* comparison                                                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+		/* Take decode byte*/
+        src_re_calc = dst;
+
+		/* calc its' parity */
+        E0 = READ_VAR_FIELD(dst, BITF0);
+        E1 = READ_VAR_FIELD(dst, BITF1);
+        E2 = READ_VAR_FIELD(dst, BITF2);
+        E3 = READ_VAR_FIELD(dst, BITF3);
+
+        SET_VAR_FIELD(src_re_calc, BITF4, E0 ^ E1);
+        SET_VAR_FIELD(src_re_calc, BITF5, E2 ^ E3);
+        SET_VAR_FIELD(src_re_calc, BITF6, E0 ^ E2);
+        SET_VAR_FIELD(src_re_calc, BITF7, E1 ^ E3);
+
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Check that only one bit is corrected per byte                                                       */
+        /*-----------------------------------------------------------------------------------------------------*/
+        BER = src_re_calc ^ datain[i];
+
+        BER =    READ_VAR_FIELD(BER, BITF0)
+               + READ_VAR_FIELD(BER, BITF1)
+               + READ_VAR_FIELD(BER, BITF2)
+               + READ_VAR_FIELD(BER, BITF3)
+               + READ_VAR_FIELD(BER, BITF4)
+               + READ_VAR_FIELD(BER, BITF5)
+               + READ_VAR_FIELD(BER, BITF6)
+               + READ_VAR_FIELD(BER, BITF7);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Bit Error Rate can be 0x00 (no change) or 0x01 0x02 0x04 0x08 -> one bit change only            */
+        /*-------------------------------------------------------------------------------------------------*/
+        if ( BER > 1 )
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Use original nible :                                                                        */
+            /*---------------------------------------------------------------------------------------------*/
+            if (i % 2)
+            { // copy lower nibble to higher nibble
+                SET_VAR_FIELD(dataout[i/2], MSNF, LSN( datain[i] ));
+
+            }
+            else
+            { // copy lower nibble to lower nibble
+                SET_VAR_FIELD(dataout[i/2], LSNF, LSN( datain[i] ) );
+            }
+
+            status = HAL_ERROR_BAD_PARITY;
+        }
+
+
+    }
+
+    return status;
+
+
+
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_NibParEccEncode                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  datain -       pointer to decoded data buffer (buffer size should be 2 x dataout)      */
+/*                  dataout -      pointer to encoded data buffer                                          */
+/*                  encoded_size - size of encoded data (decoded data x 2)                                 */
+/*                                                                                                         */
+/* Returns:         HAL_STATUS                                                                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Decodes the data according to nibble parity ECC scheme.                                */
+/*                  Size specifies the encoded data size.                                                  */
+/*                  Decodes whole bytes only                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_NibParEccEncode (
+    UINT8 *datain,
+    UINT8 *dataout,
+    UINT32 encoded_size
+)
+{
+    UINT32 i;
+    UINT8 E0;
+    UINT8 E1;
+    UINT8 E2;
+    UINT8 E3;
+    HAL_STATUS status = HAL_OK;
+    UINT32 decoded_size = encoded_size/2;
+
+//Define the Bit Field macros in order to use the SET_VAR_FIELD macro:
+#define BITF0   0, 1
+#define BITF1   1, 1
+#define BITF2   2, 1
+#define BITF3   3, 1
+#define BITF4   4, 1
+#define BITF5   5, 1
+#define BITF6   6, 1
+#define BITF7   7, 1
+
+#define LSNF    0, 4
+#define MSNF    4, 4
+
+    for (i = 0; i < decoded_size; i++)
+    {
+        dataout[i*2] = LSN(datain[i]);
+        E0 = READ_VAR_FIELD(datain[i], BITF0);
+        E1 = READ_VAR_FIELD(datain[i], BITF1);
+        E2 = READ_VAR_FIELD(datain[i], BITF2);
+        E3 = READ_VAR_FIELD(datain[i], BITF3);
+
+        SET_VAR_FIELD(dataout[i*2], BITF4, E0 ^ E1);
+        SET_VAR_FIELD(dataout[i*2], BITF5, E2 ^ E3);
+        SET_VAR_FIELD(dataout[i*2], BITF6, E0 ^ E2);
+        SET_VAR_FIELD(dataout[i*2], BITF7, E1 ^ E3);
+        
+        dataout[i*2+1] = MSN(datain[i]);
+        E0 = READ_VAR_FIELD(datain[i], BITF4);
+        E1 = READ_VAR_FIELD(datain[i], BITF5);
+        E2 = READ_VAR_FIELD(datain[i], BITF6);
+        E3 = READ_VAR_FIELD(datain[i], BITF7);
+
+        SET_VAR_FIELD(dataout[i*2+1], BITF4, E0 ^ E1);
+        SET_VAR_FIELD(dataout[i*2+1], BITF5, E2 ^ E3);
+        SET_VAR_FIELD(dataout[i*2+1], BITF6, E0 ^ E2);
+        SET_VAR_FIELD(dataout[i*2+1], BITF7, E1 ^ E3);
+    }
+
+    return status;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_MajRulEccDecode                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  datain -       pointer to encoded data buffer (buffer size should be 3 x dataout)      */
+/*                  dataout -      pointer to decoded data buffer                                          */
+/*                  encoded_size - size of encoded data (decoded data x 3)                                 */
+/*                                                                                                         */
+/* Returns:         HAL_STATUS                                                                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Decodes the data according to Major Rule ECC scheme.                                   */
+/*                  Size specifies the encoded data size.                                                  */
+/*                  Decodes whole bytes only                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_MajRulEccDecode (
+    UINT8 *datain,
+    UINT8 *dataout,
+    UINT32 encoded_size
+)
+{
+    UINT  byte;
+    UINT  bit;
+    UINT8 E1, E2, E3;
+
+    UINT32 decoded_size = encoded_size/3;
+
+    for (byte = 0; byte < decoded_size; byte++)
+    {
+        for (bit = 0; bit < 8; bit++)
+        {
+            E1 = READ_VAR_BIT(datain[decoded_size*0+byte], bit);
+            E2 = READ_VAR_BIT(datain[decoded_size*1+byte], bit);
+            E3 = READ_VAR_BIT(datain[decoded_size*2+byte], bit);
+            if ((E1+E2+E3) >= 2)
+            {
+                SET_VAR_BIT(dataout[byte], bit);    //Majority is 1
+            }
+            else
+            {
+                 CLEAR_VAR_BIT(dataout[byte], bit); //Majority is 0
+            }
+        }//Inner for (bit)
+    }//Outer for (byte)
+
+    return HAL_OK;
+
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_MajRulEccEncode                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  datain -       pointer to decoded data buffer (buffer size should be 3 x dataout)      */
+/*                  dataout -      pointer to encoded data buffer                                          */
+/*                  encoded_size - size of encoded data (decoded data x 3)                                 */
+/*                                                                                                         */
+/* Returns:         HAL_STATUS                                                                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Decodes the data according to Major Rule ECC scheme.                                   */
+/*                  Size specifies the encoded data size.                                                  */
+/*                  Decodes whole bytes only                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS FUSE_MajRulEccEncode (
+    UINT8 *datain,
+    UINT8 *dataout,
+    UINT32 encoded_size
+)
+{
+    UINT  byte;
+    UINT  bit;
+    UINT8 bit_val;
+
+    UINT32 decoded_size = encoded_size/3;
+
+    for (byte = 0; byte < decoded_size; byte++)
+    {
+        for (bit = 0; bit < 8; bit++)
+        {
+            bit_val = READ_VAR_BIT(datain[byte], bit);
+
+            if (bit_val == 1)
+            {
+                SET_VAR_BIT(dataout[decoded_size*0+byte], bit);
+                SET_VAR_BIT(dataout[decoded_size*1+byte], bit);
+                SET_VAR_BIT(dataout[decoded_size*2+byte], bit);
+
+            }
+            else
+            {
+                CLEAR_VAR_BIT(dataout[decoded_size*0+byte], bit);
+                CLEAR_VAR_BIT(dataout[decoded_size*1+byte], bit);
+                CLEAR_VAR_BIT(dataout[decoded_size*2+byte], bit);
+            }
+        } // Inner for (bit)
+    }// Outer for (byte)
+
+    return HAL_OK;
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_ReadFustrap                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  oFuse - fuse value to read                                                             */
+/*                                                                                                         */
+/* Returns:         retVal                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is a getter for fustrap                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT           FUSE_Fustrap_Get (FUSE_FUSTRAP_FIELDS_T oFuse)
+{
+    UINT retVal = 0;
+    switch (oFuse)
+    {
+        case FUSE_FUSTRAP_DIS_FAST_BOOT:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_DIS_FAST_BOOT);
+            break;
+
+        case FUSE_FUSTRAP_oWDEN:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oWDEN);
+            break;
+
+        case FUSE_FUSTRAP_oHLTOF:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oHLTOF);
+            break;
+
+        case FUSE_FUSTRAP_oAESKEYACCLK:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oAESKEYACCLK);
+            break;
+
+        case FUSE_FUSTRAP_oJDIS:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oJDIS);
+            break;
+
+        case FUSE_FUSTRAP_oSECBOOT:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oSECBOOT);
+            break;
+
+        case FUSE_FUSTRAP_USEFUSTRAP:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_USEFUSTRAP);
+            break;
+
+        case FUSE_FUSTRAP_oPKInvalid2_0:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oPKInvalid2_0);
+            break;
+
+        case FUSE_FUSTRAP_oAltImgLoc:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oAltImgLoc);
+            break;
+
+        case FUSE_FUSTRAP_Bit_28:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_BIT_28);
+            break;
+
+        case FUSE_FUSTRAP_oSecBootDisable:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oSecBootDisable);
+            break;
+
+        case FUSE_FUSTRAP_oCPU1STOP2:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oCPU1STOP2);
+            break;
+
+        case FUSE_FUSTRAP_oCPU1STOP1:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oCPU1STOP1);
+            break;
+
+        case FUSE_FUSTRAP_oHINDDIS:
+            retVal = READ_REG_FIELD(FUSTRAP, FUSTRAP_oHINDDIS);
+            break;
+                
+
+        default:
+            ASSERT(FALSE);
+            break;
+    }
+
+    return retVal;
+}
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.h b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.h
new file mode 100755
index 0000000..4b87e31
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_drv.h
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fuse_drv.h                                                                                            */
+/*            This file contains API of FUSE module routines for ROM code                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef FUSE_DRV_H
+#define FUSE_DRV_H
+
+#include "../fuse_if.h"
+#include "../../aes/aes_if.h"
+
+
+#endif /* FUSE_DRV_H */
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_regs.h b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_regs.h
new file mode 100755
index 0000000..9db1247
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fuse/Poleg_IP/fuse_regs.h
@@ -0,0 +1,102 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fuse_regs.h                                                                                           */
+/*            This file contains definitions of FUSE module registers                                      */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef FUSE_REGS_H
+#define FUSE_REGS_H
+
+#include "../../../Chips/chip.h"
+
+
+
+/**************************************************************************************************************************/
+/*   Fuse Array Control Register (FCTL1,2)                                                                                */
+/**************************************************************************************************************************/
+#define  FCTL(n)                         (FUSE_BASE_ADDR(n) + 0x14) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+14h */
+#define  FCTL_FCTL                     0 , 32             /* 31-0 FCTL. A sequence of two adjacent writes to this register, first with a value of 0000_0001h and the second with   */
+
+/**************************************************************************************************************************/
+/*   Fuse Array Status Register (FST1,2)                                                                                  */
+/**************************************************************************************************************************/
+#define  FST(n)                          (FUSE_BASE_ADDR(n) + 0x00) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+00h */
+#define  FST_RIEN                      2 , 1               /* 2 RIEN (Ready Interrupt Enable). Enables an interrupt when RDST bit is set. (Bit added in Poleg)                      */
+#define  FST_RDST                      1 , 1               /* 1 RDST (Ready Status). This bit is set by hardware when a read or program operation is competed and                   */
+#define  FST_RDY                       0 , 1               /* 0 RDY (Ready). If cleared to 0, indicates that the fuse array interface is busy processing a read or                  */
+
+/**************************************************************************************************************************/
+/*   Fuse Array Address Register (FADDR1,2)                                                                               */
+/**************************************************************************************************************************/
+#define  FADDR(n)                        (FUSE_BASE_ADDR(n) + 0x04) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+04h */
+#define  FADDR_BITPOS                  10 , 3             /* (n)-10 BITPOS (Bit Position). For write operations, designates the position of the bit (to be programmed) in the byte  */
+#define  FADDR_BYTEADDR                0 , 10             /* 9-0 BYTEADDR (Fuse Read Address). Designates the byte address in the fuse array for read and program                  */
+
+/**************************************************************************************************************************/
+/*   Fuse Array Data Register (FDATA1,2)                                                                                  */
+/**************************************************************************************************************************/
+#define  FDATA(n)                        (FUSE_BASE_ADDR(n) + 0x08) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+08h */
+#define  FDATA_FDATA                   0 , 8              /* 7-0 FDATA. On read, returns the data from the read operation. The register contents are valid only if RDY bit in      */
+
+/**************************************************************************************************************************/
+/*   Fuse Array Configuration Register (FCFG1,2)                                                                          */
+/**************************************************************************************************************************/
+#define  FCFG(n)                         (FUSE_BASE_ADDR(n) + 0x0C) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+0Ch */
+#define  FCFG_FDIS                     31 , 1              /* 31 FDIS (Fuse Array Disable). This sticky bit disables access to the first 2048 bits of the fuse array, either        */
+#define  FCFG_APBRT                    24 , 6             /* 29-24 APBRT (APB Clock Rate). Informs the fuse array state machine on the APB clock rate in MHz. The                  */
+#define  FCFG_FCFGLK                   16 , 8             /* 23-16 FCFGLK (FCFG Lock). Bit FCFGLKn locks the corresponding FPRGLKn and FRDLKn bits. These bits                     */
+#define  FCFG_FPRGLK                   8 , 8              /* FPRGLK (Fuse Program Lock). Controls program access to the fuse array. FPRGLKn bit protects the                       */
+#define  FCFG_FRDLK                    0 , 8              /* FRDLK (Fuse Read Lock). Controls APB read access to the fuse array. Bit FRDLKn protects the nth                       */
+
+/**************************************************************************************************************************/
+/*   Fuse Key Index Register (FKEYIND)                                                                                    */
+/**************************************************************************************************************************/
+#define  FKEYIND                        (FUSE_BASE_ADDR(0) + 0x10) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+10h */
+#define  FKEYIND_KIND                    18 , 2             /* 19-18 KIND (Key Index). Indicates the address of the key in the fuse array, in 5(n)-bit steps. (Changed in             */
+#define  FKEYIND_FUSERR                  8 , 1               /* 8 FUSERR (Fuse Error). Indicates that the ECC decoding mechanism detected an error while reading                      */
+#define  FKEYIND_KSIZE                   4 , 3              /* 6-4 KSIZE (Key Size). Indicates the size of the cryptographic key to upload on the sideband key port.                 */
+#define  FKEYIND_KVAL                    0 , 1               /* 0 KVAL (Key Valid). Indicates whether the sideband key port contents are valid. This bit is cleared to 0              */
+
+/**************************************************************************************************************************/
+/*   Fuse Strap Register (FUSTRAP)                                                                                        */
+/**************************************************************************************************************************/
+#define  FUSTRAP                        (FUSE_BASE_ADDR(1) + 0x10) , FUSE_OTP_ACCESS, 32 		/* Location: BASE+10h */
+#define  FUSTRAP_DIS_FAST_BOOT           29 , 1              /* 29 DIS_FAST_BOOT (Disable Fast Boot). (Z2) Disables the option to jump to SPI flash before MDLR is written.           */
+#define  FUSTRAP_BIT_28                  28 , 1    /* Apears on ROM flow. Name unknown ! */
+#define  FUSTRAP_oWDEN                   27 , 1              /* 27 oWDEN (Watchdog Enable). If set, tells the ROM Code to enable a 22 seconds watchdog before jumping to              */
+#define  FUSTRAP_oHLTOF                  26 , 1              /* 26 oHLTOF (Halt on Failure). If set, tells the ROM Code to halt execution on a signature verification failure.        */
+#define  FUSTRAP_oAESKEYACCLK            25 , 1              /* 25 oAESKEYACCLK (AES Key Access Lock). If set, prevents any access to the first 2048 bits of the Key Storage          */
+#define  FUSTRAP_oJDIS                   24 , 1              /* 24 oJDIS (JTAG Disable). If set, locks (disables) the BMC CPU JTAG port. It can be reopened via JTAGDIS bit in        */
+#define  FUSTRAP_oSECBOOT                23 , 1              /* 23 oSECBOOT (Secure Boot). If set, indicates that the ROM code will perform an integrity check on power-up,           */
+#define  FUSTRAP_USEFUSTRAP              22 , 1              /* 22 USEFUSTRAP. When set, indicates the configuration in this register must be used instead of the configuration       */
+#define  FUSTRAP_oPKInvalid2_0           19 , 3              /* 21-19 oPKInvalid2-0. A 3 bit field that may invalidate a Public Key (oPK2-0) stored in OTP. Bit 21 is for oPK2, Bit 20*/
+#define  FUSTRAP_oAltImgLoc              18 , 1              /* 18 oAltImgLoc. Alternate image location definition.                                                                   */
+#define  FUSTRAP_FUSTRAP_SFAB            11 , 1              /* 11 FUSTRAP(n). System Flash Attached to BMC (SFAB).                                                                    */
+#define  FUSTRAP_FUSTRAP3_1              0 ,  3              /* 2-0 FUSTRAP3-1. CPU core clock and DDR4 memory frequency (CKFRQ). See Power-On Setting Register                       */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Added on Z2:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  FUSTRAP_oHINDDIS               14 , 1               /* oHINDDIS (Host Independence Disable). Disables initialization of a few registers in step 1 of the ROM code */
+#define  FUSTRAP_oSecBootDisable        15 , 1               /* {oSecBootDisable} - when set, disables capability enter Secure Mode. Used for Derivatives.*/
+#define  FUSTRAP_oCPU1STOP2             16 , 1               /* {oCPU1STOP2} - when set, stops CPU core 1 clock. */
+#define  FUSTRAP_oCPU1STOP1             17 , 1               /* {oCPU1STOP1} - when set, CPU core 1 stops and cannot be woken.*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FKEYIND field values                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  FKEYIND_KSIZE_VALUE_128          0x4
+#define  FKEYIND_KSIZE_VALUE_192          0x5
+#define  FKEYIND_KSIZE_VALUE_256          0x6
+
+
+#endif /* FUSE_REGS_H */
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.c b/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.c
new file mode 100755
index 0000000..37e38b7
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fuse_if.c                                                                                             */
+/*            This file contains FUSE module driver selector                                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(FUSE_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(fuse, FUSE_MODULE_TYPE)
+#endif    
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.h b/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.h
new file mode 100755
index 0000000..16c5a35
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/fuse/fuse_if.h
@@ -0,0 +1,152 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   fuse_if.h                                                                                            */
+/*            This file contains API of FUSE module routines for ROM code                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef FUSE_IF_H
+#define FUSE_IF_H
+
+#include "defs.h"
+#include "../aes/aes_if.h"
+#include "../../Common/hal_error.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse module definitions                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FUSE_ARR_BYTE_SIZE  128
+#define KEYS_ARR_BYTE_SIZE  128
+
+#define RSA_KEY_BYTE_SIZE       256
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse ECC type                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FUSE_ECC_TYPE_tag
+{
+    FUSE_ECC_MAJORITY = 0,
+    FUSE_ECC_NIBBLE_PARITY = 1,
+    FUSE_ECC_NONE = 2
+}  FUSE_ECC_TYPE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse key Type                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FUSE_KEY_TYPE_tag
+{
+    FUSE_KEY_AES = 0,
+    FUSE_KEY_RSA = 1
+}  FUSE_KEY_TYPE_T;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse module enumerations                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Storage Array Type:                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (NPCM750)
+typedef enum
+{
+    KEY_SA    = 0,
+    FUSE_SA   = 1
+} FUSE_STORAGE_ARRAY_T;
+#else
+typedef enum
+{
+    KEY_SA,
+    FUSE_SA
+} STORAGE_ARRAY_T;
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUSTRAP fields definition                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FUSE_FUSTRAP_FIELDS_T_tag
+{
+    FUSE_FUSTRAP_DIS_FAST_BOOT = 29,                    // (Disable Fast Boot).
+    FUSE_FUSTRAP_Bit_28 = 28,                            // unknown register field !
+    FUSE_FUSTRAP_oWDEN = 27,                            // (Watchdog Enable).
+    FUSE_FUSTRAP_oHLTOF = 26,                           // (Halt on Failure). I
+    FUSE_FUSTRAP_oAESKEYACCLK = 25,                     // (AES Key Access Lock).
+    FUSE_FUSTRAP_oJDIS = 24,                            // (JTAG Disable).
+    FUSE_FUSTRAP_oSECBOOT = 23,                         // (Secure Boot).
+    FUSE_FUSTRAP_USEFUSTRAP = 22,                       //
+    FUSE_FUSTRAP_oPKInvalid2_0 = 19,                    //
+    FUSE_FUSTRAP_oAltImgLoc = 18,                       //  Alternate image location definition.
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Added on Z2                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FUSE_FUSTRAP_oHINDDIS         =      14,            // oHINDDIS: disable eSPI independent mode
+    FUSE_FUSTRAP_oSecBootDisable  =      15,            // {oSecBootDisable} - when set, disables capability enter Secure Mode. Used for Derivatives.*/
+    FUSE_FUSTRAP_oCPU1STOP2 =            16,            // {oCPU1STOP2} - when set, stops CPU core 1 clock. */
+    FUSE_FUSTRAP_oCPU1STOP1 =            17             // {oCPU1STOP1} - when set, CPU core 1 stops and cannot be woken.*/
+
+
+} FUSE_FUSTRAP_FIELDS_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Fuse module exported functions                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HW level functions:                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (NPCM750)
+HAL_STATUS   FUSE_Init                      (void);
+void         FUSE_Read                      (FUSE_STORAGE_ARRAY_T arr, UINT16 addr, UINT8 *data);
+HAL_STATUS   FUSE_ProgramBit                (FUSE_STORAGE_ARRAY_T arr, UINT16 byteNum, UINT8 bitNum);
+HAL_STATUS   FUSE_ProgramByte               (FUSE_STORAGE_ARRAY_T arr, UINT16 byteNum, UINT8 value);
+BOOLEAN      FUSE_BitIsProgrammed           (FUSE_STORAGE_ARRAY_T arr, UINT16 byteNum, UINT8 bitNum);
+void         FUSE_UploadKey                 (AES_KEY_SIZE_T keySize, UINT8 keyIndex);
+HAL_STATUS   FUSE_ReadKey                   (FUSE_KEY_TYPE_T  keyType, UINT8  keyIndex, UINT8 *output);
+void         FUSE_DisableKeyAccess          (void);
+HAL_STATUS   FUSE_SelectKey                 (UINT8 keyIndex);
+HAL_STATUS   FUSE_LockAccess                (FUSE_STORAGE_ARRAY_T array, UINT8 lockForRead, UINT8 lockForWrite, BOOLEAN lockRegister);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ECC handling                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS   FUSE_NibParEccDecode           (UINT8 *datain,    UINT8 *dataout,    UINT32  size);
+HAL_STATUS   FUSE_NibParEccEncode           (UINT8 *datain,    UINT8 *dataout,    UINT32  size);
+HAL_STATUS   FUSE_MajRulEccDecode           (UINT8 *datain,    UINT8 *dataout,    UINT32  encoded_size);
+HAL_STATUS   FUSE_MajRulEccEncode           (UINT8 *datain,    UINT8 *dataout,    UINT32  encoded_size);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* FUSTRAP register getter                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT          FUSE_Fustrap_Get               (FUSE_FUSTRAP_FIELDS_T oFuse);
+
+#else
+
+void        FUSE_Init                      (UINT8 APBclock);
+void        FUSE_Read                      (STORAGE_ARRAY_T arr, UINT8 addr, UINT8 *data);
+HAL_STATUS  FUSE_ProgramBit                (STORAGE_ARRAY_T arr, UINT8 byteNum, UINT8 bitNum);
+HAL_STATUS  FUSE_ProgramByte               (STORAGE_ARRAY_T arr, UINT8 byteNum, UINT8 value);
+BOOLEAN     FUSE_BitIsProgrammed           (STORAGE_ARRAY_T arr, UINT8 byteNum, UINT8 bitNum);
+void        FUSE_UploadKey                 (AES_KEY_SIZE_T keySize, UINT8 keyIndex);
+HAL_STATUS  FUSE_ReadKey                   (AES_KEY_SIZE_T keySize, UINT8 keyIndex, UINT8 *output);
+void        FUSE_DisableKeyAccess          (void);
+
+//Logical level functions:
+void        FUSE_NibParEccDecode           (UINT8 *datain, UINT8* dataout, UINT8 size);
+HAL_STATUS  FUSE_MajRulEccDecode           (UINT8 *datain, UINT8* dataout, UINT8 size);
+void        FUSE_ReadFuseProtectionWord    (UINT16 *word);
+void        FUSE_ReadDerivatives           (UINT32 *dword);
+void        FUSE_ReadVerFaultProt          (UINT32 *dword);
+#endif
+
+#endif /* FUSE_IF_H */
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.c b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.c
new file mode 100755
index 0000000..a73510a
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.c
@@ -0,0 +1,823 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gcr_drv.c                                                                                             */
+/*            This file contains GCR (Global Conrol Registers) module access functions                     */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GCR_C
+
+#include "../../../Common/hal_common.h"
+#include "../../../Chips/chip.h"
+
+#include "gcr_drv.h"
+#include "gcr_regs.h"
+
+#include "../../uart/uart_if.h"
+#include "../../gpio/gpio_if.h"
+#include "../../strp/strp_if.h"
+#include "../../pspi/pspi_if.h"
+#include "../../sd/sd_if.h"
+#include "../../fiu/fiu_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access macroes                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define POR_RESET()         (READ_REG_FIELD(INTCR2, INTCR2_PORST))          //Reset source was POR (powerOn) reset
+#define COR_RESET()         (READ_REG_FIELD(INTCR2, INTCR2_CORST))          //Reset source was COR reset
+#define MARK_CFG_DONE()      SET_REG_FIELD(INTCR2, INTCR2_CFG_DONE, 1)         //Chip configuration (MC, CLK, Flash, etc') is done
+#define CFG_IS_DONE()       (READ_REG_FIELD(INTCR2, INTCR2_CFG_DONE))            //Chip configuration (MC, CLK, Flash, etc') is done
+#define ENABLE_JTAG()        SET_REG_FIELD(FLOCKR1, FLOCKR1_JTAGDIS, 0)     //Rnables J-Tag
+#define DISABLE_JTAG()       SET_REG_FIELD(FLOCKR1, FLOCKR1_JTAGDIS, 1)       //Disables J-Tag
+
+
+#if defined (UART_MODULE_TYPE)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_Uart                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  CoreSP -                                                                               */
+/*                  redirection_mode -                                                                     */
+/*                  sp1 -                                                                                  */
+/*                  sp2 -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects UART muxing                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_Uart(UINT redirection_mode, BOOLEAN CoreSP, BOOLEAN sp1, BOOLEAN sp2)
+{
+    /* 111 combination is reserved: */
+    if (redirection_mode >= 7)
+        return;
+
+    SET_REG_FIELD(SPSWC, SPSWC_SPMOD, redirection_mode & 0x7); /* redirection mode number in enum == value at register */
+
+    if (CoreSP)
+	{
+        SET_REG_FIELD(MFSEL1, MFSEL1_BSPSEL,  1);
+        SET_REG_FIELD(MFSEL4, MFSEL4_BSPASEL, 1); /* use BSPRXD + BSPTXD */
+	}
+    if (sp1)
+	{
+        SET_REG_FIELD(MFSEL1, MFSEL1_HSI1SEL, 1);
+        SET_REG_FIELD(MFSEL4, MFSEL4_BSPASEL, 0); /* Select TXD2+RXD2 */
+	}
+    if (sp2)
+	{
+        SET_REG_FIELD(MFSEL1, MFSEL1_HSI2SEL, 1);
+        SET_REG_FIELD(MFSEL4, MFSEL4_BSPASEL, 0); /* Select TXD2+RXD2 */
+	}
+}
+#endif // UART_MODULE_TYPE
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SPIFash                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - SPI Flash device number                                                      */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SPI Flash muxing                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_SPIFash(UINT devNum)
+{
+    switch (devNum)
+    {
+        case 1:     SET_REG_FIELD(MFSEL1, MFSEL1_S0CS1SEL, 1);    break;
+        case 2:     SET_REG_FIELD(MFSEL1, MFSEL1_S0CS2SEL, 1);    break;
+        case 3:     SET_REG_FIELD(MFSEL1, MFSEL1_S0CS3SEL, 1);    break;
+    }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_MuxFIU                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - SPI Flash device number                                                      */
+/*                  csXEnable - enable CS.                                                                 */
+/*                  quadMode -  is Quad mode                                                               */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects FIU muxing . Notice it does not disable a CS!                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GCR_MuxFIU (   FIU_MODULE_T      devNum,
+                          BOOLEAN           cs0Enable,
+                          BOOLEAN           cs1Enable,
+                          BOOLEAN           cs2Enable,
+                          BOOLEAN           cs3Enable,
+                          BOOLEAN           quadMode)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* CS2 and CS3 are multiplexed with spid2 and spid3. So when in quad mode, can't use CS2 and CS3       */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+    switch (devNum)
+    {
+        case FIU_MODULE_0:
+        {
+            /* config CS */
+            if ( cs0Enable == TRUE)
+            {
+                // nothing to do.
+            }
+
+            /* config CS1 */
+            if ( cs1Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL1, MFSEL1_S0CS1SEL, 1);
+            }
+
+            /* Config CS2 */
+            if ( cs2Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL1, MFSEL1_S0CS2SEL, 1);
+            }
+
+            /* Config CS3 */
+            if ( cs3Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL1, MFSEL1_S0CS3SEL, 1);
+            }
+
+
+            /* select io bus width (1/2/4  <=> single/dual/quad ) */
+            if (quadMode == TRUE)
+            {
+                SET_REG_FIELD (MFSEL1, MFSEL1_S0CS2SEL, 0);  /*  0: GPIO33/SPI0D2 ,1: nSPI0CS2     */
+                SET_REG_FIELD (MFSEL1, MFSEL1_S0CS3SEL, 0);  /*  0: GPIO34/SPI0D3 ,1: nSPI0CS3     */
+                SET_REG_FIELD (MFSEL4, MFSEL4_SP0QSEL , 1);  /* enable quad */
+            }
+            break;
+        }
+        case FIU_MODULE_3:
+        {
+            /* Select SPI3 */
+            SET_REG_FIELD(MFSEL4, MFSEL4_SP3SEL, 1);
+
+            /* config CS */
+            if ( cs0Enable == TRUE)
+            {
+                // nothing to do.
+            }
+
+            /* config CS1 */
+            if ( cs1Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL4, MFSEL4_S3CS1SEL, 1);
+            }
+
+            /* Config CS2 */
+            if ( cs2Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL4, MFSEL4_S3CS2SEL, 1);
+            }
+
+            /* Config CS3 */
+            if ( cs3Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL4, MFSEL4_S3CS3SEL, 1);
+            }
+
+
+            /* select io bus width (1/2/4  <=> single/dual/quad ) */
+            if (quadMode == TRUE)
+            {
+                SET_REG_FIELD (MFSEL4, MFSEL4_S3CS2SEL, 0);  /*  0: GPIO33/SPI0D2 ,1: nSPI0CS2     */
+                SET_REG_FIELD (MFSEL4, MFSEL4_S3CS3SEL, 0);  /*  0: GPIO34/SPI0D3 ,1: nSPI0CS3     */
+                SET_REG_FIELD (MFSEL4, MFSEL4_SP3QSEL , 1);  /* enable quad */
+            }
+            break;
+        }
+        case FIU_MODULE_X:
+        {
+            /* config CS */
+            if ( cs0Enable == TRUE)
+            {
+                // nothing to do.
+            }
+
+            /* config CS1 */
+            if ( cs1Enable == TRUE)
+            {
+                SET_REG_FIELD(MFSEL4, MFSEL4_SXCS1SEL, 1);
+            }
+
+            SET_REG_FIELD(MFSEL4, MFSEL4_SPXSEL, 1);
+            break;
+        }
+
+        default:          
+           break;
+    }
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_RMII                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects RMII mux                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_RMII(UINT devNum)
+{
+    if(devNum == 0)            // ETH0 - EMC1
+    {
+        SET_REG_FIELD(MFSEL3, MFSEL3_RMII1SEL, 1);
+        SET_REG_FIELD(MFSEL1, MFSEL1_R1MDSEL, 1);
+        SET_REG_FIELD(MFSEL1, MFSEL1_R1ERRSEL, 1);
+        SET_REG_FIELD(INTCR,  INTCR_R1EN, 1);
+    }
+    else if(devNum == 1)       // ETH1 - EMC2
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_RMII2SEL, 1);
+        SET_REG_FIELD(MFSEL1, MFSEL1_R2MDSEL, 1);
+        SET_REG_FIELD(MFSEL1, MFSEL1_R2ERRSEL, 1);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetDacSense                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Makes the trigger for sense circuits to be GFX core output signal (miscOUT2)           */
+/*                  instead of VSYNC falling edge                                                          */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetDacSense(void)
+{
+    SET_REG_FIELD(INTCR, INTCR_DAC_SNS, 1);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_GMII                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects GMII mux                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GMII(UINT devNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting the RGMII Muxing                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum == 2)            // ETH2 - GMAC1
+    {
+        SET_REG_FIELD(MFSEL4, MFSEL4_RG1SEL, 1);
+        SET_REG_FIELD(MFSEL4, MFSEL4_RG1MSEL, 1);
+    }
+    else if (devNum == 3)       // ETH3 - GMAC2
+    {
+        SET_REG_FIELD(MFSEL4, MFSEL4_RG2SEL, 1);
+        SET_REG_FIELD(MFSEL4, MFSEL4_RG2MSEL, 1);
+    }
+
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SIOXH                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  enable -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SIOXH mux                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_SIOXH(BOOLEAN enable)
+{
+    if (enable)
+    {
+        SET_REG_FIELD(MFSEL3, MFSEL3_IOXHSEL, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(MFSEL3, MFSEL3_IOXHSEL, 0);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_PSPI                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - Peripheral SPI device number                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs muxing for Peripheral SPI device                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_PSPI(UINT devNum)
+{
+    switch (devNum)
+    {
+        case PSPI1_DEV:     SET_REG_FIELD(MFSEL3, MFSEL3_PSPI1SEL, 0x2);          break;
+        case PSPI2_DEV:     SET_REG_FIELD(MFSEL3, MFSEL3_PSPI2SEL, 0x1);          break;
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_GSPI                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs muxing for Graphics Core SPI Signals                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GSPI(void)
+{
+    SET_REG_FIELD(MFSEL1, MFSEL1_GSPISEL, 1);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_PowerOn_GetMemorySize                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns configured DDR memory size                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 GCR_PowerOn_GetMemorySize(void)
+{
+
+
+    UINT32 pwronRAMsize =  READ_REG_FIELD(INTCR3, INTCR3_GMMAP);
+
+
+    switch(pwronRAMsize)
+    {
+        case 0:       
+            return 0x08000000;        // 128 MB.
+        case 1:
+            return 0x10000000;        // 256 MB.
+        case 2:
+            return 0x20000000;        // 512 MB.
+        case 3:
+            return 0x40000000;        // 1 GB.
+        case 4:
+            return 0x80000000;        // 2 GB.
+            
+        default:          
+           break;
+    }
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_GPIO                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs mux for given GPIO                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GPIO(UINT gpio_num)
+{
+    GPIO_MUX_REGID_T    mux_reg1, mux_reg2;
+    GPIO_MUX_FIELD_T    mux1, mux2;
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting Mux information from GPIO module                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_GetMuxInfo(gpio_num, &mux_reg1, &mux1, &mux_reg2, &mux2);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Bypass for using DEFS.H macros                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    #define GCR_GPIO_MUX_FIELD1  mux1.position, mux1.size
+    #define GCR_GPIO_MUX_FIELD2  mux2.position, mux2.size
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Muxing                                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (mux1.size != 0)
+    {
+        SET_REG_FIELD(MFSEL(mux_reg1), GCR_GPIO_MUX_FIELD1, mux1.value);
+    }
+
+    if (mux2.size != 0)
+    {
+        SET_REG_FIELD(MFSEL(mux_reg2), GCR_GPIO_MUX_FIELD2, mux2.value);
+    }
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_PinPullUpDown                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num    -                                                                          */
+/*                  enable      -                                                                          */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets internal Pull Up/Down resistor for the given pin                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_PinPullUpDown(UINT32 gpio_num, BOOLEAN enable)
+{
+    UINT    port_num = 0;
+    UINT    port_bit = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Retriving GPIO info                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_GetGPIOInfo(gpio_num, &port_num, &port_bit);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Pull Up/Down configuration                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (enable)
+    {
+        SET_REG_BIT(GPIOPxPE(port_num), port_bit);
+    }
+    else
+    {
+        CLEAR_REG_BIT(GPIOPxPE(port_num), port_bit);
+    }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SD                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                 sdNum    - [in], SD device number                                                       */
+/*                 devType  - [in], SD1 device type (SD or MMC or MMC8)                                    */
+/*                                                                                                         */
+/* Returns:         BMC HAL Error code                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SD mux                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GCR_Mux_SD(SD_DEV_NUM_T sdNum, SD_DEV_TYPE_T sdType)
+{
+    UINT32          SDnIRVn;
+    if (sdNum >= SD_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (sdNum == SD1_DEV)
+    {
+    	/*-----------------------------------------------------------------------------------------------------*/
+        /* SD Fix internal straps reset value                                                                  */
+        /*-----------------------------------------------------------------------------------------------------*/
+        SDnIRVn = REG_READ(SD1IRV2);
+        SET_VAR_FIELD(SDnIRVn, SDnIRV2_corecfg_sdr50support, 0);   // disable sdr50 support
+        SET_VAR_FIELD(SDnIRVn, SDnIRV2_corecfg_baseclkfreq, 0x32); // Base Clock Frequency is 50MHz (0x32)
+        REG_WRITE(SD1IRV2, SDnIRVn);
+        
+        SDnIRVn = REG_READ(SD1IRV1);
+        SET_VAR_FIELD(SDnIRVn, SDnIRV1_corectrl_otapdlyena,   1);    // Output Tap Delay Enable
+        SET_VAR_FIELD(SDnIRVn, SDnIRV1_corectrl_otapdlysel, 0xF);    // Output Tap Delay: 15 = ~3ns
+        REG_WRITE(SD1IRV1, SDnIRVn);
+        
+    	/*-----------------------------------------------------------------------------------------------------*/
+        /* SD Mux select                                                                                       */
+        /*-----------------------------------------------------------------------------------------------------*/
+        SET_REG_FIELD(MFSEL3, MFSEL3_SD1SEL, 1);
+    }
+    else if (sdNum == SD2_DEV)
+    {
+    	/*-----------------------------------------------------------------------------------------------------*/
+        /* eMMC Fix internal straps reset value                                                                */
+        /*-----------------------------------------------------------------------------------------------------*/
+        SDnIRVn = REG_READ(SD2IRV2);
+        SET_VAR_FIELD(SDnIRVn, SDnIRV2_corecfg_sdr50support, 0);   // disable sdr50 support
+        SET_VAR_FIELD(SDnIRVn, SDnIRV2_corecfg_baseclkfreq, 0x32); // Base Clock Frequency is 50MHz (0x32)
+        REG_WRITE(SD2IRV2, SDnIRVn);
+        
+        SDnIRVn = REG_READ(SD2IRV1);
+        SET_VAR_FIELD(SDnIRVn, SDnIRV1_corectrl_otapdlyena,   1);    // Output Tap Delay Enable
+        SET_VAR_FIELD(SDnIRVn, SDnIRV1_corectrl_otapdlysel, 0xF);    // Output Tap Delay: 15 = ~3ns
+        REG_WRITE(SD2IRV1, SDnIRVn);
+        
+    	/*-----------------------------------------------------------------------------------------------------*/
+        /* eMMC Mux select                                                                                     */
+        /*-----------------------------------------------------------------------------------------------------*/
+        SET_REG_FIELD(MFSEL3, MFSEL3_MMCSEL, 1);
+        
+        if(GCR_Get_Chip_Version() == POLEG_Z1)
+        {
+            /* Z1 only */
+            SET_REG_FIELD(MFSEL3, MFSEL3_SMB13SEL, 1);
+        }
+        else
+        {
+            /* Z2 and up */
+            SET_REG_FIELD(MFSEL3, MFSEL3_MMCCDSEL, 0); 
+            SET_REG_FIELD(MFSEL4, MFSEL4_MMCRSEL, 1);
+        }
+
+        SET_REG_FIELD(MFSEL3, MFSEL3_MMC8SEL, sdType == SD_DEV_MMC8); // 8 bit mux according to sdType
+        SET_REG_FIELD(SD2IRV1, SDnIRV1_corecfg_8bitsupport, sdType == SD_DEV_MMC8); // 8-Bit Support according to sdType
+    }
+
+    return HAL_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootTimeConfig                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  clk - Card clock frequency (in Hz units)                                               */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates and configures the number of SDCLK clock cycles:               */
+/*                   1) In a 50 millisecond time.                                                          */
+/*                   1) In a 1 second time.                                                                */
+/*                  These values are being used to determine whether Boot Time-Out has occured.            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootTimeConfig (UINT32 clk)
+{
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootStart                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ack - TRUE means expect the boot acknowledge data, FALSE otherwise.                    */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initiates a EMMC boot sequence.                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootStart (BOOLEAN ack)
+{
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootInvalid                                                                    */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         TRUE if boot is invalid, FALSE otherwise                                               */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks whether the current boot process is invalid,                       */
+/*                  i.e., one of the following has occured:                                                */
+/*                   1) The device did not respond in time with the boot acknowledge sequence or data.     */
+/*                   2) An error in data structure occurred.                                               */
+/*                   3) A CRC error occurred when reading from the eMMC device.                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_EmmcBootInvalid (void)
+{
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootEnd                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine ends a EMMC boot sequence, either when the boot sequence is done,         */
+/*                  or an error is discovered.                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootEnd (void)
+{
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetVCDInput                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  headNum - Number of the head (1 or 2)                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects the intput for the VCD                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetVCDInput(GCR_VCD_HEAD_T headNum)
+{
+    if (headNum == GCR_VCD_HEAD1)
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_DVH1SEL, 1);
+    }
+    else if (headNum == GCR_VCD_HEAD2)
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_DVH1SEL, 0);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetGFXInput                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  config - GFX configuration                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects the intput for the VCD                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetGFXConfig(GCR_GFX_CONFIG_T config)
+{
+    if (config == GCR_GFX_CONFIG_OUTPUT_FROM_HEAD1)
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_DVOSEL, MFSEL1_DVOSEL_OUTPUT_HEAD1);
+    }
+    else if (config == GCR_GFX_CONFIG_OUTPUT_FROM_HEAD2)
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_DVOSEL, MFSEL1_DVOSEL_OUTPUT_HEAD2);
+    }
+    else if (config == GCR_GFX_CONFIG_INPUT_TO_KVM)
+    {
+        SET_REG_FIELD(MFSEL1, MFSEL1_DVOSEL, MFSEL1_DVOSEL_INPUT_KVM);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ConfigUSBBurstSize                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the USB burst size in USB test register                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_ConfigUSBBurstSize(void)
+{
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ResetTypeIsPor                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns true if reset source was POR (powerOn) reset                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_ResetTypeIsPor()
+{
+    return POR_RESET();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ResetTypeIsCor                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns TRUE if and only if a Core reset is performed                                  */
+/*                  and FALSE on any other reset type.                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_ResetTypeIsCor()
+{
+    return (COR_RESET() & !POR_RESET());
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_MarkCfgDone                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Sets a flag in scratch register specifying that CLK/DDR configuration were performed   */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_MarkCfgDone()
+{
+    MARK_CFG_DONE();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_CfgWasDone                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns true if a flag in scratch register indicates                                   */
+/*                  that CLK/DDR configuration was already done                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_CfgWasDone()
+{
+    return CFG_IS_DONE();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EnableJtag                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enable Jtag access                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EnableJtag()
+{
+   ENABLE_JTAG() ;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_DisableJtag                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Disable Jtag access                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_DisableJtag()
+{
+    DISABLE_JTAG();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_DisableModules                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  mdlr -  Value to write to MDLR register                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Writes to the MDLR register which determines which modules to disable                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_DisableModules(UINT32 mdlr)
+{
+    REG_WRITE(MDLR, mdlr);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Get_Chip_Version                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                                                         */
+/* Returns:         PDID value                                                                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the chip version (POLEG_VERSION_Z1/ POLEG_VERSION_Z2              */
+/*                                                         POLEG_VERSION_A1)                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 GCR_Get_Chip_Version(void)
+{
+    return REG_READ(PDID);
+}
+
+
+
+#undef GCR_C
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.h b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.h
new file mode 100755
index 0000000..4cd731f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_drv.h
@@ -0,0 +1,19 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gcr_drv.h                                                                                             */
+/*            This file contains API of GCR (General Control Registers) module                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef GCR_DRV_H
+#define GCR_DRV_H
+
+#include "../gcr_if.h"
+
+#endif //GCR_DRV_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_regs.h b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_regs.h
new file mode 100755
index 0000000..e2e8d26
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gcr/Poleg_IP/gcr_regs.h
@@ -0,0 +1,814 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gcr_regs.h                                                                                            */
+/*            This file contains definitions of global control registers for Yarkon                        */
+/*  Project:                                                                                               */
+/*            ROM code                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef GCR_REGS_H
+#define GCR_REGS_H
+
+#include "../../../Chips/chip.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                      Chip Configuration Registers                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/**************************************************************************************************************************/
+/*   Product Identifier Register (PDID) updated for Poleg                                                                 */
+/**************************************************************************************************************************/
+#define  PDID                           (GCR_BASE_ADDR + 0x000) , GCR_ACCESS, 32 		/* Location: GCR_BA+000h */
+#define  PDID_VER                        24 , 8             /* 31-24 Version (Tapeout Version).                                                                                      */
+#define  PDID_CHRID                      2 , 14             /* 15-2 CHRID (Chip ID). The Chip identifier is A9_2750h.                                                                */
+
+
+/**************************************************************************************************************************/
+/*   Power-On Setting Register (PWRON) Updated for Poleg                                                                  */
+/**************************************************************************************************************************/
+#define  PWRON                          (GCR_BASE_ADDR + 0x004) , GCR_ACCESS, 32 		/* Location: GCR_BA+004h */
+#define  PWRON_SB1                       22 , 1              /* 22 SB1. Security bypass. (Unchanged for Poleg)                                                                        */
+#define  PWRON_STRAP13                   12 , 1              /* 12 STRAP13. SPI0 bus powered by VSBV3 at 1.8V (SPI0F18). (added for Poleg)                                            */
+#define  PWRON_STRAP12                   11 , 1              /* 11 STRAP12. System Flash Attached to BMC (SFAB). (added for Poleg)                                                    */
+#define  PWRON_STRAP11                   10 , 1              /* 10 STRAP11. BSP Alternate pins (BSPA). (added for Poleg)                                                              */
+#define  PWRON_STRAP10_9                 8 , 2              /* 9-8 STRAP10-9. Flash UART Command routine enable (FUP). (Changed for Poleg)                                           */
+#define  PWRON_STRAP8                    7 , 1               /* 7 STRAP8. Security Enable (SECEN). Moved in Poleg.                                                                    */
+#define  PWRON_STRAP7                    6 , 1               /* 6 STRAP7. HI-Z state control (HI-Z). (Unchanged for Poleg                                                             */
+#define  PWRON_STRAP6                    5 , 1               /* 5 STRAP6. ECC Enable (ECC). (Moved for Poleg)                                                                         */
+#define  PWRON_STRAP5                    4 , 1               /* 4 STRAP5. Co-Proccesor skip init                                                                                      */
+#define  PWRON_STRAP4                    3 , 1               /* 3 STRAP4. JTAG2 Enable (J2EN). (New in Poleg)                                                                         */
+#define  PWRON_STRAP3_1                  0 , 3              /* 2-0 STRAP3-1. CPU core, system and DDR4 memory frequency (CKFRQ). (Changed for Poleg)                                 */
+
+
+/**************************************************************************************************************************/
+/*   Arbitration Control Register (ARBCON) - Removed in                                                                   */
+/**************************************************************************************************************************/
+#define  ARBCON                         (GCR_BASE_ADDR + 0x008) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 008h */
+
+/**************************************************************************************************************************/
+/*   Multiple Function Pin Select Register 1 (MFSEL1) Updated for                                                         */
+/**************************************************************************************************************************/
+#define  MFSEL1                         (GCR_BASE_ADDR + 0x00C) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 00Ch */
+#define  MFSEL1_SIRQSEL                  31 , 1              /* 31 SIRQSEL (Serial IRQ Select). Selects GPIO or SERIRQ.                                                               */
+#define  MFSEL1_IOX1SEL                  30 , 1              /* 30 IOX1SEL (Serial GPIO Expander 1 Select). Selects I/O Expander 1 interface option.                                  */
+#define  MFSEL1_DVH1SEL                  27 , 1              /* 27 DVH1SEL (Digital Video Head 1 Select). Selects VCD digital video input source when internal.                       */
+#define  MFSEL1_LPCSEL                   26 , 1              /* 26 LPCSEL (LPC Select). Selects GPIOs or LPC signals.                                                                 */
+#define  MFSEL1_PECIB                    25 , 1              /* 25 PECIB (PECI Bypass). Enables PECI PHY bypass on pins GPIOE11-10. When this bit is 1, MFSEL3.IOXHSEL                */
+#define  MFSEL1_GSPISEL                  24 , 1              /* 24 GSPISEL (Graphics SPI Select). Selects Graphics Core SPI Signals or GPIO option.                                   */
+#define  MFSEL1_SMISEL                   22 , 1              /* 22 SMISEL (SMI Select). Selects nSMI or GPIO170 option.                                                               */
+#define  MFSEL1_CLKOSEL                  21 , 1              /* 21 CLKOSEL (Clockout Select). Selects CLKOUT or GPIIO160 option.                                                      */
+#define  MFSEL1_DVOSEL                   18 , 3             /* 20-18 DVOSEL (DVO Select). Selects DVO output/input signals or GPIO option:                                           */
+#define  MFSEL1_KBCICSEL                 17 , 1              /* 17 KBCICSEL (KBC Interface Controller Select). Selects Keyboard Controller Interface Control Signals or GPIO          */
+#define  MFSEL1_R2MDSEL                  16 , 1              /* 16 R2MDSEL (RMII2 MDIO Select). Selects RMII2 MDIO or GPIO option.                                                    */
+#define  MFSEL1_R2ERRSEL                 15 , 1              /* 15 R2ERRSEL (RMII2 R2RXERR Select). Selects RMII2 R2RXERR or GPIO90 option.                                           */
+#define  MFSEL1_RMII2SEL                 14 , 1              /* 14 RMII2SEL (RMII2 Select). Selects RMII2 (GMAC2 module) or GPIO option.                                              */
+#define  MFSEL1_R1MDSEL                  13 , 1              /* 13 R1MDSEL (RMII1 MDIO Select). Selects RMII1 MDIO or GPIO option.                                                    */
+#define  MFSEL1_R1ERRSEL                 12 , 1              /* 12 R1ERRSEL (RMII1 R1RXERR Select). Selects RMII1 R1RXERR or GPIO56 option.                                           */
+#define  MFSEL1_HSI2SEL                  11 , 1              /* 11 HSI2SEL (Host Serial Interface 2 Select). Selects Host Serial Interface 2 or GPIO option.                          */
+#define  MFSEL1_HSI1SEL                  10 , 1              /* 10 HSI1SEL (Host Serial Interface 1 Select). Selects Host Serial Interface 1 or GPIO option.                          */
+#define  MFSEL1_BSPSEL                   9 , 1               /* 9 BSPSEL (BMC Serial Port Select). Selects Core Serial Port 0 or GPIO option.                                         */
+#define  MFSEL1_SMB2SEL                  8 , 1               /* 8 SMB2SEL (SMB2 Select). Selects SMB2 or GPIO option.                                                                 */
+#define  MFSEL1_SMB1SEL                  7 , 1               /* 7 SMB1SEL (SMB1 Select). Selects SMB1 or GPIO option.                                                                 */
+#define  MFSEL1_SMB0SEL                  6 , 1               /* 6 SMB0SEL (SMB0 Select). Selects SMB0 or GPIO option.                                                                 */
+#define  MFSEL1_S0CS3SEL                 5 , 1               /* 5 S0CS3SEL (SPI0CS3 Select). Selects nSPI0CS3/SPI0D3 or GPIO34 option. When this bit is set, SP0QSEL bit              */
+#define  MFSEL1_S0CS2SEL                 4 , 1               /* 4 S0CS2SEL (SPI0CS2 Select). Selects nSPI0CS2/SPI0D2 or GPIO33 option. When this bit is set, SP0QSEL bit              */
+#define  MFSEL1_S0CS1SEL                 3 , 1               /* 3 S0CS1SEL (SPI0CS1 Select). Selects nSPI0CS1 or GPIO32 option.                                                       */
+#define  MFSEL1_SMB5SEL                  2 , 1               /* 2 SMB5SEL (SMBus 5 Select). Selects SMB5 or GPIO option.                                                              */
+#define  MFSEL1_SMB4SEL                  1 , 1               /* 1 SMB4SEL (SMBus 4 Select). Selects SMB4 or GPIO option.                                                              */
+#define  MFSEL1_SMB3SEL                  0 , 1               /* 0 SMB3SEL (SMBus 3 Select). Selects SMB3 or GPIO option.                                                              */
+
+enum MFSEL1_DVOSEL_T
+{
+    MFSEL1_DVOSEL_OUTPUT_HEAD1  = 5,
+    MFSEL1_DVOSEL_OUTPUT_HEAD2  = 1,
+    MFSEL1_DVOSEL_INPUT_KVM     = 3,
+};
+
+/**************************************************************************************************************************/
+/*   Multiple Function Pin Select Register 2 (MFSEL2) updated for                                                         */
+/**************************************************************************************************************************/
+#define  MFSEL2                         (GCR_BASE_ADDR + 0x010) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 010h */
+#define  MFSEL2_HG7SEL                   31 , 1              /* 31 HG7SEL. Selects HGPIO7 or GPIO60 option.                                                                           */
+#define  MFSEL2_HG6SEL                   30 , 1              /* 30 HG6SEL. Selects HGPIO6 or GPIO59 option.                                                                           */
+#define  MFSEL2_HG5SEL                   29 , 1              /* 29 HG5SEL. Selects HGPIO5 or GPIO25 option. When this bit is 1, MFSEL3.IOXHSEL should be 0.                           */
+#define  MFSEL2_HG4SEL                   28 , 1              /* 28 HG4SEL. Selects HGPIO4 or GPIO24 option. When this bit is 1, MFSEL3.IOXHSEL should be 0.                           */
+#define  MFSEL2_HG3SEL                   27 , 1              /* 27 HG3SEL. Selects HGPIO3 or GPIO23 option.                                                                           */
+#define  MFSEL2_HG2SEL                   26 , 1              /* 26 HG2SEL. Selects HGPIO2 or GPIO22 option.                                                                           */
+#define  MFSEL2_HG1SEL                   25 , 1              /* 25 HG1SEL. Selects HGPIO1 or GPIO21 option.                                                                           */
+#define  MFSEL2_HG0SEL                   24 , 1              /* 24 HG0SEL (Host GPIO0 Select). Selects HGPIO0 or GPIO20 option.When this bit is set, the following bits should        */
+#define  MFSEL2_PWM7SEL                  23 , 1              /* 23 PWM7SEL (PWM7 Select). Selects PWM7 or GPIO147 option.                                                             */
+#define  MFSEL2_PWM6SEL                  22 , 1              /* 22 PWM6SEL (PWM6 Select). Selects PWM6 or GPIO146 option.                                                             */
+#define  MFSEL2_PWM5SEL                  21 , 1              /* 21 PWM5SEL (PWM5 Select). Selects PWM5 or GPIO145 option.                                                             */
+#define  MFSEL2_PWM4SEL                  20 , 1              /* 20 PWM4SEL (PWM4 Select). Selects PWM4 or GPIO144 option.                                                             */
+#define  MFSEL2_PWM3SEL                  19 , 1              /* 19 PWM3SEL (PWM3 Select). Selects PWM3 or GPIO83 option.                                                              */
+#define  MFSEL2_PWM2SEL                  18 , 1              /* 18 PWM2SEL (PWM2 Select). Selects PWM2 or GPIO82 option.                                                              */
+#define  MFSEL2_PWM1SEL                  17 , 1              /* 17 PWM1SEL (PWM1 Select). Selects PWM1 or GPIO81 option.                                                              */
+#define  MFSEL2_PWM0SEL                  16 , 1              /* 16 PWM0SEL (PWM0 Select). Selects PWM0 or GPIO80 option.                                                              */
+#define  MFSEL2_FI15SEL                  15 , 1              /* 15 FI15SEL (FANIN15 Select). Selects FANIN15 or GPIO79 option.                                                        */
+#define  MFSEL2_FI14SEL                  14 , 1              /* 14 FI14SEL (FANIN14 Select). Selects FANIN14 or GPIO78 option.                                                        */
+#define  MFSEL2_FI13SEL                  13 , 1              /* 13 FI13SEL (FANIN13 Select). Selects FANIN13 or GPIO77 option.                                                        */
+#define  MFSEL2_FI12SEL                  12 , 1              /* 12 FI12SEL (FANIN12 Select). Selects FANIN12 or GPIO76 option.                                                        */
+#define  MFSEL2_FI11SEL                  11 , 1              /* 11 FI11SEL (FANIN11 Select). Selects FANIN11 or GPIO75 option.                                                        */
+#define  MFSEL2_FI10SEL                  10 , 1              /* 10 FI10SEL (FANIN10 Select). Selects FANIN10 or GPIO74 option.                                                        */
+#define  MFSEL2_FI9SEL                   9 , 1               /* 9 FI9SEL (FANIN9 Select). Selects FANIN9 or GPIO73 option.                                                            */
+#define  MFSEL2_FI8SEL                   8 , 1               /* 8 FI8SEL (FANIN8 Select). Selects FANIN8 or GPIO72 option.                                                            */
+#define  MFSEL2_FI7SEL                   7 , 1               /* 7 FI7SEL (FANIN7 Select). Selects FANIN7 or GPIO71 option.                                                            */
+#define  MFSEL2_FI6SEL                   6 , 1               /* 6 FI6SEL (FANIN6 Select). Selects FANIN6 or GPIO70 option.                                                            */
+#define  MFSEL2_FI5SEL                   5 , 1               /* 5 FI5SEL (FANIN5 Select). Selects FANIN5 or GPIO69 option.                                                            */
+#define  MFSEL2_FI4SEL                   4 , 1               /* 4 FI4SEL (FANIN4 Select). Selects FANIN4 or GPIO68 option.                                                            */
+#define  MFSEL2_FI3SEL                   3 , 1               /* 3 FI3SEL (FANIN3 Select). Selects FANIN3 or GPIO67 option.                                                            */
+#define  MFSEL2_FI2SEL                   2 , 1               /* 2 FI2SEL (FANIN2 Select). Selects FANIN2 or GPIO66 option.                                                            */
+#define  MFSEL2_FI1SEL                   1 , 1               /* 1 FI1SEL (FANIN1 Select). Selects FANIN1 or GPIO65 option.                                                            */
+#define  MFSEL2_FI0SEL                   0 , 1               /* 0 FI0SEL (FANIN0 Select). Selects FANIN0 or GPIO64 option.                                                            */
+
+/**************************************************************************************************************************/
+/*   Miscellaneous Pin Pull-Up/Down Enable Register (MISCPE) (Updated for )                                               */
+/**************************************************************************************************************************/
+#define  MISCPE                         (GCR_BASE_ADDR + 0x014) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 014h */
+#define  MISCPE_PWRGD_PS                 0 , 1               /* 0 PWRGD_PS. PPE (Pin Pull-Up/Down Enable) for PWRGD_PS. This control bit controls the pull up/down                    */
+
+/**************************************************************************************************************************/
+/*   Serial Ports Switch Control Register (SPSWC) Updated for                                                             */
+/**************************************************************************************************************************/
+#define  SPSWC                          (GCR_BASE_ADDR + 0x038) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 038h */
+#define  SPSWC_UEM3M                     12 , 1              /* 12 UEM3M (UART Easy Setting Mode 3 Modifier). Modifies UES1 and UES2 settings when any of them                        */
+#define  SPSWC_UES2                      10 , 2             /* 11-10 UES2 (UART Easy Setting 2). Controls the way the BMC UART2 and Host Serial Port 2 are                           */
+#define  SPSWC_UES1                      8 , 2              /* 9-8 UES1 (UART Easy Setting 1). Controls the way the BMC UART1 and Host Serial Port 1 are                             */
+#define  SPSWC_RTSS                      7 , 1               /* 7 RTSS (RTS Setting). Controls the value for the nRTS output of an otherwise not driven Serial Interface              */
+#define  SPSWC_DTRS                      6 , 1               /* 6 DTRS (DTR Setting). Controls the value for the nDTR output of an otherwise not driven Serial Interface              */
+#define  SPSWC_DCDI                      5 , 1               /* 5 DCDI (Serial Interface 2 DCD input). nDCD2 input status. This bit is read-only. Enables monitoring the              */
+#define  SPSWC_SPMOD                     0 , 3              /* 2-0 SPMOD (Serial Port Mode). Configures the Serial Port connectivity scheme, as defined in Serial                   */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SPSWC_SPMOD field values definition                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+/*
+2 1 0 Mode
+0 0 0: Mode 1 - Core Snoop.
+0 0 1: Mode 2 - Core Take-over.
+0 1 0: Mode 3 - Core Direct to Host Serial Port 2; Host SP1 connected to SI1 (default).
+1 1 0: Mode 4 - Core Direct to Host Serial Port 2; Host SP1 connected to SI2.
+Else: Reserved.
+Note: mode 4 should be used only if SP2 is selected (MFSEL1.HSP2SEL = 1).
+*/
+#define SPSWC_SPMOD_CORESNOOP         0
+#define SPSWC_SPMOD_CORETAKEOVER      1
+#define SPSWC_SPMOD_SP1TOSI1          2
+#define SPSWC_SPMOD_SP1TOSI2          3
+
+
+/**************************************************************************************************************************/
+/*   Integration Control Register (INTCR) (Unchanged for )                                                                */
+/**************************************************************************************************************************/
+#define  INTCR                          (GCR_BASE_ADDR + 0x03C) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 03Ch */
+#define  INTCR_DUDKSMOD                  30 , 2             /* 31-30 DUDKSMOD (Display update during KVM-scan Mode).                                                                 */
+#define  INTCR_DDC3I                     29 , 1              /* 29 DDC3I (Spare Graphics Control). Spare control for graphics (TBD if used).                                          */
+#define  INTCR_KVMSI                     28 , 1              /* 28 KVMSI (KVM Session Indication) DDC2I. Used to indicate to the windows graphics driver that a KVM session           */
+#define  INTCR_DEHS                      27 , 1              /* 27 DEHS (DE or HSYNC from Graphics Core). Selects (head 2 and head 1 - added in Yarkon) the DE signal or              */
+#define  INTCR_GGPCT2_0                  24 , 3             /* 26-24 GGPCT2-0 (Graphics General Purpose Control). Controls graphics, TBD--future definition.                         */
+#define  INTCR_SGC2                      23 , 1              /* 23 SGC2 (Spare Graphics Control 2). Spare control for graphics (TBD if used).                                         */
+#define  INTCR_DSNS_TRIG                 21 , 1              /* 21 DSNS_TRIG (DAC Sense Trigger). (Changed from Hermon.) Triggers the DAC sense mechanism for inputs of               */
+#define  INTCR_DAC_SNS                   20 , 1              /* 20 DAC_SNS (DAC Sense). (Changed from Hermon.) Controls the DAC sense mechanism for inputs of the                     */
+#define  INTCR_SGC1                      19 , 1              /* 19 SGC1 (Spare Graphics Control 1). Spare control for graphics (TBD if used).                                         */
+#define  INTCR_LDDRB                     18 , 1              /* 18 LDDRB (Local Display Disable with Reduced Bandwidth).                                                              */
+#define  INTCR_GIRST                     17 , 1              /* 17 GIRST (Graphics Interface Head 2 Reset). Resets the graphics second head level 0.                                  */
+#define  INTCR_DUDKSEN                   16 , 1              /* 16 DUDKSEN (Display Update During KVM-scan Enable). Controls display updating during KVM scan.                        */
+#define  INTCR_DACOFF                    15 , 1              /* 15 DACOFF (Turn Off Graphics DAC). Controls the blanking of the DACs by the BMC, if the BMC wants to turn             */
+#define  INTCR_DACSEL                    14 , 1              /* 14 DACSEL (DAC Select). Selects which DAC will have the display instead of DACOSEL pin, if override enable            */
+#define  INTCR_GFXINT                    12 , 1              /* 12 GFXINT (Graphics Interrupt). Generates an interrupt to the graphics driver so it will retry reading the EDID       */
+#define  INTCR_DACOSOVR                  10 , 2             /* 11-10 DACOSOVR (DAC Output Select Override).                                                                          */
+#define  INTCR_GFXIFDIS                  8 , 2              /* 9-8 GFXIFDIS (Graphics Interface Disable). Disables graphics interface to KVM.                                        */
+#define  INTCR_H2RQDIS                   9 , 1               /* 9 H2RQDIS (Head 2 Request Disable). Disables head2 (requests) access to memory (read refresh for KVM                  */
+#define  INTCR_H2DISPOFF                 8 , 1               /* 8 H2DISPOFF (Head 2 Display Off). Disables display from head2. Syncs and data are stopped at 0.                       */
+#define  INTCR_GFXINT2                   7 , 1               /* 7 GFXINT2 (Graphics Interrupt 2). May generate an interrupt to the graphics driver.                                   */
+#define  INTCR_VGAIOEN                   6 , 1               /* 6 VGAIOEN (Enable VGA Core to Decode I/O Addresses). The value of this bit is connected to VGA core                   */
+#define  INTCR_R1EN                      5 , 1               /* 5 R1EN (Enable RMII Outputs). Controls the HI-Z status of RMII 1.                                                     */
+#define  INTCR_PSPIFEN                   4 , 1               /* 4 PSPIFEN (PSPI Freeze Enable). Controls the freezing of the PSPI modules. When set, and nDBGACK internal             */
+#define  INTCR_HIFEN                     3 , 1               /* 3 HIFEN (Host Interface Freeze Enable). Controls the freezing of the Host Interface modules (Keyboard and             */
+#define  INTCR_SMBFEN                    2 , 1               /* 2 SMBFEN (SMB Freeze Enable). Controls the freezing of the SMB modules. When set, and nDBGACK internal                */
+#define  INTCR_MFTFEN                    1 , 1               /* 1 MFTFEN (MFT Freeze Enable). Controls the freezing of the MFT modules. When set, and nDBGACK internal                */
+#define  INTCR_KCSRST_MODE               0 , 1               /* 0 KCSRST_MODE (Host Interface Modules Reset Mode Select). Selects the reset source for both the host and              */
+
+/**************************************************************************************************************************/
+/*   Integration Status Register (INTSR) (Unchanged in )                                                                  */
+/**************************************************************************************************************************/
+#define  INTSR                          (GCR_BASE_ADDR + 0x040) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 040h */
+#define  INTSR_USBHOSTST                 16 , 14            /* 29-16 USBHOSTST (USB Host Status). Indication or controls From USB Host:                                              */
+#define  INTSR_SDHC2PC                   14 , 1              /* 14 SDHC2PC (SDHC2 Power Control). Indication for control MMC power supply.                                            */
+#define  INTSR_SDHC1PC                   13 , 1              /* 13 SDHC1PC (SDHC1 Power Control). Indication for control SD power supply.                                             */
+#define  INTSR_BLUS                      12 , 1              /* 12 BLUS (Blue Connection Sense).                                                                                      */
+#define  INTSR_GRNS                      11 , 1              /* 11 GRNS (Green Connection Sense).                                                                                     */
+#define  INTSR_REDS                      10 , 1              /* 10 REDS (Red Connection Sense).                                                                                       */
+#define  INTSR_MGAMODE                   9 , 1               /* 9 MGAMODE (MGA or VGA Status).                                                                                        */
+#define  INTSR_VGAWRS                    8 , 1               /* 8 VGAWRS (VGA Attribute Write Status).                                                                                */
+#define  INTSR_DOSIN                     7 , 1               /* 7 DOSIN (DACOSEL Input State).                                                                                        */
+#define  INTSR_DDC3O                     6 , 1               /* 6 DDC3O (Spare Graphics Status). Spare status from Graphics (TBD if used).                                            */
+#define  INTSR_DDC2O                     5 , 1               /* 5 DDC2O (Spare Graphics Status). Spare status from Graphics (TBD if used).                                            */
+#define  INTSR_DWGENGST                  4 , 1               /* 4 DWGENGST (Drawing Engine Stall). Indicates drawing engine stall status.                                             */
+#define  INTSR_DWGENGBUSY                3 , 1               /* 3 DWGENGBUSY (Drawing Engine Busy). Indicates drawing engine busy status.                                             */
+#define  INTSR_GGPST2_0                  0 , 3              /* 2-0 GGPST2-0 (Graphics General Purpose Status). Graphics status, future definition.                                   */
+
+/**************************************************************************************************************************/
+/*   Observability Control Register 1-2 (OBSCR1-2) (Unchanged in )                                                        */
+/**************************************************************************************************************************/
+#define  OBSCR1                         (GCR_BASE_ADDR + 0x044) , GCR_ACCESS, 32 		/* Offset: OBSCR1: GCR_BA + 044h */
+#define  OBSCR2                         (GCR_BASE_ADDR + 0x0C4) , GCR_ACCESS, 32 		/* OBSCR2: GCR_BA + 0C4h  */
+#define  OBSCR2_OBSMSEL                  11 , 5             /* 15-11 OBSMSEL (Observability Module Select).                                                                          */
+#define  OBSCR2_OBSDSEL                  7 , 4              /* 10-7 OBSDSEL (Observability Data Select).                                                                             */
+#define  OBSCR2_MUXC                     5 , 2              /* 6-5 MUXC (Mux Control). Selects where to output the observability output signals:                                     */
+#define  OBSCR2_ULSEL                    3 , 2              /* 4-3 ULSEL (Observability Upper/Lower Data Select). Selects which of the 8/16-bit observability signal groups is       */
+#define  OBSCR2_OBSBW                    1 , 2              /* 2-1 OBSBW (Observability Bus Width). This field exists only in OBSCR1.                                                */
+#define  OBSCR2_Width                    10 , 1              /* 10 Width                                                                                                              */
+#define  OBSCR2_OBSEN                    0 , 1               /* 0 OBSEN (Observe Enable).                                                                                             */
+
+/**************************************************************************************************************************/
+/*   Observability Data Register 1-2 (OBSDR1-2) (Unchanged in )                                                           */
+/**************************************************************************************************************************/
+#define  OBSD1                          (GCR_BASE_ADDR + 0x048) , GCR_ACCESS, 32 		/* Offset: OBSD1: GCR_BA + 048h */
+#define  OBSD2                          (GCR_BASE_ADDR + 0x0C8) , GCR_ACCESS, 32 		/* OBSD2: GCR_BA + 0C8h  */
+#define  OBSD2_OBSDATA                   0 , 16             /* 15-0 OBSDATA (Observability Data).                                                                                    */
+
+/**************************************************************************************************************************/
+/*   NPCM750Host Interface Control Register (HIFCR) (Updated for )                                                        */
+/**************************************************************************************************************************/
+#define  HIFCR                          (GCR_BASE_ADDR + 0x050) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 050h */
+#define  HIFCR_LPC_ADDR                0 , 16             /* 15-0 LPC_ADDR (LPC Address). Defines LPC address (when BADDR strap selects BMC CORE selectable address                */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 1 (SDnIRV1) (reg40_dt) Updated for                                              */
+/**************************************************************************************************************************/
+#define  SD1IRV1                        (GCR_BASE_ADDR + 0x54) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 54h */
+#define  SD2IRV1                        (GCR_BASE_ADDR + 0xB4) , GCR_ACCESS, 32 		/* MMC: GCR_BA + B4h  */
+#define  SDnIRV1_corecfg_8bitsupport     27 , 1             /* 27 (8-Bit Support). Eight-bit support for embedded devices. The default is 1 (Core supports 8bit MMC interface)       */
+#define  SDnIRV1_corecfg_maxblklength    25 , 2             /* 26-25 corecfg_maxblklength (Maximum Block Length). Maximum block length is supported by the Core.                     */
+#define  SDnIRV1_corecfg_timeoutclkunit  24 , 1              /* 24 corecfg_timeoutclkunit (Timeout Clock Unit). The timeout clock unit can be either MHz or KHz. The default          */
+#define  SDnIRV1_corecfg_timeoutclkfreq  19 , 5             /* 23-19 corecfg_timeoutclkfreq (Timeout Clock Frequency). The default is 25 MHz (see corecfg_timeoutclkunit             */
+#define  SDnIRV1_corecfg_tuningcount     13 , 6             /* 18-13 corecfg_tuningcount (Tuning Count). Selects the looped clock phase (tap). Assumes tuning is used (instead       */
+#define  SDnIRV1_test_mode               12 , 1              /* 12 test_mode (Test Mode). Enable Test mode. The Test Mode signal is used for DFT purposes. It muxes in the            */
+#define  SDnIRV1_corectrl_otapdlysel     8 , 4              /* 11-8 corectrl_otapdlysel (Output Tap Delay). The delay of the output clock to the SD (rxclk_out), for SD sampling.    */
+#define  SDnIRV1_corectrl_otapdlyena     7 , 1               /* 7 corectrl_otapdlyena (Output Tap Delay Enable). Not Supported.                                                       */
+#define  SDnIRV1_corectrl_itapchgwin     6 , 1               /* 6 corectrl_itapchgwin. Not Supported.                                                                                 */
+#define  SDnIRV1_corectrl_itapdlysel     1 , 5              /* 5-1 corectrl_itapdlysel (Input Tap Delay). The delay of the looped clock from SD (rxclk_in). It must be configured    */
+#define  SDnIRV1_corectrl_itapdlyena     0 , 1               /* 0 corectrl_itapdlyena (Input Tap Delay Enable). Used to enable selective Tap delay line on the loop-backed SD         */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 2 (SDnIRV2) (reg44_dt) Updated for                                              */
+/**************************************************************************************************************************/
+#define  SD1IRV2                        (GCR_BASE_ADDR + 0x58) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 58h */
+#define  SD2IRV2                        (GCR_BASE_ADDR + 0xB8) , GCR_ACCESS, 32 		/* MMC: GCR_BA + B8h  */
+#define  SDnIRV2_corecfg_asyncwkupena    30 , 1              /* 30 corecfg_asyncwkupena (Asynchronous Wake-Up). Determines the wake-up signal generation mode.                        */
+#define  SDnIRV2_corecfg_retuningmodes   26 , 2             /* 27-26 corecfg_retuningmodes (Retuning Modes). Must be set to 00 (Mode0 retuning).                                   */
+#define  SDnIRV2_corecfg_tuningforsdr50  25 , 1              /* 25 corecfg_tuningforsdr50 (Tuning for SDR50). Set to 1 if the Application wants Tuning be used for SDR50              */
+#define  SDnIRV2_corecfg_retuningtimercnt  21 , 4             /* 24-21 corecfg_retuningtimercnt (Timer Count for Retuning). This is the Timer Count for the Retuning timer for         */
+#define  SDnIRV2_corecfg_sdr50support      15 , 1             /* 15 corecfg_sdr50support (SDR50 Support). Simple Data Rate: 50 MHz, 50 Mbps.                                           */
+#define  SDnIRV2_corecfg_slottype        13 , 2             /* 14-13 corecfg_slottype (Slot Type). Used by the card detection. 1 for eMMC, 0 for SD.                                 */
+#define  SDnIRV2_corecfg_baseclkfreq     0 , 8              /* 7-0 corecfg_baseclkfreq (Base Clock Frequency). Base clock frequency for the SD clock. This is the frequency          */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 3 (SDnIRV3) (reg48_dt) (Updated for )                                           */
+/**************************************************************************************************************************/
+#define  SD1IRV3                        (GCR_BASE_ADDR + 0x5C) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 5Ch */
+#define  SD2IRV3                        (GCR_BASE_ADDR + 0xBC) , GCR_ACCESS, 32 		/* MMC: GCR_BA + BCh  */
+#define  SDnIRV3_dbg_sel                 24 , 3             /* 26-24 dbg_sel (Debug Select). Selects observability bus (16 bits). See User guide for details                         */
+#define  SDnIRV3_corecfg_maxcurrent3p3v  16 , 8             /* 23-16 corecfg_maxcurrent3p3v (Maximum Current for 3.3V). Default is 5 for MMC and 0Bh for SD. This stands for         */
+#define  SDnIRV3_corecfg_maxcurrent3p0v  8 , 8              /* 15-8 corecfg_maxcurrent3p0v (Maximum Current for 3.0V). No 3.0V support.                                              */
+#define  SDnIRV3_corecfg_maxcurrent1p8v  0 , 8              /* 7-0 corecfg_maxcurrent1p8v (Maximum Current for 1.8V). No 1.8V support.                                               */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 4 (SDnIRV4) (reg50_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV4                        (GCR_BASE_ADDR + 0x200) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 200h */
+#define  SD2IRV4                        (GCR_BASE_ADDR + 0x220) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 220h  */
+#define  SDnIRV4_corecfg_initpresetval   0 , 13             /* 12-0 corecfg_initpresetval (Preset Value for Initialization). Assumes driver strength type B, SPECLK=50 MHz.        */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 5 (SDnIRV5) (reg54_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV5                        (GCR_BASE_ADDR + 0x204) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 204h */
+#define  SD2IRV5                        (GCR_BASE_ADDR + 0x224) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 224h  */
+#define  SDnIRV5_corecfg_dsppresetval    0 , 13             /* 12-0 corecfg_dsppresetval (Preset Value for Default Speed). Assumes driver strength type B, SPECLK=50 MHz.          */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 6 (SDnIRV6) (reg58_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV6                        (GCR_BASE_ADDR + 0x208) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 208h */
+#define  SD2IRV6                        (GCR_BASE_ADDR + 0x228) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 228h  */
+#define  SDnIRV6_corecfg_hsppresetval    0 , 13             /* 12-0 corecfg_hsppresetval (Preset Value for High Speed). Assumes driver strength type B, SPECLK=50 MHz.             */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 7 (SDnIRV7) (reg5C_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV7                        (GCR_BASE_ADDR + 0x20C) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 20Ch */
+#define  SD2IRV7                        (GCR_BASE_ADDR + 0x22C) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 22Ch  */
+#define  SDnIRV7_corecfg_sdr12presetval  0 , 13             /* 12-0 corecfg_sdr12presetval (Preset Value for SDR12). Assumes driver strength type B, SPECLK=50 MHz. See            */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 8 (SDnIRV8) (reg60_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV8                        (GCR_BASE_ADDR + 0x210) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 210h */
+#define  SD2IRV8                        (GCR_BASE_ADDR + 0x230) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 230h  */
+#define  SDnIRV8_corecfg_sdr25presetval  0 , 13             /* 12-0 corecfg_sdr25presetval (Preset Value for SDR25). Assumes driver strength type B, SPECLK=50 MHz. See            */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 9 (SDnIRV9) (reg64_dt) New for                                                  */
+/**************************************************************************************************************************/
+#define  SD1IRV9                        (GCR_BASE_ADDR + 0x214) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 214h */
+#define  SD2IRV9                        (GCR_BASE_ADDR + 0x234) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 234h  */
+#define  SDnIRV9_corecfg_sdr50presetval  0 , 13             /* 12-0 corecfg_sdr50presetval (Preset Value for SDR50). Assumes driver strength type B, SPECLK=50 MHz. See            */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 10 (SDnIRV10) (reg68_dt) New for                                                */
+/**************************************************************************************************************************/
+#define  SD1IRV10                       (GCR_BASE_ADDR + 0x218) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 218h */
+#define  SD2IRV10                       (GCR_BASE_ADDR + 0x238) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 238h  */
+#define  SDnIRV10_corecfg_sdr104presetval  0 , 13             /* 12-0 corecfg_sdr104presetval (Preset Value for SDR104). Assumes driver strength type B, SPECLK=50 MHz.              */
+
+/**************************************************************************************************************************/
+/*   SDHCn Interface Reset Value Register 11 (SDnIRV11) (reg6C_dt) New for                                                */
+/**************************************************************************************************************************/
+#define  SD1IRV11                       (GCR_BASE_ADDR + 0x21C) , GCR_ACCESS, 32 		/* Offset: SD: GCR_BA + 21Ch */
+#define  SD2IRV11                       (GCR_BASE_ADDR + 0x23C) , GCR_ACCESS, 32 		/* MMC: GCR_BA + 23Ch  */
+#define  SDnIRV11_corecfg_ddr50presetval  0 , 13             /* 12-0 corecfg_ddr50presetval (Preset Value for DDR50). Assumes driver strength type B, SPECLK=50 MHz. See            */
+
+/**************************************************************************************************************************/
+/*   Integration Control Register 2 (INTCR2) (Updated for )                                                               */
+/**************************************************************************************************************************/
+#define  INTCR2                         (GCR_BASE_ADDR + 0x060) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 060h */
+#define  INTCR2_PORST                    31 , 1              /* 31 PORST (Standby Power On* Reset Status). Updated by ROM code from RESSR register; indicates a Standby               */
+#define  INTCR2_CORST                    30 , 1              /* 30 CORST (Core Domain Reset Status). Updated by ROM code from RESSR register; indicates a Core Domain                 */
+#define  INTCR2_WD0RST                   29 , 1              /* 29 WD0RST (Watchdog 0 Reset Status). Updated by ROM code from RESSR register; indicates a Watchdog 0                  */
+#define  INTCR2_SWR1ST                   28 , 1              /* 28 SWR1ST (Software Reset 1 Status). Updated by ROM code from RESSR register; indicates a Software reset              */
+#define  INTCR2_SWR2ST                   27 , 1              /* 27 SWR2ST (Software Reset 2 Status). Updated by ROM code from RESSR register; indicates a Software reset              */
+#define  INTCR2_SWR3ST                   26 , 1              /* 26 SWR3ST (Software Reset 3 Status). Updated by ROM code from RESSR register; indicates a Software reset              */
+#define  INTCR2_SWR4ST                   25 , 1              /* 25 SWR4ST (Software Reset 4 Status). Updated by ROM code from RESSR register; indicates a Software reset              */
+#define  INTCR2_WD1RST                   24 , 1              /* 24 WD1RST (Watchdog 1 Reset Status). Updated by ROM code from RESSR register; indicates a Watchdog 1                  */
+#define  INTCR2_WD2RST                   23 , 1              /* 23 WD2RST (Watchdog 2 Reset Status). Updated by ROM code from RESSR register; indicates a Watchdog 2                  */
+#define  INTCR2_WDC                      21 , 1              /* 21 WDC (Watchdog Counter). Scratch pad. This bit is used by ROM code for watchdog sequence.                           */
+#define  INTCR2_rChosenImage             20 , 1              /* 20 rChosenImage (Current Chosen Image). Scratch pad. This bit is used by ROM code for watchdog sequence.              */
+#define  INTCR2_MC_INIT                  19 , 1              /* 19 MC_INIT. Indicates that Memory controller and PHY initialization was done. The software that initialize the Memory 
+                                                                   controller and PHY, should clear this bit before initialization and set it at the end of it                        */
+#define  INTCR2_CFG_DONE                 18 , 1              /* 18 CFGDone (Clock Configuration indication). Scratch pad. The ROM code sets this bit to indicate to upper             */
+#define  INTCR2_Scratchpad2              10 , 8              /* 17-10 Scratchpad. May be used by software for any purpose. Check ROM code and Boot Loader documentation for           */
+#define  INTCR2_CP_FUSTRAP5_4             8 , 2              /* 9-8 Scratchpad. In Z1 the BMC ROM code should put here the value of CP_FUSTRAP5-4 after calculating its majority rule */
+                                                              /* CP_FUSTRAP5-4 (Boot Source). Selects the start address of the CP boot sequence when CP_FUSTRAP1 is 1.
+                                                                Bits
+                                                                4 3 Boot Address
+                                                                0 0: Address 8000_0000 - SPI0 chip-select 0 (default)
+                                                                0 1: Address 8800_0000 - SPI0 chip-select 1.
+                                                                1 0: Address A000_0000 - SPI3 chip-select 0.
+                                                                1 1: Address A800_0000 - SPI3 chip-select 1. */
+#define  INTCR2_CP_FUSTRAP1              7,  1               /* CP fustarp1. CP_FUSTRAP1 (CP Core Release). Enables the CP core to run immediately after reset if set:
+                                                                    0: CP core held at reset until released by the BMC CPU software by setting CPRSTREL bit in CPCTL
+                                                                       register (default). In this case the BMC CPU determines the CP start address as programmed in
+                                                                       B2CPST1-0 registers. See COPROCESSOR ROM CODE on page 771.
+                                                                    1: CP core runs immediately after reset.
+                                                                    used for a workaround for a bug in reading fustraps for CP. */
+#define  INTCR2_GIVCRST                   6 , 1              /* 6 GIVCRST (Graphics (second head) interface vertical counters reset enable).                                          */
+#define  INTCR2_GIHCRST                   5 , 1              /* 5 GIHCRST (Graphics (second head) interface Horizontal Counters Reset Enable).                                        */
+#define  INTCR2_H2RBRST                   4 , 1              /* 4 H2RBRST (GFX (second head) Interface Register Block Reset).                                                         */
+#define  INTCR2_H2RST1                    3 , 1              /* 3 H2RST1 (GFX (second head) interface Reset Level 1).                                                                 */
+#define  INTCR2_GIRST2                    2 , 1              /* 2 GIRST2 (Graphics (second head) interface Reset Level 2).                                                            */
+#define  INTCR2_USB2FS                    1 , 1              /* 1 USB2FS (USB2 PHY Force Suspend). Forces the USB 2.0 PHY to suspend mode.                                            */
+
+/**************************************************************************************************************************/
+/*   Multiple Function Pin Select Register 3 (MFSEL3) Updated for                                                         */
+/**************************************************************************************************************************/
+#define  MFSEL3                         (GCR_BASE_ADDR + 0x064) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 064h */
+#define  MFSEL3_HSDVOSEL                 26 , 1              /* 26 HSDVOSEL (HSTL DVO Select). Selects DDR DVO on RGMII2 pins (HSTL levels). In Z2 and later. */
+#define  MFSEL3_MMCCDSEL                 25 , 1              /* 25 MMCCDSEL (nMMCCD Select). Selects GPIO155 or nMMCCD. In Z2 and later.                         */
+#define  MFSEL3_GPOCSEL                  22 , 1              /* 22 GPOCSEL (GPOC Select). Selects either GPOI207-206 and GPIO205-204 or CRT2 digital signals.                         */
+#define  MFSEL3_WDO2SEL                  20 , 1              /* 20 WDO2SEL (nWDO2 Select). Selects GPIO219 or nWDO2.                                                                  */
+#define  MFSEL3_WDO1SEL                  19 , 1              /* 19 WDO1SEL (nWDO1 Select). Selects GPIO218 or nWDO1.                                                                  */
+#define  MFSEL3_IOXHSEL                  18 , 1              /* 18 IOXHSEL (Host Serial I/O Expander Select). Selects Host SIOX pins or other options. When this bit is set,          */
+#define  MFSEL3_PCIEPUSE                 17 , 1              /* 17 PCIEPUSE (PCI Express PHY Usage). Selects the PCI Express interface connected to the PHY. PIPE bus                 */
+#define  MFSEL3_CLKRUNSEL                16 , 1              /* 16 CLKRUNSEL (CLKRUN Select). Selects GPIO168 or LPC signal nCLKRUN. When this bit is 1, MFSEL4.8                     */
+#define  MFSEL3_IOX2SEL                  14 , 1              /* 14 IOX2SEL (I/O Expander 2 Select). Selects I/O Expander 2 interface option.                                          */
+#define  MFSEL3_PSPI2SEL                 13 , 1              /* 13 PSPI2SEL (PSPI2 Select). Selects PSPI Signals or GPIO option.                                                      */
+#define  MFSEL3_SD1SEL                   12 , 1              /* 12 SD1SEL (SD1 Select). Selects SD1 or GPIO option.                                                                   */
+#define  MFSEL3_MMC8SEL                  11 , 1              /* 11 MMC8SEL (MMC Select). Selects four additional data lines for MMC or GPIO option.                                   */
+#define  MFSEL3_MMCSEL                   10 , 1              /* 10 MMCSEL (MMC Select). Selects MMC or GPIO option.                                                                   */
+#define  MFSEL3_RMII1SEL                 9 , 1               /* 9 RMII1SEL (RMII1 Select). Selects RMII1 (EMC1 or GMAC1 module) or GPIO option.                                       */
+#define  MFSEL3_SMB15SEL                 8 , 1               /* 8 SMB15SEL (SMB15 Select). Selects SMBus15 signals or GPIO21-20. When this bit is set, MFSEL2 bits 25-24              */
+#define  MFSEL3_SMB14SEL                 7 , 1               /* 7 SMB14SEL (SMB14 Select). Selects SMBus14 signals or GPIO23-22. When this bit is set, MFSEL2 bits 27-26              */
+#define  MFSEL3_SMB13SEL                 6 , 1               /* 6 SMB13SEL (SMB13 Select). Selects SMBus13 signals or GPIO223-222.                                                    */
+#define  MFSEL3_SMB12SEL                 5 , 1               /* 5 SMB12SEL (SMB12 Select). Selects SMBus12 signals or GPIO221-220.                                                    */
+#define  MFSEL3_PSPI1SEL                 3 , 2              /* 4-3 PSPI1SEL (PSPI1 Select). Selects PSPI1, FANINs or GPIOs.                                                          */
+#define  MFSEL3_SMB7SEL                  2 , 1               /* 2 SMB7SEL (SMB7 Select). Selects SMBus7 signals or GPIO174-173.                                                       */
+#define  MFSEL3_SMB6SEL                  1 , 1               /* 1 SMB6SEL (SMB6 Select). Selects SMBus6 signals or GPIO172-171.                                                       */
+#define  MFSEL3_SCISEL                   0 , 1               /* 0 SCISEL (SCI Select). Selects nSCIPME or GPIO169.                                                                    */
+
+/**************************************************************************************************************************/
+/*   Slew Rate Control Register (SRCNT) (Updated in )                                                                     */
+/**************************************************************************************************************************/
+#define  SRCNT                          (GCR_BASE_ADDR + 0x068) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 068h */
+#define  SRCNT_TDO                       4 , 1               /* 4 TDO. Slew Rate for TDO output. Controls the slew rate of TDO.                                                       */
+#define  SRCNT_ESPI                      3 , 1               /* 3 ESPI. Slew Rate for ESPI and LPC. Controls the two I/O cells slew rate of LAD3-0/ ESPI_IO3-0/ GPIO167-164.          */
+#define  SRCNT_SPI0C                     2 , 1               /* 2 SPI0C. Slew Rate for SPI0CK Signal.                                                                                 */
+#define  SRCNT_SPI0D                     1 , 1               /* 1 SPI0D. Slew Rate for SPI0D1-0 Signals.                                                                              */
+
+/**************************************************************************************************************************/
+/*   Reset Status Register (RESSR) (Changed in )                                                                          */
+/**************************************************************************************************************************/
+#define  RESSR                          (GCR_BASE_ADDR + 0x06C) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 06Ch */
+#define  RESSR_PORST                     31 , 1              /* 31 PORST (Standby Power On Reset Status). This bit is set by Standby Power-Up reset (nPORST is asserted).             */
+#define  RESSR_CORST                     30 , 1              /* 30 CORST (Core Domain Reset Status). This bit is set by nCORST assertion. See INTCR2 bit 30 for indication.           */
+#define  RESSR_WD0RST                    29 , 1              /* 29 WD0RST (Watchdog 0 Reset Status). This bit is set by Watchdog 0 reset event See INTCR2 bit 29 for                  */
+#define  RESSR_SWRST1                    28 , 1              /* 28 SWRST1 (Software Reset 1 Status). This bit is set by Software reset 1 (PMCON.SWRST1 was set). See                  */
+#define  RESSR_SWRST2                    27 , 1              /* 27 SWRST2 (Software Reset 2 Status). This bit is set by Software reset 2 (PMCON.SWRST2 was set) See                   */
+#define  RESSR_SWRST3                    26 , 1              /* 26 SWRST3 (Software Reset 3 Status). This bit is set by Software reset 3 (PMCON.SWRST3 was set). See                  */
+#define  RESSR_SWRST4                    25 , 1              /* 25 SWRST4 (Software Reset 4 Status). This bit is set by Software reset 4 (PMCON.SWRST4 was set). See                  */
+#define  RESSR_WD1RST                    24 , 1              /* 24 WD1RST (Watchdog 1 Reset Status). This bit is set by Watchdog 1 reset event. See INTCR2 bit 24 for                 */
+#define  RESSR_WD2RST                    23 , 1              /* 23 WD2RST (Watchdog 2 Reset Status). This bit is set by Watchdog 2 reset event See INTCR2 bit 23 for                  */
+
+
+/**************************************************************************************************************************/
+/*   Register Lock Register 1 (RLOCKR1) (Updated in )                                                                     */
+/**************************************************************************************************************************/
+#define  RLOCKR1                        (GCR_BASE_ADDR + 0x070) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 070h */
+#define  RLOCKR1_CORSTLK                 27 , 1              /* 27 CORSTLK. Locks CORSTC register, when set. (added in )                                                              */
+#define  RLOCKR1_SWR34LK                 26 , 1              /* 26 SWR34LK. Locks SWRSTC3 and SWRSTC4 registers, when set. (added in )                                                */
+#define  RLOCKR1_SWR12LK                 25 , 1              /* 25 SWR12LK. Locks SWRSTC1 and SWRSTC2 registers, when set. (added in )                                                */
+#define  RLOCKR1_WD2RLK                  24 , 1              /* 24 WD2RLK. Locks WD2RCR register, when set. (added in )                                                               */
+#define  RLOCKR1_WD1RLK                  23 , 1              /* 23 WD1RLK. Locks WD1RCR register, when set. (added in )                                                               */
+#define  RLOCKR1_WD0RLK                  22 , 1              /* 22 WD0RLK. Locks WD0RCR register, when set. (added in )                                                               */
+#define  RLOCKR1_IPR3LK                  21 , 1              /* 21 IPR3LK. Locks IPSRST3 register, when set. (added in )                                                              */
+#define  RLOCKR1_CKE3LK                  20 , 1              /* 20 CKE3LK. Locks CLKEN3 register, when set. (added in )                                                               */
+#define  RLOCKR1_PLL2LK                  19 , 1              /* 19 PLL2LK. Locks PLLCON2 register and PLLCONG register, when set. (added in )                                         */
+#define  RLOCKR1_SEL4K                   18 , 1              /* 18 SEL4K. Locks MFSEL4 register, when set. (added in )                                                                */
+#define  RLOCKR1_IPR2LK                  17 , 1              /* 17 IPR2LK. Locks IPSRST2 register, when set.                                                                          */
+#define  RLOCKR1_IPR1LK                  16 , 1              /* 16 IPR1LK. Locks IPSRST1 register, when set.                                                                          */
+#define  RLOCKR1_PLL1LK                  15 , 1              /* 15 PLL1LK. Locks PLLCON1 register, when set.                                                                          */
+#define  RLOCKR1_PLL0LK                  14 , 1              /* 14 PLL0LK. Locks PLLCON0 register, when set.                                                                          */
+#define  RLOCKR1_CKDVLK                  13 , 1              /* 13 CKDVLK. Locks CLKDIV1, CLKDIV2 and CLKDIV3 registers, when set.                                                    */
+#define  RLOCKR1_CKSLLK                  12 , 1              /* 12 CKSLLK. Locks CLKSEL register, when set.                                                                           */
+#define  RLOCKR1_CKE2LK                  11 , 1              /* 11 CKE2LK. Locks CLKEN2 register, when set.                                                                           */
+#define  RLOCKR1_CKE1LK                  10 , 1              /* 10 CKE1LK. Locks CLKEN1 register, when set.                                                                           */
+#define  RLOCKR1_DS1LK                   9 , 1               /* 9 DS1LK. Locks DSCNT register, when set.                                                                              */
+#define  RLOCKR1_HIFLK                   8 , 1               /* 8 HIFLK. Locks HIFCR register, when set.                                                                              */
+#define  RLOCKR1_SR1LK                   6 , 1               /* 6 SR1LK. Locks SRCNT register, when set.                                                                              */
+#define  RLOCKR1_SEL3LK                  5 , 1               /* 5 SEL3LK. Locks MFSEL3 register, when set.                                                                            */
+#define  RLOCKR1_VSRCLK                  4 , 1               /* 4 VSRCLK. Locks VSRCR register, when set. (changed in )                                                               */
+#define  RLOCKR1_I2CSSLK                 3 , 1               /* 3 I2CSSLK. Locks I2CSEGSEL register, when set. (changed in )                                                          */
+#define  RLOCKR1_MPELK                   2 , 1               /* 2 MPELK. Locks MISCPE register, when set.                                                                             */
+#define  RLOCKR1_SEL2LK                  1 , 1               /* 1 SEL2LK. Locks MFSEL2 register, when set.                                                                            */
+#define  RLOCKR1_SEL1LK                  0 , 1               /* 0 SEL1LK. Locks MFSEL1 register, when set.                                                                            */
+
+/**************************************************************************************************************************/
+/*   Function Lock Register 1 (FLOCKR1) (Updated in )                                                                     */
+/**************************************************************************************************************************/
+#define  FLOCKR1                        (GCR_BASE_ADDR + 0x074) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 074h */
+#define  FLOCKR1_ICCFGLK                 23 , 1              /* 23 ICCFGLK. Locks itself and INCCFGD bit.                                                                             */
+#define  FLOCKR1_INTCCFGD                22 , 1              /* 22 INTCCFGD. Disables write access to specific Interrupt Controller LSPI registers. (Connected to                     */
+#define  FLOCKR1_PSMILK                  21 , 1              /* 21 PSMILK. Locks itself and PSMISEL bit.                                                                              */
+#define  FLOCKR1_PSMISEL                 20 , 1              /* 20 PSMISEL. Defines the selection of Periodic SMI or GPIO pin. (function added in )                                   */
+#define  FLOCKR1_RAMVLK                  19 , 1              /* 19 RAMVLK. Locks itself and FAMV bit.                                                                                 */
+#define  FLOCKR1_RAMV                    18 , 1              /* 18 RAMV. Defines what is mapped to address FFFF_0000h to FFFF_00FFh (256 bytes). This bit is reset                    */
+#define  FLOCKR1_JDISLK                  17 , 1              /* 17 JDISLK (JTAG Disable Lock). Locks itself and JTAGDIS bit.                                                          */
+#define  FLOCKR1_JTAGDIS                 16 , 1              /* 16 JTAGDIS (JTAG Disable). Disables JTAG access to NPCM750.                                                           */
+#define  FLOCKR1_LKSRAM2                 15 , 1              /* 15 LKSRAM2 (SRAM2 Lock). Locks itself and FCTL7 bit.                                                                  */
+#define  FLOCKR1_CNTSRAM2                14 , 1              /* 14 CNTSRAM2 (SRAM2 Control). Function control bit. This enables writing to 1 KB block in RAM2.                        */
+#define  FLOCKR1_LKSRAM1                 13 , 1              /* 13 LKSRAM1 (SRAM1 Lock). Locks itself and FCTL6 bit.                                                                  */
+#define  FLOCKR1_CNTSRAM1                12 , 1              /* 12 CNTSRAM1 (SRAM1 Control). Function control bit. This enables writing to 1 KB block in RAM2.                        */
+#define  FLOCKR1_LKGPO2VLK               11 , 1              /* 11 LKGPO2VLK (LKGPO2 Value Lock). Locks itself and FCTL5.                                                             */
+#define  FLOCKR1_LKGPO2VAL               10 , 1              /* 10 LKGPO2VAL (LKGPO2 Value). Function control bit. The bit controls the value of LKGPO2.                              */
+#define  FLOCKR1_LKGPO2SLK               9 , 1               /* 9 LKGPO2SLK (LKGPO2 Select Lock). Locks itself and FCTL4.                                                             */
+#define  FLOCKR1_LKGPO2SEL               8 , 1               /* 8 LKGPO2SEL (LKGPO2 Select). Function control bit. The bit controls selection of LKGPO2.                              */
+#define  FLOCKR1_LKGPO1VLK               7 , 1               /* 7 LKGPO1VLK (LKGPO1 Value Lock). Locks itself and FCTL3.                                                              */
+#define  FLOCKR1_LKGPO1VAL               6 , 1               /* 6 LKGPO1VAL (LKGPO1 Value). Function control bit. The bit controls the value of LKGPO1.                               */
+#define  FLOCKR1_LKGPO1SLK               5 , 1               /* 5 LKGPO1SLK (LKGPO1 Select Lock). Locks itself and FCTL2.                                                             */
+#define  FLOCKR1_LKGPO1SEL               4 , 1               /* 4 LKGPO1SEL (LKGPO1 Select). Function control bit. The bit controls selection of LKGPO1.                              */
+#define  FLOCKR1_LKGPO0VLK               3 , 1               /* 3 LKGPO0VLK (LKGPO0 Value Lock). Locks itself and FCTL1.                                                              */
+#define  FLOCKR1_LKGPO0VAL               2 , 1               /* 2 LKGPO0VAL (LKGPO0 Value). Function control bit. The bit controls the value of LKGPO0.                               */
+#define  FLOCKR1_LKGPO0SLK               1 , 1               /* 1 LKGPO0SLK (LKGPO0 Select Lock). Locks itself and FCTL0.                                                             */
+#define  FLOCKR1_LKGPO0SEL               0 , 1               /* 0 LKGPO0SEL (LKGPO0 Select). Function control bit. The bit controls selection of LKGPO0.                              */
+
+
+/**************************************************************************************************************************/
+/*   Drive Strength Control Register (DSCNT) (Updated for )                                                               */
+/**************************************************************************************************************************/
+#define  DSCNT                          (GCR_BASE_ADDR + 0x078) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 078h */
+#define  DSCNT_SPLD                      9 , 1               /* 9 SPLD. Drive Strength for nSPILOAD.                                                                                  */
+#define  DSCNT_ESPI                      6 , 3              /* 8-6 ESPI. Drive Strength for ESPI and LPC. Controls the 2 I/O cells drive strength of LAD3-0/ESPI_IO3-0/              */
+#define  DSCNT_JTDO                      5 , 1               /* 5 JTDO. Drive Strength for JTAG TDO.                                                                                  */
+#define  DSCNT_DDC1                      4 , 1               /* 4 DDC1. Drive Strength for DDC1SDA and DDC1SCL.                                                                       */
+#define  DSCNT_SYNC1                     3 , 1               /* 3 SYNC1. Drive Strength for HSYNC1 and VSYNC1.                                                                        */
+#define  DSCNT_SPI0C                     2 , 1               /* 2 SPI0C. Drive Strength for SPI0CK.                                                                                   */
+#define  DSCNT_SPI0D                     1 , 1               /* 1 SPI0D. Drive Strength for SPI0D1-0.                                                                                 */
+
+/**************************************************************************************************************************/
+/*   Module Disable Lock Register (MDLR) (Updated for )                                                                   */
+/**************************************************************************************************************************/
+#define  MDLR                           (GCR_BASE_ADDR + 0x7C) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 7Ch */
+#define  MDLR_SMB1                       31 , 1              /* 31 SMB1 Module Disable Control.                                                                                       */
+#define  MDLR_SMB0                       30 , 1              /* 30 SMB0 Module Disable Control.                                                                                       */
+#define  MDLR_PSP1                       29 , 1              /* 29 PSP1 and PSPI2 Module Disable Control.                                                                             */
+#define  MDLR_MMC                        28 , 1              /* 28 MMC Controller Module Disable Control.                                                                             */
+#define  MDLR_ADC                        27 , 1              /* 27 ADC Module Disable Control.                                                                                        */
+#define  MDLR_SD                         26 , 1              /* 26 SD Controller Module Disable Control.                                                                              */
+#define  MDLR_SIOX1                      25 , 1              /* 25 SIOX1 and SIOX2 Module Disable Control.                                                                            */
+#define  MDLR_PECI                       24 , 1              /* 24 PECI Module Disable Control.                                                                                       */
+#define  MDLR_SMB15_8                    23 , 1              /* 23 SMB15-8 Modules Disable Control.                                                                                   */
+#define  MDLR_USBD5_9                    22 , 1              /* 22 USBD5-9 Module Disable Control. USB Devices 5-9.                                                                   */
+#define  MDLR_USBD2_4                    21 , 1              /* 21 USBD2-4 Module Disable Control. USB Devices 2-4.                                                                   */
+#define  MDLR_AHBTOPCIBRG                20 , 1              /* 20 AHBTOPCIBRG Module Disable Control. AHB-to-PCI Bridge.                                                             */
+#define  MDLR_ECE                        19 , 1              /* 19 ECE Module Disable Control.                                                                                        */
+#define  MDLR_SHA                        18 , 1              /* 18 SHA Module Disable Control.                                                                                        */
+#define  MDLR_PKA                        17 , 1              /* 17 PKA Module Disable Control.                                                                                        */
+#define  MDLR_SMB7_5                     16 , 1              /* 16 SMB7-5 Module Disable Control.                                                                                     */
+#define  MDLR_SMB4                       15 , 1              /* 15 SMB4 Module Disable Control.                                                                                       */
+#define  MDLR_SMB3                       14 , 1              /* 14 SMB3 Module Disable Control.                                                                                       */
+#define  MDLR_SMB2                       13 , 1              /* 13 SMB2 Module Disable Control.                                                                                       */
+#define  MDLR_KEYOTP                     12 , 1              /* 12 KEYOTP Module Disable Control. Key OTP fuse block.                                                                 */
+#define  MDLR_AES                        10 , 1              /* 10 AES Module Disable Control.                                                                                        */
+#define  MDLR_USBD0                      9 , 1               /* 9 USBD0 Module Disable Control.                                                                                       */
+#define  MDLR_USBD1                      8 , 1               /* 8 USBD1 Module Disable Control.                                                                                       */
+#define  MDLR_GMAC1_2                    7 , 1               /* 7 GMAC1-2 Modules Disable Control.                                                                                    */
+#define  MDLR_EMC1                       6 , 1               /* 6 EMC1 and EMC2 Module Disable Control.                                                                               */
+#define  MDLR_GDMA                       5 , 1               /* 5 GDMA Modules Disable Control.                                                                                       */
+#define  MDLR_DVC                        4 , 1               /* 4 DVC Module Disable Control.                                                                                         */
+#define  MDLR_VDMA                       3 , 1               /* 3 VDMA Module Disable Control.                                                                                        */
+#define  MDLR_VGAONLY                    2 , 1               /* 2 VGAONLY. Graphics core accelerators are disabled; only VGA functionality is enabled.                                */
+#define  MDLR_VDMX                       1 , 1               /* 1 VDMX Module Disable Control.                                                                                        */
+#define  MDLR_VCD                        0 , 1               /* 0 VCD Module Disable Control.                                                                                         */
+
+/**************************************************************************************************************************/
+/*   Scratchpad Register 2 (SCRPAD2) (New in POLEG A1)                                                                    */
+/**************************************************************************************************************************/
+#define  SCRPAD2                        (GCR_BASE_ADDR + 0x084) , GCR_ACCESS, 32        /* Offset: GCR_BA + 084h */
+
+/**************************************************************************************************************************/
+/*   Scratchpad Register 2 (SCRPAD3) (New in POLEG A1)                                                                    */
+/**************************************************************************************************************************/
+#define  SCRPAD3                        (GCR_BASE_ADDR + 0x080) , GCR_ACCESS, 32        /* Offset: GCR_BA + 080h */
+
+/**************************************************************************************************************************/
+/*   Slew Rate Control Register 2 (SRCNT2) (Removed in )                                                                  */
+/**************************************************************************************************************************/
+#define  SRCNT2                         (GCR_BASE_ADDR + 0x094) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 094h */
+
+/**************************************************************************************************************************/
+/*   DAC Level Control Register (DACLVLR) (updated in )                                                                   */
+/**************************************************************************************************************************/
+#define  DACLVLR                        (GCR_BASE_ADDR + 0x098) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 098h */
+#define  DACLVLR_CONNSNSLVL              24 , 8             /* 31-24 CONNSNSLVL. Used as level setting by the Connection sense mechanism. (Eng note: 8 bit MSB of the required       */
+#define  DACLVLR_BLUELEVEL               12 , 6             /* 17-12 BLUELEVEL. Controls the output full scale current of the blue DAC. Setting as in bits 5-0 of this register.     */
+#define  DACLVLR_GREENLEVEL              6 , 6              /* 11-6 GREENLEVEL. Controls the output full scale current of the green DAC. Setting as in bits 5-0 of this register.    */
+#define  DACLVLR_REDLEVEL                0 , 6              /* 5-0 REDLEVEL. Controls the output full scale current of the red DAC. Reasonable values are 0Bh to 13h. The            */
+
+/**************************************************************************************************************************/
+/*   Integration Control Register 3 (INTCR3) (Updated for )                                                               */
+/**************************************************************************************************************************/
+#define  INTCR3                         (GCR_BASE_ADDR + 0x09C) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 09Ch */
+#define  INTCR3_SSIDPWR                  31 , 1              /* 31 SSIDPWR (Subsystem ID Reset). Graphics core PCI subsystem ID Reset setting.                                        */
+#define  INTCR3_USBLPBK                  24 , 1              /* 24 USBLPBK (USB Loopback Mode). USB loopback mode enables the USB host to be connected to the internal                */
+#define  INTCR3_DACSBYOFF                23 , 1              /* 23 DACSBYOFF (DAC Standby Off). DAC off in standby.                                                                   */
+#define  INTCR3_RCCORER                  22 , 1              /* 22 RCCORER (Root Complex Core Reset). PCIe Root Complex Core Reset.                                                   */
+#define  INTCR3_GFX_ORL                  20 , 2             /* 21-20 GFX_ORL (Graphics Outstanding Read Request Limit). Limits the number of the outstanding read requests           */
+#define  INTCR3_PECIVSEL                 19 , 1              /* 19 PECIVSEL (PECI Voltage Select). Adapts PECI I/O interface to voltage range. The interface is always                */
+#define  INTCR3_A2PZ1C                   18 , 1              /* 18 A2PZ1C (AHB-to-PCI Z1 Compatibility). AHB2PCI Yarkon Z1 compatibility.                                             */
+#define  INTCR3_PCIEDEM                  17 , 1              /* 17 PCIEDEM (PCI Express De-Emphasis). Selects the level of de-emphasis for an PCI Express upstream                    */
+#define  INTCR3_DRAMINIT                 16 , 1              /* 16 DRAMINIT (DRAM Initialization). Stalls the streaming interfaces from GFX to MC stalled.                            */
+#define  INTCR3_NAT_ON2                  15 , 1              /* 15 NAT_ON2 (EMC2_NAT_ON). EMC2 NAT_ON input strap. Used in as 0. An engineering setting that we                       */
+#define  INTCR3_NAT_ON1                  14 , 1              /* 14 NAT_ON1 (EMC1 NAT_ON). EMC1 NAT_ON input strap. Used in as 0. An engineering setting that we                       */
+#define  INTCR3_USBPHYSW                 12 , 2             /* 13-12 USBPHYSW (USB PHY2 Switch). Selects USB Host, USB PHY2 and USB Device 0 UTMI connection.                        */
+#define  INTCR3_eSPI_INT_POL             11 , 1              /* 11 eSPI_INT_POL (eSPI Interrupt Polarity). When set to 1, the interrupt polarity bit at index 71 of the selected      */
+#define  INTCR3_GMMAP                    8 , 3              /* 10-8 GMMAP (Graphics Memory Map). Configures Graphics core address mapping into main memory, according to             */
+#define  INTCR3_PCIeENHD                 7 , 1               /* 7 PCIeENHD (PCI Express Bridge Enhancement Disable).                                                                  */
+#define  INTCR3_GFXACCDIS                4 , 1               /* 4 GFXACCDIS (Graphics Core Access Disable). Disables access to PCI configuration of the Graphics core.                */
+#define  INTCR3_HSRDIS                   2 , 1               /* 2 HSRDIS. Disables Host PCIe Secondary Reset to PCI devices. This bit added as an engineering feature.                */
+#define  INTCR3_BIOSEN                   1 , 1               /* 1 BIOSEN (BIOS Enable). BIOS boot ROM included in a flash connected to SPI3.                                          */
+#define  INTCR3_HHRDIS                   0 , 1               /* 0 HHRDIS (Host PCIe Hot Reset Disable). Disables Host PCIe Hot Reset to PCI devices.                                  */
+
+
+/**************************************************************************************************************************/
+/*   VSYNC Interrupt Control Register (VSINTR) (Unchanged in )                                                            */
+/**************************************************************************************************************************/
+#define  VSINTR                         (GCR_BASE_ADDR + 0x0AC) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0ACh */
+#define  VSINTR_VSINTST                  2 , 1               /* 2 VSINTST (VSYNC Interrupt Status). Head 1 VSYNC Interrupt status.                                                    */
+#define  VSINTR_VSINTEDGE                1 , 1               /* 1 VSINTEDGE (VSYNC Interrupt Edge Select).                                                                            */
+#define  VSINTR_VSINTEN                  0 , 1               /* 0 VSINTEN (VSYNC Interrupt Enable).                                                                                   */
+
+/**************************************************************************************************************************/
+/*   Multiple Function Pin Select Register 4 (MFSEL4) (Updated in )                                                       */
+/**************************************************************************************************************************/
+#define  MFSEL4                         (GCR_BASE_ADDR + 0x0B0) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0B0h */
+#define  MFSEL4_SMB11DDC                 29 , 2             /* 30-29 SMB11DDC. Enables SMB11 to control or emulate the DDC signals.                                                  */
+#define  MFSEL4_SXCS1SEL                 28 , 1              /* 28 SXCS1SEL (SPIX Chip Select 1 Select). Selects SPIXCS1 or GPIO signals.                                             */
+#define  MFSEL4_SPXSEL                   27 , 1              /* 27 SPXSEL (SPIX Select). Selects SPIX or GPIO signals.                                                                */
+#define  MFSEL4_RG2SEL                   24 , 1              /* 24 RG2SEL (RGMII 2 Select). Selects RGMII 2 (for GMAC2) instead of GPIO.                                              */
+#define  MFSEL4_RG2MSEL                  23 , 1              /* 23 RG2MSEL (RGMII 2 MDIO Select). Selects RGMII 2 MDIO or GPIO.                                                       */
+#define  MFSEL4_RG1SEL                   22 , 1              /* 22 RG1SEL (RGMII 1 Select). Selects RGMII 1 (for GMAC1) instead of GPIO.                                              */
+#define  MFSEL4_RG1MSEL                  21 , 1              /* 21 RG1MSEL (RGMII 1 MDIO Select). Selects RGMII1 MDIO or GPIO.                                                        */
+#define  MFSEL4_SP3QSEL                  20 , 1              /* 20 SP3QSEL (SPI3 Quad Select). Selects SPI3 quad data option. When this bit is set, MFSEL4 bits S3CS2SEL              */
+#define  MFSEL4_S3CS3SEL                 19 , 1              /* 19 S3CS3SEL (SPI3CS3 Select). Selects SPI3CS3 or GPIO signals.                                                        */
+#define  MFSEL4_S3CS2SEL                 18 , 1              /* 18 S3CS2SEL (SPI3CS2 Select). Selects SPI3CS2 or GPIO signals.                                                        */
+#define  MFSEL4_S3CS1SEL                 17 , 1              /* 17 S3CS1SEL (SPI3CS1 Select). Selects SPI3CS1 or GPIO signals.                                                        */
+#define  MFSEL4_SP3SEL                   16 , 1              /* 16 SP3SEL (SPI3 Select). Selects SPI3 or GPIO signals.                                                                */
+#define  MFSEL4_SP0QSEL                  15 , 1              /* 15 SP0QSEL (SPI0 Quad Select). Selects SPI0 quad data option. When this bit is set, MFSEL1 bits S0CS2SEL              */
+#define  MFSEL4_SMB11SEL                 14 , 1              /* 14 SMB11SEL (SMB11 Select). Selects SMB11 or GPIO option.                                                             */
+#define  MFSEL4_SMB10SEL                 13 , 1              /* 13 SMB10SEL (SMB10 Select). Selects SMB10 or GPIO option.                                                             */
+#define  MFSEL4_SMB9SEL                  12 , 1              /* 12 SMB9SEL (SMB9 Select). Selects SMB9 or GPIO option.                                                                */
+#define  MFSEL4_SMB8SEL                  11 , 1              /* 11 SMB8SEL (SMB8 Select). Selects SMB8 or GPIO option.                                                                */
+#define  MFSEL4_DBGTRSEL                 10 , 1              /* 10 DBGTRSEL (Debug Trace Select). Selects debug trace or GPIO signals.                                                */
+#define  MFSEL4_CKRQSEL                  9 , 1               /* 9 CKRQSEL (nCKRQ Signal Select). Selects GPIO or PCIe nCLKREQ signal.                                                 */
+#define  MFSEL4_ESPISEL                  8 , 1               /* 8 ESPISEL (eSPI Signal Select). Selects either LPC or eSPI signals. If this bit is set, MFSEL1 bit LPCSEL must        */
+#define  MFSEL4_MMCRSEL                  6 , 1               /* 6 MMCRSEL (MMC Reset Control Select). Selects either MMC reset control or card detect signals. If this bit is         */
+#define  MFSEL4_SD1PSEL                  5 , 1               /* 5 SD1PSEL (SDHC1 Power Control Select). Selects either SDHC1 power control or card detect signals. If this            */
+#define  MFSEL4_ROSEL                    4 , 1               /* 4 ROSEL (RIng Oscillator Output Select). Selects either RNGOSCOUT (Ring Oscillator output) or                         */
+#define  MFSEL4_ESPIPMESEL               2 , 2              /* 3-2 ESPIPMESEL (ESPI PME Connection Select). Selects nSCIPME connection to PME# and SCI# virtual wires                */
+#define  MFSEL4_BSPASEL                  1 , 1               /* 1 BSPASEL (BMC Serial Port Alternate Port Select). Selects BSP (BMC UART0) onto Serial Interface 2 pins.              */
+#define  MFSEL4_JTAG2SEL                 0 , 1               /* 0 JTAG2SEL (Coprocessor Debug Port Select). Selects SI1/GPIOs or JTAG2.                                               */
+
+/**************************************************************************************************************************/
+/*   I2C Segment Pin Select Register (I2CSEGSEL) (New in )                                                                */
+/**************************************************************************************************************************/
+#define  I2CSEGSEL                      (GCR_BASE_ADDR + 0x0E0) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0E0h */
+#define  I2CSEGSEL_S4DESEL               23 , 1              /* 23 S4DESEL. Selects either GPIO or SMBus 4 Drive Enable signals. If this bit is set, MFSEL3 bit 13 must be 0.         */
+#define  I2CSEGSEL_S0DESEL               22 , 1              /* 22 S0DESEL. Selects either GPIO or SMBus 0 Drive Enable signals. If this bit is set, MFSEL1 bits 18-20 must be 0.     */
+#define  I2CSEGSEL_S5SDSEL               21 , 1              /* 21 S5SDSEL. Selects either GPIOs or SMBus 5 segment D signals. If this bit is set, MFSEL1 bit 17 must be 0.           */
+#define  I2CSEGSEL_S5CSEL                20 , 1              /* 20 S5CSEL. Selects either GPIOs or SMBus 5 segment C signals. If this bit is set, MFSEL1 bit 24 must be 0.            */
+#define  I2CSEGSEL_S5SBSEL               19 , 1              /* 19 S5SBSEL. Selects either GPIOs or SMBus 5 segment B signals. If this bit is set, MFSEL1 bit 24 must be 0.           */
+#define  I2CSEGSEL_S4DECFG               17 , 2             /* 18-17 S4DECFG. Selects SMBus 4 Drive Enable controls.                                                                 */
+#define  I2CSEGSEL_S4SDSEL               16 , 1              /* 16 S4SDSEL. Selects either GPIOs or SMBus 4 segment D signals. If this bit is set, MFSEL2 bits 27-26 must be 0.       */
+#define  I2CSEGSEL_S4CSEL                15 , 1              /* 15 S4CSEL. Selects either GPIOs or SMBus 4 segment C signals. If this bit is set, MFSEL2 bits 25-24 must be 0.        */
+#define  I2CSEGSEL_S4SBSEL               14 , 1              /* 14 S4SBSEL. Selects either GPIOs or SMBus 4 segment B signals. If this bit is set, MFSEL3 bit 13 must be 0.           */
+#define  I2CSEGSEL_S3SDSEL               13 , 1              /* 13 S3SDSEL. Selects either GPIOs or SMBus 3 segment D signals. If this bit is set, MFSEL2.31-30 must be 0.            */
+#define  I2CSEGSEL_S3SCSEL               12 , 1              /* 12 S3SCSEL. Selects either GPIOs or SMBus 3 segment C signals. If this bit is set, MFSEL1.DVOSEL must be 0.           */
+#define  I2CSEGSEL_S3SBSEL               11 , 1              /* 11 S3SBSEL. Selects either GPIOs or SMBus 3 segment B signals. If this bit is set, MFSEL1.DVOSEL must be 0.           */
+#define  I2CSEGSEL_S2SDSEL               10 , 1              /* 10 S2SDSEL. Selects either GPIOs or SMBus 2 segment D signals. If this bit is set, MFSEL3.14 must be 0.               */
+#define  I2CSEGSEL_S2SCSEL               9 , 1               /* 9 S2SCSEL. Selects either GPIOs or SMBus 2 segment C signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S2SBSEL               8 , 1               /* 8 S2SBSEL. Selects either GPIOs or SMBus 2 segment B signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S1SDSEL               7 , 1               /* 7 S1SDSEL. Selects either GPIOs or SMBus 1 segment D signals. If this bit is set, MFSEL3.14 must be 0.                */
+#define  I2CSEGSEL_S1SCSEL               6 , 1               /* 6 S1SCSEL. Selects either GPIOs or SMBus 1 segment C signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S1SBSEL               5 , 1               /* 5 S1SBSEL. Selects either GPIOs or SMBus 1 segment B signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S0DECFG               3 , 2              /* 4-3 S0DECFG. Selects SMBus 0 Drive Enable controls.                                                                   */
+#define  I2CSEGSEL_S0SDSEL               2 , 1               /* 2 S0SDSEL. Selects either GPIOs or SMBus 0 segment D signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S0SCSEL               1 , 1               /* 1 S0SCSEL. Selects either GPIOs or SMBus 0 segment C signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+#define  I2CSEGSEL_S0SBSEL               0 , 1               /* 0 S0SBSEL. Selects either GPIOs or SMBus 0 segment B signals. If this bit is set, MFSEL1.DVOSEL must be 0.            */
+
+/**************************************************************************************************************************/
+/*   I2C Segment Control Register (I2CSEGCTL) (New in )                                                                   */
+/**************************************************************************************************************************/
+#define  I2CSEGCTL                      (GCR_BASE_ADDR + 0x0E4) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0E4h */
+#define  I2CSEGCTL_S4DWE                 25 , 1              /* 25 S4DWE. This bit must be written as 1 to enable writing to S4DEN bit in the same write transaction.                 */
+#define  I2CSEGCTL_S0DWE                 21 , 1              /* 21 S0DWE. This bit must be written as 1 to enable writing to S0DEN bit in the same write transaction.                 */
+#define  I2CSEGCTL_WEN5SS                17 , 1              /* 17 WEN5SS. This bit must be written as 1 to enable writing to SMB5SS field in the same write                          */
+#define  I2CSEGCTL_WEN4SS                16 , 1              /* 16 WEN4SS. This bit must be written as 1 to enable writing to SMB4SS field in the same write                          */
+#define  I2CSEGCTL_WEN3SS                15 , 1              /* 15 WEN3SS. This bit must be written as 1 to enable writing to SMB3SS field in the same write                          */
+#define  I2CSEGCTL_WEN2SS                14 , 1              /* 14 WEN2SS. This bit must be written as 1 to enable writing to SMB2SS field in the same write                          */
+#define  I2CSEGCTL_WEN1SS                13 , 1              /* 13 WEN1SS. This bit must be written as 1 to enable writing to SMB1SS field in the same write                          */
+#define  I2CSEGCTL_WEN0SS                12 , 1              /* 12 WEN0SS. This bit must be written as 1 to enable writing to SMB0SS field in the same write                          */
+#define  I2CSEGCTL_SMB5SS                11 , 0             /* SMB5SS. Selects SMB5 sub-segment operation. Signals in segments that are not selected float. If the                   */
+#define  I2CSEGCTL_SMB4SS                8 , 2              /* SMB4SS. Selects SMB4 sub-segment operation. Signals in segments that are not selected float. If the                   */
+#define  I2CSEGCTL_SMB3SS                6 , 2              /* SMB3SS. Selects SMB0 sub-segment operation. Signals in segments that are not selected float. If the                   */
+#define  I2CSEGCTL_SMB2SS                4 , 2              /* SMB2SS. Selects SMB2 sub-segment operation. Signals in segments that are not selected float. If the                   */
+#define  I2CSEGCTL_SMB1SS                2 , 2              /* SMB1SS. Selects SMB1 sub-segment operation. Signals in segments that are not selected float. If the                   */
+#define  I2CSEGCTL_SMB0SS                0 , 2              /* SMB0SS. Selects SMB0 sub-segment operation. Signals in segments that are not selected float. If the                   */
+
+/**************************************************************************************************************************/
+/*   Voltage Supply Report Register (VSRCR) (New in )                                                                     */
+/**************************************************************************************************************************/
+#define  VSRCR                          (GCR_BASE_ADDR + 0x0E8) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0E8h */
+#define  VSRCR_VSIF                      14 , 1              /* 14 VSIF. Reports the voltage level on supply VSBSIF.                                                                  */
+#define  VSRCR_V14                       13 , 1              /* 13 V14. Reports the voltage level on supply VSBV14.                                                                   */
+#define  VSRCR_V13                       12 , 1              /* 12 V13. Reports the voltage level on supply VSBV13.                                                                   */
+#define  VSRCR_V12                       11 , 1              /* 11 V12. Reports the voltage level on supply VSBV12.                                                                   */
+#define  VSRCR_V11                       10 , 1              /* 10 V11. Reports the voltage level on supply VSBV11.                                                                   */
+#define  VSRCR_V10                       9 , 1               /* 9 V10. Reports the voltage level on supply VSBV10.                                                                    */
+#define  VSRCR_V9                        8 , 1               /* 8 V9. Reports the voltage level on supply VSBV9.                                                                      */
+#define  VSRCR_V8                        7 , 1               /* 7 V8. Reports the voltage level on supply VSBV8.                                                                      */
+#define  VSRCR_V7                        6 , 1               /* 6 V7. Reports the voltage level on supply VSBV7.                                                                      */
+#define  VSRCR_V6                        5 , 1               /* 5 V6. Reports the voltage level on supply VSBV6.                                                                      */
+#define  VSRCR_V5                        4 , 1               /* 4 V5. Reports the voltage level on supply VSBV5.                                                                      */
+#define  VSRCR_V4                        3 , 1               /* 3 V4. Reports the voltage level on supply VSBV4.                                                                      */
+#define  VSRCR_V3                        2 , 1               /* 2 V3. Reports the voltage level on supply VSBV3.                                                                      */
+#define  VSRCR_V2                        1 , 1               /* 1 V2. Reports the voltage level on supply VSBV2.                                                                      */
+#define  VSRCR_V1                        0 , 1               /* 0 V1. Reports the voltage level on supply VSBV1.                                                                      */
+
+/**************************************************************************************************************************/
+/*   Coprocessor Control Register (CPCTL) (Changed in )                                                                   */
+/**************************************************************************************************************************/
+#define  CPCTL                          (GCR_BASE_ADDR + 0x0D0) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0D0h */
+#define  CPCTL_CP_FUSTRAP10_1            16 , 10            /* 25-16 CP_FUSTRAP10-1 (Coprocessor FUSTRAP10-1). Values of Coprocessor CP_FUSTRAPs.                                    */
+#define  CPCTL_CPBOOTC                   8 , 2              /* 9-8 CPBOOTC (Coprocessor Boot Control). These bits select the boot address of the CP core boot                        */
+#define  CPCTL_BMCRST_STS                7 , 1               /* 7 BMCRST_STS (BMC Core Reset Status).                                                                                 */
+#define  CPCTL_CPRST_STS                 6 , 1               /* 6 CPRST_STS (Coprocessor Reset Status).                                                                               */
+#define  CPCTL_BMCRSTREL                 1 , 1               /* 1 BMCRSTREL (BMC Core Reset Release). This functionality is not implemented in .                                      */
+#define  CPCTL_CPRSTREL                  0 , 1               /* 0 CPRSTREL (Coprocessor Reset Release). Releases coprocessor from reset after VSB Power-Up                            */
+
+/**************************************************************************************************************************/
+/*   This register reflects CP to BMC Notification Register 0 (CP2BNT0) on page 713 and CP to BMC Notification Register 1 */
+/**************************************************************************************************************************/
+#define  CP2BST                         (GCR_BASE_ADDR + 0x0D4) , GCR_ACCESS, 32 		/* Location: GCR_BA+0D4h */
+#define  CP2BST_CP2BST                   0 , 32             /* 31-0 CP2BST (Coprocessor to BMC Core status).                                                                         */
+
+/**************************************************************************************************************************/
+/*   This register is reflected in registers BMC to CP Status Register 0 (B2CPST0) on page 712 and CP to BMC Notification Register*/
+/**************************************************************************************************************************/
+#define  B2CPNT                          (GCR_BASE_ADDR + 0x0D8) , GCR_ACCESS, 32 		/* Location: GCR_BA+0D8h */
+#define  B2CPNT_B2CPNT                   0 , 32             /* 31-0 B2CPNT (BMC to Coprocessor Core Notification).                                                                   */
+
+/**************************************************************************************************************************/
+/*   Coprocessor Protection Control Register (CPPCTL) (Changed in )                                                       */
+/**************************************************************************************************************************/
+#define  CPPCTL                         (GCR_BASE_ADDR + 0x0DC) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 0DCh */
+#define  CPPCTL_CPD3L                    3 , 1               /* 3 CPD3L (Coprocessor and GDMA AHB3 Lock). Locks CP and GDMA access to AHB3. Disables any                              */
+#define  CPPCTL_CPCL                     0 , 1               /* 0 CPCL (Coprocessor Control Registers Lock). Locks (Disables) CP write capability to System                           */
+
+/**************************************************************************************************************************/
+/*   Engineering Test Straps Register (ETSR) (Updated in Poleg)                                                           */
+/**************************************************************************************************************************/
+#define  ETSR                           (GCR_BASE_ADDR + 0x110) , GCR_ACCESS, 32 		/* Location: GCR_BA+110h */
+#define  ETSR_ESTRP13_9                  9 , 5              /* 13-9 ESTRP13-9. TBD Engineering test straps.                                                                          */
+#define  ETSR_ESTRP8                     8 , 1               /* 8 ESTRP8. SPI-QUAD Run Enable (XSRE).                                                                                 */
+#define  ETSR_ESTRP7_1                   1 , 7              /* 7-1 ESTRP7-1. TBD Engineering test straps.                                                                            */
+
+/**************************************************************************************************************************/
+/*   Engineering DFT 1 Register (DFT1R)                                                                                   */
+/**************************************************************************************************************************/
+#define  DFT1R                          (GCR_BASE_ADDR + 0x114) , GCR_ACCESS, 32 		/* Location: GCR_BA+114h */
+
+/**************************************************************************************************************************/
+/*   Engineering DFT 2 Register (DFT2R)                                                                                   */
+/**************************************************************************************************************************/
+#define  DFT2R                          (GCR_BASE_ADDR + 0x118) , GCR_ACCESS, 32 		/* Location: GCR_BA+118h */
+
+/**************************************************************************************************************************/
+/*   Engineering DFT 3 Register (DFT3R)                                                                                   */
+/**************************************************************************************************************************/
+#define  DFT3R                          (GCR_BASE_ADDR + 0x11C) , GCR_ACCESS, 32 		/* Location: GCR_BA+11Ch */
+
+/**************************************************************************************************************************/
+/*   Engineering Debug Flip-Flop Scan Register (EDFFSR)                                                                   */
+/**************************************************************************************************************************/
+#define  EDFFSR                         (GCR_BASE_ADDR + 0x120) , GCR_ACCESS, 32 		/* Location: GCR_BA+120h */
+#define  EDFFSR_AUTOSCAN                 4 , 1               /* 4 AUTOSCAN. (This bit and operation is optional, not implemented) Enables a very easy use of scan mode.               */
+#define  EDFFSR_SCANMODE                 3 , 1               /* 3 SCANMODE. Enables easy entry to scan mode. Only TEST mode need be asserted, if this bit is set.                     */
+#define  EDFFSR_SWSCANEVT                2 , 1               /* 2 SWSCANEVT. If set will trigger an event for clock change. Event from software (this bit) and hardware (selected     */
+#define  EDFFSR_SCANMUX                  0 , 2              /* 1-0 SCANMUX. Enables one of the following signals to become an hardware event trigger for the Filp-Flop scan.         */
+
+/**************************************************************************************************************************/
+/*   Engineering Integration Control Register for PCIe 0 (INTCRPCE0) (TBD** in Poleg)                                     */
+/**************************************************************************************************************************/
+#define  INTCRPCE0                      (GCR_BASE_ADDR + 0x130) , GCR_ACCESS, 32 		/* Location: GCR_BA+130h */
+#define  INTCRPCE0_cko_alive_con         0 , 32             /* 31-0 cko_alive_con = INTCRPCE0[1:0]; //Default value is 2'b00 (cko_alive clock is not used)                           */
+
+/**************************************************************************************************************************/
+/*   Engineering Integration Control Register for PCIe 1 (INTCRPCE1) (TBD** in Poleg)                                     */
+/**************************************************************************************************************************/
+#define  INTCRPCE1                      (GCR_BASE_ADDR + 0x134) , GCR_ACCESS, 32 		/* Location: GCR_BA+134h */
+#define  INTCRPCE1_phy_tx_lvl            0 , 32             /* 31-0 phy_tx_lvl = INTCRPCE1[4:0]; //Default is 5'b10000 in Z1A, 6 in Z1.                                              */
+
+/**************************************************************************************************************************/
+/*   Engineering DAC Test Register (DACTEST) (TBD** in Poleg)                                                             */
+/**************************************************************************************************************************/
+#define  DACTEST                        (GCR_BASE_ADDR + 0x138) , GCR_ACCESS, 32 		/* Location: GCR_BA+138h */
+#define  DACTEST_Entry                   0 , 32             /* 31-0 Entry into the test mode:                                                                                        */
+
+/**************************************************************************************************************************/
+/*   JUMP ADDRESS FOR SMP                                                   */
+/**************************************************************************************************************************/
+#define  SCRPAD                         (GCR_BASE_ADDR + 0x13C) , GCR_ACCESS, 32 		/* Location: GCR_BA+13Ch */
+
+/**************************************************************************************************************************/
+/*   Engineering Analog Test Control Register (ANTEST) (TBD** in Poleg)                                                   */
+/**************************************************************************************************************************/
+#define  ANTEST                         (GCR_BASE_ADDR + 0x13C) , GCR_ACCESS, 32 		/* Location: GCR_BA+13Ch */
+#define  ANTEST_Regulator                0 , 8              /* 7-0 Regulator Calibration Value. One bit only must be set at a time.                                                  */
+
+/**************************************************************************************************************************/
+/*   USB PHY 1 Control Register (USB1PHYCTL) (Updated in Poleg)                                                           */
+/**************************************************************************************************************************/
+#define  USBTEST                        (GCR_BASE_ADDR + 0x140) , GCR_ACCESS, 32 		/* Location: GCR_BA+140h */
+#define  USB1PHYCTL                     (GCR_BASE_ADDR + 0x140) , GCR_ACCESS, 32 		/* Location: GCR_BA+140h */
+#define  USBPHY1_RS                     28 , 1             /* 28 This bit should be set after the PHY reset bit is released and the host is initialized. */
+
+
+/**************************************************************************************************************************/
+/*   USB PHY 2 Control Register (USB2PHYCTL) (Updated in Poleg)                                                           */
+/**************************************************************************************************************************/
+#define  USB2TEST                       (GCR_BASE_ADDR + 0x144) , GCR_ACCESS, 32 		/* Offset: GCR_BA + 144h */
+#define  USB2PHYCTL                     (GCR_BASE_ADDR + 0x144) , GCR_ACCESS, 32 		/* Location: GCR_BA+144h */
+#define  USBPHY2_RS                     28 , 1             /* 28 This bit should be set after the PHY reset bit is released and the host is initialized. */
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* MFSEL dynamic access                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MFSEL(x)            (GCR_BASE_ADDR + (((x) < 2) ? (0x00C + (4*(x))) : 0x064)) , GCR_ACCESS, 32
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIOPxPE dynamic access                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIOPxPE(x)         ( GCR_BASE_ADDR + (((x) < 8) ? 0x18 + (4*(x)) : 0x80 + (4*((x)-8)))), GCR_ACCESS, 32
+
+
+#endif /* GCR_REGS_H */
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.c b/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.c
new file mode 100755
index 0000000..9a948f6
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gcr_if.c                                                                                              */
+/*            This file contains GCR module driver selector                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(GCR_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(gcr, GCR_MODULE_TYPE)
+#endif    
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.h b/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.h
new file mode 100755
index 0000000..23a788b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gcr/gcr_if.h
@@ -0,0 +1,429 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gcr_if.h                                                                                              */
+/*            This file contains GCR interface                                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _GCR_IF_H
+#define _GCR_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+#include "../sd/sd_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* VCD Head Configuration                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    GCR_VCD_HEAD1,
+    GCR_VCD_HEAD2,
+} GCR_VCD_HEAD_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GFX Configuration                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    GCR_GFX_CONFIG_OUTPUT_FROM_HEAD1,
+    GCR_GFX_CONFIG_OUTPUT_FROM_HEAD2,
+    GCR_GFX_CONFIG_INPUT_TO_KVM,
+}GCR_GFX_CONFIG_T;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_Uart                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  redirection_mode - Mode of UART redirection                                            */
+/*                  CoreSP           - Mux CoreSP                                                          */
+/*                  sp1              - Mux SP1                                                             */
+/*                  sp2              - Mux SP2                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects UART muxing                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_Uart(UINT redirection_mode, BOOLEAN CoreSP, BOOLEAN sp1, BOOLEAN sp2);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SPIFash                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - SPI Flash device number                                                      */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SPI Flash muxing                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_SPIFash(UINT devNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_MuxFIU                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - SPI Flash device number                                                      */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SPI Flash muxing                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GCR_MuxFIU (   FIU_MODULE_T      devNum,
+                          BOOLEAN           cs0Enable,
+                          BOOLEAN           cs1Enable,
+                          BOOLEAN           cs2Enable,
+                          BOOLEAN           cs3Enable,
+                          BOOLEAN           quadMode);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_RMII                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - Ethernet device number                                                        */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects RMII mux                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_RMII(UINT devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetDacSense                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Makes the trigger for sense circuits to be GFX core output signal (miscOUT2)           */
+/*                  instead of VSYNC falling edge                                                          */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetDacSense(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_RMII                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - Gigabit Ethernet device number                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects GMII mux                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GMII(UINT devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_GPIO                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs mux for given GPIO                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GPIO(UINT gpio_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SIOXH                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  enable - if TRUE enables the mux, otherwise disable                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SIOXH mux                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_SIOXH(BOOLEAN enable);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_PSPI                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - Peripheral SPI device number                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs muxing for Peripheral SPI device                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_PSPI(UINT devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_GSPI                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs muxing for Graphics Core SPI Signals                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_Mux_GSPI(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_PowerOn_GetMemorySize                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns configured DDR memory size                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  GCR_PowerOn_GetMemorySize(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_PinPullUpDown                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num    -                                                                          */
+/*                  enable      -                                                                          */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets internal Pull Up/Down resistor for the given pin                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_PinPullUpDown(UINT32 gpio_num, BOOLEAN enable);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Mux_SD                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                 sdNum    - [in], SD device number                                                       */
+/*                 sdType   - [in], SD1 device type (SD or MMC)                                            */
+/*                                                                                                         */
+/* Returns:         BMC HAL Error code                                                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects SD mux                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GCR_Mux_SD(SD_DEV_NUM_T sdNum, SD_DEV_TYPE_T sdType);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootTimeConfig                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  clk - Card clock frequency (in Hz units)                                               */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine calculates and configures the number of SDCLK clock cycles:               */
+/*                   1) In a 50 millisecond time.                                                          */
+/*                   1) In a 1 second time.                                                                */
+/*                  These values are being used to determine whether Boot Time-Out has occured.            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootTimeConfig (UINT32 clk);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootStart                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  ack - TRUE means expect the boot acknowledge data, FALSE otherwise.                    */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initiates a EMMC boot sequence.                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootStart (BOOLEAN ack);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootInvalid                                                                    */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         TRUE if boot is invalid, FALSE otherwise                                               */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks whether the current boot process is invalid,                       */
+/*                  i.e., one of the following has occured:                                                */
+/*                   1) The device did not respond in time with the boot acknowledge sequence or data.     */
+/*                   2) An error in data structure occurred.                                               */
+/*                   3) A CRC error occurred when reading from the eMMC device.                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_EmmcBootInvalid (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EmmcBootEnd                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine ends a EMMC boot sequence, either when the boot sequence is done,         */
+/*or an error is discovered.                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EmmcBootEnd (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetVCDInput                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  headNum - Number of the head (1 or 2)                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects the intput for the VCD                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetVCDInput(GCR_VCD_HEAD_T headNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_SetGFXInput                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  config - GFX configuration                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine selects the intput for the VCD                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_SetGFXConfig(GCR_GFX_CONFIG_T config);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ConfigUSBBurstSize                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Configures the USB burst size in USB test register                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_ConfigUSBBurstSize(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ResetTypeIsPor                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns true if reset source was POR (powerOn) reset                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_ResetTypeIsPor(void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_ResetTypeIsCor                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns TRUE if and only if a Core reset is performed                                  */
+/*                  and FALSE on any other reset type.                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_ResetTypeIsCor(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_MarkCfgDone                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Sets a flag in scratch register specifying that CLK/DDR configuration were performed   */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_MarkCfgDone(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_CfgWasDone                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Returns true if a flag in scratch register indicates                                   */
+/*                  that CLK/DDR configuration was already done                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GCR_CfgWasDone(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_EnableJtag                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enable Jtag access                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_EnableJtag(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_DisableJtag                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Disable Jtag access                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_DisableJtag(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_DisableModules                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  mdlr -  Value to write to MDLR register                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Writes to the MDLR register which determines which modules to disable                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void GCR_DisableModules(UINT32 mdlr);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GCR_Get_Chip_Version                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                                                         */
+/* Returns:         PDID value                                                                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the chip version (POLEG_VERSION_Z1/ POLEG_VERSION_Z2              */
+/*                                                         POLEG_VERSION_A1)                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 GCR_Get_Chip_Version(void);
+
+
+#endif
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.c b/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.c
new file mode 100755
index 0000000..e7f51b5
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.c
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gmac_if.c                                                                                             */
+/*            This file contains GMAC module driver selector                                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(GMAC_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(gmac, GMAC_MODULE_TYPE)
+#endif    
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.h b/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.h
new file mode 100755
index 0000000..664325b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gmac/gmac_if.h
@@ -0,0 +1,109 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   GMAC_if.h                                                                                             */
+/*            This file contains interface of GMAC module                                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _GMAC_IF_H
+#define _GMAC_IF_H
+
+#include "../../Common/hal_error.h"
+#include "defs.h"
+
+
+#ifndef GMAC_NUM_OF_RX_DESC
+#define GMAC_NUM_OF_RX_DESC     32
+#endif
+
+#ifndef GMAC_NUM_OF_TX_DESC
+#define GMAC_NUM_OF_TX_DESC     32
+#endif
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMAC_Initialize                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Initialize GMAC Controller                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GMAC_Initialize(         UINT            devNum,
+                            const   UINT8*          mac_addr,
+                            const   ETH_CALLBACK_T* callbacks,
+                            const   ETH_PHY_OPS_T*  phyOps,
+                            const   UINT8**         RxBuffersArray,
+                            const   UINT32          buffersSize);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMAC_Halt                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ETH device                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GMAC_Halt(UINT deviceNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMAC_Send                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ETH device                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GMAC_Send(UINT deviceNum, UINT8* packet, UINT32 length);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMAC_SetMacAddr                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - Device Number                                                            */
+/*                  mac_addr    - MAC address to set                                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Set MAC Address                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GMAC_SetMacAddr(UINT devNum, const UINT8* mac_addr);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMAC_Isr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This is Interrupt Service Routine Tx Interrupt request                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GMAC_Isr(UINT32 devNum);
+
+
+#endif
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.c b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.c
new file mode 100755
index 0000000..cbf2a8b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.c
@@ -0,0 +1,1020 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gpio_drv.c                                                                                            */
+/*            This file contains GPIO driver implementation                                                */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_DRV_C
+
+#ifndef NO_LIBC
+#include <string.h>
+#endif
+
+#include "../../../Chips/chip_if.h"
+
+#include "gpio_drv.h"
+#include "gpio_regs.h"
+
+#include "stdarg.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DEBUG related                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(VERBOSE_GLOBAL) || defined(VERBOSE_GPIO)
+#ifndef __LINUX_KERNEL_ONLY__
+#define GPIO_DEBUG_MSG(fmt,args...) printf (fmt ,##args)
+#else
+#define GPIO_DEBUG_MSG(fmt,args...) printk (fmt ,##args)
+#endif
+#else
+#define GPIO_DEBUG_MSG(fmt,args...)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Main GPIO Table                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+static const GPIO_TABLE_ENTRY_T GPIO_table[GPIO_NUM_OF_GPIOS] = GPIO_DEFINITION_TABLE;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt dispatcher tables                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    GPIO_EVEN_HANDLE_T  handler;
+    void*               arg;
+} GPIO_Handler_t;
+
+static GPIO_Handler_t GPIO_handler[GPIO_NUM_OF_MODULES * GPIO_EVENT_GPIOS_PER_MODULE] = {{0}};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              Local Macros                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_IN_RANGE(gpio)             (gpio<GPIO_NUM_OF_GPIOS)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* operations on GPIO list                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_LIST_START(queue, arg)      va_start(queue, arg)
+#define GPIO_LIST_END(queue)             va_end(queue)
+#define GPIO_NEXT(queue)                 va_arg( queue, INT)
+#define GPIO_LAST(gpio)                 ((gpio) == GPIO_END_OF_ARG_LIST)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* operations on GPIO TABLE ENTRY                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_PORT_NUM(gpio_entry)        READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_ID_PORT_NUM)
+#define GPIO_PORT_BIT(gpio_entry)        READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_ID_PORT_BIT)
+
+#define GPIO_INPUTABLE(gpio_entry)      (READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_INPUT_BIT)   != GPIO_CAP_NO_INPUT)
+#define GPIO_OUTPUTABLE(gpio_entry)     (READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_OUTPUT_BIT)  != GPIO_CAP_NO_OUTPUT)
+#define GPIO_EVENTABLE(gpio_entry)      (READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_EVENT_FIELD) != GPIO_CAP_NO_EVENT)
+#define GPIO_DEBOUNCABLE(gpio_entry)    (READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_DEB_FIELD)   != GPIO_CAP_NO_DEBOUNCE)
+#define GPIO_BLINKABLE(gpio_entry)      (READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_BLINK_FIELD) != GPIO_CAP_NO_BLINK)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Possition in Handlers array by port and bit                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_HANDLER_POS(port,bit)      ((GPIO_PORT_TO_MODULE(port)*GPIO_EVENT_GPIOS_PER_MODULE) + (bit))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Array initializing                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_CLEAR_ARRAY(array)         { UINT i; for(i=0; i<(sizeof(array)/sizeof(array[0])); ++i) array[i]=0;}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                  Local functions Forward declarations                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+static void         GPIO_ConfigureInputPort_L     ( UINT    port,
+                                                    UINT32  input_mask,
+                                                    UINT32  event_mask,
+                                                    UINT32  event_en,
+                                                    UINT32  event_debounce,
+                                                    UINT32  event_type,
+                                                    UINT32  event_pol);
+
+static HAL_STATUS   GPIO_ConfigureOutputPort_L    ( GPIO_OUTPUT_T   type,
+                                                    BOOLEAN         init_val,
+                                                    UINT            port,
+                                                    UINT32          mask);
+
+static void         GPIO_WritePort_L              ( BOOLEAN value, UINT port, UINT32 mask);
+
+static void         GPIO_BlinkPort_L              ( UINT port, UINT32 mask, UINT32 val);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Interface functions                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+HAL_STATUS GPIO_Init()
+{    
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureInput                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  handler             - Handler function for GPIO event                                  */
+/*                  handler_args        - Handler function argument                                        */
+/*                  event_type          - Event type (Raising/Falling edge, High/Low level)                */
+/*                  debounce            - Enable HW debounce                                               */
+/*                  internal_resistor   - Enable internal Pull-Up/Down                                     */
+/*                  gpio_num            - One or more GPIO number(s) to configure                          */
+/*                                        SHOULD BE SET USING 'GPIOS' macro                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures one or more GPIOs to input                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_ConfigureInput( GPIO_EVEN_HANDLE_T  handler,
+                                void*               handler_args,
+                                GPIO_EVENT_T        event_type,
+                                BOOLEAN             debounce,
+                                BOOLEAN             internal_resistor,
+                                UINT                gpio_num, ... )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Retriving Table entry for the given GPIO                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_TABLE_ENTRY_T  gpio_entry      = GPIO_table[gpio_num];
+    INT                 current_gpio    = 0;
+    INT                 current_module  = 0;
+    va_list             queue;
+    UINT                errors          = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* masks arrays                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 port_mask[GPIO_NUM_OF_PORTS];
+    UINT32 debounce_mask[GPIO_NUM_OF_MODULES];
+    UINT32 event_mask[GPIO_NUM_OF_MODULES];
+    UINT32 event_type_mask[GPIO_NUM_OF_MODULES];
+    UINT32 event_pol_mask[GPIO_NUM_OF_MODULES];
+    UINT32 event_en_mask[GPIO_NUM_OF_MODULES];
+
+
+    GPIO_DEBUG_MSG("GPIO: Configuring Input\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing the arrays                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_CLEAR_ARRAY(port_mask);
+    GPIO_CLEAR_ARRAY(debounce_mask);
+    GPIO_CLEAR_ARRAY(event_mask);
+    GPIO_CLEAR_ARRAY(event_type_mask);
+    GPIO_CLEAR_ARRAY(event_pol_mask);
+    GPIO_CLEAR_ARRAY(event_en_mask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Marking first element                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_LIST_START(queue, gpio_num);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parsing all GPIOs and group them by ports                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    current_gpio    = gpio_num;
+    current_module  = GPIO_PORT_TO_MODULE(GPIO_PORT_NUM(gpio_entry));
+
+    while(!GPIO_LAST(current_gpio))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If the GPIO can be configured as INPUT, add it to port masks                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (GPIO_INPUTABLE(gpio_entry) && GPIO_IN_RANGE(current_gpio))
+        {
+            GPIO_DEBUG_MSG("GPIO: Setting GPIO %d into port mask. Port %d, Port Bit %d\n", current_gpio, GPIO_PORT_NUM(gpio_entry), GPIO_PORT_BIT(gpio_entry));
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Muxing the GPIO                                                                             */
+            /*---------------------------------------------------------------------------------------------*/
+            GCR_Mux_GPIO(current_gpio);
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Configuring internal pull up/down                                                           */
+            /*---------------------------------------------------------------------------------------------*/
+            GCR_PinPullUpDown(current_gpio, internal_resistor);
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Setting Input configuration mask                                                            */
+            /*---------------------------------------------------------------------------------------------*/
+            SET_VAR_BIT(port_mask[GPIO_PORT_NUM(gpio_entry)], GPIO_PORT_BIT(gpio_entry));
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Setting debounce mask                                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            if (GPIO_DEBOUNCABLE(gpio_entry) && (debounce))
+            {
+                SET_VAR_BIT(debounce_mask[current_module], READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_DEB_FIELD));
+            }
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Setting events mask                                                                         */
+            /*---------------------------------------------------------------------------------------------*/
+            if (GPIO_EVENTABLE(gpio_entry))
+            {
+                UINT32  event_bit   = READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_EVENT_FIELD);
+                UINT32  handler_pos = GPIO_HANDLER_POS(GPIO_PORT_NUM(gpio_entry), event_bit);
+
+                SET_VAR_BIT(event_mask[current_module], event_bit);
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Setting event polarity                                                                  */
+                /*-----------------------------------------------------------------------------------------*/
+                if ((event_type == GPIO_EVENT_HIGH_LEVEL) || (event_type == GPIO_EVENT_RISING_EDGE))
+                {
+                    SET_VAR_BIT(event_pol_mask[current_module], event_bit);
+                }
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Setting event type                                                                      */
+                /*-----------------------------------------------------------------------------------------*/
+                if ((event_type == GPIO_EVENT_HIGH_LEVEL) || (event_type == GPIO_EVENT_LOW_LEVEL))
+                {
+                    SET_VAR_BIT(event_type_mask[current_module], event_bit);
+                }
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Setting event handler                                                                   */
+                /*-----------------------------------------------------------------------------------------*/
+                if (handler != NULL)
+                {
+                    SET_VAR_BIT(event_en_mask[current_module], event_bit);
+
+                    GPIO_handler[handler_pos].handler   = handler;
+                    GPIO_handler[handler_pos].arg       = handler_args;
+
+#if !defined(NO_INTERNAL_IRQ_HANDLER)
+                    /*-------------------------------------------------------------------------------------*/
+                    /* Registering event handler to AIC                                                    */
+                    /*-------------------------------------------------------------------------------------*/
+                    AIC_RegisterHandler(GPIO_INTERRUPT(current_gpio), GPIO_Isr, 0);
+                    AIC_EnableInt(GPIO_INTERRUPT(current_gpio));
+#endif
+                }
+                else
+                {
+                    GPIO_handler[handler_pos].handler   = NULL;
+                    GPIO_handler[handler_pos].arg       = 0;
+                }
+
+            }
+        }
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting error flag if wrong GPIO was given                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+        else
+        {
+            errors += HAL_ERROR_BAD_PARAM;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Getting Next GPIO                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (!GPIO_LAST(current_gpio = GPIO_NEXT(queue)))
+        {
+            gpio_entry      = GPIO_table[current_gpio];
+            current_module  = GPIO_PORT_TO_MODULE(GPIO_PORT_NUM(gpio_entry));
+        }
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure all ports                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    {
+        UINT port = 0;
+        for(port=0; port<GPIO_NUM_OF_PORTS; ++port)
+        {
+            if (port_mask[port] != 0)
+            {
+                GPIO_DEBUG_MSG("GPIO: Configuring port %d with mask %x to Input\n", port, port_mask[port]);
+
+                GPIO_ConfigureInputPort_L(  port,
+                                            port_mask[port],                            \
+                                            event_mask[GPIO_PORT_TO_MODULE(port)],      \
+                                            event_en_mask[GPIO_PORT_TO_MODULE(port)],   \
+                                            debounce_mask[GPIO_PORT_TO_MODULE(port)],   \
+                                            event_type_mask[GPIO_PORT_TO_MODULE(port)], \
+                                            event_pol_mask[GPIO_PORT_TO_MODULE(port)]);
+            }
+        }
+
+    }
+
+    GPIO_LIST_END(queue);
+
+    if (errors > 0)
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureOutput                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  type     -  Output type (Push Pull/ Open Drain)                                        */
+/*                  gpio_num -  One or more GPIO number(s) to configure                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures one or more GPIOs to output                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_ConfigureOutput(GPIO_OUTPUT_T type, BOOLEAN init_val, UINT gpio_num, ... )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Retriving Table entry for the given GPIO                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_TABLE_ENTRY_T  gpio_entry      = GPIO_table[gpio_num];
+    INT                 current_gpio    = 0;
+    UINT                errors          = 0;
+    va_list             queue;
+    UINT32              port_mask[GPIO_NUM_OF_PORTS];
+
+    GPIO_DEBUG_MSG("GPIO: Configuring Output val=%d, type=%d\n", init_val, type);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Ports mask array init                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_CLEAR_ARRAY(port_mask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Marking first element                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_LIST_START(queue, gpio_num);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parsing all GPIOs and group them by ports                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    current_gpio = gpio_num;
+    while(!GPIO_LAST(current_gpio))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If the GPIO can be configured as OUTPUT, add it to port masks                                   */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (GPIO_OUTPUTABLE(gpio_entry) && GPIO_IN_RANGE(current_gpio))
+        {
+            GPIO_DEBUG_MSG("GPIO: Setting GPIO %d into port mask. Port %d, Port Bit %d\n", current_gpio, GPIO_PORT_NUM(gpio_entry), GPIO_PORT_BIT(gpio_entry));
+
+            GCR_Mux_GPIO(current_gpio);
+            SET_VAR_BIT(port_mask[GPIO_PORT_NUM(gpio_entry)], GPIO_PORT_BIT(gpio_entry));
+        }
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting error flag if wrong GPIO was given                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+        else
+        {
+            errors += HAL_ERROR_BAD_PARAM;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Getting Next GPIO                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (!GPIO_LAST(current_gpio = GPIO_NEXT(queue)))
+        {
+            gpio_entry = GPIO_table[current_gpio];
+        }
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure all ports                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    {
+        UINT port = 0;
+        for(port=0; port<GPIO_NUM_OF_PORTS; ++port)
+        {
+            if (port_mask[port] != 0)
+            {
+                GPIO_DEBUG_MSG("GPIO: Configuring port %d with mask %x to Output\n", port, port_mask[port]);
+                errors += GPIO_ConfigureOutputPort_L(type, init_val, port, port_mask[port]);
+            }
+        }
+    }
+
+    GPIO_LIST_END(queue);
+
+    if (errors > 0)
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Blink                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  type     - Blinking timing configuration                                               */
+/*                  gpio_num - One or more GPIO number(s) to configure                                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures one or more GPIOs to start blinking                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Blink(GPIO_BLINK_T type, UINT gpio_num, ... )
+{
+    GPIO_TABLE_ENTRY_T  gpio_entry      = GPIO_table[gpio_num];
+    UINT                gpio_cap_blink  = READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_BLINK_FIELD);
+    INT                 current_gpio    = 0;
+    INT                 current_module  = 0;
+    va_list             queue;
+    UINT                errors          = 0;
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Defining BLINK Field                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    #define GPIO_BLINK_FIELD    gpio_cap_blink,  3
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Marking first element                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_LIST_START( queue, gpio_num );
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If only 1 GPIO was passed we execute single function faster (speed optimization)                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (GPIO_LAST(GPIO_NEXT(queue)) && GPIO_BLINKABLE(gpio_entry) && GPIO_IN_RANGE(gpio_num))
+    {
+           SET_REG_FIELD(GPxBLINK(GPIO_PORT_NUM(gpio_entry)), GPIO_BLINK_FIELD, type);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* otherwise we group the GPIOs into single mask and BLINK them together                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        UINT32 blink_val[GPIO_NUM_OF_MODULES];
+        UINT32 blink_mask[GPIO_NUM_OF_MODULES];
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Clearing the arrays                                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        GPIO_CLEAR_ARRAY(blink_val);
+        GPIO_CLEAR_ARRAY(blink_mask);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Resetting arguments queue                                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        GPIO_LIST_START( queue, gpio_num );
+        current_gpio    = gpio_num;
+        current_module  = GPIO_PORT_TO_MODULE(GPIO_PORT_NUM(gpio_entry));
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Parsing all GPIOs                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        while(!GPIO_LAST(current_gpio))
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If the GPIO is blinkable, add it to blink mask                                              */
+            /*---------------------------------------------------------------------------------------------*/
+            if (GPIO_BLINKABLE(gpio_entry)&& GPIO_IN_RANGE(current_gpio))
+            {
+                /*-----------------------------------------------------------------------------------------*/
+                /* Collecting BLINK values and their mask                                                  */
+                /*-----------------------------------------------------------------------------------------*/
+                SET_VAR_FIELD(blink_val[current_module], GPIO_BLINK_FIELD, type);
+                blink_mask[current_module] |= MASK_FIELD(GPIO_BLINK_FIELD);
+            }
+            /*---------------------------------------------------------------------------------------------*/
+            /* Setting error flag if wrong GPIO was given                                                  */
+            /*---------------------------------------------------------------------------------------------*/
+            else
+            {
+                errors += HAL_ERROR_BAD_PARAM;
+            }
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Getting Next GPIO                                                                           */
+            /*---------------------------------------------------------------------------------------------*/
+            if (!GPIO_LAST(current_gpio  = GPIO_NEXT(queue)))
+            {
+                gpio_entry      = GPIO_table[current_gpio];
+                gpio_cap_blink  = READ_VAR_FIELD(gpio_entry.id, GPIO_TABLE_CAP_BLINK_FIELD);
+                current_module  = GPIO_PORT_TO_MODULE(GPIO_PORT_NUM(gpio_entry));
+            }
+        }
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Writing blink values for each module                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        {
+            UINT i=0;
+
+            for (i=0; i<GPIO_NUM_OF_MODULES; ++i)
+            {
+                GPIO_BlinkPort_L(i*GPIO_PORTS_PER_MODULE, blink_mask[i], blink_val[i]);
+            }
+        }
+    }
+
+    GPIO_LIST_END(queue);
+
+    if (errors > 0)
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Write                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  value    - Value of the GPIO(s) to set                                                 */
+/*                  gpio_num - One or more GPIO number(s) to configure                                     */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set value of one or more GPIOs                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Write(BOOLEAN value, UINT gpio_num, ... )
+{
+    GPIO_TABLE_ENTRY_T  gpio_entry      = GPIO_table[gpio_num];
+    INT                 current_gpio    = 0;
+    UINT                errors          = 0;
+    va_list             queue;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Marking first element                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GPIO_LIST_START( queue, gpio_num );
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If only 1 GPIO was passed we execute single function faster (speed optimization)                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (GPIO_LAST(GPIO_NEXT(queue)) && GPIO_OUTPUTABLE(gpio_entry) && GPIO_IN_RANGE(gpio_num))
+    {
+        GPIO_WritePort_L(value, GPIO_PORT_NUM(gpio_entry), 1<<GPIO_PORT_BIT(gpio_entry));
+    }
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* otherwise we group the GPIOs by port and write each port                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        UINT32 port_mask[GPIO_NUM_OF_PORTS];
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Clearing the array                                                                              */
+        /*-------------------------------------------------------------------------------------------------*/
+        GPIO_CLEAR_ARRAY(port_mask);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Resetting arguments queue                                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        GPIO_LIST_START( queue, gpio_num);
+        current_gpio = gpio_num;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Parsing all GPIOs and group them by ports                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        while(!GPIO_LAST(current_gpio))
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If the GPIO can be configured as OUTPUT, add it to port masks                               */
+            /*---------------------------------------------------------------------------------------------*/
+            if (GPIO_OUTPUTABLE(gpio_entry) && GPIO_IN_RANGE(current_gpio))
+            {
+                SET_VAR_BIT(port_mask[GPIO_PORT_NUM(gpio_entry)], GPIO_PORT_BIT(gpio_entry));
+            }
+            /*-------------------------------------------------------------------------------------------------*/
+            /* Setting error flag if wrong GPIO was given                                                      */
+            /*-------------------------------------------------------------------------------------------------*/
+            else
+            {
+                errors += HAL_ERROR_BAD_PARAM;
+            }
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Getting Next GPIO                                                                           */
+            /*---------------------------------------------------------------------------------------------*/
+            if (!GPIO_LAST(current_gpio = GPIO_NEXT(queue)))
+            {
+                gpio_entry = GPIO_table[current_gpio];
+            }
+        }
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Writing all ports                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        {
+            UINT port = 0;
+            for(port=0; port<GPIO_NUM_OF_PORTS; ++port)
+            {
+                /*-----------------------------------------------------------------------------------------*/
+                /* Writing only ports with set mask                                                        */
+                /*-----------------------------------------------------------------------------------------*/
+                if (port_mask[port] != 0)
+                {
+                    GPIO_WritePort_L(value, port, port_mask[port]);
+                }
+            }
+        }
+    }
+
+    GPIO_LIST_END(queue);
+
+    if (errors > 0)
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Read                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num - GPIO number to read the value from                                          */
+/*                                                                                                         */
+/* Returns:         Value of the given GPIO number                                                         */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads value of given GPIO                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GPIO_Read(UINT gpio_num)
+{
+    GPIO_TABLE_ENTRY_T  gpio_entry       = GPIO_table[gpio_num];
+
+    if (GPIO_INPUTABLE(gpio_entry) && GPIO_IN_RANGE(gpio_num))
+        return (BOOLEAN)READ_REG_BIT(GPxDIN(GPIO_PORT_NUM(gpio_entry)), GPIO_PORT_BIT(gpio_entry));
+    else
+        return TRUE;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_GetMuxInfo                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num        - Number of given GPIO                                                 */
+/*                  mux_regid1      - ID of the first muxing register                                      */
+/*                  mux_field1      - Muxing info of the first register                                    */
+/*                  mux_regid2      - ID of the second muxing register                                     */
+/*                  mux_field2      - Muxing info of the second register                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:    none                                                                                   */
+/* Description:                                                                                            */
+/*                  This routine returns muxing information for given GPIO                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_GetMuxInfo( UINT                gpio_num,
+                            GPIO_MUX_REGID_T*   mux_regid1,
+                            GPIO_MUX_FIELD_T*   mux_field1,
+                            GPIO_MUX_REGID_T*   mux_regid2,
+                            GPIO_MUX_FIELD_T*   mux_field2  )
+{
+    GPIO_TABLE_ENTRY_T  gpio_entry  = GPIO_table[gpio_num];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Early error handling                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!GPIO_IN_RANGE(gpio_num))
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading Simple muxing information                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (mux_regid1 != NULL)
+    {
+        *mux_regid1          =  (GPIO_MUX_REGID_T)READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_REGID1);
+    }
+
+    if (mux_regid2 != NULL)
+    {
+        *mux_regid2          =  (GPIO_MUX_REGID_T)READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_REGID2);
+    }
+
+    if (mux_field1 != NULL)
+    {
+        mux_field1->position = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD1_POS);
+        mux_field1->size     = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD1_SIZE);
+        mux_field1->value    = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD1_VAL);
+    }
+
+    if (mux_field2 != NULL)
+    {
+        mux_field2->position = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD2_POS);
+        mux_field2->size     = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD2_SIZE);
+        mux_field2->value    = READ_VAR_FIELD(gpio_entry.mux, GPIO_TABLE_MUX_FIELD2_VAL);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((mux_regid1 == NULL) || (mux_regid2 == NULL) ||(mux_field1 == NULL) || (mux_field2 == NULL))
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_GetGPIOInfo                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num -                                                                             */
+/*                  port_bit -                                                                             */
+/*                  port_num -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns GPIO information                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_GetGPIOInfo(UINT gpio_num, UINT* port_num, UINT* port_bit)
+{
+    GPIO_TABLE_ENTRY_T  gpio_entry = GPIO_table[gpio_num];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Early error handling                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!GPIO_IN_RANGE(gpio_num))
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Retriving info                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (port_num != NULL)
+    {
+        *port_num = GPIO_PORT_NUM(gpio_entry);
+    }
+
+    if (port_bit != NULL)
+    {
+        *port_bit = GPIO_PORT_BIT(gpio_entry);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Late Error handling                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((port_num == NULL) || (port_bit == NULL))
+        return HAL_ERROR_BAD_PARAM;
+    else
+        return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Isr                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  arg -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GPIO IRQ handling                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Isr(UINT32 arg)
+{
+    UINT module;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Going over all modules                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (module=0; module<GPIO_NUM_OF_MODULES; ++module)
+    {
+        UINT    bit_num     = 0;
+        UINT    fake_port   = module*GPIO_PORTS_PER_MODULE;
+        UINT32  actual_mask = REG_READ(GPEVST(fake_port)) & REG_READ(GPEVEN(fake_port));
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* and over all events in the module                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        for (bit_num=0; bit_num<GPIO_EVENT_GPIOS_PER_MODULE; ++bit_num)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Checking if event happened and enabled                                                      */
+            /*---------------------------------------------------------------------------------------------*/
+            if (READ_VAR_BIT(actual_mask, bit_num) != 0)
+            {
+                /*-----------------------------------------------------------------------------------------*/
+                /* Executing event                                                                         */
+                /*-----------------------------------------------------------------------------------------*/
+                if (GPIO_handler[GPIO_HANDLER_POS(fake_port, bit_num)].handler != NULL)
+                {
+                    GPIO_handler[GPIO_HANDLER_POS(fake_port, bit_num)].handler(GPIO_handler[GPIO_HANDLER_POS(fake_port, bit_num)].arg);
+                }
+
+            }
+        }
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Cleaning all events in the module                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        REG_WRITE(GPEVST(fake_port), 0xFFFFFFFF);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                     Local functions implementation                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureOutputPort_L                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  init_val -                                                                             */
+/*                  mask -                                                                                 */
+/*                  port -                                                                                 */
+/*                  type -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs configures complete port to Output                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS   GPIO_ConfigureOutputPort_L    ( GPIO_OUTPUT_T   type,
+                                                    BOOLEAN         init_val,
+                                                    UINT            port,
+                                                    UINT32          mask)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting OUTPUT type (push/pull or open drain)                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (type == GPIO_OUTPUT_PUSH_PULL)
+    {
+        CLEAR_REG_MASK(GPxCFG1(port), mask);
+    }
+    else if (type == GPIO_OUTPUT_OPEN_DRAIN)
+    {
+        SET_REG_MASK(GPxCFG1(port), mask);
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Unknown OUTPUT type                                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Pushing the default value before enabling                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (init_val)
+        SET_REG_MASK(GPxDOUT(port), mask);
+    else
+        CLEAR_REG_MASK(GPxDOUT(port), mask);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling OUTPUT state                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_MASK(GPxCFG0(port), mask);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureInputPort_L                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  port            - Number of port to configure                                          */
+/*                  input_mask      - Mask of the input bits in the given port                             */
+/*                  event_mask      - Mask of GPIOs that were 'touched' (cleaned/set)                      */
+/*                  event_en        - Mask of GPIOs that were enabled for event                            */
+/*                  event_debounce  - Mask of GPIOs that were enabled for debounce                         */
+/*                  event_type      - Mask of GPIOs that were set to Level                                 */
+/*                  event_pol       - Mask of GPIOs that were set to Active High (either edge or level)    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs configuration of input port                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+static void GPIO_ConfigureInputPort_L(  UINT    port,
+                                        UINT32  input_mask,
+                                        UINT32  event_mask,
+                                        UINT32  event_en,
+                                        UINT32  event_debounce,
+                                        UINT32  event_type,
+                                        UINT32  event_pol)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring input/output                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPxCFG0(port), input_mask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring debounce                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPEVDBNC(port), event_mask);
+    SET_REG_MASK  (GPEVDBNC(port), event_debounce);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring event type                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPEVTYPE(port), event_mask);
+    SET_REG_MASK  (GPEVTYPE(port), event_type);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring event polarity                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPEVPOL(port), event_mask);
+    SET_REG_MASK  (GPEVPOL(port), event_pol);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring event enable                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPEVEN(port), event_mask);
+    SET_REG_MASK  (GPEVEN(port), event_en);
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_WritePort_L                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  mask -                                                                                 */
+/*                  port -                                                                                 */
+/*                  value -                                                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes a value to the whole port                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+static void GPIO_WritePort_L(BOOLEAN value, UINT port, UINT32 mask)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Writing the output                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (value)
+    {
+        SET_REG_MASK(GPxDOUT(port), mask);
+    }
+    else
+    {
+        CLEAR_REG_MASK(GPxDOUT(port), mask);
+    }
+}
+
+
+static void GPIO_BlinkPort_L( UINT port, UINT32 mask, UINT32 val)
+{
+    /*-----------------------------------------------------------------------------------------*/
+    /* First cleaning the previous values of the given GPIOs                                   */
+    /*-----------------------------------------------------------------------------------------*/
+    CLEAR_REG_MASK(GPxBLINK(port), mask);
+
+    /*-----------------------------------------------------------------------------------------*/
+    /* Write the new blinking value                                                            */
+    /*-----------------------------------------------------------------------------------------*/
+    SET_REG_MASK(GPxBLINK(port), val);
+
+}
+
+#undef GPIO_DRV_C
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.h b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.h
new file mode 100755
index 0000000..12e84a50
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_drv.h
@@ -0,0 +1,20 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gpio_drv.h                                                                                            */
+/*            This file contains GPIO driver interface                                                     */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _GPIO_DRV_H
+#define _GPIO_DRV_H
+
+#include "../gpio_if.h"
+
+#endif //_GPIO_DRV_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_regs.h b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_regs.h
new file mode 100755
index 0000000..2511128
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gpio/Hermon_IP/gpio_regs.h
@@ -0,0 +1,80 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gpio_regs.h                                                                                           */
+/*            This file contains registers definition of GPIO module                                       */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _GPIO_REGS_H
+#define _GPIO_REGS_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Utility for defining global variables for GPIO in H file                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef GPIO_DRV_C
+#define EXTERN extern
+#else
+#define EXTERN
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                   Local definitions for port handling                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_PORTS_PER_MODULE           8
+#define GPIO_PORT_IN_MODULE(port)       ((port) % GPIO_PORTS_PER_MODULE)
+#define GPIO_PORT_TO_MODULE(port)       ((port) / GPIO_PORTS_PER_MODULE)
+
+#define GPIO_EVENT_GPIOS_PER_MODULE     18
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* We define 'undefined registers' in reserved space after module registers but within module's reserved   */
+/* address space.                                                                                          */
+/* This solution is a bit tricky and should be checked if applicable against every new chip                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_UNDEF_REG      0xF0
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Registers offset table for O(1) access                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+EXTERN const UINT8 GPIO_RegOffset[5][GPIO_PORTS_PER_MODULE] =
+{
+    {   0x14,         0x24,  0x3C,  0x50,  0x64,  0x78,  GPIO_UNDEF_REG,  0x90 },
+    {   0x18,         0x28,  0x40,  0x54,  0x68,  0x7C,  GPIO_UNDEF_REG,  0x94 },
+    {GPIO_UNDEF_REG,  0x2C,  0x44,  0x58,  0x6C,  0x80,  GPIO_UNDEF_REG,  0x98 },
+    {   0x1C,         0x34,  0x48,  0x5C,  0x70,  0x84,  GPIO_UNDEF_REG,  0x9C },
+    {   0x20,         0x38,  0x4C,  0x60,  0x74,  0x88,  0x8c,            0xA0 },
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                REGISTERS                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Unique registers in each module                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPEVTYPE(port)  (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x00),   GPIO_ACCESS, 32 
+#define GPEVPOL(port)   (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x04),   GPIO_ACCESS, 32 
+#define GPEVDBNC(port)  (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x08),   GPIO_ACCESS, 32 
+#define GPEVEN(port)    (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x0C),   GPIO_ACCESS, 32 
+#define GPEVST(port)    (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x10),   GPIO_ACCESS, 32 
+#define GPxBLINK(port)  (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + 0x30),   GPIO_ACCESS, 32 
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Multiple registers for each port in a single module                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPxCFG0(port)   (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + GPIO_RegOffset[0][GPIO_PORT_IN_MODULE(port)]), GPIO_ACCESS, 32
+#define GPxCFG1(port)   (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + GPIO_RegOffset[1][GPIO_PORT_IN_MODULE(port)]), GPIO_ACCESS, 32
+#define GPxCFG2(port)   (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + GPIO_RegOffset[2][GPIO_PORT_IN_MODULE(port)]), GPIO_ACCESS, 32
+#define GPxDOUT(port)   (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + GPIO_RegOffset[3][GPIO_PORT_IN_MODULE(port)]), GPIO_ACCESS, 32
+#define GPxDIN(port)    (GPIO_BASE_ADDR(GPIO_PORT_TO_MODULE(port)) + GPIO_RegOffset[4][GPIO_PORT_IN_MODULE(port)]), GPIO_ACCESS, 32
+
+#endif // _GPIO_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.c b/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.c
new file mode 100755
index 0000000..ac1ddd9
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.c
@@ -0,0 +1,23 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gpio_if.c                                                                                             */
+/*            This file contains GPIO module driver selector                                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(GPIO_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(gpio, GPIO_MODULE_TYPE)
+#endif    
+  
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.h b/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.h
new file mode 100755
index 0000000..93addcc
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/gpio/gpio_if.h
@@ -0,0 +1,450 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   gpio_if.h                                                                                             */
+/*            This file contains GPIO driver interface                                                     */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _GPIO_IF_H
+#define _GPIO_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                  TYPES                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Input related types                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+  GPIO_EVENT_RISING_EDGE,
+  GPIO_EVENT_FALLING_EDGE,
+  GPIO_EVENT_HIGH_LEVEL,
+  GPIO_EVENT_LOW_LEVEL,
+} GPIO_EVENT_T;
+
+typedef void (*GPIO_EVEN_HANDLE_T)(void* args);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Output related types                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    GPIO_OUTPUT_PUSH_PULL,
+    GPIO_OUTPUT_OPEN_DRAIN,
+} GPIO_OUTPUT_T;
+
+
+typedef enum
+{
+    GPIO_BLINK_OFF          = 0x0,
+    GPIO_BLINK_0_5_to_1     = 0x1,
+    GPIO_BLINK_1_to_2       = 0x2,
+    GPIO_BLINK_1_to_4       = 0x3,
+    GPIO_BLINK_0_25_to_0_5  = 0x4,
+    GPIO_BLINK_0_25_to_1    = 0x5,
+    GPIO_BLINK_3_to_4       = 0x6,
+    GPIO_BLINK_0_75_to_1    = 0x7,
+} GPIO_BLINK_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Muxing related types                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    UINT position;
+    UINT size;
+    UINT value;
+} GPIO_MUX_FIELD_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                               GPIO TABLES                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* GPIO Table entry description:                                                                           */
+/* -----------------------------                                                                           */
+/* GPIO Table contains entries, 64 bit each, that contain information about GPIO port and bit ID,          */
+/* GPIO capabilities (INPUT/OUTPUT/EVENT SUPPORT/HW DEBOUNCE/BLINKING) and muxing                          */
+/*                                                                                                         */
+/* Lower 32bit word decription:                                                                            */
+/*                                                                                                         */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/* |              |            GPIO CAPABILITIES                     |      GPIO ID      |                 */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/* |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|                 */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | | | | | |                  */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | +-+-+-+-+---- Port Number  */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | |                            */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | +-+-+-+-+-------------- Bit Number   */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                      */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +-------------- Input Capability       */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                         */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +----------------- Output Capability      */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                            */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  +--+--+--+--+--+-------------------- Event Cap. Field       */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |                                                              */
+/*   |  |  |  |  |  |  |  |  +--+--+--+--+--+-------------------------------------- HW Debounce Cap. Field */
+/*   |  |  |  |  |  |  |  |                                                                                */
+/*   |  |  +--+--+--+--+--+-------------------------------------------------------- Blinking Cap. Field    */
+/*   |  |                                                                                                  */
+/*   +--+-------------------------------------------------------------------------- RESERVERD              */
+/*                                                                                                         */
+/* Upper 32bit word description:                                                                           */
+/*                                                                                                         */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/* |RSRVD|                  MUX 2                     |              MUX 1               |                 */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/* |31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|                 */
+/* +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-+-+-+-+-+-+-+-+-+-+                 */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | | | | | |                  */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | | +-+-+-+-- Mux Reg1 ID    */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | |                          */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | | | | | |                          */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | | +-+-+-+-+---------- Field 1 Pos    */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | |                                    */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +--+-+-------------------- Field 1 Size   */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                            */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  +--+--+---------------------------- Field 1 Val    */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                                     */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |                                                     */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |  +--+--+--+------------------------------------- Mux Reg2 ID    */
+/*   |  |  |  |  |  |  |  |  |  |  |  |  |                                                                 */
+/*   |  |  |  |  |  |  |  |  +--+--+--+--+------------------------------------------------- Field 2 Pos    */
+/*   |  |  |  |  |  |  |  |                                                                                */
+/*   |  |  |  |  |  +--+--+---------------------------------------------------------------- Field 2 Size   */
+/*   |  |  |  |  |                                                                                         */
+/*   |  |  +--+--+------------------------------------------------------------------------- Field 2 Val    */
+/*   |  |                                                                                                  */
+/*   |  |                                                                                                  */
+/*   +--+---------------------------------------------------------------------------------- RESERVED       */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Fields Description:                                                                                     */
+/* -------------------                                                                                     */
+/* Port number              - Number of the port of the specified GPIO                                     */
+/*                                                                                                         */
+/* Bit number               - Number of the bit in the port of the specified GPIO                          */
+/*                                                                                                         */
+/* Input Capability Bit     - Mark if the GPIO is capable to receive input                                 */
+/*                                                                                                         */
+/* Output Capability Bit    - Mark if the GPIO capable of transmit output                                  */
+/*                                                                                                         */
+/* Event Cap. Field         - Position in EVENT register if GPIO is event generation capable               */
+/*                            (if not capable the field is filled with 1)                                  */
+/*                                                                                                         */
+/* HW Debounce Cap. Field   - Position in Debounce register if GPIO is debounce capable                    */
+/*                            (if not capable the field is filled with 1)                                  */
+/*                                                                                                         */
+/* Blinking Cap. Field      - Position in BLINK register if GPIO is blinking capable                       */
+/*                            (if not capable the field is filled with 1)                                  */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Mux Reg ID               - Number of MFSEL register that mux the current GPIO                           */
+/*                            (if no muxing needed the field is filled with 0)                             */
+/*                                                                                                         */
+/* Mux Field 1 Pos          - Position of the first field in the MFSEL register that sets the mux          */
+/*                                                                                                         */
+/* Mux Field 1 Size         - Size of the first field                                                      */
+/*                            (if no muxing set the size should be 0)                                      */
+/*                                                                                                         */
+/* Mux Field 1 Value1       - Value of the first field that muxes the GPIO                                 */
+/*                                                                                                         */
+/* Mux Field 2 Pos          - Position of the second field in the MFSEL register that sets the mux         */
+/*                                                                                                         */
+/* Mux Field 2 Size         - Size of the second field                                                     */
+/*                            (if no additional muxing set the size should be 0)                           */
+/*                                                                                                         */
+/* Mux Field 2 Value1       - Value of the second field that muxes the GPIO                                */
+/*                                                                                                         */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           GPIO TABLE RELATED                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Entry type                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    UINT32  id;        // Lower word contain GPIO ID and Capabilities
+    UINT32  mux;       // Upper word contain muxing information
+} GPIO_TABLE_ENTRY_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Table Fields description                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_TABLE_ID_PORT_NUM          0, 5
+#define GPIO_TABLE_ID_PORT_BIT          5, 5
+#define GPIO_TABLE_CAP_INPUT_BIT       10, 1
+#define GPIO_TABLE_CAP_OUTPUT_BIT      11, 1
+#define GPIO_TABLE_CAP_EVENT_FIELD     12, 5
+#define GPIO_TABLE_CAP_DEB_FIELD       17, 5
+#define GPIO_TABLE_CAP_BLINK_FIELD     22, 5
+
+
+#define GPIO_TABLE_MUX_REGID1           0, 4
+#define GPIO_TABLE_MUX_FIELD1_POS       4, 5
+#define GPIO_TABLE_MUX_FIELD1_SIZE      9, 3
+#define GPIO_TABLE_MUX_FIELD1_VAL      12, 3
+#define GPIO_TABLE_MUX_REGID2          15, 4
+#define GPIO_TABLE_MUX_FIELD2_POS      19, 5
+#define GPIO_TABLE_MUX_FIELD2_SIZE     24, 3
+#define GPIO_TABLE_MUX_FIELD2_VAL      27, 3
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Table entry creation macro                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_TABLE_ENTRY(port, port_bit, cap_in, cap_out, cap_event, cap_db, cap_blink, mux_reg1, mux_field1_p, mux_field1_s, mux_field1_val, mux_reg2, mux_field2_p, mux_field2_s, mux_field2_val)    \
+        {                                                                                                   \
+             (  BUILD_FIELD_VAL(GPIO_TABLE_ID_PORT_NUM,         port                )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_ID_PORT_BIT,         port_bit            )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_CAP_INPUT_BIT,       cap_in              )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_CAP_OUTPUT_BIT,      cap_out             )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_CAP_EVENT_FIELD,     cap_event           )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_CAP_DEB_FIELD,       cap_db              )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_CAP_BLINK_FIELD,     cap_blink           ) ),                    \
+                                                                                                            \
+             (  BUILD_FIELD_VAL(GPIO_TABLE_MUX_REGID1,          mux_reg1            )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD1_POS,      mux_field1_p        )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD1_SIZE,     mux_field1_s        )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD1_VAL,      mux_field1_val      )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_REGID2,          mux_reg2            )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD2_POS,      mux_field2_p        )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD2_SIZE,     mux_field2_s        )   |                   \
+                BUILD_FIELD_VAL(GPIO_TABLE_MUX_FIELD2_VAL,      mux_field2_val      ) )                     \
+        }
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Capabilities                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define     GPIO_CAP_INPUT          1
+#define     GPIO_CAP_NO_INPUT       0
+
+#define     GPIO_CAP_OUTPUT         1
+#define     GPIO_CAP_NO_OUTPUT      0
+
+#define     GPIO_CAP_EVENT(x)       (x)
+#define     GPIO_CAP_NO_EVENT       0x3F
+
+#define     GPIO_CAP_BLINK(x)       (x)
+#define     GPIO_CAP_NO_BLINK       0x3F
+
+#define     GPIO_CAP_DEBOUNCE(x)    (x)
+#define     GPIO_CAP_NO_DEBOUNCE    0x3F
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* GPIO Mux Register ID                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    GPIO_MUX_REGID_NONE     = 0,
+    GPIO_MUX_REGID_MFSL1    = 1,
+    GPIO_MUX_REGID_MFSL2    = 2,
+    GPIO_MUX_REGID_MFSL3    = 3,
+    GPIO_MUX_REGID_MFSL4    = 4,
+    GPIO_MUX_REGID_MFSL5    = 5,
+    GPIO_MUX_REGID_MFSL6    = 6,
+    GPIO_MUX_REGID_MFSL7    = 7,
+} GPIO_MUX_REGID_T;
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           FUNCTIONS INTERFACE                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* End of GPIO argument list marker                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIO_END_OF_ARG_LIST        -1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defines group of GPIOs (1 or more) that should be passed to variadic interface functions                */
+/* that can handle multiple GPIO numbers                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GPIOS(gpios...)         gpios, GPIO_END_OF_ARG_LIST
+
+
+
+HAL_STATUS GPIO_Init(void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureInput                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  handler             - Handler function for GPIO event                                  */
+/*                  handler_args        - Handler function argument                                        */
+/*                  event_type          - Event type (Raising/Falling edge, High/Low level)                */
+/*                  debounce            - Enable HW debounce                                               */
+/*                  internal_resistor   - Enable internal Pull-Up/Down                                     */
+/*                  gpio_num            - One or more GPIO number(s) to configure                          */
+/*                                        SHOULD BE SET USING 'GPIOS' macro                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures one or more GPIOs to input                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_ConfigureInput( GPIO_EVEN_HANDLE_T  handler,
+                                void*               handler_args,
+                                GPIO_EVENT_T        event_type,
+                                BOOLEAN             debounce,
+                                BOOLEAN             internal_resistor,
+                                UINT                gpio_num, ... );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_ConfigureOutput                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  type     -  Output type (Push Pull/ Open Drain)                                        */
+/*                  gpio_num -  One or more GPIO number(s) to configure                                    */
+/*                              SHOULD BE SET USING 'GPIOS' macro                                          */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures one or more GPIOs to output                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_ConfigureOutput(GPIO_OUTPUT_T type, BOOLEAN init_val, UINT gpio_num, ... );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Blink                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  type     - Blinking timing configuration                                               */
+/*                  gpio_num - One or more GPIO number(s) to configure                                     */
+/*                             SHOULD BE SET USING 'GPIOS' macro                                           */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets one or more GPIOs to start blinking.                                 */
+/*                  The given GPIOs must be configured to Output                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Blink(GPIO_BLINK_T type, UINT gpio_num, ... );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Write                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  value    - Value of the GPIO(s) to set                                                 */
+/*                  gpio_num - One or more GPIO number(s) to configure                                     */
+/*                             SHOULD BE SET USING 'GPIOS' macro                                           */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set value of one or more GPIOs.                                           */
+/*                  The given GPIOs must be configured to Output                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Write(BOOLEAN value, UINT gpio_num, ... );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Read                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num - GPIO number to read the value from                                          */
+/*                                                                                                         */
+/* Returns:         Value of the given GPIO number                                                         */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads value of given GPIO                                                 */
+/*                  The given GPIOs must be configured to Input                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN GPIO_Read(UINT gpio_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_GetMuxInfo                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num        - Number of given GPIO                                                 */
+/*                  mux_regid1      - ID of the first muxing register                                      */
+/*                  mux_field1      - Muxing info of the first register                                    */
+/*                  mux_regid2      - ID of the second muxing register                                     */
+/*                  mux_field2      - Muxing info of the second register                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:    none                                                                                   */
+/* Description:                                                                                            */
+/*                  This routine returns muxing information for given GPIO                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_GetMuxInfo( UINT                gpio_num,
+                            GPIO_MUX_REGID_T*   mux_regid1,
+                            GPIO_MUX_FIELD_T*   mux_field1,
+                            GPIO_MUX_REGID_T*   mux_regid2,
+                            GPIO_MUX_FIELD_T*   mux_field2  );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_GetGPIOInfo                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gpio_num -                                                                             */
+/*                  port_bit -                                                                             */
+/*                  port_num -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns GPIO information                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_GetGPIOInfo(UINT gpio_num, UINT* port_num, UINT* port_bit);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GPIO_Isr                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  arg -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GPIO IRQ handling                                                */
+/*                  It should be called as a handler for all GPIO interrupts                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS GPIO_Isr(UINT32 arg);
+
+#endif //_GPIO_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/mc/mc_if.h b/board/nuvoton/common/BMC_HAL/Modules/mc/mc_if.h
new file mode 100755
index 0000000..976c285
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/mc/mc_if.h
@@ -0,0 +1,146 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   mc_if.h                                                                                               */
+/*            This file contains MC module interface                                                       */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _MC_IF_H
+#define _MC_IF_H
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                 INCLUDES                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#include "defs.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Priority type                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    MC_PRIO_HIGH,
+    MC_PRIO_MIDDLE,
+    MC_PRIO_LOW,
+} MC_PRIO_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_ConfigureDDR                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         status                                                                                 */
+/* Side effects:    none                                                                                   */
+/* Description:                                                                                            */
+/*                  Set default configuration for the  DDR Memory Controller                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS MC_ConfigureDDR (int iteration);
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_SetPortPriority                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  portNum     - Number of the Memory port to set the priority to                         */
+/*                  fixedPrio   - Indicates if to set fixed priority or auto priority                      */
+/*                  priority    - In fixed mode, setting fixed priority                                    */
+/*                                In auto mode, setting initial priority                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine priority configuration for Memory controller ports                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_SetPortPriority (UINT portNum, BOOLEAN fixedPrio, MC_PRIO_T priority);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_ReconfigureODT                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Transfers the PCTL to CFG state, writes to ODTCFG register and                         */
+/*                  returns to ACTIVE state.                                                               */
+/*                  Assumes: PCTL has already been configured.                                             */
+/*                  This function serves the Booter to bypass Z1 ROM configuration issue.                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_ReconfigureODT (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_EnableCoherency                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enables the Coherency Reorder feature in Memory Controller                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_EnableCoherency (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_UpdateDramSize                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Update refresh rate according to size                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_UpdateDramSize (UINT iDramSize);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_CheckDramSize                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  measure the DRAM size                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 MC_CheckDramSize (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_PrintRegs                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module registers                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_PrintRegs (void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        MC_PrintVersion                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module version                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void MC_PrintVersion (void);
+
+
+#endif //_MC_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/pspi/pspi_if.h b/board/nuvoton/common/BMC_HAL/Modules/pspi/pspi_if.h
new file mode 100755
index 0000000..5da2dbe
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/pspi/pspi_if.h
@@ -0,0 +1,101 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   pspi_if.h                                                                                             */
+/*            This file contains Peripheral SPI interface                                                  */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _PSPI_IF_H
+#define _PSPI_IF_H
+
+#include "../../Common/hal_error.h"
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* PSPI Devices                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    PSPI1_DEV = 0,
+    PSPI2_DEV = 1,
+} PSPI_DEV_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Data transfer modes                                                                                     */
+/* Either output data is written on rising edge and input data read on falling edge or vise versa          */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    PSPI_WRITE_RISING_EDGE,
+    PSPI_WRITE_FALLING_EDGE,
+} PSPI_TRANSFER_MODE;
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        PSPI_Init                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - number of PSPI device                                                    */
+/*                  mode        - Data shifting mode                                                       */
+/*                  clockFreq   - Data shifting clock                                                      */
+/*                                                                                                         */
+/* Returns:         Returns HAL_OK on success or ERROR CODE on failure                                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PSPI module initialization                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS PSPI_Init(PSPI_DEV_T devNum, PSPI_TRANSFER_MODE mode, UINT32 clockFreq);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        PSPI_Transfer                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - number of PSPI device                                                    */
+/*                  csGpio      - GPIO number of the Chip Select                                           */
+/*                  writeBuf    - Buffer for sending                                                       */
+/*                  readBuf     - Buffer for receiving                                                     */
+/*                  size        - Buffers size (both buffers must have the same size                       */
+/*                                                                                                         */
+/* Returns:         HAL_OK on success or HAL_ERROR_* or error                                              */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SPI tranfer.                                                     */
+/*                  Each clock cycle 1 bit from writeBuf is written out and 1 bit is read into the         */
+/*                  readBuf.                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS PSPI_Transfer (PSPI_DEV_T devNum, UINT csGpio, UINT8* writeBuf, UINT8* readBuf, UINT size);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        PSPI_WriteRead                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum      - number of PSPI device                                                    */
+/*                  csGpio      - GPIO number of the Chip Select                                           */
+/*                  writeBuf    - Buffer for sending                                                       */
+/*                  writeSize   - sending buffer size                                                      */
+/*                  readBuf     - Buffer for reading                                                       */
+/*                  readSize    - sending buffer size                                                      */
+/*                                                                                                         */
+/* Returns:         HAL_OK on success or HAL_ERROR_* or error                                              */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine first writes a data on the SPI bus (from writeBuf) and then reads the     */
+/*                  data from the SPI bus into the readBuf                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS PSPI_WriteRead(PSPI_DEV_T devNum, UINT csGpio, UINT8* writeBuf,  UINT writeSize, UINT8* readBuf, UINT readSize);
+
+
+
+#endif //_PSPI_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sd/sd_if.h b/board/nuvoton/common/BMC_HAL/Modules/sd/sd_if.h
new file mode 100755
index 0000000..0066f8d
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sd/sd_if.h
@@ -0,0 +1,232 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sd_if.h                                                                                               */
+/*            This file contains SD driver interface                                                       */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef SD_IF_H
+#define SD_IF_H
+
+#include "defs.h"
+#include "../timer/timer_if.h"
+#include "../../Common/hal_error.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD device definitions                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    SD1_DEV = 0,
+    SD2_DEV = 1,
+} SD_DEV_NUM_T;
+
+typedef enum
+{
+    SD_DEV_SD  = 0,
+    SD_DEV_MMC = 1,
+    SD_DEV_MMC8 = 2,
+} SD_DEV_TYPE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD block definitions                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SD_SECTOR_SIZE          512
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD clock configurations definitions                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/* Clock frequency type */
+typedef enum
+{
+    SD_CLK_400_KHZ = (400 * _1KHz_),    /* 400  KHz */
+    SD_CLK_20_MHZ  = (20  * _1MHz_),    /* 20   MHz */
+    SD_CLK_25_MHZ  = (25  * _1MHz_),    /* 25   MHz */
+    SD_CLK_50_MHZ  = (50  * _1MHz_),    /* 50   MHz */
+} SD_CLK_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD function definitions                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_Init                                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum   - [in], SD device number                                                         */
+/*               devType  - [in], SD1 device type (SD or MMC)                                              */
+/*               timerNum - [in], Timer device number                                                      */
+/*                                                                                                         */
+/* Returns:      Flash Card Error Code                                                                     */
+/* Side effects: None                                                                                      */
+/* Description:                                                                                            */
+/*               This routine initializes the SD HW module and SW driver without                           */
+/*               accessing the card (no card initialization)                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_Init (SD_DEV_NUM_T devNum, SD_DEV_TYPE_T devType, TIMER_DEV_T timerNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_InitializeCard                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum   - [in], SD device number                                                         */
+/*                                                                                                         */
+/* Returns:      BMC HAL Error Code                                                                        */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*               This routine performs SD/MMC card identification process,                                 */
+/*               as defined by the SD and MMC System Specifications, chapter 4.2.3.                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_InitializeCard (SD_DEV_NUM_T devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SD_ReadDataBuf                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - [in], SD device number                                                        */
+/*                                                                                                         */
+/* Returns:         SD data buffer contents                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads SD Buffer (32-bit) Data Port.                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 SD_ReadDataBuf (SD_DEV_NUM_T devNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SD_BufferReadEnabled                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - [in], SD device number                                                        */
+/*                                                                                                         */
+/* Returns:         TRUE if read buffer is enabled, FALSE otherwise                                        */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks whether SD buffer read is enabled.                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN SD_BufferReadEnabled (SD_DEV_NUM_T devNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SD_EmptyFifoBuffer                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -   [in], SD device number                                                      */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Reads and discards the data from fifo buffer until no more data is available           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_EmptyFifoBuffer(SD_DEV_NUM_T devNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_ReadDataBlocks                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum     - [in], SD device number                                                       */
+/*               deviceAddr - [in], data address in device to read from                                    */
+/*               memoryAddr - [out], buffer to read data into                                              */
+/*               count      - [in], number of bytes to read                                                */
+/*               bUseDMA    - [in], TRUE to use DMA, FALSE to use uC                                       */
+/*                                                                                                         */
+/* Returns:      Flash Card Error Code                                                                     */
+/* Side effects: If 'bUseDMA' is TRUE, SD DMA ia used.                                                     */
+/* Description:                                                                                            */
+/*               This routine reads contiguous data blocks from the SD card.                               */
+/*               If the DMA is in use, READ_MULTIPLE_BLOCK command is initiated by the micro-controller,   */
+/*               transaction is stopped automatically by DMA, and data is read into 'memoryAddr'.          */
+/*               If DMA is not used, the uC reads the data into 'memoryAddr'.                              */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_ReadDataBlocks (SD_DEV_NUM_T devNum, UINT32 SrcAddr, UINT8* DstAddr, UINT32 cnt, BOOLEAN bUseDMA);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_WriteDataBlocks                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum     - [in], SD device number                                                       */
+/*               deviceAddr - [in], data address in device to read from                                    */
+/*               memoryAddr - [out], buffer to read data into                                              */
+/*               count      - [in], number of bytes to read                                                */
+/*               bUseDMA    - [in], TRUE to use DMA, FALSE to use uC                                       */
+/*                                                                                                         */
+/* Returns:      Flash Card Error Code                                                                     */
+/* Side effects: If 'bUseDMA' is TRUE, SD DMA ia used.                                                     */
+/* Description:                                                                                            */
+/*               This routine writes contiguous data blocks to the SD card.                                */
+/*               If the DMA is in use, WRITE_MULTIPLE_BLOCK command is initiated by the micro-controller,  */
+/*               transaction is stopped automatically by DMA, data is written into the SD card memory.     */
+/*               If DMA is not used, the uC writes the data from 'memoryAddr'.                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_WriteDataBlocks (SD_DEV_NUM_T devNum, UINT32 SrcAddr, UINT8* DstAddr, UINT32 cnt, BOOLEAN bUseDMA);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_SetClock                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum   - [in], SD device number                                                         */
+/*               clk      - [in], Target clock frequency (in Hz units)                                     */
+/*                                                                                                         */
+/* Returns:      Flash Card Error Code                                                                     */
+/* Side effects: None                                                                                      */
+/* Description:                                                                                            */
+/*               This routine sets the clock frequency by adjusting the                                    */
+/*               SDCLK Frequency Select using the Base Clock Frequency For SD Clock.                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_SetClock (SD_DEV_NUM_T devNum, SD_CLK_T clk);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SD_CardPowerOn                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -  SD device number                                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enables the clock to the card and powers on the card if implemented on the board       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_CardPowerOn(SD_DEV_NUM_T devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SD_CardPowerOff                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -  SD device number                                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Disables the clock to the card and powers off the card if implemented on the board     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_CardPowerOff(SD_DEV_NUM_T devNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:     SD_Isr                                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*               devNum   - [in], SD device number                                                         */
+/*                                                                                                         */
+/* Returns:      BMC HAL Error Code                                                                        */
+/* Side effects: None                                                                                      */
+/* Description:                                                                                            */
+/*               SD interrupt service routine. The handler covers the following sources:                   */
+/*                1) Normal Interrupt Status.                                                              */
+/*                2) Error Interrupt Status.                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SD_Isr (UINT32 devNum);
+
+#endif /* SD_IF_H */
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.c b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.c
new file mode 100755
index 0000000..71b2d46
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.c
@@ -0,0 +1,861 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2013-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sha_drv.c                                                                                             */
+/*            This file contains SHA driver implementation                                                 */
+/* Project:                                                                                                */
+/*            SWC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                INCLUDES                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../../Chips/chip.h"
+
+#ifndef NO_LIBC
+#include <string.h>
+#endif
+
+#include "sha_drv.h"
+#include "sha_regs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           TYPES & DEFINITIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define SHA_SECRUN_BUFF_SIZE            64
+#define SHA_TIMEOUT                     100
+#define SHA_DATA_LAST_BYTE              0x80
+#define SHA_SET_TYPE(type)              SET_REG_FIELD(HASH_CFG, HASH_CFG_SHA1_SHA2, type)
+#ifdef SHA_SELF_TEST
+#define SHA2_NUM_OF_SELF_TESTS          3
+#define SHA1_NUM_OF_SELF_TESTS          4
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_BUFF_POS                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  length - number of bytes written                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine compute the # of bytes currently in the sha block buffer                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_BUFF_POS(length)            (length & (SHA_BLOCK_LENGTH - 1))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_BUFF_FREE                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  length - number of bytes written                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine compute the # of free bytes in the sha block buffer                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_BUFF_FREE(length)           (SHA_BLOCK_LENGTH - SHA_BUFF_POS(length))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_RET_CHECK                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks if give function returns HAL_STATUS error, and returns the error    */
+/*                  immediately after SHA disabling                                                        */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_RET_CHECK(func)                                         \
+{                                                                   \
+    HAL_STATUS status;                                             \
+                                                                    \
+    if ((status = func) != DEFS_STATUS_OK)                          \
+    {                                                               \
+       DEFS_STATUS_RET_CHECK(SHA_Power(FALSE));                     \
+       return status;                                               \
+    }                                                               \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       LOCAL FUNCTIONS DECLARATION                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+static void                             SHA_FlushLocalBuffer_l (const UINT32* buff);
+static HAL_STATUS                      SHA_BusyWait_l(void);
+static void                             SHA_GetShaDigest_l(UINT8* hashDigest, SHA_TYPE_T shaType);
+static void                             SHA_SetShaDigest_l(const UINT32* hashDigest, SHA_TYPE_T shaType);
+static void                             SHA_SetBlock_l(const UINT8* data,UINT32 len, UINT16 position, UINT32* block);
+static void                             SHA_ClearBlock_l(UINT16 len, UINT16 position, UINT32* block);
+static void                             SHA_SetLength32_l(const SHA_HANDLE_T* handlePtr, UINT32* block);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           INTERFACE FUNCTIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Calc                                                                               */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/*                  inBuff -    Pointer to a buffer containing the data to be hashed                       */
+/*                  len -    Length of the data to hash                                                    */
+/*                  hashDigest -   Pointer to a buffer where the reseulting digest will be copied to       */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs complete SHA calculation in one step                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Calc (
+    SHA_TYPE_T shaType,
+    const UINT8* inBuff,
+    UINT32 len,
+    UINT8* hashDigest
+)
+{
+    SHA_HANDLE_T handle;
+
+    DEFS_STATUS_RET_CHECK(SHA_Init(&handle));
+    DEFS_STATUS_RET_CHECK(SHA_Power(TRUE));
+    SHA_RET_CHECK(SHA_Reset());
+    SHA_RET_CHECK(SHA_Start(&handle, shaType));
+    SHA_RET_CHECK(SHA_Update(&handle, inBuff, len));
+    SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+    DEFS_STATUS_RET_CHECK(SHA_Power(FALSE));
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:      handlePtr - SHA processing handle pointer                                              */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialize the SHA module                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Init (SHA_HANDLE_T* handlePtr)
+{
+    handlePtr->active = FALSE;
+
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Start                                                                              */
+/*                                                                                                         */
+/* Parameters:      handlePtr   - SHA processing handle pointer                                            */
+/*                  shaType     - SHA module type                                                          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine start a single SHA process                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Start (
+    SHA_HANDLE_T* handlePtr,
+    SHA_TYPE_T shaType
+)
+{
+    UINT16 l;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initialize handle                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    handlePtr->length0 = 0;
+    handlePtr->length1 = 0;
+    handlePtr->shaType = shaType;
+    handlePtr->active = TRUE;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset SHA hardware                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(HASH_CTR_STS, HASH_CTR_STS_SHA_RST, 0x01);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The handlePtr->hv is initialized with the correct IV as the SHA engine automaticly                  */
+    /* fill the HASH_DIG_Hn registers according to SHA spec (following SHA_RST assertion)                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l((UINT8*)handlePtr->hv, shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Init block with zeros                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(l = 0 ; l < (SHA_BLOCK_LENGTH / sizeof(UINT32)); l++)
+    {
+        handlePtr->block[l] = 0;
+    }
+
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Update                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  buffer -   Pointer to the data that will be added to the hash calculation              */
+/*                  len -      Length of data to add to SHA calculation                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine adds data to previously started SHA calculation                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Update (
+    SHA_HANDLE_T* handlePtr,
+    const UINT8* buffer,
+    UINT32 len
+)
+{
+    UINT32 localBuffer[SHA_SECRUN_BUFF_SIZE / sizeof(UINT32)];
+    UINT32 bufferLen          = len;
+    UINT16 pos                = 0;
+    UINT8* blockPtr;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error check                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_COND_CHECK(handlePtr->active == TRUE, DEFS_STATUS_SYSTEM_NOT_INITIALIZED);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set SHA type                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SET_TYPE(handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Write SHA latest digest into SHA module                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetShaDigest_l(handlePtr->hv, handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set number of unhashed bytes which remained from last update                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    pos = SHA_BUFF_POS(handlePtr->length0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Copy unhashed bytes which remained from last update to secrun buffer                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l((UINT8*)handlePtr->block, pos, 0, localBuffer);
+
+    while (len)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Wait for the hardware to be available (in case we are hashing)                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Move as much bytes  as we can into the secrun buffer                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        bufferLen = MIN(len, SHA_BUFF_FREE(handlePtr->length0));
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Copy current given buffer to the secrun buffer                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_SetBlock_l((UINT8*)buffer, bufferLen, pos, localBuffer);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update size of hashed bytes                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        handlePtr->length0 += bufferLen;
+
+        if ((handlePtr->length0) < bufferLen)
+        {
+            handlePtr->length1++;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update length of data left to digest                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        len -= bufferLen;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update given buffer pointer                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        buffer += bufferLen;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If secrun buffer is full                                                                        */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (SHA_BUFF_POS(handlePtr->length0) == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* We just filled up the buffer perfectly, so let it hash                                      */
+            /* (we'll unload the hash only when we are done with all hashing)                              */
+            /*---------------------------------------------------------------------------------------------*/
+            SHA_FlushLocalBuffer_l(localBuffer);
+
+            pos = 0;
+            bufferLen = 0;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Copy unhashed bytes from given buffer to handle block for next update/finish                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    blockPtr = (UINT8*)handlePtr->block;
+    while (bufferLen)
+    {
+        blockPtr[--bufferLen+pos] = *(--buffer);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Save SHA current digest                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l((UINT8*)handlePtr->hv, handlePtr->shaType);
+
+    return DEFS_STATUS_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Finish                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  hashDigest -     Pointer to a buffer where the final digest will be copied to          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine finish SHA calculation and get the resulting SHA digest                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Finish (
+    SHA_HANDLE_T* handlePtr,
+    UINT8* hashDigest
+
+)
+{
+    UINT32 localBuffer[SHA_SECRUN_BUFF_SIZE / sizeof(UINT32)];
+    const UINT8 lastbyte = SHA_DATA_LAST_BYTE;
+    UINT16 pos;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error check                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_COND_CHECK(handlePtr->active == TRUE, DEFS_STATUS_SYSTEM_NOT_INITIALIZED);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set SHA type                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SET_TYPE(handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Finish off the current buffer with the SHA spec'ed padding                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    pos = SHA_BUFF_POS(handlePtr->length0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Init SHA digest                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetShaDigest_l(handlePtr->hv, handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Load data into secrun buffer                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l((UINT8*)handlePtr->block, pos, 0, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set data last byte as in SHA algorithm spec                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l(&lastbyte, 1, pos++, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If the remainder of data is longer then one block                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (pos > (SHA_BLOCK_LENGTH - 8))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* The message length will be in the next block                                                    */
+        /* Pad the rest of the last block with 0's                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_ClearBlock_l((SHA_BLOCK_LENGTH - pos), pos, localBuffer);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Hash the current block                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_FlushLocalBuffer_l(localBuffer);
+
+        pos = 0;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Wait till SHA is not busy                                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Pad the rest of the last block with 0's except for the last 8-3 bytes                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_ClearBlock_l((SHA_BLOCK_LENGTH-(8-3))-pos, pos, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The last 8-3 bytes are set to the bit-length of the message in big-endian form                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetLength32_l(handlePtr, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Hash all that, and save the hash for the caller                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_FlushLocalBuffer_l(localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Save SHA final digest into given buffer                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l(hashDigest, handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Free handle                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    handlePtr->active = FALSE;
+
+    return DEFS_STATUS_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reset SHA module                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Reset (void)
+{
+    SET_REG_FIELD(HASH_CTR_STS, HASH_CTR_STS_SHA_RST, 0x01);
+
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Power                                                                              */
+/*                                                                                                         */
+/* Parameters:      on - TRUE enable the module, FALSE disable the module                                  */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set SHA module power on/off                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Power (BOOLEAN on)
+{
+    SET_REG_FIELD(HASH_CTR_STS, HASH_CTR_STS_SHA_EN, on);
+
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintRegs                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module registers                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintRegs (void)
+{
+    UINT i;
+
+    HAL_PRINT("/*--------------*/\n");
+    HAL_PRINT("/*     SHA      */\n");
+    HAL_PRINT("/*--------------*/\n\n");
+
+    HAL_PRINT("HASH_CTR_STS        = 0x%02X\n", REG_READ(HASH_CTR_STS));
+    HAL_PRINT("HASH_CFG            = 0x%02X\n", REG_READ(HASH_CFG));
+
+    for (i = 0; i < HASH_DIG_H_NUM; i++)
+    {
+        HAL_PRINT("HASH_DIG_H%d         = 0x%08X\n", i, REG_READ(HASH_DIG_H(i)));
+    }
+
+    HAL_PRINT("\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintVersion                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module version                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintVersion (void)
+{
+    HAL_PRINT("SHA         = %d\n", SHA_MODULE_TYPE);
+}
+
+#ifdef SHA_SELF_TEST
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SelfTest                                                                           */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs various tests on the SHA HW and SW                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_SelfTest (SHA_TYPE_T shaType)
+{
+    SHA_HANDLE_T handle;
+    UINT8 hashDigest[MAX(SHA_1_HASH_LENGTH, SHA_2_HASH_LENGTH)];
+    UINT8 i;
+    UINT16 j;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA1 tests info                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    static const UINT8 sha1SelfTestBuff[SHA1_NUM_OF_SELF_TESTS][94] =
+    {
+        {"abc"},
+        {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"},
+        {"0123456789012345678901234567890123456789012345678901234567890123"},
+        {0x30, 0x5c, 0x30, 0x2c, 0x02, 0x01, 0x00, 0x30, 0x09, 0x06, 0x05, 0x2b,
+         0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x30, 0x06, 0x06, 0x04, 0x67, 0x2a,
+         0x01, 0x0c, 0x04, 0x14, 0xe1, 0xb6, 0x93, 0xfe, 0x33, 0x43, 0xc1, 0x20,
+         0x5d, 0x4b, 0xaa, 0xb8, 0x63, 0xfb, 0xcf, 0x6c, 0x46, 0x1e, 0x88, 0x04,
+         0x30, 0x2c, 0x02, 0x01, 0x00, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03,
+         0x02, 0x1a, 0x05, 0x00, 0x30, 0x06, 0x06, 0x04, 0x67, 0x2a, 0x01, 0x0c,
+         0x04, 0x14, 0x13, 0xc1, 0x0c, 0xfc, 0xc8, 0x92, 0xd7, 0xde, 0x07, 0x1c,
+         0x40, 0xde, 0x4f, 0xcd, 0x07, 0x5b, 0x68, 0x20, 0x5a, 0x6c}
+    };
+
+    static const UINT8 sha1SelfTestBuffLen[SHA1_NUM_OF_SELF_TESTS] =
+    {
+        3, 56, 64, 94
+    };
+    static const UINT8 sha1SelfTestExpRes[SHA1_NUM_OF_SELF_TESTS][SHA_1_HASH_LENGTH] =
+    {
+        {0xA9, 0x99, 0x3E, 0x36,
+         0x47, 0x06, 0x81, 0x6A,
+         0xBA, 0x3E, 0x25, 0x71,
+         0x78, 0x50, 0xC2, 0x6C,
+         0x9C, 0xD0, 0xD8, 0x9D},
+        {0x84, 0x98, 0x3E, 0x44,
+         0x1C, 0x3B, 0xD2, 0x6E,
+         0xBA, 0xAE, 0x4A, 0xA1,
+         0xF9, 0x51, 0x29, 0xE5,
+         0xE5, 0x46, 0x70, 0xF1},
+        {0xCF, 0x08, 0x00, 0xF7,
+         0x64, 0x4A, 0xCE, 0x3C,
+         0xB4, 0xC3, 0xFA, 0x33,
+         0x38, 0x8D, 0x3B, 0xA0,
+         0xEA, 0x3C, 0x8B, 0x6E},
+        {0xc9, 0x84, 0x45, 0xc8,
+         0x64, 0x04, 0xb1, 0xe3,
+         0x3c, 0x6b, 0x0a, 0x8c,
+         0x8b, 0x80, 0x94, 0xfc,
+         0xf3, 0xc9, 0x98, 0xab}
+    };
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA2 tests info                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    static const UINT8 sha2SelfTestBuff[SHA2_NUM_OF_SELF_TESTS][100] =
+    {
+        { "abc" },
+        { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
+        {'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a'}
+    };
+
+    static const UINT8 sha2SelfTestBuffLen[SHA2_NUM_OF_SELF_TESTS] =
+    {
+        3, 56, 100
+    };
+
+    static const UINT8 sha2SelfTestExpRes[SHA2_NUM_OF_SELF_TESTS][SHA_2_HASH_LENGTH] =
+    {
+        /*
+         * SHA-256 test vectors
+         */
+        { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
+          0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
+          0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
+          0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
+        { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
+          0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
+          0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
+          0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
+        { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
+          0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
+          0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
+          0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
+    };
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA 1 TESTS                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (shaType == SHA_TYPE_SHA1)
+    {
+        for(i = 0; i < SHA1_NUM_OF_SELF_TESTS; i++)
+        {
+            if (i != 3)
+            {
+                DEFS_STATUS_RET_CHECK(SHA_Calc(SHA_TYPE_SHA1, sha1SelfTestBuff[i], sha1SelfTestBuffLen[i], hashDigest));
+            }
+            else
+            {
+                SHA_Power(TRUE);
+                SHA_Reset();
+                SHA_RET_CHECK(SHA_Start(&handle, SHA_TYPE_SHA1));
+                SHA_RET_CHECK(SHA_Update(&handle, sha1SelfTestBuff[i],73));
+                SHA_RET_CHECK(SHA_Update(&handle, &(sha1SelfTestBuff[i][73]),sha1SelfTestBuffLen[i] - 73));
+                SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+                SHA_Power(FALSE);
+            }
+            if (memcmp(hashDigest, sha1SelfTestExpRes[i], SHA_1_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+        }
+
+    }
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA 2 TESTS                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        for( i = 0; i < SHA2_NUM_OF_SELF_TESTS; i++ )
+        {
+            SHA_Power(TRUE);
+            SHA_Reset();
+            SHA_RET_CHECK(SHA_Start(&handle, SHA_TYPE_SHA2));
+            if( i == 2 )
+            {
+                for( j = 0; j < 10000; j++ )//not working
+                {
+                    SHA_RET_CHECK(SHA_Update(&handle, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i]));
+                }
+            }
+            else
+            {
+                SHA_RET_CHECK(SHA_Update(&handle, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i]));
+            }
+
+            SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+            SHA_Power(FALSE);
+            if(memcmp(hashDigest, sha2SelfTestExpRes[i], SHA_2_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+
+            SHA_Calc(SHA_TYPE_SHA2, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i], hashDigest);
+            if(memcmp(hashDigest, sha2SelfTestExpRes[i], SHA_2_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+        }
+    }
+    return DEFS_STATUS_OK;
+}
+#endif //SHA_SELF_TEST
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             LOCAL FUNCTIONS                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_FlushLocalBuffer_l                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine flush secrun buffer to SHA module                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_FlushLocalBuffer_l (const UINT32* buff)
+{
+    UINT i;
+
+    for(i = 0; i < (SHA_BLOCK_LENGTH / sizeof(UINT32)); i++)
+    {
+        REG_WRITE(HASH_DATA_IN, buff[i]);
+    }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_BusyWait_l                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/* Returns:         DEFS_STATUS_OK if no error was found or DEFS_STATUS_ERROR otherwise                    */
+/* Side effects:                                                                                           */
+/* Description:     This routine wait for SHA unit to no longer be busy                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS SHA_BusyWait_l (void)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* While SHA module is busy                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    BUSY_WAIT_TIMEOUT((READ_REG_FIELD(HASH_CTR_STS, HASH_CTR_STS_SHA_BUSY) == 0x01), SHA_TIMEOUT);
+    return DEFS_STATUS_OK;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_GetShaDigest_l                                                                     */
+/*                                                                                                         */
+/* Parameters:      hashDigest - buffer for the hash output.                                               */
+/*                  shaType - SHA module type                                                              */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine copy the hash digest from the hardware and into given buffer( in ram)     */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_GetShaDigest_l(
+    UINT8* hashDigest,
+    SHA_TYPE_T shaType
+)
+{
+  UINT16 j;
+  UINT32* src =     (UINT32 *)REG_ADDR(HASH_DIG_H(0));
+  UINT32* dest =    (UINT32 *)(void*)hashDigest;
+  UINT8 len = ((shaType == SHA_TYPE_SHA2) ? SHA_2_HASH_LENGTH : SHA_1_HASH_LENGTH) / sizeof(UINT32);
+
+  /*-------------------------------------------------------------------------------------------------------*/
+  /* Copy Bytes from SHA module to given buffer                                                            */
+  /*-------------------------------------------------------------------------------------------------------*/
+  for (j = 0; j < len; j++)
+  {
+    dest[j] = src[j];
+  }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetShaDigest_l                                                                     */
+/*                                                                                                         */
+/* Parameters:      hashDigest - input buffer to set as hash digest(in SHA module).                        */
+/*                  shaType - SHA module type                                                              */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine set the hash digest in the hardware from a given buffer( in ram)          */
+/*---------------------------------------------------------------------------------------------------------*/
+static  void SHA_SetShaDigest_l(
+    const UINT32* hashDigest,
+    SHA_TYPE_T shaType
+)
+{
+  UINT16 j;
+  UINT32* dest = (UINT32 *)REG_ADDR(HASH_DIG_H(0));
+  UINT8 len = ((shaType == SHA_TYPE_SHA2) ? SHA_2_HASH_LENGTH : SHA_1_HASH_LENGTH) / sizeof(UINT32);
+
+  /*-------------------------------------------------------------------------------------------------------*/
+  /* Copy Bytes from given buffer to SHA module                                                            */
+  /*-------------------------------------------------------------------------------------------------------*/
+  for (j = 0; j < len; j++)
+  {
+    dest[j] = hashDigest[j];
+  }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetBlock_l                                                                         */
+/*                                                                                                         */
+/* Parameters:      data        - data to copy                                                             */
+/*                  len         -  size of data                                                            */
+/*                  position    - byte offset into the block at which data should be placed                */
+/*                  block       - block buffer                                                             */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine load bytes into block buffer                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_SetBlock_l(const UINT8* data,UINT32 len, UINT16 position, UINT32* block)
+{
+    UINT8 * dest = (UINT8*)block;
+    memcpy(dest + position, data, len);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetBlock_l                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  len -  size of data                                                                    */
+/*                  position - byte offset into the block at which data should be placed                   */
+/*                  block - block buffer                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine load zero's into the block buffer                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_ClearBlock_l (
+    UINT16 len,
+    UINT16 position,
+    UINT32* block
+)
+{
+    UINT8 * dest = (UINT8*)block;
+    memset(dest + position, 0, len);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetLength32_l                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  handlePtr  -   SHA processing handle pointer                                           */
+/*                  block - block buffer                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine set the length of the hash's data                                         */
+/*                  len is the 32-bit byte length of the message                                           */
+/*lint -efunc(734,SHA_SetLength32_l) Supperess loss of percision lint warning                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_SetLength32_l (const SHA_HANDLE_T* handlePtr, UINT32* block)
+{
+  UINT16*       secrunBufferSwappedPtr = (UINT16*)(void*)(block);
+
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 1] = (UINT16)
+        ((handlePtr->length0 << 3) << 8) | ((UINT16) (handlePtr->length0 << 3) >> 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 2] = (UINT16)
+        ((handlePtr->length0 >> (16-3)) >> 8) | ((UINT16) (handlePtr->length0 >> (16-3)) << 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 3] = (UINT16)
+    ((handlePtr->length1 << 3) << 8) | ((UINT16) (handlePtr->length1 << 3) >> 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 4] = (UINT16)
+    ((handlePtr->length1 >> (16-3)) >> 8) | ((UINT16) (handlePtr->length1 >> (16-3)) << 8);
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.h b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.h
new file mode 100755
index 0000000..dba7b05
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_drv.h
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2013-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sha_drv.h                                                                                             */
+/*            This file contains SHA driver interface                                                      */
+/* Project:                                                                                                */
+/*            SWC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef SHA_DRV_H
+#define SHA_DRV_H
+
+#include "../sha_if.h"
+
+#endif  /* SHA_DRV_H */
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_regs.h b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_regs.h
new file mode 100755
index 0000000..a582eeb
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sha/1/sha_regs.h
@@ -0,0 +1,50 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2013-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sha_regs.h                                                                                            */
+/*            This file contains SHA  module registers                                                     */
+/* Project:                                                                                                */
+/*            SWC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _SHA_REGS_H
+#define _SHA_REGS_H
+
+#include "../../../Chips/chip.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                  SHA Registers                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define HASH_DATA_IN            (SHA_BASE_ADDR + 0x000),                 SHA_ACCESS,     32
+#define HASH_CTR_STS            (SHA_BASE_ADDR + 0x004),                 SHA_ACCESS,     8
+#define HASH_CFG                (SHA_BASE_ADDR + 0x008),                 SHA_ACCESS,     8
+#define HASH_VER                (SHA_BASE_ADDR + 0x00C),                 SHA_ACCESS,     8
+#define HASH_DIG_H(i)           (SHA_BASE_ADDR + 0x020 + (4 * i)),       SHA_ACCESS,     32
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_CTR_STS fields                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_CTR_STS_SHA_EN     0,  1
+#define HASH_CTR_STS_SHA_BUSY   1,  1
+#define HASH_CTR_STS_SHA_RST    2,  1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_CFG fields                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_CFG_SHA1_SHA2      0,  1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_DIG_H fields                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_DIG_H_NUM          8
+
+#endif /* _SHA_REGS_H */
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.c b/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.c
new file mode 100755
index 0000000..f460a2f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.c
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2013-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sha_if.c                                                                                              */
+/*            This file contains SHA module driver selector                                                */
+/* Project:                                                                                                */
+/*            SWC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../Chips/chip.h"
+
+#if defined(SHA_MODULE_TYPE)
+    #include __MODULE_DRIVER(sha, SHA_MODULE_TYPE)
+#endif
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.h b/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.h
new file mode 100755
index 0000000..0f42378
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/sha/sha_if.h
@@ -0,0 +1,194 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2013-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   sha_if.h                                                                                              */
+/*            This file contains SHA driver interface                                                      */
+/* Project:                                                                                                */
+/*            SWC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _SHA_IF_H
+#define _SHA_IF_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                INCLUDES                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../Chips/chip.h"
+
+#if defined SHA_MODULE_TYPE
+#include __MODULE_HEADER(sha, SHA_MODULE_TYPE)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                  TYPES & DEFINITIONS                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define SHA_BLOCK_LENGTH     (512/8)
+#define SHA_2_HASH_LENGTH    (256/8)
+#define SHA_1_HASH_LENGTH    (160/8)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SHA type                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+  SHA_TYPE_SHA2 = 0,/*do not change - match SHA arch spec */
+  SHA_TYPE_SHA1,
+  SHA_TYPE_NUM
+} SHA_TYPE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SHA instance struct handler                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct SHA_HANDLE_T
+{
+  UINT32              hv[SHA_2_HASH_LENGTH / sizeof(UINT32)];
+  UINT32              length0;
+  UINT32              length1;
+  UINT32              block[SHA_BLOCK_LENGTH / sizeof(UINT32)];
+  SHA_TYPE_T          shaType;
+  BOOLEAN             active;
+} SHA_HANDLE_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           INTERFACE FUNCTIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Calc                                                                               */
+/*                                                                                                         */
+/* Parameters:      shaType     - SHA module type                                                          */
+/*                  inBuff      -    Pointer to a buffer containing the data to be hashed                  */
+/*                  len         -    Length of the data to hash                                            */
+/*                  hashDigest  -   Pointer to a buffer where the reseulting digest will be copied to      */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs complete SHA calculation in one step including SHA_Init routine  */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Calc (SHA_TYPE_T shaType, const UINT8* inBuff, UINT32 len, UINT8* hashDigest);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:      handlePtr - SHA processing handle pointer                                              */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialize the SHA module                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Init (SHA_HANDLE_T* handlePtr);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Start                                                                              */
+/*                                                                                                         */
+/* Parameters:      handlePtr   - SHA processing handle pointer                                            */
+/*                  shaType     - SHA module type                                                          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine start a single SHA process                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Start (SHA_HANDLE_T* handlePtr, SHA_TYPE_T shaType);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Update                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  buffer -   Pointer to the data that will be added to the hash calculation              */
+/*                  len -      Length of data to add to SHA calculation                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine adds data to previously started SHA calculation                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Update (SHA_HANDLE_T* handlePtr, const UINT8* buffer, UINT32 len);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Finish                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  hashDigest -     Pointer to a buffer where the final digest will be copied to          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine finish SHA calculation and get the resulting SHA digest                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Finish (SHA_HANDLE_T* handlePtr, UINT8* hashDigest);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reset SHA module                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Reset (void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Power                                                                              */
+/*                                                                                                         */
+/* Parameters:      on - TRUE enable the module, FALSE disable the module                                  */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set SHA module power on/off                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_Power (BOOLEAN on);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintRegs                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module registers                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintRegs (void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintVersion                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module version                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintVersion (void);
+
+#ifdef SHA_SELF_TEST
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SelfTest                                                                           */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/* Returns:         DEFS_STATUS_OK on success or other HAL_STATUS error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs various tests on the SHA HW and SW                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHA_SelfTest (SHA_TYPE_T shaType);
+#endif//#ifdef SHA_SELF_TEST
+
+#endif//SHA_IF_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/shm/shm_if.h b/board/nuvoton/common/BMC_HAL/Modules/shm/shm_if.h
new file mode 100755
index 0000000..85c5cc1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/shm/shm_if.h
@@ -0,0 +1,72 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   shm_if.h                                                                                              */
+/*            This file contains SHM interface                                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _SHM_IF_H
+#define _SHM_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHM_ConfigureBiosFlash                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures the size and base address of BIOS Flash for SHM operations     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHM_ConfigureBiosFlash(void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHM_ReleaseHostLpc                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Releases the LPC bus stall which allows the host to boot                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHM_ReleaseHost(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHM_EnableAccessFromHost                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  enable -    determines whether to enable or disable access                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine configures whether to enable or disable (stall) access                    */
+/*                  of the Host to the SHM                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SHM_EnableAccessFromHost(BOOLEAN enable);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHM_EnableIndirectMemoryAccess                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enables the access to AHB address space from the host                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHM_EnableIndirectMemoryAccess(void);
+
+
+
+#endif //_SHM_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.c b/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.c
new file mode 100755
index 0000000..3aaf754
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.c
@@ -0,0 +1,261 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   straps.c                                                                                              */
+/*            This file contains straps and fuse straps access routines                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define STRAPS_C
+
+#include "../../../Common/hal_common.h"
+#include "../../../Chips/chip.h"
+
+#if defined (NPCM750)
+#include "../../gcr/Poleg_IP/gcr_regs.h"
+#include "../../fuse/Poleg_IP/fuse_regs.h"
+#elif defined (NPCM650)
+#include "../../gcr/Yarkon_IP/gcr_regs.h"
+#include "../../fuse/Yarkon_IP/fuse_regs.h"
+#elif defined (WPCM450)
+#include "../../gcr/Hermon_IP/gcr_regs.h"
+#else
+#error "Update gcr_regs register of the chip"
+#endif
+
+#include "defs.h"
+
+#include "strp_drv.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access macroes                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define USE_FUSESTARP()        (READ_REG_FIELD(FUSTRAP, FUSTRAP_USEFUSTRAP))         // Use FUSSTRAP register for startup configuration
+
+#define SECBOOT_ON()           (READ_REG_FIELD(FUSTRAP, FUSTRAP_oSECBOOT))           // Perform a secure boot
+#define ECC_IS_ON(straps)      (READ_VAR_FIELD(STRP_Straps, FUSTRAP))                     // Enable ECC for DDR
+#define HALT_ON_FAILURE()      (READ_REG_FIELD(FUSTRAP, FUSTRAP_oHLTOF))             // Halt execution of Image verification error
+#define KEY_ACCESS_LOCK_ON()   (READ_REG_FIELD(FUSTRAP, FUSTRAP_oAESKEYACCLK))       // instructs to FW to lock keys OTP on sec fail
+#define SIG_KEY_SIZE()         (READ_REG_FIELD(FKEYIND, FKEYIND_KSIZE) ? AES_KEY_128 : AES_256) // Retrieves the signature key size from a fuse strap
+#define SECEN_ON()             (!READ_REG_FIELD(PWRON, PWRON_STRAP8))
+
+#define SECURE_BOOT_ON()       (SECBOOT_ON())                           // Boot with security checks
+
+
+
+#define SKIP_INIT_MODE()       ((STRP_CLKFRQ_T)READ_REG_FIELD(PWRON, PWRON_STRAP3_1) == STRP_CLKFRQ_OPTION1)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Module local variables                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  STRP_Straps       = 0;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function implementation                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_Select                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine get the calculated strap values (either from the fuses or directly        */
+/*                  from the straps. This is a singleton.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void STRP_Select()
+{
+
+    STRP_Straps = 0;
+    if (USE_FUSESTARP())
+
+    {
+        // Read startup configuration from FUSTRAP register:
+        STRP_Straps = REG_READ(FUSTRAP);  // take from fusetrap: CP_SKIPINIT, CKFRQ
+
+        // Flip all the bits (all configuration is according to FUSTRAP bit polarity)
+        STRP_Straps = ~STRP_Straps;
+
+        // set straps values that are not in fuses ( on fusetrap they are marked as reseved):
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP4    , READ_REG_FIELD(PWRON, PWRON_STRAP4));   // J2EN
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP6    , READ_REG_FIELD(PWRON, PWRON_STRAP6));   // ECC
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP7    , READ_REG_FIELD(PWRON, PWRON_STRAP7));   // HIZ
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP8    , READ_REG_FIELD(PWRON, PWRON_STRAP8));   // SECEN
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP10_9 , READ_REG_FIELD(PWRON, PWRON_STRAP10_9));// FUP
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP12   , READ_REG_FIELD(PWRON, PWRON_STRAP12));  // SFAB
+        SET_VAR_FIELD(STRP_Straps, PWRON_STRAP13   , READ_REG_FIELD(PWRON, PWRON_STRAP13));  // SPI0F18
+
+    }
+    else
+    {
+        // Read startup configuration from PWRON register:
+        STRP_Straps = REG_READ(PWRON);
+    }
+
+    // If ROM code mode is set to secureboot (oSecBoot ) but straps are set to skip init mode
+    // the ROM ignores clk fuse and set the clk to default. skip init in secire mode means igore fuse clock configuration.
+    if ( STRP_SecureBoot_On () == 1 )
+    {
+        // if it's skipinit - set clk to default (800MHz) regardless of what fusestrap says:
+        if (STRP_SkipInit_On())
+        {
+            SET_VAR_FIELD(STRP_Straps, FUSTRAP_FUSTRAP3_1 , STRP_CLKFRQ_OPTION7);
+        }
+    }
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_SecureBoot_On                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine  Read the SB strap and oSecboot, as is. without init, which will be done  */
+/*                  later on                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN STRP_SecureBoot_On()
+{
+    return (SECBOOT_ON() );
+
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_SkipInit_On                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the skip init mode. It is derived from the clk configuration register*/
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN STRP_SkipInit_On (void)
+{
+    /* Read the clk strap, as is. without init, which will be done later on */
+    return SKIP_INIT_MODE();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_Ecc_On                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets strap 6 (ECC)  value . Used by boot block                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN STRP_Ecc_On (void)
+{
+    return READ_VAR_FIELD(STRP_Straps, PWRON_STRAP6); //  ECC_IS_ON(STRP_Straps);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_FUP_mode                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the FUP mode ( Flash update mode)                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+STRP_FUP_T STRP_FUP_mode (void)
+{
+    return (STRP_FUP_T)READ_VAR_FIELD(STRP_Straps, PWRON_STRAP10_9); // Specifies Core UART connection to external I/F SI2
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_Ckfrq_Get                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the clk strap configuration from the pwrn register                   */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 STRP_Ckfrq_Get (void)
+{
+    return READ_VAR_FIELD(STRP_Straps, PWRON_STRAP3_1);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_get                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  strp    -  strp the to get . Value is not reverted or anything like that               */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the actual strap value (from the pin strap, not from the fuse        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT           STRP_get (STRP_TYPE_T strp)
+{
+    UINT retVal = 0;
+    switch (strp)
+    {
+        case STRP_1_3_CKFRQ:
+            retVal = (STRP_CLKFRQ_T)READ_REG_FIELD(PWRON, PWRON_STRAP3_1);
+            break;
+
+        case STRP_4_J2EN:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP4);
+            break;
+
+        case STRP_5:
+            ASSERT(FALSE) ; // strp 5 is reserved
+            break;
+
+        case STRP_6_ECC:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP6);
+            break;
+
+        case STRP_7_HIZ:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP7);
+            break;
+
+        case STRP_8_SECEN:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP8);
+            break;
+
+        case STRP_9_10_FUP:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP10_9);
+            break;
+
+        case STRP_11_BSPA:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP11);
+            break;
+
+        case STRP_12_SFAB:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP12);
+            break;
+
+        case STRP_13_SPI0F18:
+            retVal = READ_REG_FIELD(PWRON, PWRON_STRAP13);
+            break;
+
+
+        default:
+            ASSERT(FALSE);
+            break;
+    }
+
+    return retVal;
+}
+
+
+#undef STRAPS_C
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.h b/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.h
new file mode 100755
index 0000000..0693e1d
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/strp/Poleg_IP/strp_drv.h
@@ -0,0 +1,21 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   strp_drv.h                                                                                            */
+/*            This file contains API of straps and fuse straps access routines                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef STRP_DRV_H
+#define STRP_DRV_H
+
+#include "../strp_if.h"
+
+#endif //STRP_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.c b/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.c
new file mode 100755
index 0000000..c2b2d8b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.c
@@ -0,0 +1,23 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   strp_if.c                                                                                             */
+/*            This file contains STRP module driver selector                                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(STRP_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(strp, STRP_MODULE_TYPE)
+#endif    
+  
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.h b/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.h
new file mode 100755
index 0000000..49739ad
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/strp/strp_if.h
@@ -0,0 +1,274 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   strp_if.h                                                                                             */
+/*            This file contains API of straps and fuse straps access routines                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef STRP_IF_H
+#define STRP_IF_H
+
+
+#include "defs.h"
+#include "../aes/aes_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* STRP types definition                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum STRP_TYPE_T_tag
+{
+    STRP_1_3_CKFRQ = 1,         // CPU core and DDR4 memory clock frequency (by firmware) Also one combination is SkipInit and one  for clocks bypass
+    STRP_4_J2EN = 4 ,           // Select JTAG2 for Coprocessor debug and enable Ring Oscillator output (set by ROM firmware)
+    STRP_5 = 5,                 // Reserved
+    STRP_6_ECC= 6,              // ECC for DRAM enable
+    STRP_7_HIZ = 7,             // HI-Z Control
+    STRP_8_SECEN = 8,           // SECEN - for debug.
+    STRP_9_10_FUP = 9,          // UART Command routine enable (by ROM firmware) and UART source selection
+    STRP_11_BSPA = 11,          // Select BMC debug Serial Port (BSP) on Serial Interface 2. (set by ROM code when STRAP11 is pulled low)
+    STRP_12_SFAB = 12,          // BIOS ROM included in SPI3 flash or POLEG does not respond to host access to BIOS (default no response) (set by ROM firmware).
+    STRP_13_SPI0F18 = 13,       // SPI0 bus powered by 1.8V (set by ROM code when STRAP13 is pulled low)
+    STRP_14_15_DDR_SPEED,
+} STRP_TYPE_T;
+
+#if defined (NPCM750)
+/*---------------------------------------------------------------------------------------------------------*/
+/* DDR Memory Size - used by STRP_MemSize_Get()                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* 3 memory capacities  DDR_SIZE0 -                                                                      */
+/*    GPIO190 Existing.       DDR_SIZE1 - GPIO17 NEW                                                       */
+/*    Board options for       DDR_SIZE1 is currently                                                       */
+/*    Pulldown (default)      named I2C_BMC_SEG4_EN                                                        */
+/*    and pullup.             with a 10K pulldown                                                          */
+/*    Not a dipswitch         (no provision to pullup).                                                    */
+/*    which is OK.            I2C SEG4 enable function                                                     */
+/*                            to be internaly configured                                                   */
+/*                            to use PWRGD_PS input instead.                                               */
+/*                            Thus when needing 2GB,                                                       */
+/*                            add a rework pullup on                                                       */
+/*                            this net (e.g., J_PSU1_2                                                     */
+/*                            pin 8 2K pullup to 3.3V)                                                     */
+/*                                                                                                         */
+/* a.512MB      0           0                       Default for iDRAC                                    */
+/* b.1GB        1           0                       Default for Enclosure Contorller and                 */
+/*                                                    iDRAC special builds for mem test tools              */
+/* c.2GB        1           1                       EC special build - one off.                          */
+/* d.  Reserved   0           1                       Nobody uses. Do not need a 256MB variant.            */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum STRP_MEM_SIZE_T_tag
+#else
+typedef enum
+#endif
+{
+    STRP_MEMSIZ_512MB_MODE   = 0x0,   // 512 MB. Default for iDRAC  
+    STRP_MEMSIZ_1GB_MODE     = 0x2,   // 1024 MB. Default for Enclosure Contorller and iDRAC special builds for mem test tools  
+    STRP_MEMSIZ_2GB_MODE     = 0x3,   // 2048 MB. EC special build - one off.   
+    STRP_MEMSIZ_RESERVED     = 0x1    // Reserved, Nobody uses. Do not need a 256MB variant.    
+} STRP_MEM_SIZE_T;
+
+
+
+
+ /*--------------------------------------------------------------------------------------------------------*/
+ /* DDR Memory Speed - used by STRP_MemSpeed_Get()                                                         */
+ /*--------------------------------------------------------------------------------------------------------*/
+
+ /*--------------------------------------------------------------------------------------------------------*/
+ /* DDR speeds                                                                                             */
+ /*                      DDR_SPEED0    DDR_SPEED1 =                                                        */
+ /*                      STRAP6        GPIO169.                                                            */
+ /*                                                                                                        */
+ /* a.667 MHz      0            1       Default                                                      */
+ /* b. 800 MHz      1            0       Only a couple dare devils try this.                          */
+ /* c.333 MHz      0            0       General populace tries this setting if instability           */
+ /*                                           is observed  and CPU slow down did not help.                 */
+ /* d.      Res.         1            1       Nobody runs this                                             */
+ /*                                                                                                        */
+ /* GPIO169 is currently called JMP_NO_RST_IERR_N which will be relocated on real platforms and not needed */
+ /* on DRB.                                                                                                */
+ /*  It is a FW function on whether the BMC should reset the host of detecteing a crash or not.            */
+ /*--------------------------------------------------------------------------------------------------------*/
+typedef enum STRP_MEM_SPEED_T_tag
+{                                         //            highBit(s6) lowBit(SW1.4)
+    STRP_MEM_SPEED_667MHz_MODE   = 0x3,   // 667 MHz    1           1       Default 
+    STRP_MEM_SPEED_800MHz_MODE   = 0x1,   // 800 MHz    0           1       Only a couple dare devils try this. 
+    STRP_MEM_SPEED_333MHz_MODE   = 0x2,   // 333 MHz    1           0       General populace tries this setting if instability is observed and CPU slow down did not help.  
+    STRP_MEM_SPEED_RESERVED      = 0x0    // Reserved   0           0       Nobody runs this
+} STRP_MEM_SPEED_T; 
+
+
+
+#if defined (NPCM750)
+/*---------------------------------------------------------------------------------------------------------*/
+/* CPU core clock and DDR memory frequency - used by STRP_Ckfrq_Get()                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum STRP_CLKFRQ_T_tag
+{
+    STRP_CLKFRQ_OPTION0   =  0  , /* DDR=MCBPCK  CORE=FT     AXI=FT/2    AHB=FT/4    AHB3=FT/2   SPI0=FT/2   APB5=FT/4   APB1_4=FT/4     PCI=FT/5    GFX=FT/4 */
+    STRP_CLKFRQ_OPTION1   =  1  , /* DDR=25      CORE=25     AXI=12.5    AHB=6.25    AHB3=3.1    SPI0=6.25   APB5=3.1    APB1_4=1.5      PCI=4.17    GFX=5    */
+    STRP_CLKFRQ_OPTION2   =  2  , /* DDR=1066    CORE=1000   AXI=500     AHB=250     AHB3=19.23  SPI0=19.23  APB5=62.5   APB1_4=31.25    PCI=142.8   GFX=167  */
+    STRP_CLKFRQ_OPTION3   =  3  , /* DDR=667     CORE=500    AXI=250     AHB=125     AHB3=17.85  SPI0=17.85  APB5=62.5   APB1_4=31.25    PCI=166.7   GFX=167  */
+    STRP_CLKFRQ_OPTION4   =  4  , /* DDR=850     CORE=800    AXI=400     AHB=200     AHB3=20     SPI0=20     APB5=50     APB1_4=25       PCI=133     GFX=160  */
+    STRP_CLKFRQ_OPTION5   =  5  , /* DDR=900     CORE=888    AXI=444     AHB=222     AHB3=18.5   SPI0=18.5   APB5=55.5   APB1_4=27.75    PCI=148     GFX=177.6*/
+    STRP_CLKFRQ_OPTION6   =  6  , /* DDR=800     CORE=850    AXI=425     AHB=212.5   AHB3=19.3   SPI0=19.3   APB5=53.1   APB1_4=26.6     PCI=170     GFX=170  */
+    STRP_CLKFRQ_OPTION7   =  7  , /* DDR=800     CORE=800    AXI=400     AHB=200     AHB3=20     SPI0=20     APB5=50     APB1_4=25       PCI=133     GFX=160  */
+
+} STRP_CLKFRQ_T;
+#else
+typedef enum
+{
+    STRP_CKFRQ_400_400_MODE  = 0x0,   // DDR=400MHz;  CPU=400MHz
+    STRP_CKFRQ_300_408_MODE  = 0x1,   // DDR=300MHz;  CPU=408MHz
+    STRP_CKFRQ_200_200_MODE  = 0x2,   // DDR=200MHz;  CPU=200MHz
+    STRP_CKFRQ_400_240_MODE  = 0x3,   // DDR=400MHz;  CPU=240MHz
+    STRP_CKFRQ_432_432_MODE  = 0x4,   // DDR=432MHz;  CPU=432MHz
+    STRP_CKFRQ_480_480_MODE  = 0x5,   // DDR=480MHz;  CPU=480MHz
+    STRP_CKFRQ_533_480_MODE  = 0x6,   // DDR=533MHz;  CPU=480MHz
+    STRP_CKFRQ_SYSBPCK_MODE  = 0x7    // DDR=SYSBPCK; CPU=SYSBPCK
+} STRP_CKFRQ_T;
+
+#endif
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART programming modes enum                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum STRP_FUP_T_tag
+{
+    STRP_FUP_NONE_UART3     = 0,    // Normal boot operation. If boot will fail, go to FUP at UART3
+    STRP_FUP_ENABLE_UART2   = 1,    // Programming enabled. After initialization, the core waits for commands from UART2, which is connected to host SP2 (internal connection). In this case, there is no jump to an SPI flash device.
+    STRP_FUP_ENABLE_UART3   = 2,    // Programming enabled. After initialization, the core waits for commands from UART3, which is connected to external SI2 interface. In this case, there is no jump to an SPI flash device.
+    STRP_FUP_NONE_UART2     = 3,    // Normal boot operation. If boot will fail, go to FUP at UART2
+} STRP_FUP_T;
+
+
+/*-----------------------------------------------------------------------------------------------------*/
+/* 2   1   0   DDR         CORE    AXI     AHB     AHB3    SPI0    APB5    APB1_4  PCI     GFX         */
+/* Straps                                                                                              */
+/* 3   2   1                                                                                           */
+/* 0   0   0   MCBPCK       FT     FT/2    FT/4    FT/2    FT/2    FT/4    FT/4    FT/5    FT/4        */
+/* 0   0   1   25           25     12.5    6.25    3.1     6.25    3.1     1.5     4.17    5           */
+/* 0   1   0   1066         1000    500    250     19.23   19.23   62.5    31.25   142.8   167         */
+/* 0   1   1   667          500     250    125     17.85   17.85   62.5    31.25   166.7   167         */
+/* 1   0   0   850          800     400    200     20      20      50      25      133     160         */
+/* 1   0   1   900          888     444    222     18.5    18.5    55.5    27.75   148     177.6       */
+/* 1   1   0   800          850     425    212.5   19.3    19.3    53.1    26.6    170     170         */
+/* 1   1   1   800          800     400    200     20      20      50      25      133     160         */
+/*-----------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Straps module exported functions (API)                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (NPCM750)
+void           STRP_Init(void);
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_Select                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine get the calculated strap values (either from the fuses or directly        */
+/*                  from the straps. This is a singleton.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void           STRP_Select (void);
+
+#if !defined (NPCM750)
+BOOLEAN        STRP_SecureBoot_Off(void);
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_SecureBoot_On                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine  Read the SB strap and oSecboot and oSecBootDisabled.                     */
+/*                  without init, which will be done                                                       */
+/*                  If the   oSecBootDisable conflicts with oSecBoot enable return error                   */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN        STRP_SecureBoot_On(void);
+#if !defined (NPCM750)
+BOOLEAN        STRP_Strap19_On(void);
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_SkipInit_On                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the skip init mode. It is derived from the clk configuration register*/
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN        STRP_SkipInit_On (void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_Ecc_On                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets strap 6 (ECC)  value . Used by boot block                            */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN        STRP_Ecc_On (void);
+
+#if defined (NPCM750)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_FUP_mode                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the FUP mode ( Flash update mode)                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+STRP_FUP_T     STRP_FUP_mode (void);
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        STRP_get                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  strp    -  strp the to get . Value is not reverted or anything like that               */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets the actual strap value (from the pin strap, not from the fuse        */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT                     STRP_get           (STRP_TYPE_T strp);
+BOOLEAN                  STRP_ShmBypass_On     (void);
+BOOLEAN                  STRP_Propf_On         (void);
+BOOLEAN                  STRP_BootFromSpi      (void);
+BOOLEAN                  STRP_HaltOnFailure    (void);
+BOOLEAN                  STRP_Gp_On            (void);
+BOOLEAN                  STRP_Sioxh_On         (void);
+BOOLEAN                  STRP_KeyAccessLock_On (void);
+BOOLEAN                  STRP_BiosEn_On        (void);
+#if defined (NPCM750)
+UINT32                   STRP_Ckfrq_Get(void);
+UINT                     STRP_get              (STRP_TYPE_T strp);
+STRP_MEM_SPEED_T         STRP_MemSpeed_Get     (void);
+#else
+BOOLEAN                  STRP_Upsrc_External   (void);
+UINT32                   STRP_Ckfrq_Get        (void);
+UINT32                   STRP_MemSize_Get      (void);
+UINT32                   STRP_BiosFlashSize_Get(void);
+AES_KEY_SIZE_T           STRP_KeySize_Get      (void);
+#endif
+
+#endif //STRP_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.c b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.c
new file mode 100755
index 0000000..7a13072
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.c
@@ -0,0 +1,541 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   TIMER_drv.c                                                                                           */
+/*            This file contains TIMER module implementation                                               */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../../Common/hal_common.h"
+#include "../../../Chips/chip.h"
+
+#include "timer_drv.h"
+#include "timer_regs.h"
+
+#include "../../aic/aic_if.h"
+#include "../../clk/clk_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Array of timer counters                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+volatile static UINT32 TIMER_tickCount[TIMER_NUM_OF_PORTS] = {0};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Array of timer interrupt handlers                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+static AIC_Isr_T TIMER_handler[TIMER_NUM_OF_PORTS] = {0};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Array of timer interrupt handlers args                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32 TIMER_handler_args[TIMER_NUM_OF_PORTS] = {0};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_InternalHandler                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  arg -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is internal TIMER Irq Handler                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS TIMER_InternalHandler(UINT32 arg)
+{
+    UINT32 timerNum = (UINT32)arg;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* set start TIMER value                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    TIMER_tickCount[timerNum]++;
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_StartPeriodic                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum        - Timer number                                                         */
+/*                  ticksPerSec     - Timer frequency in hertz                                             */
+/*                  tickHanlder     - Handler for Timer tick event. If NULL is given, internal event       */
+/*                                    handler is used                                                      */
+/*                  tickHandlerArg  - Argument to the handler                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialization of the timer to perform periodic event.                    */
+/*                  If 'tickHandler' is given it is called every 'tickPerSec' tick.                        */
+/*                  Otherwise internal handler is increasing internal tick counter for the given timer.    */
+/*                  Its value can be read using TIMER_GetTick function                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StartPeriodic(TIMER_DEV_T timerNum, UINT32 ticksPerSec, AIC_Isr_T tickHanlder, void* tickHandlerArg)
+{
+    UINT32      timerClk = 0;
+    UINT32      loadVal  = 0;
+    HAL_STATUS  ret = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring the Timer clock                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    timerClk = CLK_ConfigureTimerClock();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Cleaning the status register                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(TIMER_TCSR(timerNum), 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clearing the timer counter                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    TIMER_tickCount[timerNum]=0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Periodic interrupt mode                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_MODE, TCSR_MODE_PERIODIC);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* set start TIMER value                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (ticksPerSec == 0)
+    {
+        loadVal = 0xFFFFFFFF;
+        ret = HAL_ERROR_BAD_FREQ;
+    }
+    else
+    {
+        loadVal = timerClk / ticksPerSec;
+    }
+    REG_WRITE(TIMER_TICR(timerNum), loadVal);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Register handler                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (tickHanlder != NULL)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Registering given handler if given                                                              */
+        /*-------------------------------------------------------------------------------------------------*/
+        TIMER_handler[timerNum]         = tickHanlder;
+        TIMER_handler_args[timerNum]    = (UINT32)tickHandlerArg;
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Registering internal handler if no handler given                                                */
+        /*-------------------------------------------------------------------------------------------------*/
+        TIMER_handler[timerNum]         = TIMER_InternalHandler;
+        TIMER_handler_args[timerNum]    = (UINT32)timerNum;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Interrupt muxing                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    AIC_EnableGroupInt(TIMER_GROUP_INTERRUPT(timerNum));
+
+#if !defined(NO_INTERNAL_IRQ_HANDLER)
+    AIC_RegisterHandler(TIMER_INTERRUPT(timerNum), TIMER_Isr, timerNum);
+    AIC_EnableInt(TIMER_INTERRUPT(timerNum));
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clear interrupt flag                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_BIT(TIMER_TISR(timerNum), TIMER_PORT_IN_MODULE(timerNum));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* interrupt enable                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_IE, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* start TIMER                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 1);
+
+    return ret;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_StopPeriodic                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine stops the timer started by startPeriodic routine                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StopPeriodic(TIMER_DEV_T timerNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* interrupt disable                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_IE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* stop TIMER                                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clearing interrupt handlers                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    TIMER_handler[timerNum]         = NULL;
+    TIMER_handler_args[timerNum]    = 0;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_StartOneShot                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSec -    number of micro seconds the timer will count (to zero)                   */
+/*                  timerNum -    the timer number to use                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Activate timer in OneShot mode, no use of interrupts                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StartOneShot(TIMER_DEV_T timerNum, UINT32 microSec)
+{
+    UINT32      timerClk = 0;
+     INT32      divisor  = 0;
+    HAL_STATUS  ret      = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* if microSec is 0 nothing to do                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (microSec==0)
+    {
+        return HAL_OK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configure timer source clock:                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    timerClk = CLK_ConfigureTimerClock();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Computing divisor                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    divisor = (timerClk/_1MHz_)-1;
+
+    if (divisor < 0)
+    {
+        divisor = 0;
+        ret = HAL_ERROR_BAD_FREQ;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set prescaler to produce timer tick each 1uSec:                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_PRESCALE, divisor);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clean status register:                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(TIMER_TCSR(timerNum), 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set one shot mode                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_MODE, TCSR_MODE_ONESHOT);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Load timer value:                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(TIMER_TICR(timerNum), microSec);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Start TIMER:                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 1);
+
+    return ret;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_OneShotRunning                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -  number of timer to check                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*              Checks whether the specified timer is still running (counting)                             */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN TIMER_OneShotRunning(TIMER_DEV_T timerNum)
+{
+    volatile UINT32 i=0;
+    volatile UINT32 retval =0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return FALSE;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* HW BUG BYPASS:                                                                                      */
+    /* Only 4th reading from CACT bit is consistent                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<4; ++i)
+    {
+        retval = READ_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CACT);
+    }
+
+    return retval;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_Reset                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs TIMER reset                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_Reset (TIMER_DEV_T timerNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Timer reset                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CRST, 1);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_GetTick                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns TIMER value                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 TIMER_GetTick(TIMER_DEV_T timerNum)
+{
+    UINT32 tickCount;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return 0;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* interrupt disable                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_IE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading timer tick (critical section)                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    tickCount = TIMER_tickCount[timerNum];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* interrupt enable                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_IE, 1);
+
+    return tickCount;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_GetHWTick                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -                                                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine return the content of the HW ticking register                             */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 TIMER_GetHWTick(TIMER_DEV_T timerNum)
+{
+    UINT32 hw_tick = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return 0;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* we stop the counter first, read the value and continue the count                                    */
+    /* assuming the core clock is much faster than timer clock, it shouldn't cause missed count            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 0);
+    hw_tick = REG_READ(TIMER_TDR(timerNum));
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 1);
+
+    return hw_tick;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_GetCurrVal                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -                                                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine return the content of the HW ticking register                             */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 TIMER_GetCurrVal(TIMER_DEV_T timerNum)
+{
+    UINT32 val = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return 0;
+    }
+
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 0);
+	val =  REG_READ(TIMER_TDR(timerNum));
+    SET_REG_FIELD(TIMER_TCSR(timerNum), TCSR_CEN, 1);
+
+    return val;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_WatchdogReset                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -  number of timer to check                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs watchdog reset                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void TIMER_WatchdogReset(UINT32 timerNum)
+{   
+    volatile INT i = 1;
+    REG_WRITE(TIMER_WTCR(timerNum), 0x83);
+    while(i);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_Isr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  data - timer number                                                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is TIMER IRQ handler                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_Isr(UINT32 timerNum)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error handling                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (timerNum >= TIMER_NUM_OF_PORTS)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if Timer interrupt set                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_BIT(TIMER_TISR(timerNum), TIMER_PORT_IN_MODULE(timerNum)))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If not, do nothing. (probably bad call to the function)                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        return HAL_ERROR_NOT_HANDLED;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Executing the handler                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (TIMER_handler[timerNum] != NULL)
+        TIMER_handler[timerNum](TIMER_handler_args[timerNum]);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Clear interrupt                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_BIT(TIMER_TISR(timerNum), TIMER_PORT_IN_MODULE(timerNum));
+
+    return HAL_OK;
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.h b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.h
new file mode 100755
index 0000000..84274c1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_drv.h
@@ -0,0 +1,23 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   TIMER_drv.h                                                                                           */
+/*            This file contains TIMER module interface                                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _TIMER_DRV_H
+#define _TIMER_DRV_H
+
+#include "../timer_if.h"
+
+#endif //_TIMER_DRV_H
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_regs.h b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_regs.h
new file mode 100755
index 0000000..45e3ab1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/timer/Hermon_IP/timer_regs.h
@@ -0,0 +1,91 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   timer_regs.h                                                                                          */
+/*            This file contains TIMER module registers                                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _TIMER_REGS_H
+#define _TIMER_REGS_H
+
+#include "../../../Chips/chip.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             TIMER Register                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_PORTS_PER_MODULE          5
+#define TIMER_PORT_TO_MODULE(port)      ((port) / TIMER_PORTS_PER_MODULE)
+#define TIMER_PORT_IN_MODULE(port)      ((port) % TIMER_PORTS_PER_MODULE)
+#define TIMER_PORT_BASE_FUNCTION(port)  ((((port)>>1)<<5) + (((port)&1)<<2))
+#define TIMER_PORT_BASE_ADDR(port)      (TIMER_BASE_ADDR(TIMER_PORT_TO_MODULE(port)) + TIMER_PORT_BASE_FUNCTION(TIMER_PORT_IN_MODULE(port)))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Multiple per module                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_TCSR(port)    (TIMER_PORT_BASE_ADDR(port) + 0x00), TIMER_ACCESS, 32     // R/W Timer Control and Status Register 0 0000_0005h
+#define TIMER_TICR(port)    (TIMER_PORT_BASE_ADDR(port) + 0x08), TIMER_ACCESS, 32     // R/W Timer Initial Control Register 0 0000_0000h
+#define TIMER_TDR(port)     (TIMER_PORT_BASE_ADDR(port) + 0x10), TIMER_ACCESS, 32     // RO Timer Data Register 0 0000_0000h
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Single per module                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TIMER_TISR(port)    (TIMER_BASE_ADDR(TIMER_PORT_TO_MODULE(port))+ 0x18), TIMER_ACCESS, 32     // R/W1C Timer Interrupt Status Register 0000_0000h
+#define TIMER_WTCR(port)    (TIMER_BASE_ADDR(TIMER_PORT_TO_MODULE(port))+ 0x1C), TIMER_ACCESS, 32     // R/W Watchdog Timer Control Register 0000_0400h
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Control and Status Register fields                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TCSR_PRESCALE            0, 8
+#define TCSR_CACT               25, 1 
+#define TCSR_CRST               26, 1
+#define TCSR_MODE               27, 2
+#define TCSR_IE                 29, 1
+#define TCSR_CEN                30, 1
+#define TCSR_FREEZE_EN          31, 1
+
+enum TCSR_MODE_type
+{
+    TCSR_MODE_ONESHOT   = 0x0,
+    TCSR_MODE_PERIODIC  = 0x1,
+    TCSR_MODE_TPGGLE    = 0x2,
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer Interrupt Status Register (TISR)fields                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define TISR_TIF0               0, 1
+#define TISR_TIF1               1, 1
+#define TISR_TIF2               2, 1
+#define TISR_TIF3               3, 1
+#define TISR_TIF4               4, 1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Watchdog Timer Control Register (WTCR) fields                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define WTCR_WTR                 0, 1
+#define WTCR_WTRE                1, 1
+#define WTCR_WTRF                2, 1
+#define WTCR_WTIF                3, 1
+#define WTCR_WTIS                4, 2
+#define WTCR_WTIE                6, 1
+#define WTCR_WTE                 7, 1
+#define WTCR_WTTME               8, 1
+#define WTCR_FREEZE_EN           9, 1
+#define WTCR_WTCLK              10, 1
+
+
+#endif // _TIMER_REGS_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.c b/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.c
new file mode 100755
index 0000000..cd2a709
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.c
@@ -0,0 +1,23 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   timer_if.c                                                                                            */
+/*            This file contains TIMER module driver selector                                              */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(TIMER_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(timer, TIMER_MODULE_TYPE)
+#endif    
+  
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.h b/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.h
new file mode 100755
index 0000000..d507df7
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/timer/timer_if.h
@@ -0,0 +1,185 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   timer_if.h                                                                                           */
+/*            This file contains TIMER module interface                                                    */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _TIMER_IF_H
+#define _TIMER_IF_H
+
+#include "../aic/aic_if.h"
+#include "../../Common/hal_error.h"
+#include "defs.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Timer definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    /* TIMER_MODULE_0 : */
+    TIMER0_DEV  = 0,
+    TIMER1_DEV  = 1,
+    TIMER2_DEV  = 2,
+    TIMER3_DEV  = 3,
+    TIMER4_DEV  = 4,
+
+    /* TIMER_MODULE_1 : */
+    TIMER5_DEV  = 5,
+    TIMER6_DEV  = 6,
+    TIMER7_DEV  = 7,
+    TIMER8_DEV  = 8,
+    TIMER9_DEV  = 9,
+    
+    /* TIMER_MODULE_2 : */
+    TIMER10_DEV  = 10,
+    TIMER11_DEV  = 11,
+    TIMER12_DEV  = 12,
+    TIMER13_DEV  = 13,
+    TIMER14_DEV  = 14,
+} TIMER_DEV_T;
+
+UINT32 TIMER_GetCurrVal(TIMER_DEV_T timerNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_StartPeriodic                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum        - Timer number                                                         */
+/*                  ticksPerSec     - Timer frequency in hertz                                             */
+/*                  tickHanlder     - Handler for Timer tick event. If NULL is given, internal event       */
+/*                                    handler is used                                                      */
+/*                  tickHandlerArg  - Argument to the handler                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialization of the timer to perform periodic event.                    */
+/*                  If 'tickHandler' is given it is called every 'tickPerSec' tick.                        */
+/*                  Otherwise internal handler is increasing internal tick counter for the given timer.    */
+/*                  Its value can be read using TIMER_GetTick function                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StartPeriodic(TIMER_DEV_T timerNum, UINT32 ticksPerSec, AIC_Isr_T tickHanlder, void* tickHandlerArg);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_stopPeriodic                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine stops the timer started by startPeriodic routine                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StopPeriodic(TIMER_DEV_T timerNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_startOneShot                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  microSec -    number of micro seconds the timer will count (to zero)                   */
+/*                  timerNum -    the timer number to use                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Activate timer in OneShot mode, no use of interrupts                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_StartOneShot(TIMER_DEV_T timerNum, UINT32 microSec);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_oneShotRunning                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -  number of timer to check                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Checks whether the specified timer is still running (counting)                         */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN TIMER_OneShotRunning(TIMER_DEV_T timerNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_reset                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs TIMER reset                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_Reset (TIMER_DEV_T timerNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_getTick                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns TIMER value                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 TIMER_GetTick(TIMER_DEV_T timerNum);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_getHWTick                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum -                                                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine return the content of the HW ticking register                             */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 TIMER_GetHWTick(TIMER_DEV_T timerNum);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_Isr                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum - timer number                                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is TIMER IRQ handler                                                      */
+/*                  It should be calle upon TIMER Interrupt event for all timers                           */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS TIMER_Isr(UINT32 timerNum);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        TIMER_watchdogRest                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timerNum - timer number                                                                */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs watchdog reset                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void TIMER_WatchdogReset(UINT32 timerNum);
+
+
+
+
+#endif // _TIMER_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.c b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.c
new file mode 100755
index 0000000..5b76446
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.c
@@ -0,0 +1,852 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   uart_drv.c                                                                                            */
+/*            This file contains implementation of UART driver                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include "../../../Chips/chip_if.h"
+
+#include "uart_drv.h"
+#include "uart_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_Init                                                                              */
+/*                                                                                                         */
+/* Parameters:      devNum - uart module number                                                            */
+/*                  muxMode - configuration mode (last setting is the one that is active)                  */
+/*                  baudRate - BAUD for the UART module                                                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs UART initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_Init(UART_DEV_T devNum, UART_MUX_T muxMode, UART_BAUDRATE_T baudRate)
+{
+    UINT32 FCR_Val      = 0;
+
+    BOOLEAN CoreSP  = FALSE;
+    BOOLEAN sp1     = FALSE;
+    BOOLEAN sp2     = FALSE;
+    UINT32  ret     = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting the module                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // removed since resets all UARTS
+    //CLK_ResetUART(devNum); 
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Muxing for UART0                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum == UART0_DEV)
+    {
+        CoreSP = TRUE;
+    }
+
+#if defined NPCM650
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Muxing for UART1                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else if (devNum == UART1_DEV)
+    {
+        CoreSP = FALSE;
+
+        switch (muxMode)
+        {
+            case UART_MUX_CORE_SNOOP:
+            case UART_MUX_CORE_TAKEOVER:
+                {
+                    sp1 = TRUE;
+                    sp2 = TRUE;
+                    break;
+                }
+            case UART_MUX_CORE_SP2__SP1_SI1:
+                {
+                    sp1 = TRUE;
+                    break;
+                }
+            case UART_MUX_CORE_SP2__SP1_SI2:
+                {
+                    sp2= TRUE;
+                    break;
+                }
+
+	        case UART_MUX_SKIP_CONFIG:
+	            {
+	                /* Do nothing. Don't call CHIP_Mux_UART. Assuming it was called before */
+	                break;
+	            }
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Illegal mux mode                                                                            */
+            /*---------------------------------------------------------------------------------------------*/
+            default: return HAL_ERROR_BAD_PARAM;
+        }
+    }
+#elif (defined NPCM750 || defined NPCM750_CP)
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable serial interfaces according to mux mode                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    switch (muxMode)
+    {
+        case UART_MUX_MODE4_HSP1_SI1____HSP2_SI2____UART1_s_SI1___UART3_s_SI2__UART2_s_HSP1:
+        case UART_MUX_MODE6_HSP1_SI1____HSP2_SI2____UART1_s_SI1___UART3_s_SI2__UART2_s_HSP2:
+        case UART_MUX_MODE7_HSP1_SI1____HSP2_UART2__UART1_s_HSP1__UART3_SI2:
+            {
+                sp1 = TRUE;
+                sp2 = TRUE;
+                break;
+            }
+        case UART_MUX_MODE5_HSP1_SI1____HSP2_UART2__UART1_s_HSP1__UART3_s_SI1:
+            {
+                sp1 = TRUE;
+                break;
+            }
+        case UART_MUX_MODE1_HSP1_SI2____HSP2_UART2__UART1_s_HSP1__UART3_s_SI2:
+        case UART_MUX_MODE2_HSP1_UART1__HSP2_SI2____UART2_s_HSP2__UART3_s_SI2:
+        case UART_MUX_MODE3_HSP1_UART1__HSP2_UART2__UART3_SI2:
+            {
+                sp2= TRUE;
+                break;
+            }
+
+        case UART_MUX_SKIP_CONFIG:
+            {
+                /* Do nothing. Don't call CHIP_Mux_UART. Assuming it was called before */
+                break;
+            }
+
+        /*---------------------------------------------------------------------------------------------*/
+        /* Illegal mux mode                                                                            */
+        /*---------------------------------------------------------------------------------------------*/
+        default: return DEFS_STATUS_INVALID_PARAMETER;
+    }
+#endif
+    if (muxMode != UART_MUX_SKIP_CONFIG)
+    {
+        GCR_Mux_Uart(muxMode, CoreSP, sp1, sp2);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disable interrupts                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(UART_LCR(devNum), 0);            // prepare to Init UART
+    REG_WRITE(UART_IER(devNum), 0x0);          // Disable all UART interrupt
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set baudrate                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    ret += UART_SetBaudrate(devNum, baudRate);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set port for 8 bit, 1 stop, no parity                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    ret += UART_SetBitsPerChar(devNum, 8);
+    ret += UART_SetStopBit(devNum, UART_STOPBIT_1);
+    ret += UART_SetParity(devNum, UART_PARITY_NONE);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set the RX FIFO trigger level, reset RX, TX FIFO                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FCR_Val = 0;
+    SET_VAR_FIELD(FCR_Val, FCR_RFITL, FCR_RFITL_4B);
+    SET_VAR_FIELD(FCR_Val, FCR_TFR, 1);
+    SET_VAR_FIELD(FCR_Val, FCR_RFR, 1);
+    SET_VAR_FIELD(FCR_Val, FCR_FME, 1);
+
+    REG_WRITE(UART_FCR(devNum), FCR_Val);
+    REG_WRITE(UART_TOR(devNum), 0x0);
+
+    if (ret > 0)
+        return HAL_ERROR;
+    else
+        return HAL_OK;
+
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_PutC                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART                                                 */
+/*                  Note that the function is blocking till char can be send                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_PutC(UART_DEV_T devNum, const UINT8 c )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait until Tx ready                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(UART_LSR(devNum), LSR_THRE));
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Put the char                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(UART_THR(devNum), (c & 0xFF));
+
+    return HAL_OK;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_GetC                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART                                                      */
+/*                  Note that the function is blocking till char is available                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT8 UART_GetC( UART_DEV_T devNum )
+{
+    UINT8 Ch;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return 0;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait until char is available                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!UART_TestRX(devNum));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading the char                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    Ch = REG_READ(UART_RBR(devNum)) & 0xFF;
+
+    return Ch;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_PutC_NB                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         HAL_OK if the char was written or error if it couldn't be written                      */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART in NON-Blocking manner                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_PutC_NB(UART_DEV_T devNum, const UINT8 c )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Put the char                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    REG_WRITE(UART_THR(devNum), (c & 0xFF));
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_GetC_NB                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         HAL_OK if char was read or error if it no char was available                           */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART in NON-Blocking manner                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_GetC_NB( UART_DEV_T devNum, UINT8* c )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait until char is available                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!UART_TestRX(devNum))
+    {
+        return HAL_ERROR_QUEUE_EMPTY;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reading the char                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    *c = (REG_READ(UART_RBR(devNum)) & 0xFF);
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_TestRX                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char in RX fifo                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN UART_TestRX( UART_DEV_T devNum )
+{
+
+    if (READ_REG_FIELD(UART_LSR(devNum), LSR_RFDR))
+        return TRUE;
+    else
+        return FALSE;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_TestTX                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char in TX fifo                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN UART_TestTX( UART_DEV_T devNum )
+{
+    if (!READ_REG_FIELD(UART_LSR(devNum), LSR_THRE))
+        return TRUE;
+    else
+        return FALSE;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_ResetFIFOs                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  rxFifo - if TRUE RX fifo is reseted                                                    */
+/*                  txFifo - if TRUE TX fifo is reseted                                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs FIFO reset                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_ResetFIFOs(UART_DEV_T devNum, BOOLEAN txFifo, BOOLEAN rxFifo)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting fifos                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (txFifo)
+    {
+        SET_REG_FIELD(UART_FCR(devNum), FCR_TFR, 1);
+    }
+
+    if (rxFifo)
+    {
+        SET_REG_FIELD(UART_FCR(devNum), FCR_RFR, 1);
+    }
+
+    return HAL_OK;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetTxIrqState                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  On -                                                                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enables/disables Tx Interrupt                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetTxIrqState(UART_DEV_T devNum, BOOLEAN On)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Tx State                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (On)
+    {
+        SET_REG_FIELD(UART_IER(devNum), IER_THREIE, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(UART_IER(devNum), IER_THREIE, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetRxIrqState                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  On -                                                                                   */
+/*                  timeout -                                                                              */
+/*                  triggerLevel -                                                                         */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Rx interrupt enable/disable and configuration                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetRxIrqState(UART_DEV_T devNum, BOOLEAN On)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Rx state                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (On)
+    {
+        SET_REG_FIELD(UART_IER(devNum), IER_RDAIE, 1);
+        SET_REG_FIELD(UART_TOR(devNum), TOR_TOIE, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(UART_IER(devNum), IER_RDAIE, 0);
+        SET_REG_FIELD(UART_TOR(devNum), TOR_TOIE, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetRxConfig                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timeout -                                                                              */
+/*                  triggerLevel -                                                                         */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Rx irq configurations                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetRxConfig(UART_DEV_T devNum, UINT8 timeout, UART_RXFIFO_TRIGGER_T triggerLevel)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Rx interrupt timeout                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(UART_TOR(devNum), TOR_TOIC, (timeout & 0x7F));
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting Rx interrupt FIFO trigger level                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(UART_FCR(devNum), FCR_RFITL, (triggerLevel<<2));
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetParity                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  parity -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets parity configuration                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetParity(UART_DEV_T devNum, UART_PARITY_T parity)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (parity != UART_PARITY_NONE)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Parity enable, choosing type                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        SET_REG_FIELD(UART_LCR(devNum), LCR_PBE, 1);
+
+        if (parity == UART_PARITY_EVEN)
+        {
+            SET_REG_FIELD(UART_LCR(devNum), LCR_EPE, 1);
+
+        }
+        else if (parity == UART_PARITY_ODD)
+        {
+            SET_REG_FIELD(UART_LCR(devNum), LCR_EPE, 0);
+        }
+        else
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Unknown parity type                                                                         */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_BAD_PARAM;
+        }
+
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* No parity                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        SET_REG_FIELD(UART_LCR(devNum), LCR_PBE, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBitsPerChar                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  bits -                                                                                 */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set bits per char                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBitsPerChar(UART_DEV_T devNum, UINT32 bits)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    switch (bits)
+    {
+        case 5:   SET_REG_FIELD(UART_LCR(devNum), LCR_WLS, LCR_WLS_5bit);   break;
+        case 6:   SET_REG_FIELD(UART_LCR(devNum), LCR_WLS, LCR_WLS_6bit);   break;
+        case 7:   SET_REG_FIELD(UART_LCR(devNum), LCR_WLS, LCR_WLS_7bit);   break;
+        default:
+        case 8:   SET_REG_FIELD(UART_LCR(devNum), LCR_WLS, LCR_WLS_8bit);   break;
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBaudrate                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  baudrate -                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets new baudrate                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBaudrate(UART_DEV_T devNum, UART_BAUDRATE_T baudrate)
+{
+    INT32       divisor     = 0;
+    UINT32      uart_clock  = 0;
+    HAL_STATUS  ret         = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring UART clock                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    uart_clock = CLK_ConfigureUartClock();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Computing the divisor for the given baudrate.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    divisor = ((INT32)uart_clock / ((INT32)baudrate * 16)) - 2;
+
+    // since divisor is rounded down check if it is better when rounded up
+    if ( ((INT32)uart_clock / (16 * (divisor + 2)) - (INT32)baudrate) > 
+         ((INT32)baudrate - (INT32)uart_clock / (16 * ((divisor+1) + 2))) )
+    {
+        divisor++;
+    }
+
+    if (divisor < 0 )
+    {
+        divisor = 0;
+        ret = HAL_ERROR_BAD_FREQ;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set baud rate to baudRate bps                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(UART_LCR(devNum), LCR_DLAB, 1);    // prepare to access Divisor
+    REG_WRITE(UART_DLL(devNum), LSB(divisor));
+    REG_WRITE(UART_DLM(devNum), MSB(divisor));
+    SET_REG_FIELD(UART_LCR(devNum), LCR_DLAB, 0);   // prepare to access RBR, THR, IER
+
+    return ret;
+
+
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetStopBit                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  stopbit -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets number of stopbits                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetStopBit(UART_DEV_T devNum, UART_STOPBIT_T stopbit)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (stopbit == UART_STOPBIT_1)
+    {
+        SET_REG_FIELD(UART_LCR(devNum), LCR_NSB, 0);
+    }
+    else if (stopbit == UART_STOPBIT_DYNAMIC)
+    {
+        SET_REG_FIELD(UART_LCR(devNum), LCR_NSB, 1);
+    }
+    else
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Unknown stopbits configuration                                                                  */
+        /*------------------------------------------------------------------------------------------------*/
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBreak                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets break on the given UART                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBreak(UART_DEV_T devNum, BOOLEAN state)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= UART_NUM_OF_MODULES)
+    {
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (state)
+    {
+        SET_REG_FIELD(UART_LCR(devNum), LCR_BCB, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(UART_LCR(devNum), LCR_BCB, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_Irq                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  rxCallback -                                                                           */
+/*                  rxParam -                                                                              */
+/*                  txCallback -                                                                           */
+/*                  txParam -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs IRQ handling                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_Isr(UART_DEV_T devNum,  UART_irq_callback_t rxCallback, void* rxParam,
+                                        UART_irq_callback_t txCallback, void* txParam)
+{
+    HAL_STATUS  ret = HAL_OK;
+    UINT32      iir = REG_READ(UART_IIR(devNum)) & 0xF;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if we got any interrupts at all                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_VAR_FIELD(iir, IIR_NIP))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* if no interrupts actually occurred, we return "not handled"                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        ret = HAL_ERROR_NOT_HANDLED;
+    }
+    else
+    {
+        switch (READ_VAR_FIELD(iir, IIR_IID))
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* We don't support modem interrups yet                                                        */
+            /*---------------------------------------------------------------------------------------------*/
+            case IIR_IID_MODEM:                                     break;
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Tx Interrupt                                                                                */
+            /*---------------------------------------------------------------------------------------------*/
+            case IIR_IID_THRE:      txCallback(devNum, txParam);    break;
+
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Rx Interrupts                                                                               */
+            /*---------------------------------------------------------------------------------------------*/
+            case IIR_IID_TOUT:
+            case IIR_IID_RDA:       rxCallback(devNum, rxParam);    break;
+
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* WE should never get here                                                                    */
+            /*---------------------------------------------------------------------------------------------*/
+            default:                                                break;
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Error interrupts                                                                            */
+            /*---------------------------------------------------------------------------------------------*/
+            case IIR_IID_RLS:
+            {
+                UINT32 lsr = REG_READ(UART_LSR(devNum));
+                if      (READ_VAR_FIELD(lsr, LSR_OEI))
+                    ret = HAL_ERROR_OVERRUN_OCCURRED;
+                else if (READ_VAR_FIELD(lsr, LSR_PEI))
+                    ret = HAL_ERROR_BAD_PARITY;
+                else if (READ_VAR_FIELD(lsr, LSR_FEI))
+                    ret = HAL_ERROR_BAD_FRAME;
+                else if (READ_VAR_FIELD(lsr, LSR_BII))
+                    ret = HAL_ERROR_BREAK_OCCURRED;
+                else
+                    ret = HAL_ERROR;
+
+                break;
+            }
+        }
+    }
+
+    return ret;
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.h b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.h
new file mode 100755
index 0000000..767d2e9
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_drv.h
@@ -0,0 +1,20 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   uart_drv.h                                                                                            */
+/*            This file contains interface of UART driver                                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _UART_DRV_H
+#define _UART_DRV_H
+
+#include "../uart_if.h"
+
+#endif //_UART_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_regs.h b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_regs.h
new file mode 100755
index 0000000..a633345
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/uart/Hermon_IP/uart_regs.h
@@ -0,0 +1,160 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2015 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   UART_regs.h                                                                                           */
+/*            This file contains definitions of UART registers                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _UART_REGS_H
+#define _UART_REGS_H
+
+
+#include "../../../Chips/chip.h"
+
+
+/**************************************************************************************************************************/
+/*   Receive Buffer Register (RBR)                                                                                        */
+/**************************************************************************************************************************/
+#define  UART_RBR(n)                            (UART_BASE_ADDR(n) + 0x0000) , UART_ACCESS, 8        /* Offset: UART_BA + 0000h */
+#define  RBR_Transmit                    0 , 8               /* Transmit Holding Register (THR)                                                                                       */
+
+/**************************************************************************************************************************/
+/*   Transmit Holding Register (THR)                                                                                      */
+/**************************************************************************************************************************/
+#define  UART_THR(n)                            (UART_BASE_ADDR(n) + 0x0000) , UART_ACCESS, 8        /* Offset: UART_BA + 0000h */
+
+/**************************************************************************************************************************/
+/*   Interrupt Enable Register (IER)                                                                                      */
+/**************************************************************************************************************************/
+#define  UART_IER(n)                            (UART_BASE_ADDR(n) + 0x0004) , UART_ACCESS, 8        /* Offset: UART_BA + 0004h */
+#define  IER_nDBGACK_EN                  4 , 1               /* 4 nDBGACK_EN (ICE Debug Mode Acknowledge Enable).                                                                     */
+#define  IER_MSIE                        3 , 1               /* 3 MSIE (Modem Status Interrupt (Irpt_MOS) Enable).                                                                    */
+#define  IER_RLSIE                       2 , 1               /* 2 RLSIE (Receive Line Status Interrupt (Irpt_RLS) Enable).                                                            */
+#define  IER_THREIE                      1 , 1               /* 1 THREIE (Transmit Holding Register Empty Interrupt (Irpt_THRE) Enable).                                              */
+#define  IER_RDAIE                       0 , 1               /* 0 RDAIE (Receive Data Available Interrupt (Irpt_RDA) Enable and Timeout Interrupt (Irpt_TOUT) Enable).                */
+
+/**************************************************************************************************************************/
+/*   Divisor Latch (Low Byte) Register (DLL)                                                                              */
+/**************************************************************************************************************************/
+#define  UART_DLL(n)                        (UART_BASE_ADDR(n) + 0x0000) , UART_ACCESS, 8        /* Offset: UART_BA + 0000h */
+
+/**************************************************************************************************************************/
+/*   Divisor Latch (High Byte) Register (DLM)                                                                             */
+/**************************************************************************************************************************/
+#define  UART_DLM(n)                       (UART_BASE_ADDR(n) + 0x0004) , UART_ACCESS, 8         /* Offset: UART_BA + 0004h */
+#define  DLM_Baud                   0 , 8                    /* 7-0 Baud Rate Divisor (High Byte). The high byte of the baud rate divisor.                                            */
+
+/**************************************************************************************************************************/
+/*   Interrupt Identification Register (IIR)                                                                              */
+/**************************************************************************************************************************/
+#define  UART_IIR(n)                            (UART_BASE_ADDR(n) + 0x0008) , UART_ACCESS, 8        /* Offset: UART_BA + 0008h */
+#define  IIR_FMES                        7 , 1               /* 7 FMES (FIFO Mode Enable Status). Indicates whether FIFO mode is enabled or not. Since FIFO mode is                   */
+#define  IIR_RFTLS                       5 , 2               /* 6-5 RFTLS (RxFIFO Threshold Level Status). Shows the current setting of the receiver FIFO threshold level             */
+#define  IIR_DMS                         4 , 1               /* 4 DMS (DMA Mode Select). The DMA function is not implemented in this version. When reading IIR, the DMS               */
+#define  IIR_IID                         1 , 3               /* 3-1 IID (Interrupt Identification). IID together with NIP indicates the current interrupt request from the UART.      */
+#define  IIR_NIP                         0 , 1               /* 0 NIP (No Interrupt Pending).                                                                                         */
+
+/**************************************************************************************************************************/
+/*   FIFO Control Register (FCR)                                                                                          */
+/**************************************************************************************************************************/
+#define  UART_FCR(n)                            (UART_BASE_ADDR(n) + 0x0008) , UART_ACCESS, 8        /* Offset: UART_BA + 0008h */
+#define  FCR_RFITL                       4 , 4               /* 7-4 RFITL (RxFIFO Interrupt (Irpt_RDA) Trigger Level).                                                                */
+#define  FCR_DMS                         3 , 1               /* 3 DMS (DMA Mode Select). The DMA function is not implemented in this version.                                         */
+#define  FCR_TFR                         2 , 1               /* 2 TFR (TxFIFO Reset). Setting this bit generates a reset to the TxFIFO. The TxFIFO becomes empty (Tx pointer          */
+#define  FCR_RFR                         1 , 1               /* 1 RFR (RxFIFO Reset). Setting this bit generates an OSC cycle reset pulse to reset the RxFIFO. The RxFIFO             */
+#define  FCR_FME                         0 , 1               /* 0 FME (FIFO Mode Enable). The UART always operates in FIFO mode; therefore, writing this bit has no effect            */
+
+/**************************************************************************************************************************/
+/*   Line Control Register (LCR)                                                                                          */
+/**************************************************************************************************************************/
+#define  UART_LCR(n)                            (UART_BASE_ADDR(n) + 0x000C) , UART_ACCESS, 8        /* Offset: UART_BA + 000Ch */
+#define  LCR_DLAB                        7 , 1               /* 7 DLAB (Divisor Latch Access Bit).                                                                                    */
+#define  LCR_BCB                         6 , 1               /* 6 BCB (Break Control Bit). When this bit is set to logic 1, the serial data output (SOUT) is forced to the Spacing    */
+#define  LCR_SPE                         5 , 1               /* 5 SPE (Stick Parity Enable).                                                                                          */
+#define  LCR_EPE                         4 , 1               /* 4 EPE (Even Parity Enable).                                                                                           */
+#define  LCR_PBE                         3 , 1               /* 3 PBE (Parity Bit Enable).                                                                                            */
+#define  LCR_NSB                         2 , 1               /* 2 NSB (Number of STOP Bits).                                                                                        */
+#define  LCR_WLS                         0 , 2               /* 1-0 WLS (Word Length Select).                                                                                         */
+#define  LCR_Word                        10 , 1              /* 10 Word Length                                                                                                        */
+
+/**************************************************************************************************************************/
+/*   Modem Control Register (MCR)                                                                                         */
+/**************************************************************************************************************************/
+#define  UART_MCR(n)                            (UART_BASE_ADDR(n) + 0x0010) , UART_ACCESS, 8        /* Offset: UART_BA + 0010h */
+#define  MCR_LBME                        4 , 1               /* 4 LBME (Loopback Mode Enable).                                                                                        */
+#define  MCR_OUT2                        3 , 1               /* 3 OUT2. Used in loopback mode to drive DCD input.                                                                     */
+#define  MCR_RTS                         1 , 1               /* 1 RTS (Request to Send Signal). Complement version of Request to Send (RTS) signal.                                   */
+#define  MCR_DTR                         0 , 1               /* 0 DTR (Data Terminal Ready Signal). Complement version of Data Terminal Ready (DTR) signal.                           */
+
+/**************************************************************************************************************************/
+/*   Line Status Control Register (LSR)                                                                                   */
+/**************************************************************************************************************************/
+#define  UART_LSR(n)                            (UART_BASE_ADDR(n) + 0x0014) , UART_ACCESS, 8        /* Offset: UART_BA + 0014h */
+#define  LSR_ERR_Rx                      7 , 1               /* 7 ERR_Rx (RxFIFO Error).                                                                                              */
+#define  LSR_TE                          6 , 1               /* 6 TE (Transmitter Empty).                                                                                             */
+#define  LSR_THRE                        5 , 1               /* 5 THRE (Transmitter Holding Register Empty).                                                                          */
+#define  LSR_BII                         4 , 1               /* 4 BII (Break Interrupt Indicator). Is set to a logic 1 when the received data input is held in the spacing state    */
+#define  LSR_FEI                         3 , 1               /* 3 FEI (Framing Error Indicator). Is set to logic 1 when the received character does not have a valid stop bit       */
+#define  LSR_PEI                         2 , 1               /* 2 PEI (Parity Error Indicator). This bit is set to logic 1 when the received character does not have a valid parity  */
+#define  LSR_OEI                         1 , 1               /* 1 OEI (Overrun Error Indicator). An overrun error occurs only after the RxFIFO is full and the next character has     */
+#define  LSR_RFDR                        0 , 1               /* 0 RFDR (RxFIFO Data Ready).                                                                                           */
+
+/**************************************************************************************************************************/
+/*   Modem Status Register (MSR)                                                                                          */
+/**************************************************************************************************************************/
+#define  UART_MSR(n)                            (UART_BASE_ADDR(n) + 0x0018) , UART_ACCESS, 8        /* Offset: UART_BA + 0018h */
+#define  MSR_DCD                         7 , 1               /* 7 DCD. (Data Carrier Detect). Complement version of Data Carrier Detect (DCD) input.                                  */
+#define  MSR_RI                          6 , 1               /* 6 RI. (Ring Indicator) Complement version of Ring Indicator (RI) input.                                               */
+#define  MSR_DSR                         5 , 1               /* 5 DSR (Data Set Ready). Complement version of Data Set Ready (DSR) input.                                             */
+#define  MSR_CTS                         4 , 1               /* 4 CTS (Clear to Send). Complement version of Clear To Send (CTS) input).                                              */
+#define  MSR_DDCD                        3 , 1               /* 3 DDCD (DCD State Change). Is set when DCD input changes state; it is reset if the CPU reads the MSR. When            */
+#define  MSR_DRI                         2 , 1               /* 2 DRI (RI State Change). It is set when RI input changes state to asserted; it is reset if the CPU reads the MSR.     */
+#define  MSR_DDSR                        1 , 1               /* 1 DDSR (DSR State Change). It is set when DSR input changes state; it is reset if the CPU reads the MSR.              */
+#define  MSR_DCTS                        0 , 1               /* 0 DCTS (CTS State Change). It is set when CTS input changes state; it is reset if the CPU reads the MSR.              */
+
+/**************************************************************************************************************************/
+/*   Timeout Register (TOR)                                                                                               */
+/**************************************************************************************************************************/
+#define  UART_TOR(n)                            (UART_BASE_ADDR(n) + 0x001C) , UART_ACCESS, 8        /* Offset: UART_BA + 001Ch */
+#define  TOR_TOIE                        7 , 1               /* 7 TOIE (Timeout Interrupt Enable). Enabled only when this bit is set and IER register bit 0 is set.                   */
+#define  TOR_TOIC                        0 , 7               /* 6-0 TOIC (Timeout Interrupt Comparator). The timeout counter resets and starts counting (the counting clock =         */
+
+
+
+enum FCR_RFITL_type
+{
+    FCR_RFITL_1B    = 0x0,
+    FCR_RFITL_4B    = 0x4,
+    FCR_RFITL_8B    = 0x8,
+    FCR_RFITL_14B   = 0xC,
+};
+
+
+
+enum LCR_WLS_type
+{
+    LCR_WLS_5bit    = 0x0,
+    LCR_WLS_6bit    = 0x1,
+    LCR_WLS_7bit    = 0x2,
+    LCR_WLS_8bit    = 0x3,
+};
+
+
+enum IIR_IID_type
+{
+  IIR_IID_MODEM = 0x0,
+  IIR_IID_THRE  = 0x1,
+  IIR_IID_TOUT  = 0x5,
+  IIR_IID_RDA   = 0x2,
+  IIR_IID_RLS   = 0x3,
+};
+
+
+#endif // _UART_REGS_H
diff --git a/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.c b/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.c
new file mode 100755
index 0000000..1224195
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.c
@@ -0,0 +1,23 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   uart_if.c                                                                                             */
+/*            This file contains UART module driver selector                                               */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "../../Common/hal_common.h"
+#include "../../Chips/chip.h"
+
+#if defined(UART_MODULE_TYPE)
+    #include __MODULE_FILE_NAME(uart, UART_MODULE_TYPE)
+#endif    
+  
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.h b/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.h
new file mode 100755
index 0000000..9258fb1
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/uart/uart_if.h
@@ -0,0 +1,385 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   UART_if.h                                                                                             */
+/*            This file contains interface of UART driver                                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _UART_IF_H
+#define _UART_IF_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART ports definition                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    UART0_DEV = 0,  // UART0 is a general UART block without modem-I/O-control connection to external signals.
+    UART1_DEV = 1,  // UART1-3 are each a general UART with modem-I/O-control connection to external signals.
+    UART2_DEV = 2,
+    UART3_DEV = 3,
+} UART_DEV_T;
+
+#if defined NPCM650
+/*---------------------------------------------------------------------------------------------------------*/
+/* Uart Mux modes definitions                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+typedef enum
+{
+    UART_MUX_CORE_SNOOP        = 0,
+    UART_MUX_CORE_TAKEOVER     = 1,
+    UART_MUX_CORE_SP2__SP1_SI1 = 2,
+    UART_MUX_CORE_SP2__SP1_SI2 = 3,
+	UART_MUX_SKIP_CONFIG       = 4,
+} UART_MUX_T;
+
+#elif (defined NPCM750 || defined NPCM750_CP)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Uart Mux modes definitions. These numbers match the register field value. Do not change !               */
+/* s == snoop                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum UART_MUX_tag
+{
+    UART_MUX_MODE1_HSP1_SI2____HSP2_UART2__UART1_s_HSP1__UART3_s_SI2                = 0,       // 0 0 0: Mode 1 - HSP1 connected to SI2  , HSP2 connected to UART2 ,UART1 snoops HSP1, UART3 snoops SI2
+    UART_MUX_MODE2_HSP1_UART1__HSP2_SI2____UART2_s_HSP2__UART3_s_SI2                = 1,       // 0 0 1: Mode 2 - HSP1 connected to UART1, HSP2 connected to SI2   ,UART2 snoops HSP2, UART3 snoops SI2
+    UART_MUX_MODE3_HSP1_UART1__HSP2_UART2__UART3_SI2                                = 2,       // 0 1 0: Mode 3 - HSP1 connected to UART1, HSP2 connected to UART2 ,UART3 connected to SI2
+    UART_MUX_MODE4_HSP1_SI1____HSP2_SI2____UART1_s_SI1___UART3_s_SI2__UART2_s_HSP1  = 3,       // 0 1 1: Mode 4 - HSP1 connected to SI1  , HSP2 connected to SI2   ,UART1 snoops SI1,  UART3 snoops SI2,   UART2 snoops HSP1 (default)
+    UART_MUX_MODE5_HSP1_SI1____HSP2_UART2__UART1_s_HSP1__UART3_s_SI1                = 4,       // 1 0 0: Mode 5 - HSP1 connected to SI1  , HSP2 connected to UART2 ,UART1 snoops HSP1, UART3 snoops SI1
+    UART_MUX_MODE6_HSP1_SI1____HSP2_SI2____UART1_s_SI1___UART3_s_SI2__UART2_s_HSP2  = 5,       // 1 0 1: Mode 6 - HSP1 connected to SI1  , HSP2 connected to SI2   ,UART1 snoops SI1,  UART3 snoops SI2,   UART2 snoops HSP2
+    UART_MUX_MODE7_HSP1_SI1____HSP2_UART2__UART1_s_HSP1__UART3_SI2                  = 6,       // 1 1 0: Mode 7 - HSP1 connected to SI1  , HSP2 connected to UART2 ,UART1 snoops HSP1, UART3 connected to SI2
+    UART_MUX_RESERVED                                                               = 7,       // skip uart mode configuration.
+    UART_MUX_SKIP_CONFIG                                                            = 8        // this is a SW option to allow config of UART without touching the UART mux.
+} UART_MUX_T;
+
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Common baudrate definitions                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    UART_BAUDRATE_110       = 110,
+    UART_BAUDRATE_300       = 300,
+    UART_BAUDRATE_600       = 600,
+    UART_BAUDRATE_1200      = 1200,
+    UART_BAUDRATE_2400      = 2400,
+    UART_BAUDRATE_4800      = 4800,
+    UART_BAUDRATE_9600      = 9600,
+    UART_BAUDRATE_14400     = 14400,
+    UART_BAUDRATE_19200     = 19200,
+    UART_BAUDRATE_38400     = 38400,
+    UART_BAUDRATE_57600     = 57600,
+    UART_BAUDRATE_115200    = 115200,
+    UART_BAUDRATE_230400    = 230400,
+    UART_BAUDRATE_380400    = 380400,
+    UART_BAUDRATE_460800    = 460800,
+} UART_BAUDRATE_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Uart Rx Fifo Trigger level definitions                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    UART_RXFIFO_TRIGGER_1B      = 0x0,
+    UART_RXFIFO_TRIGGER_4B      = 0x1,
+    UART_RXFIFO_TRIGGER_8B      = 0x2,
+    UART_RXFIFO_TRIGGER_14B     = 0x3,
+} UART_RXFIFO_TRIGGER_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* UART parity types                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    UART_PARITY_NONE    = 0x00,
+    UART_PARITY_EVEN    = 0x01,
+    UART_PARITY_ODD     = 0x02,
+} UART_PARITY_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Uart stop bits                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    UART_STOPBIT_1          = 0x00,
+    UART_STOPBIT_DYNAMIC    = 0x01,
+} UART_STOPBIT_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Callback functions for UART IRQ handler                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef void (*UART_irq_callback_t)(UINT8 devNum, void *args);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_Init                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs UART initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_Init(UART_DEV_T devNum, UART_MUX_T muxMode, UART_BAUDRATE_T baudRate);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_PutC                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART                                                 */
+/*                  Note that the function is blocking till char can be send                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_PutC(UART_DEV_T devNum, const UINT8 c );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_GetC                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART                                                      */
+/*                  Note that the function is blocking till char is available                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT8 UART_GetC( UART_DEV_T devNum );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_PutC_NB                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         HAL_OK if the char was written or error if it couldn't be written                      */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART in NON-Blocking manner                          */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_PutC_NB(UART_DEV_T devNum, const UINT8 c );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_GetC_NB                                                                           */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         HAL_OK if char was read or error if it no char was available                           */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART in NON-Blocking manner                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_GetC_NB( UART_DEV_T devNum, UINT8* c );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_TestRX                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char in RX fifo                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN UART_TestRX( UART_DEV_T devNum );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_TestTX                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char in TX fifo                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN UART_TestTX( UART_DEV_T devNum );
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_ResetFIFOs                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  rxFifo - if TRUE RX fifo is reseted                                                    */
+/*                  txFifo - if TRUE TX fifo is reseted                                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs FIFO reset                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_ResetFIFOs(UART_DEV_T devNum, BOOLEAN txFifo, BOOLEAN rxFifo);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetTxIrqState                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  On -                                                                                   */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine enables/disables Tx Interrupt                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetTxIrqState(UART_DEV_T devNum, BOOLEAN On);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetRxIrqState                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  On -                                                                                   */
+/*                  timeout -                                                                              */
+/*                  triggerLevel -                                                                         */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Rx interrupt enable/disable                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetRxIrqState(UART_DEV_T devNum, BOOLEAN On);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetRxConfig                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  timeout -                                                                              */
+/*                  triggerLevel -                                                                         */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Rx irq configurations                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetRxConfig(UART_DEV_T devNum, UINT8 timeout, UART_RXFIFO_TRIGGER_T triggerLevel);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetParity                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  parity -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets parity configuration                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetParity(UART_DEV_T devNum, UART_PARITY_T parity);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBitsPerChar                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  bits -                                                                                 */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set bits per char                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBitsPerChar(UART_DEV_T devNum, UINT32 bits);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBaudrate                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  baudrate -                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets new baudrate                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBaudrate(UART_DEV_T devNum, UART_BAUDRATE_T baudrate);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetStopBit                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  stopbit -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets number of stopbits                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetStopBit(UART_DEV_T devNum, UART_STOPBIT_T stopbit);
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_SetBreak                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets break on the given UART                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_SetBreak(UART_DEV_T devNum, BOOLEAN state);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        UART_Isr                                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  rxCallback -                                                                           */
+/*                  rxParam -                                                                              */
+/*                  txCallback -                                                                           */
+/*                  txParam -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs IRQ handling                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS UART_Isr(UART_DEV_T devNum,  UART_irq_callback_t rxCallback, void* rxParam,
+                                        UART_irq_callback_t txCallback, void* txParam);
+#endif //_UART_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Modules/vcd/vcd_if.h b/board/nuvoton/common/BMC_HAL/Modules/vcd/vcd_if.h
new file mode 100755
index 0000000..1477620
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Modules/vcd/vcd_if.h
@@ -0,0 +1,564 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   vcd_if.h                                                                                              */
+/*            This file contains Interface library for Video Capture and Differentiate (VCD) block.        */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _VCD_IF_H
+#define _VCD_IF_H
+
+#include "defs.h"
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                  Types                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Pixel format for VCD_SetMode()                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum {rgb_555, rgb_222, rgb_666} VCD_PixelFormat;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* The VCD_VideoMode structure describes a video mode.                                                     */
+/* These values are constant for a given mode.                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+  char* name;           // name used to identify this mode
+  char* video_name;     // video name (vesa, sun, apple or Digita)
+
+  int internal_video;   // 1- if from internal GFX, 0- otherwize
+
+  UINT32 pixelClock;    // pixel clock frequency in Hz
+
+  int hdisp;            // displayed pixels i.e. width
+  int hfrontporch;      // front porch time in pixels (includes right border)
+  int hsync;            // hsync time in pixels
+  int hbackporch;       // back porch time in pixels (includes left border)
+
+  int vdisp;            // displayed lines i.e. height
+  int vfrontporch;      // front porch time in lines (includes bottom border)
+  int vsync;            // vsync time in lines
+  int vbackporch;       // back porch time in lines (includes top border)
+
+  int refresh_rate;     // number of refresh rates per second
+
+  int hpositive;        // polarities
+  int vpositive;
+
+} VCD_VideoMode;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS API Class                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           Interface functions                                           */
+/*                                                                                                         */
+/* Most routines return 0 for success, or a code from errno.h for failure.                                 */
+/*                                                                                                         */
+/* These functions are not thread safe: this should not be a problem, as                                   */
+/* only one thread should be using the VCD block.                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_Initialise_Ex                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  uSleep - optional uSleep from OS (can be NULL)                                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Initialise the VCD block and interface library.                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_Initialise_Ex(int (*uSleep) (unsigned int uSec));
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_HWIsPresent                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Test whether the VCD block is present. (Useful with FPGA emulation)                    */
+/*                  There is no ID or version register, so test the writable bits in                       */
+/*                  some of the registers.                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_HWIsPresent(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Stop and reset the VCD state machine.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_Reset(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_Command                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cmd -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Start a VCD command                                                                    */
+/*                  cmd is a VCD_CMD value (VCD_CMD_OPER_xxxx).                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_Command(UINT32 cmd);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function Prototype: VCD_SetFrameBufferAddrs                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  PhysAddrA - Frame buffer A address (must be aligned to 512-byte boundaries)            */
+/*                  PhysAddrB - Frame buffer B address (must be aligned to 512-byte boundaries)            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set the two frame buffer addresses.                                                    */
+/*                  These must be aligned to 512-byte boundaries                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int VCD_SetFrameBufferAddrs(UINT32 PhysAddrA, UINT32 PhysAddrB);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetMode                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  initDiff -                                                                             */
+/*                  threshold -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set the VCD mode.                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetMode(UINT32 threshold, BOOLEAN initDiff);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetPixelFormat                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  pixelFormat -                                                                          */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set the VCD pixel format and line pitch.                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetPixelFormat(VCD_PixelFormat pixelFormat);
+
+
+#define VCD_DONE (1<<0)  // VCD State Machine Done Interrupt Enable
+#define VCD_IFOR (1<<3)  // Input FIFO Overrun Interrupt Enable
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetStatus                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return the current VCD status.                                                         */
+/*                  This is the raw hardware register, with bits as defined in vcd.h.                      */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetStatus(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetInterruptEnable                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flags -                                                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set or clear VCD Interrup Enable flags.                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void VCD_SetInterruptEnable(UINT32 flags);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_IsInterruptEnable                                                                  */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns true if one of VCD interrupts is enabled                          */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_IsInterruptEnabled(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_IsStatusBusy                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return TRUE if VCD is busy                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_IsStatusBusy(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* The following routines provide more convenient access to                                                */
+/* commonly-used status fields.                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetCurrentLine                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return the frame line currently being processed.                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetCurrentLine(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_IsDone                                                                               */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return true if the last capture/compare operation has completed.                       */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_IsDone(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_OperationOK                                                                        */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return true if the last capture/compare operation was successful.                      */
+/*                  A false result means that the operation needs some attention - i.e.                    */
+/*                  there was a FIFO overrun, the resolution has changed, or a blue screen                 */
+/*                  was detected.                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_OperationOK(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_EnableBlueScreenDetection                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  blueColour -                                                                           */
+/*                  pixelCount -                                                                           */
+/*                  tolerance -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Enable blue screen detection.                                                          */
+/*                  blueColour is interpreted in the current pixel format as set in VCD_MODE.              */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_EnableBlueScreenDetection(  UINT32 blueColour,
+                                    UINT32 pixelCount,
+                                    UINT32 tolerance);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_EnableBlueScreenDetection                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  blueColour -                                                                           */
+/*                  pixelCount -                                                                           */
+/*                  tolerance -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Disable blue screen detection.                                                         */
+/*                  blueColour is interpreted in the current pixel format as set in VCD_MODE.              */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_DisableBlueScreenDetection(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetupResChangeDetection                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dispChangeTol -                                                                        */
+/*                  horChangeTol -                                                                         */
+/*                  prescale -                                                                             */
+/*                  vertChangeTol -                                                                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set up Resolution Change Detection.                                                    */
+/*                  Prescale should be 0 to disable detection, or 1-15 to enable.                          */
+/*                  The tolerance values specify what changes are ignored for the horizontal,              */
+/*                  vertical, and display resolution timer/counters respectively.                          */
+/*                  Tolerance values can be 0, 1, 2, 4, 8, 16 or 32.                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetupResChangeDetection(UINT32 prescale,
+                      UINT32 horChangeTol,
+                      UINT32 vertChangeTol,
+                      UINT32 dispChangeTol);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_CheckResChangeEx                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  gtfMode_p -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Check whether the mode has changed and set videoMode appropriately.                    */
+/*                  Returns true if the mode has changed, false otherwise.                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_CheckResChangeEx(VCD_VideoMode **gtfMode_p);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetVideoMode                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Return the current video mode or null if unrecognised.                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+const VCD_VideoMode *VCD_GetVideoMode(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetLinePitch                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Get the line pitch (in bytes) for the two frame buffers                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetLinePitch(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetCaptureResolution                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  horRes -                                                                               */
+/*                  vertRes -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  Set the capture resolution in pixels.                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetCaptureResolution(UINT32 horRes, UINT32 vertRes);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetLocalDisplay                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  LocalDisplayIsActive -                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  If LocalDisplayIsActive == 0 the local display is disabled and the                     */
+/*                  bandwidth is reduced.                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+void VCD_SetLocalDisplay(BOOLEAN LocalDisplayIsActive);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetLocalDisplayIsActive                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns true if Local display is active, otherwise returns false          */
+/*---------------------------------------------------------------------------------------------------------*/
+BOOLEAN VCD_GetLocalDisplayIsActive(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Routines for setting and reading the FIFO parameters                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetFifoPreRead                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  preRead -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the Fifo Read Ahead - the Input Buffer FIFO threshold for when to    */
+/*                  return compare mode, once the threshold defined by FIFO_TH is crossed                  */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetFifoPreRead(UINT32 preRead);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetFifoPreRead                                                                     */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the Fifo Read Ahead value                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetFifoPreRead(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetFifoThreshold                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  threshold -                                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the FIFO Threshold - the Input Buffer FIFO threshold for stop        */
+/*                  comparing in Compare while Capture mode. This is a relative value in 1/16 FIFO size    */
+/*                  increments                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetFifoThreshold(UINT32 threshold);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetFifoThreshold                                                                   */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the FIFO Threshold                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetFifoThreshold(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetDropThreshold                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  drop -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the DROP Threshold - the Input Buffer FIFO threshold for when to     */
+/*                  return to compare mode, once the threshold defined by FIFO_TH is crossed               */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetDropThreshold(UINT32 drop);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetDropThreshold                                                                   */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the DROP Threshold                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetDropThreshold(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetFifoDic                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dic -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the Disable INCR Command for 128 bytes read - When set, disables     */
+/*                  using INCR AHB bus command for 128 bytes read. In this case, 2 INCR16 commands will    */
+/*                  be used                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetFifoDic(UINT32 dic);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetFifoDic                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the Disable INCR Command for 128 bytes read                       */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetFifoDic(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_SetFifoHrb                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  hrb -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets the Half Read Buffer - When set, reduces read buffer depth to 256    */
+/*                  bytes, by not requesting data if FIFO content + request is over 256 bytes.             */
+/*                  Intended to tune bus usage if needed                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+int VCD_SetFifoHrb(UINT32 hrb);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        VCD_GetFifoHrb                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the Half Read Buffer                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 VCD_GetFifoHrb(void);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif //_VCD_IF_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.c
new file mode 100755
index 0000000..c11aeb7
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.c
@@ -0,0 +1,378 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm5221_drv.c                                                                                        */
+/*            This file contains BCM5221 PHY driver implementation                                        */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_DRV_C
+
+#include <defs.h>
+#include "bcm5221_drv.h"
+#include "bcm5221_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_TIMEOUT_COUNT       100000
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_PHY_REG_READ_T   RegReadCallback;
+static ETH_PHY_REG_WRITE_T  RegWriteCallback;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access functions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  BCM5221_PhyRegRead_L    (UINT32 addr);
+static void    BCM5221_PhyRegWrite_L   (UINT32 addr, UINT32 data);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access redirections                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_R8         BCM5221_PhyRegRead_L
+#define BCM5221_R16        BCM5221_PhyRegRead_L
+#define BCM5221_R32        BCM5221_PhyRegRead_L
+
+#define BCM5221_W8         BCM5221_PhyRegWrite_L
+#define BCM5221_W16        BCM5221_PhyRegWrite_L
+#define BCM5221_W32        BCM5221_PhyRegWrite_L
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5221 Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const ETH_PHY_OPS_T BCM5221_Ops =
+{
+    BCM5221_ID,
+
+    BCM5221_Init,
+    BCM5221_GetID,
+    BCM5221_Reset,
+    BCM5221_AutoNegotiate,
+    BCM5221_GetLinkCapabilities,
+    BCM5221_SetLinkCapabilities,
+};
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_Init                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  reg_read    - Phy registers read function                                              */
+/*                  reg_write   - Phy registers write function                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs BCM5221 driver initialization                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  BCM5221_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy driver initialize                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    RegReadCallback     = phy_reg_read;
+    RegWriteCallback    = phy_reg_write;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_GetID                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of the phy to access                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine return ID of the PHY                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 BCM5221_GetID(UINT devNum, UINT phyNum)
+{
+    return (UINT32)((REG_READ(BCM5221_PHYIDR1(devNum, phyNum))<<16) | REG_READ(BCM5221_PHYIDR2(devNum, phyNum)));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_Reset                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of the phy to reset                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine resets the PHY                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5221_Reset(UINT devNum, UINT phyNum)
+{
+    UINT32 timeout = BCM5221_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting reset                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_RESET, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Waiting for reset to complete                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_RESET))
+    {
+        if (timeout-- == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If reset is too long, exit with error                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_AutoNegotiate                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Phy number to access                                                         */
+/*                  speed   - Max supported capabilities                                                   */
+/*                  duplex  -            "                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Auto Negotiation                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5221_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex)
+{
+    UINT32 timeout = BCM5221_TIMEOUT_COUNT;
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling auto negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting capabilities for advertising                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        if (speed == ETH_SPEED_100)
+        {
+            SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_100_FULL, 1);
+            SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_100_HALF, 1);
+        }
+
+        SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_10_FULL, 1);
+        SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_10_HALF, 1);
+    }
+    else
+    {
+        if (speed == ETH_SPEED_100)
+        {
+            SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_100_HALF, 1);
+        }
+
+        SET_REG_FIELD(BCM5221_ANAR(devNum, phyNum), ANAR_10_HALF, 1);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling auto negotiation                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Re-Starting auto negotiation                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_RESTART_AUTONEG, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait for auto-negotiation complete                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_AUTONEG_COMPLETE))
+    {
+        if (timeout-- == 0)
+        {
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_GetLinkCapabilities                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of PHY to access                                                     */
+/*                  speed   - Speed of the Link                                                            */
+/*                  duplex  - Duplexity of the Link                                                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns established Link Capabilities.                                    */
+/*                  It should be called upon successful Auto-Negotiation                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5221_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking parameters                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((speed == NULL) || (duplex == NULL))
+        return HAL_ERROR_BAD_PARAM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if valid link established                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_LINK))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Valid link was not established!                                                                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        return HAL_ERROR_NO_LINK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting duplex setting                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_10_FD) || READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_100_FD)))
+        *duplex = ETH_DUPLEX_FULL;
+    else
+        *duplex = ETH_DUPLEX_HALF;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting speed setting                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_100_HD) || READ_REG_FIELD(BCM5221_BMSR(devNum, phyNum), HAL_BMSR_100_FD)))
+        *speed = ETH_SPEED_100;
+    else
+        *speed = ETH_SPEED_10;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_SetLinkCapabilities                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev     - MAC module number                                                            */
+/*                  phyNum  - Address of PHY to access                                                     */
+/*                  speed   - Ethernet Speed settings                                                      */
+/*                  duplex  - Ethernet Duplex settings                                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets link capabilities of the PHY                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5221_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting speed                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_SPEED_SELECT, 0);
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_SPEED_SELECT, 1);
+    }
+    else
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Seting duplex                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_DUPLEX_MODE, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(BCM5221_BMCR(devNum, phyNum), HAL_BMCR_DUPLEX_MODE, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             LOCAL FUNCTIONS                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_PhyRegRead_L                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs read from register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 BCM5221_PhyRegRead_L(UINT32 addr)
+{
+    if (RegReadCallback)
+    {
+        return RegReadCallback(BCM5221_ADDRESS_DEV(addr), BCM5221_ADDRESS_PHY(addr), BCM5221_ADDRESS_OFFS(addr));
+    }
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5221_PhyRegWrite_L                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs write to register                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void BCM5221_PhyRegWrite_L(UINT32 addr, UINT32 data)
+{
+    if (RegWriteCallback)
+    {
+        RegWriteCallback(BCM5221_ADDRESS_DEV(addr),  BCM5221_ADDRESS_PHY(addr), BCM5221_ADDRESS_OFFS(addr), data);
+    }
+}
+
+
+#undef BCM5221_DRV_C
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.h
new file mode 100755
index 0000000..638ad30
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_drv.h
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   dp83848c_drv.h                                                                                        */
+/*            This file contains BCM5221 PHY driver interface                                             */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _BCM5221_DRV_H
+#define _BCM5221_DRV_H
+
+#include "defs.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Common/hal_ethernet.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5221 ID                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_ID     0x004061E0
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interface functions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  BCM5221_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+UINT32      BCM5221_GetID(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM5221_Reset(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM5221_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex);
+HAL_STATUS  BCM5221_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+HAL_STATUS  BCM5221_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5221 Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const extern ETH_PHY_OPS_T BCM5221_Ops;
+
+#endif //_BCM5221_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_regs.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_regs.h
new file mode 100755
index 0000000..a6fffa0
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5221/bcm5221_regs.h
@@ -0,0 +1,60 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm5221_regs.h                                                                                       */
+/*            This file contains BCM5221 PHY registers                                                    */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _BCM5221_REG_H
+#define _BCM5221_REG_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining access type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_ACCESS                             BCM5221_
+#define BCM5221_ADDRESS(dev, phyNum, offset)       (((dev & 0xFF) << 16) | ((phyNum & 0xFF) << 8) | (offset & 0xFF))
+
+#define BCM5221_ADDRESS_DEV(addr)                  ((addr >> 16)   & 0xFF)
+#define BCM5221_ADDRESS_PHY(addr)                  ((addr >> 8)    & 0xFF)
+#define BCM5221_ADDRESS_OFFS(addr)                 ( addr          & 0xFF)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy basic registers                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_BMCR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x00),  BCM5221_ACCESS,    16
+#define BCM5221_BMSR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x01),  BCM5221_ACCESS,    16
+#define BCM5221_PHYIDR1(dev, phy)       BCM5221_ADDRESS(dev, phy, 0x02),  BCM5221_ACCESS,    16
+#define BCM5221_PHYIDR2(dev, phy)       BCM5221_ADDRESS(dev, phy, 0x03),  BCM5221_ACCESS,    16
+#define BCM5221_ANAR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x04),  BCM5221_ACCESS,    16
+#define BCM5221_ANLPAR(dev, phy)        BCM5221_ADDRESS(dev, phy, 0x05),  BCM5221_ACCESS,    16
+#define BCM5221_ANLPARNP(dev, phy)      BCM5221_ADDRESS(dev, phy, 0x05),  BCM5221_ACCESS,    16
+#define BCM5221_ANER(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x06),  BCM5221_ACCESS,    16
+#define BCM5221_ANNPTR(dev, phy)        BCM5221_ADDRESS(dev, phy, 0x07),  BCM5221_ACCESS,    16
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy extended registers                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5221_PHYSTS(dev, phy)        BCM5221_ADDRESS(dev, phy, 0x10),  BCM5221_ACCESS,    16
+#define BCM5221_MICR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x11),  BCM5221_ACCESS,    16
+#define BCM5221_MISR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x12),  BCM5221_ACCESS,    16
+#define BCM5221_FCSCR(dev, phy)         BCM5221_ADDRESS(dev, phy, 0x14),  BCM5221_ACCESS,    16
+#define BCM5221_RECR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x15),  BCM5221_ACCESS,    16
+#define BCM5221_PCSR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x16),  BCM5221_ACCESS,    16
+#define BCM5221_RBR(dev, phy)           BCM5221_ADDRESS(dev, phy, 0x17),  BCM5221_ACCESS,    16
+#define BCM5221_LEDCR(dev, phy)         BCM5221_ADDRESS(dev, phy, 0x18),  BCM5221_ACCESS,    16
+#define BCM5221_PHYCR2(dev, phy)        BCM5221_ADDRESS(dev, phy, 0x19),  BCM5221_ACCESS,    16
+#define BCM5221_BTSCR(dev, phy)         BCM5221_ADDRESS(dev, phy, 0x1A),  BCM5221_ACCESS,    16
+#define BCM5221_CDCTRL1(dev, phy)       BCM5221_ADDRESS(dev, phy, 0x1B),  BCM5221_ACCESS,    16
+#define BCM5221_EDCR(dev, phy)          BCM5221_ADDRESS(dev, phy, 0x1D),  BCM5221_ACCESS,    16
+
+
+#endif //_BCM5221_REG_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.c
new file mode 100755
index 0000000..5c7767f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.c
@@ -0,0 +1,389 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54210e_drv.c                                                                                         */
+/*            This file contains BCM54210E Gigabit Phy driver implementation                                 */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <defs.h>
+#include "bcm54210e_drv.h"
+#include "bcm54210e_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54210E Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const ETH_PHY_OPS_T BCM54210E_Ops =
+{
+    BCM54210E_ID,
+
+    BCM54210E_Init,
+    BCM54210E_GetID,
+    BCM54210E_Reset,
+    BCM54210E_AutoNegotiate,
+    BCM54210E_GetLinkCapabilities,
+    BCM54210E_SetLinkCapabilities,
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54210E_TIMEOUT_COUNT       1000000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_PHY_REG_READ_T   RegReadCallback;
+static ETH_PHY_REG_WRITE_T  RegWriteCallback;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access functions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  BCM54210E_PhyRegRead_L    (UINT32 addr);
+static void    BCM54210E_PhyRegWrite_L   (UINT32 addr, UINT32 data);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access redirections                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54210E_R8         BCM54210E_PhyRegRead_L
+#define BCM54210E_R16        BCM54210E_PhyRegRead_L
+#define BCM54210E_R32        BCM54210E_PhyRegRead_L
+
+#define BCM54210E_W8         BCM54210E_PhyRegWrite_L
+#define BCM54210E_W16        BCM54210E_PhyRegWrite_L
+#define BCM54210E_W32        BCM54210E_PhyRegWrite_L
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_Init                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  phy_reg_read    - Phy register read  callback                                          */
+/*                  phy_reg_write   - Phy register write callback                                          */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY driver initialization                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54210E_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write)
+{
+    RegReadCallback     = phy_reg_read;
+    RegWriteCallback    = phy_reg_write;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_GetID                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns PHY Identification                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 BCM54210E_GetID(UINT devNum, UINT phyNum)
+{
+    return (UINT32)(REG_READ(BCM54210E_PHY_ID2(devNum, phyNum)) | (REG_READ(BCM54210E_PHY_ID1(devNum, phyNum)) << 16));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_Reset                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY reset                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54210E_Reset(UINT devNum, UINT phyNum)
+{
+    UINT32 timeout = BCM54210E_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting reset                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_RST, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Waiting for reset to complete                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_RST))
+    {
+        if (timeout-- == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If reset is too long, exit with error                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_AutoNegotiate                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Max ETH speed to be announced to the link                                     */
+/*                  duplex - Max ETH duplexity setting to be announced to the link                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Auto-Negotiation with the link                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54210E_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex)
+{
+    UINT32 timeout = BCM54210E_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Advertise capabilities                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_1000)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54210E_BASET_CON(devNum, phyNum),    BASET_CON_1000FULL  , 1);
+            SET_REG_FIELD(BCM54210E_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54210E_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+    else
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54210E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling Auto-Negotiation and restarting it                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 1);
+    SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_RESTART_AN, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for auto-negotiation complete                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(BCM54210E_MII_STAT(devNum, phyNum), MII_STAT_AN_COMPLETED))
+    {
+        if (timeout-- == 0)
+        {
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_GetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Pointer where ETH speed would be placed                                       */
+/*                  duplex - Pointer where ETH duplexity would be placed                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine retrives established link capabilities after successfull Auto-Negotiation */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54210E_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((speed == NULL) || (duplex == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* if Auto-Negotiation wasn't completed and no linked created, return error                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_FIELD(BCM54210E_AUX_STAT(devNum, phyNum), AUX_STAT_AN_COMPLETE))
+    {
+        return HAL_ERROR_NO_LINK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting capabilities                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    switch (READ_REG_FIELD(BCM54210E_AUX_STAT(devNum, phyNum), AUX_STAT_HCD))
+    {
+        case AUX_STAT_HCD_1000FULL:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_1000HALF:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_100FULL:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_100HALF:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_10FULL:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_10HALF:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_HALF;  break;
+
+        default:      return HAL_ERROR;
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_SetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  duplex -                                                                               */
+/*                  phyNum -                                                                               */
+/*                  speed -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs...                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54210E_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting speed                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 1);
+    }
+    else if (speed == ETH_SPEED_1000)
+    {
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 1);
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Seting duplex                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(BCM54210E_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Local functions                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_PhyRegRead_L                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads from PHY register                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  BCM54210E_PhyRegRead_L(UINT32 addr)
+{
+    return RegReadCallback(BCM54210E_ADDRESS_DEV(addr), BCM54210E_ADDRESS_PHY(addr), BCM54210E_ADDRESS_OFFS(addr));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54210E_PhyRegWrite_L                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes to PHY register                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void    BCM54210E_PhyRegWrite_L(UINT32 addr, UINT32 data)
+{
+    RegWriteCallback(BCM54210E_ADDRESS_DEV(addr), BCM54210E_ADDRESS_PHY(addr), BCM54210E_ADDRESS_OFFS(addr), data);
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.h
new file mode 100755
index 0000000..d029872
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_drv.h
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54612e_drv.h                                                                                         */
+/*            This file contains BCM54210E Gigabit Phy driver interface                                      */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM54210E_DRV_H
+#define _BCM54210E_DRV_H
+
+#include "defs.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Common/hal_ethernet.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54210E ID                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54210E_ID     0x600D84A2    // Version B1    - DRB use BCM54210EB1KMLG
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interface functions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  BCM54210E_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+UINT32      BCM54210E_GetID(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM54210E_Reset(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM54210E_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex);
+HAL_STATUS  BCM54210E_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+HAL_STATUS  BCM54210E_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54210E Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const extern ETH_PHY_OPS_T BCM54210E_Ops;
+
+#endif //_BCM54210E_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_regs.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_regs.h
new file mode 100755
index 0000000..70ca9ee
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54210e/bcm54210e_regs.h
@@ -0,0 +1,60 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54210e_regs.h                                                                                        */
+/*            This file contains BCM54210E Gigabit Phy register definition                                   */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM54210E_REGS_H
+#define _BCM54210E_REGS_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining access type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54210E_ACCESS                          BCM54210E_
+#define BCM54210E_ADDRESS(dev, phyNum, offset)    (((dev & 0xFF) << 16) | ((phyNum & 0xFF) << 8) | (offset & 0xFF))
+
+#define BCM54210E_ADDRESS_DEV(addr)               ((addr >> 16)   & 0xFF)
+#define BCM54210E_ADDRESS_PHY(addr)               ((addr >> 8)    & 0xFF)
+#define BCM54210E_ADDRESS_OFFS(addr)              ( addr          & 0xFF)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy registers                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54210E_MII_CON(dev, phy)               BCM54210E_ADDRESS(dev, phy, 0x00),  BCM54210E_ACCESS,    16
+#define BCM54210E_MII_STAT(dev, phy)              BCM54210E_ADDRESS(dev, phy, 0x01),  BCM54210E_ACCESS,    16
+#define BCM54210E_PHY_ID1(dev, phy)               BCM54210E_ADDRESS(dev, phy, 0x02),  BCM54210E_ACCESS,    16
+#define BCM54210E_PHY_ID2(dev, phy)               BCM54210E_ADDRESS(dev, phy, 0x03),  BCM54210E_ACCESS,    16
+#define BCM54210E_AN_ADV(dev, phy)                BCM54210E_ADDRESS(dev, phy, 0x04),  BCM54210E_ACCESS,    16
+#define BCM54210E_AN_LNK(dev, phy)                BCM54210E_ADDRESS(dev, phy, 0x05),  BCM54210E_ACCESS,    16
+#define BCM54210E_AN_EXP(dev, phy)                BCM54210E_ADDRESS(dev, phy, 0x06),  BCM54210E_ACCESS,    16
+#define BCM54210E_NPT(dev, phy)                   BCM54210E_ADDRESS(dev, phy, 0x07),  BCM54210E_ACCESS,    16
+#define BCM54210E_LPRNP(dev, phy)                 BCM54210E_ADDRESS(dev, phy, 0x08),  BCM54210E_ACCESS,    16
+#define BCM54210E_BASET_CON(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x09),  BCM54210E_ACCESS,    16
+#define BCM54210E_BASET_STAT(dev, phy)            BCM54210E_ADDRESS(dev, phy, 0x0A),  BCM54210E_ACCESS,    16
+#define BCM54210E_EXT_STAT(dev,phy)               BCM54210E_ADDRESS(dev, phy, 0x0F),  BCM54210E_ACCESS,    16
+#define BCM54210E_PHY_EXT_CON(dev, phy)           BCM54210E_ADDRESS(dev, phy, 0x10),  BCM54210E_ACCESS,    16
+#define BCM54210E_PHY_EXT_STAT(dev, phy)          BCM54210E_ADDRESS(dev, phy, 0x11),  BCM54210E_ACCESS,    16
+#define BCM54210E_Rx_ERROR(dev, phy)              BCM54210E_ADDRESS(dev, phy, 0x12),  BCM54210E_ACCESS,    16
+#define BCM54210E_FALSE_CARRIER(dev, phy)         BCM54210E_ADDRESS(dev, phy, 0x13),  BCM54210E_ACCESS,    16
+#define BCM54210E_Rx_NOT_OK(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x14),  BCM54210E_ACCESS,    16
+#define BCM54210E_EXP_REG_ACC(dev, phy)           BCM54210E_ADDRESS(dev, phy, 0x17),  BCM54210E_ACCESS,    16
+#define BCM54210E_AUX_CTRL_SV(dev, phy)           BCM54210E_ADDRESS(dev, phy, 0x18),  BCM54210E_ACCESS,    16
+#define BCM54210E_AUX_STAT(dev, phy)              BCM54210E_ADDRESS(dev, phy, 0x19),  BCM54210E_ACCESS,    16
+#define BCM54210E_INTR_STAT(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x1A),  BCM54210E_ACCESS,    16
+#define BCM54210E_INTR_MASK(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x1B),  BCM54210E_ACCESS,    16
+#define BCM54210E_AUX_CTRL2(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x1C),  BCM54210E_ACCESS,    16
+#define BCM54210E_MASTER_SLAVE(dev, phy)          BCM54210E_ADDRESS(dev, phy, 0x1D),  BCM54210E_ACCESS,    16
+#define BCM54210E_TEST_REG1(dev, phy)             BCM54210E_ADDRESS(dev, phy, 0x1E),  BCM54210E_ACCESS,    16
+
+
+
+#endif //_BCM54210E_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.c
new file mode 100755
index 0000000..00b603c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.c
@@ -0,0 +1,397 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54612e_drv.c                                                                                       */
+/*            This file contains BCM54612E Gigabit Phy driver implementation                               */
+/*            Also this driver enable 125Mhz clock out for PolegSVB                                        */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <defs.h>
+#include "bcm54612e_drv.h"
+#include "bcm54612e_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54612E Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const ETH_PHY_OPS_T BCM54612E_Ops =
+{
+    BCM54612E_ID,
+
+    BCM54612E_Init,
+    BCM54612E_GetID,
+    BCM54612E_Reset,
+    BCM54612E_AutoNegotiate,
+    BCM54612E_GetLinkCapabilities,
+    BCM54612E_SetLinkCapabilities,
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54612E_TIMEOUT_COUNT       1000000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_PHY_REG_READ_T   RegReadCallback;
+static ETH_PHY_REG_WRITE_T  RegWriteCallback;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access functions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  BCM54612E_PhyRegRead_L    (UINT32 addr);
+static void    BCM54612E_PhyRegWrite_L   (UINT32 addr, UINT32 data);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access redirections                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54612E_R8         BCM54612E_PhyRegRead_L
+#define BCM54612E_R16        BCM54612E_PhyRegRead_L
+#define BCM54612E_R32        BCM54612E_PhyRegRead_L
+
+#define BCM54612E_W8         BCM54612E_PhyRegWrite_L
+#define BCM54612E_W16        BCM54612E_PhyRegWrite_L
+#define BCM54612E_W32        BCM54612E_PhyRegWrite_L
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_Init                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  phy_reg_read    - Phy register read  callback                                          */
+/*                  phy_reg_write   - Phy register write callback                                          */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY driver initialization                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54612E_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write)
+{
+    RegReadCallback     = phy_reg_read;
+    RegWriteCallback    = phy_reg_write;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_GetID                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns PHY Identification                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 BCM54612E_GetID(UINT devNum, UINT phyNum)
+{
+    return (UINT32)(REG_READ(BCM54612E_PHY_ID2(devNum, phyNum)) | (REG_READ(BCM54612E_PHY_ID1(devNum, phyNum)) << 16));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_Reset                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY reset                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54612E_Reset(UINT devNum, UINT phyNum)
+{
+    UINT32 timeout = BCM54612E_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting reset                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_RST, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Waiting for reset to complete                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_RST))
+    {
+        if (timeout-- == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If reset is too long, exit with error                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* 125Mhz Clock Output Enable                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/    
+    SET_REG_FIELD(BCM54612E_EXP_REG_ACC(devNum, phyNum), BCM54612E_EXP_SELECT, 0xD34);       // Enable Top Level Expantion Register 34H
+    SET_REG_FIELD(BCM54612E_EXP_TOP_LVL(devNum, phyNum), BCM54612E_125MHZ_EN, 1);            // Enable 125MHZ clock output 
+    SET_REG_FIELD(BCM54612E_EXP_REG_ACC(devNum, phyNum), BCM54612E_EXP_SELECT, 0x000);       // Disable Top Level Expantion Register 34H
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_AutoNegotiate                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Max ETH speed to be announced to the link                                     */
+/*                  duplex - Max ETH duplexity setting to be announced to the link                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Auto-Negotiation with the link                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54612E_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex)
+{
+    UINT32 timeout = BCM54612E_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Advertise capabilities                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_1000)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54612E_BASET_CON(devNum, phyNum),    BASET_CON_1000FULL  , 1);
+            SET_REG_FIELD(BCM54612E_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54612E_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+    else
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM54612E_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling Auto-Negotiation and restarting it                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 1);
+    SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_RESTART_AN, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for auto-negotiation complete                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(BCM54612E_MII_STAT(devNum, phyNum), MII_STAT_AN_COMPLETED))
+    {
+        if (timeout-- == 0)
+        {
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_GetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Pointer where ETH speed would be placed                                       */
+/*                  duplex - Pointer where ETH duplexity would be placed                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine retrives established link capabilities after successfull Auto-Negotiation */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54612E_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((speed == NULL) || (duplex == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* if Auto-Negotiation wasn't completed and no linked created, return error                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_FIELD(BCM54612E_AUX_STAT(devNum, phyNum), AUX_STAT_AN_COMPLETE))
+    {
+        return HAL_ERROR_NO_LINK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting capabilities                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    switch (READ_REG_FIELD(BCM54612E_AUX_STAT(devNum, phyNum), AUX_STAT_HCD))
+    {
+        case AUX_STAT_HCD_1000FULL:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_1000HALF:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_100FULL:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_100HALF:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_10FULL:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_10HALF:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_HALF;  break;
+
+        default:      return HAL_ERROR;
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_SetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  duplex -                                                                               */
+/*                  phyNum -                                                                               */
+/*                  speed -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs...                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM54612E_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting speed                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 1);
+    }
+    else if (speed == ETH_SPEED_1000)
+    {
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED1, 1);
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Seting duplex                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(BCM54612E_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Local functions                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_PhyRegRead_L                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads from PHY register                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  BCM54612E_PhyRegRead_L(UINT32 addr)
+{
+    return RegReadCallback(BCM54612E_ADDRESS_DEV(addr), BCM54612E_ADDRESS_PHY(addr), BCM54612E_ADDRESS_OFFS(addr));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM54612E_PhyRegWrite_L                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes to PHY register                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void    BCM54612E_PhyRegWrite_L(UINT32 addr, UINT32 data)
+{
+    RegWriteCallback(BCM54612E_ADDRESS_DEV(addr), BCM54612E_ADDRESS_PHY(addr), BCM54612E_ADDRESS_OFFS(addr), data);
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.h
new file mode 100755
index 0000000..80add00
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_drv.h
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54612e_drv.h                                                                                         */
+/*            This file contains BCM54612E Gigabit Phy driver interface                                      */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM54612E_DRV_H
+#define _BCM54612E_DRV_H
+
+#include "defs.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Common/hal_ethernet.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54612E ID                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54612E_ID     0x03625E6A
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interface functions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  BCM54612E_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+UINT32      BCM54612E_GetID(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM54612E_Reset(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM54612E_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex);
+HAL_STATUS  BCM54612E_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+HAL_STATUS  BCM54612E_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM54612E Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const extern ETH_PHY_OPS_T BCM54612E_Ops;
+
+#endif //_BCM54612E_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_regs.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_regs.h
new file mode 100755
index 0000000..068082b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm54612e/bcm54612e_regs.h
@@ -0,0 +1,64 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm54612e_regs.h                                                                                        */
+/*            This file contains BCM54612E Gigabit Phy register definition                                   */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM54612E_REGS_H
+#define _BCM54612E_REGS_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining access type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54612E_ACCESS                          BCM54612E_
+#define BCM54612E_ADDRESS(dev, phyNum, offset)    (((dev & 0xFF) << 16) | ((phyNum & 0xFF) << 8) | (offset & 0xFF))
+
+#define BCM54612E_ADDRESS_DEV(addr)               ((addr >> 16)   & 0xFF)
+#define BCM54612E_ADDRESS_PHY(addr)               ((addr >> 8)    & 0xFF)
+#define BCM54612E_ADDRESS_OFFS(addr)              ( addr          & 0xFF)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy registers                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM54612E_MII_CON(dev, phy)               BCM54612E_ADDRESS(dev, phy, 0x00),  BCM54612E_ACCESS,    16
+#define BCM54612E_MII_STAT(dev, phy)              BCM54612E_ADDRESS(dev, phy, 0x01),  BCM54612E_ACCESS,    16
+#define BCM54612E_PHY_ID1(dev, phy)               BCM54612E_ADDRESS(dev, phy, 0x02),  BCM54612E_ACCESS,    16
+#define BCM54612E_PHY_ID2(dev, phy)               BCM54612E_ADDRESS(dev, phy, 0x03),  BCM54612E_ACCESS,    16
+#define BCM54612E_AN_ADV(dev, phy)                BCM54612E_ADDRESS(dev, phy, 0x04),  BCM54612E_ACCESS,    16
+#define BCM54612E_AN_LNK(dev, phy)                BCM54612E_ADDRESS(dev, phy, 0x05),  BCM54612E_ACCESS,    16
+#define BCM54612E_AN_EXP(dev, phy)                BCM54612E_ADDRESS(dev, phy, 0x06),  BCM54612E_ACCESS,    16
+#define BCM54612E_NPT(dev, phy)                   BCM54612E_ADDRESS(dev, phy, 0x07),  BCM54612E_ACCESS,    16
+#define BCM54612E_LPRNP(dev, phy)                 BCM54612E_ADDRESS(dev, phy, 0x08),  BCM54612E_ACCESS,    16
+#define BCM54612E_BASET_CON(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x09),  BCM54612E_ACCESS,    16
+#define BCM54612E_BASET_STAT(dev, phy)            BCM54612E_ADDRESS(dev, phy, 0x0A),  BCM54612E_ACCESS,    16
+#define BCM54612E_EXT_STAT(dev,phy)               BCM54612E_ADDRESS(dev, phy, 0x0F),  BCM54612E_ACCESS,    16
+#define BCM54612E_PHY_EXT_CON(dev, phy)           BCM54612E_ADDRESS(dev, phy, 0x10),  BCM54612E_ACCESS,    16
+#define BCM54612E_PHY_EXT_STAT(dev, phy)          BCM54612E_ADDRESS(dev, phy, 0x11),  BCM54612E_ACCESS,    16
+#define BCM54612E_Rx_ERROR(dev, phy)              BCM54612E_ADDRESS(dev, phy, 0x12),  BCM54612E_ACCESS,    16
+#define BCM54612E_FALSE_CARRIER(dev, phy)         BCM54612E_ADDRESS(dev, phy, 0x13),  BCM54612E_ACCESS,    16
+#define BCM54612E_Rx_NOT_OK(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x14),  BCM54612E_ACCESS,    16
+#define BCM54612E_EXP_TOP_LVL(dev, phy)           BCM54612E_ADDRESS(dev, phy, 0x15),  BCM54612E_ACCESS,    16
+#define BCM54612E_EXP_REG_ACC(dev, phy)           BCM54612E_ADDRESS(dev, phy, 0x17),  BCM54612E_ACCESS,    16
+#define BCM54612E_AUX_CTRL_SV(dev, phy)           BCM54612E_ADDRESS(dev, phy, 0x18),  BCM54612E_ACCESS,    16
+#define BCM54612E_AUX_STAT(dev, phy)              BCM54612E_ADDRESS(dev, phy, 0x19),  BCM54612E_ACCESS,    16
+#define BCM54612E_INTR_STAT(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x1A),  BCM54612E_ACCESS,    16
+#define BCM54612E_INTR_MASK(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x1B),  BCM54612E_ACCESS,    16
+#define BCM54612E_AUX_CTRL2(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x1C),  BCM54612E_ACCESS,    16
+#define BCM54612E_MASTER_SLAVE(dev, phy)          BCM54612E_ADDRESS(dev, phy, 0x1D),  BCM54612E_ACCESS,    16
+#define BCM54612E_TEST_REG1(dev, phy)             BCM54612E_ADDRESS(dev, phy, 0x1E),  BCM54612E_ACCESS,    16
+
+
+
+#define BCM54612E_EXP_SELECT                 0, 12
+#define BCM54612E_125MHZ_EN                  1, 1
+
+#endif //_BCM54612E_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.c
new file mode 100755
index 0000000..82909a9
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.c
@@ -0,0 +1,389 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm5481_drv.c                                                                                         */
+/*            This file contains BCM5481 Gigabit Phy driver implementation                                 */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <defs.h>
+#include "bcm5481_drv.h"
+#include "bcm5481_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5481 Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const ETH_PHY_OPS_T BCM5481_Ops =
+{
+    BCM5481_ID,
+
+    BCM5481_Init,
+    BCM5481_GetID,
+    BCM5481_Reset,
+    BCM5481_AutoNegotiate,
+    BCM5481_GetLinkCapabilities,
+    BCM5481_SetLinkCapabilities,
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5481_TIMEOUT_COUNT       1000000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_PHY_REG_READ_T   RegReadCallback;
+static ETH_PHY_REG_WRITE_T  RegWriteCallback;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access functions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  BCM5481_PhyRegRead_L    (UINT32 addr);
+static void    BCM5481_PhyRegWrite_L   (UINT32 addr, UINT32 data);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access redirections                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5481_R8         BCM5481_PhyRegRead_L
+#define BCM5481_R16        BCM5481_PhyRegRead_L
+#define BCM5481_R32        BCM5481_PhyRegRead_L
+
+#define BCM5481_W8         BCM5481_PhyRegWrite_L
+#define BCM5481_W16        BCM5481_PhyRegWrite_L
+#define BCM5481_W32        BCM5481_PhyRegWrite_L
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_Init                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  phy_reg_read    - Phy register read  callback                                          */
+/*                  phy_reg_write   - Phy register write callback                                          */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY driver initialization                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5481_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write)
+{
+    RegReadCallback     = phy_reg_read;
+    RegWriteCallback    = phy_reg_write;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_GetID                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns PHY Identification                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 BCM5481_GetID(UINT devNum, UINT phyNum)
+{
+    return (UINT32)(REG_READ(BCM5481_PHY_ID2(devNum, phyNum)) | (REG_READ(BCM5481_PHY_ID1(devNum, phyNum)) << 16));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_Reset                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs PHY reset                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5481_Reset(UINT devNum, UINT phyNum)
+{
+    UINT32 timeout = BCM5481_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting reset                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_RST, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Waiting for reset to complete                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_RST))
+    {
+        if (timeout-- == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If reset is too long, exit with error                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_AutoNegotiate                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Max ETH speed to be announced to the link                                     */
+/*                  duplex - Max ETH duplexity setting to be announced to the link                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Auto-Negotiation with the link                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5481_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex)
+{
+    UINT32 timeout = BCM5481_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Advertise capabilities                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_1000)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM5481_BASET_CON(devNum, phyNum),    BASET_CON_1000FULL  , 1);
+            SET_REG_FIELD(BCM5481_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM5481_BASET_CON(devNum, phyNum),    BASET_CON_1000HALF  , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100FULL      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_100HALF      , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+    else
+    {
+        if (duplex == ETH_DUPLEX_FULL)
+        {
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10FULL       , 1);
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+        else
+        {
+            SET_REG_FIELD(BCM5481_AN_ADV(devNum, phyNum),       AN_ADV_10HALF       , 1);
+        }
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling Auto-Negotiation and restarting it                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 1);
+    SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_RESTART_AN, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait for auto-negotiation complete                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(BCM5481_MII_STAT(devNum, phyNum), MII_STAT_AN_COMPLETED))
+    {
+        if (timeout-- == 0)
+        {
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_GetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - MAC device number                                                             */
+/*                  phyNum - PHY address                                                                   */
+/*                  speed  - Pointer where ETH speed would be placed                                       */
+/*                  duplex - Pointer where ETH duplexity would be placed                                   */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine retrives established link capabilities after successfull Auto-Negotiation */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5481_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((speed == NULL) || (duplex == NULL))
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* if Auto-Negotiation wasn't completed and no linked created, return error                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_FIELD(BCM5481_AUX_STAT(devNum, phyNum), AUX_STAT_AN_COMPLETE))
+    {
+        return HAL_ERROR_NO_LINK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting capabilities                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    switch (READ_REG_FIELD(BCM5481_AUX_STAT(devNum, phyNum), AUX_STAT_HCD))
+    {
+        case AUX_STAT_HCD_1000FULL:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_1000HALF:     *speed = ETH_SPEED_1000;    *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_100FULL:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_100HALF:      *speed = ETH_SPEED_100;     *duplex = ETH_DUPLEX_HALF;  break;
+        case AUX_STAT_HCD_10FULL:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_FULL;  break;
+        case AUX_STAT_HCD_10HALF:       *speed = ETH_SPEED_10;      *duplex = ETH_DUPLEX_HALF;  break;
+
+        default:      return HAL_ERROR;
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_SetLinkCapabilities                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  duplex -                                                                               */
+/*                  phyNum -                                                                               */
+/*                  speed -                                                                                */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs...                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS BCM5481_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_AN_ENABLE, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting speed                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED1, 0);
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED2, 1);
+    }
+    else if (speed == ETH_SPEED_1000)
+    {
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED1, 1);
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_SPEED2, 0);
+    }
+    else
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Seting duplex                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(BCM5481_MII_CON(devNum, phyNum), MII_CON_DUPLEX, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Local functions                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_PhyRegRead_L                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads from PHY register                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32  BCM5481_PhyRegRead_L(UINT32 addr)
+{
+    return RegReadCallback(BCM5481_ADDRESS_DEV(addr), BCM5481_ADDRESS_PHY(addr), BCM5481_ADDRESS_OFFS(addr));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        BCM5481_PhyRegWrite_L                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes to PHY register                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+void    BCM5481_PhyRegWrite_L(UINT32 addr, UINT32 data)
+{
+    RegWriteCallback(BCM5481_ADDRESS_DEV(addr), BCM5481_ADDRESS_PHY(addr), BCM5481_ADDRESS_OFFS(addr), data);
+}
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.h
new file mode 100755
index 0000000..213a37c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_drv.h
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm5481_drv.h                                                                                         */
+/*            This file contains BCM5481 Gigabit Phy driver interface                                      */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM5481_DRV_H
+#define _BCM5481_DRV_H
+
+#include "defs.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Common/hal_ethernet.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5481 ID                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5481_ID     0x0143BCA2
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interface functions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  BCM5481_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+UINT32      BCM5481_GetID(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM5481_Reset(UINT devNum, UINT phyNum);
+HAL_STATUS  BCM5481_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex);
+HAL_STATUS  BCM5481_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+HAL_STATUS  BCM5481_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* BCM5481 Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const extern ETH_PHY_OPS_T BCM5481_Ops;
+
+#endif //_BCM5481_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_regs.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_regs.h
new file mode 100755
index 0000000..542a88e
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/bcm5481/bcm5481_regs.h
@@ -0,0 +1,61 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   bcm5481_regs.h                                                                                        */
+/*            This file contains BCM5481 Gigabit Phy register definition                                   */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _BCM5481_REGS_H
+#define _BCM5481_REGS_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining access type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5481_ACCESS                          BCM5481_
+#define BCM5481_ADDRESS(dev, phyNum, offset)    (((dev & 0xFF) << 16) | ((phyNum & 0xFF) << 8) | (offset & 0xFF))
+
+#define BCM5481_ADDRESS_DEV(addr)               ((addr >> 16)   & 0xFF)
+#define BCM5481_ADDRESS_PHY(addr)               ((addr >> 8)    & 0xFF)
+#define BCM5481_ADDRESS_OFFS(addr)              ( addr          & 0xFF)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy registers                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BCM5481_MII_CON(dev, phy)               BCM5481_ADDRESS(dev, phy, 0x00),  BCM5481_ACCESS,    16
+#define BCM5481_MII_STAT(dev, phy)              BCM5481_ADDRESS(dev, phy, 0x01),  BCM5481_ACCESS,    16
+#define BCM5481_PHY_ID1(dev, phy)               BCM5481_ADDRESS(dev, phy, 0x02),  BCM5481_ACCESS,    16
+#define BCM5481_PHY_ID2(dev, phy)               BCM5481_ADDRESS(dev, phy, 0x03),  BCM5481_ACCESS,    16
+#define BCM5481_AN_ADV(dev, phy)                BCM5481_ADDRESS(dev, phy, 0x04),  BCM5481_ACCESS,    16
+#define BCM5481_AN_LNK(dev, phy)                BCM5481_ADDRESS(dev, phy, 0x05),  BCM5481_ACCESS,    16
+#define BCM5481_AN_EXP(dev, phy)                BCM5481_ADDRESS(dev, phy, 0x06),  BCM5481_ACCESS,    16
+#define BCM5481_NPT(dev, phy)                   BCM5481_ADDRESS(dev, phy, 0x07),  BCM5481_ACCESS,    16
+#define BCM5481_LPRNP(dev, phy)                 BCM5481_ADDRESS(dev, phy, 0x08),  BCM5481_ACCESS,    16
+#define BCM5481_BASET_CON(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x09),  BCM5481_ACCESS,    16
+#define BCM5481_BASET_STAT(dev, phy)            BCM5481_ADDRESS(dev, phy, 0x0A),  BCM5481_ACCESS,    16
+#define BCM5481_EXT_STAT(dev,phy)               BCM5481_ADDRESS(dev, phy, 0x0F),  BCM5481_ACCESS,    16
+#define BCM5481_PHY_EXT_CON(dev, phy)           BCM5481_ADDRESS(dev, phy, 0x10),  BCM5481_ACCESS,    16
+#define BCM5481_PHY_EXT_STAT(dev, phy)          BCM5481_ADDRESS(dev, phy, 0x11),  BCM5481_ACCESS,    16
+#define BCM5481_Rx_ERROR(dev, phy)              BCM5481_ADDRESS(dev, phy, 0x12),  BCM5481_ACCESS,    16
+#define BCM5481_FALSE_CARRIER(dev, phy)         BCM5481_ADDRESS(dev, phy, 0x13),  BCM5481_ACCESS,    16
+#define BCM5481_Rx_NOT_OK(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x14),  BCM5481_ACCESS,    16
+#define BCM5481_EXP_REG_ACC(dev, phy)           BCM5481_ADDRESS(dev, phy, 0x17),  BCM5481_ACCESS,    16
+#define BCM5481_AUX_CTRL_SV(dev, phy)           BCM5481_ADDRESS(dev, phy, 0x18),  BCM5481_ACCESS,    16
+#define BCM5481_AUX_STAT(dev, phy)              BCM5481_ADDRESS(dev, phy, 0x19),  BCM5481_ACCESS,    16
+#define BCM5481_INTR_STAT(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x1A),  BCM5481_ACCESS,    16
+#define BCM5481_INTR_MASK(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x1B),  BCM5481_ACCESS,    16
+#define BCM5481_AUX_CTRL2(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x1C),  BCM5481_ACCESS,    16
+#define BCM5481_MASTER_SLAVE(dev, phy)          BCM5481_ADDRESS(dev, phy, 0x1D),  BCM5481_ACCESS,    16
+#define BCM5481_TEST_REG1(dev, phy)             BCM5481_ADDRESS(dev, phy, 0x1E),  BCM5481_ACCESS,    16
+
+
+
+
+#endif //_BCM5481_REGS_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.c
new file mode 100755
index 0000000..f64649b
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.c
@@ -0,0 +1,378 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   dp83848c_drv.c                                                                                        */
+/*            This file contains DP83848C PHY driver implementation                                        */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_DRV_C
+
+#include <defs.h>
+#include "dp83848c_drv.h"
+#include "dp83848c_regs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local definitions                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_TIMEOUT_COUNT       100000
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_PHY_REG_READ_T   RegReadCallback;
+static ETH_PHY_REG_WRITE_T  RegWriteCallback;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access functions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32  DP83848C_PhyRegRead_L    (UINT32 addr);
+static void    DP83848C_PhyRegWrite_L   (UINT32 addr, UINT32 data);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register access redirections                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_R8         DP83848C_PhyRegRead_L
+#define DP83848C_R16        DP83848C_PhyRegRead_L
+#define DP83848C_R32        DP83848C_PhyRegRead_L
+
+#define DP83848C_W8         DP83848C_PhyRegWrite_L
+#define DP83848C_W16        DP83848C_PhyRegWrite_L
+#define DP83848C_W32        DP83848C_PhyRegWrite_L
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DP83848C Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const ETH_PHY_OPS_T DP83848C_Ops =
+{
+    DP83848C_ID,
+
+    DP83848C_Init,
+    DP83848C_GetID,
+    DP83848C_Reset,
+    DP83848C_AutoNegotiate,
+    DP83848C_GetLinkCapabilities,
+    DP83848C_SetLinkCapabilities,
+};
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_Init                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  reg_read    - Phy registers read function                                              */
+/*                  reg_write   - Phy registers write function                                             */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs DP83848C driver initialization                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  DP83848C_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy driver initialize                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    RegReadCallback     = phy_reg_read;
+    RegWriteCallback    = phy_reg_write;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_GetID                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of the phy to access                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine return ID of the PHY                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 DP83848C_GetID(UINT devNum, UINT phyNum)
+{
+    return (UINT32)((REG_READ(DP83848C_PHYIDR1(devNum, phyNum))<<16) | REG_READ(DP83848C_PHYIDR2(devNum, phyNum)));
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_Reset                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of the phy to reset                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine resets the PHY                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS DP83848C_Reset(UINT devNum, UINT phyNum)
+{
+    UINT32 timeout = DP83848C_TIMEOUT_COUNT;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting reset                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_RESET, 1);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Waiting for reset to complete                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (READ_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_RESET))
+    {
+        if (timeout-- == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If reset is too long, exit with error                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_AutoNegotiate                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Phy number to access                                                         */
+/*                  speed   - Max supported capabilities                                                   */
+/*                  duplex  -            "                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs Auto Negotiation                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS DP83848C_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex)
+{
+    UINT32 timeout = DP83848C_TIMEOUT_COUNT;
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling auto negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting capabilities for advertising                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        if (speed == ETH_SPEED_100)
+        {
+            SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_100_FULL, 1);
+            SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_100_HALF, 1);
+        }
+
+        SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_10_FULL, 1);
+        SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_10_HALF, 1);
+    }
+    else
+    {
+        if (speed == ETH_SPEED_100)
+        {
+            SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_100_HALF, 1);
+        }
+
+        SET_REG_FIELD(DP83848C_ANAR(devNum, phyNum), ANAR_10_HALF, 1);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enabling auto negotiation                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Re-Starting auto negotiation                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_RESTART_AUTONEG, 1);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* wait for auto-negotiation complete                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    while (!READ_REG_FIELD(DP83848C_PHYSTS(devNum, phyNum), PHYSTS_AUTONEG_COMPLETE))
+    {
+        if (timeout-- == 0)
+        {
+            return HAL_ERROR_TIMEOUT;
+        }
+    }
+
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_GetLinkCapabilities                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - MAC module number                                                            */
+/*                  phyNum  - Address of PHY to access                                                     */
+/*                  speed   - Speed of the Link                                                            */
+/*                  duplex  - Duplexity of the Link                                                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns established Link Capabilities.                                    */
+/*                  It should be called upon successful Auto-Negotiation                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS DP83848C_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking parameters                                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((speed == NULL) || (duplex == NULL))
+        return HAL_ERROR_BAD_PARAM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if valid link established                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!READ_REG_FIELD(DP83848C_PHYSTS(devNum, phyNum), PHYSTS_LINK))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Valid link was not established!                                                                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        return HAL_ERROR_NO_LINK;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting duplex setting                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_REG_FIELD(DP83848C_PHYSTS(devNum, phyNum), PHYSTS_DUPLEX))
+        *duplex = ETH_DUPLEX_FULL;
+    else
+        *duplex = ETH_DUPLEX_HALF;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Getting speed setting                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (READ_REG_FIELD(DP83848C_PHYSTS(devNum, phyNum), PHYSTS_SPEED))
+        *speed = ETH_SPEED_10;
+    else
+        *speed = ETH_SPEED_100;
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_SetLinkCapabilities                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev     - MAC module number                                                            */
+/*                  phyNum  - Address of PHY to access                                                     */
+/*                  speed   - Ethernet Speed settings                                                      */
+/*                  duplex  - Ethernet Duplex settings                                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine sets link capabilities of the PHY                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS DP83848C_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T duplex)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Disabling Auto-Negotiation                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_AUTONEG, 0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting speed                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (speed == ETH_SPEED_10)
+    {
+        SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_SPEED_SELECT, 0);
+    }
+    else if (speed == ETH_SPEED_100)
+    {
+        SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_SPEED_SELECT, 1);
+    }
+    else
+    {
+        return HAL_ERROR_BAD_PARAM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Seting duplex                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (duplex == ETH_DUPLEX_FULL)
+    {
+        SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_DUPLEX_MODE, 1);
+    }
+    else
+    {
+        SET_REG_FIELD(DP83848C_BMCR(devNum, phyNum), HAL_BMCR_DUPLEX_MODE, 0);
+    }
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             LOCAL FUNCTIONS                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_PhyRegRead_L                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs read from register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 DP83848C_PhyRegRead_L(UINT32 addr)
+{
+    if (RegReadCallback)
+    {
+        return RegReadCallback(DP83848C_ADDRESS_DEV(addr), DP83848C_ADDRESS_PHY(addr), DP83848C_ADDRESS_OFFS(addr));
+    }
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        DP83848C_PhyRegWrite_L                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr -                                                                                 */
+/*                  data -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs write to register                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+void DP83848C_PhyRegWrite_L(UINT32 addr, UINT32 data)
+{
+    if (RegWriteCallback)
+    {
+        RegWriteCallback(DP83848C_ADDRESS_DEV(addr),  DP83848C_ADDRESS_PHY(addr), DP83848C_ADDRESS_OFFS(addr), data);
+    }
+}
+
+
+#undef DP83848C_DRV_C
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.h
new file mode 100755
index 0000000..534768a
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_drv.h
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   dp83848c_drv.h                                                                                        */
+/*            This file contains DP83848C PHY driver interface                                             */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DP83848C_DRV_H
+#define _DP83848C_DRV_H
+
+#include "defs.h"
+#include "../../../Common/hal_error.h"
+#include "../../../Common/hal_ethernet.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DP83848C ID                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_ID     0x20005C90
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interface functions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS  DP83848C_Init(ETH_PHY_REG_READ_T phy_reg_read, ETH_PHY_REG_WRITE_T phy_reg_write);
+UINT32      DP83848C_GetID(UINT devNum, UINT phyNum);
+HAL_STATUS  DP83848C_Reset(UINT devNum, UINT phyNum);
+HAL_STATUS  DP83848C_AutoNegotiate(UINT devNum, UINT phyNum, ETH_SPEED_T speed, ETH_DUPLEX_T duplex);
+HAL_STATUS  DP83848C_GetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T* speed, ETH_DUPLEX_T* duplex);
+HAL_STATUS  DP83848C_SetLinkCapabilities(UINT devNum, UINT phyNum, ETH_SPEED_T  speed, ETH_DUPLEX_T  duplex);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* DP83848C Driver ops structure                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+const extern ETH_PHY_OPS_T DP83848C_Ops;
+
+#endif //_DP83848C_DRV_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_regs.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_regs.h
new file mode 100755
index 0000000..838ddb3
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/dp83848c/dp83848c_regs.h
@@ -0,0 +1,62 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   dp83848c_regs.h                                                                                       */
+/*            This file contains DP83848C PHY registers                                                    */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DP83848C_REG_H
+#define _DP83848C_REG_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defining access type                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_ACCESS                             DP83848C_
+#define DP83848C_ADDRESS(dev, phyNum, offset)       (((dev & 0xFF) << 16) | ((phyNum & 0xFF) << 8) | (offset & 0xFF))
+
+#define DP83848C_ADDRESS_DEV(addr)                  ((addr >> 16)   & 0xFF)
+#define DP83848C_ADDRESS_PHY(addr)                  ((addr >> 8)    & 0xFF)
+#define DP83848C_ADDRESS_OFFS(addr)                 ( addr          & 0xFF)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy basic registers                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_BMCR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x00),  DP83848C_ACCESS,    16
+#define DP83848C_BMSR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x01),  DP83848C_ACCESS,    16
+#define DP83848C_PHYIDR1(dev, phy)       DP83848C_ADDRESS(dev, phy, 0x02),  DP83848C_ACCESS,    16
+#define DP83848C_PHYIDR2(dev, phy)       DP83848C_ADDRESS(dev, phy, 0x03),  DP83848C_ACCESS,    16
+#define DP83848C_ANAR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x04),  DP83848C_ACCESS,    16
+#define DP83848C_ANLPAR(dev, phy)        DP83848C_ADDRESS(dev, phy, 0x05),  DP83848C_ACCESS,    16
+#define DP83848C_ANLPARNP(dev, phy)      DP83848C_ADDRESS(dev, phy, 0x05),  DP83848C_ACCESS,    16
+#define DP83848C_ANER(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x06),  DP83848C_ACCESS,    16
+#define DP83848C_ANNPTR(dev, phy)        DP83848C_ADDRESS(dev, phy, 0x07),  DP83848C_ACCESS,    16
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Phy extended registers                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DP83848C_PHYSTS(dev, phy)        DP83848C_ADDRESS(dev, phy, 0x10),  DP83848C_ACCESS,    16
+#define DP83848C_MICR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x11),  DP83848C_ACCESS,    16
+#define DP83848C_MISR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x12),  DP83848C_ACCESS,    16
+#define DP83848C_FCSCR(dev, phy)         DP83848C_ADDRESS(dev, phy, 0x14),  DP83848C_ACCESS,    16
+#define DP83848C_RECR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x15),  DP83848C_ACCESS,    16
+#define DP83848C_PCSR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x16),  DP83848C_ACCESS,    16
+#define DP83848C_RBR(dev, phy)           DP83848C_ADDRESS(dev, phy, 0x17),  DP83848C_ACCESS,    16
+#define DP83848C_LEDCR(dev, phy)         DP83848C_ADDRESS(dev, phy, 0x18),  DP83848C_ACCESS,    16
+#define DP83848C_PHYCR2(dev, phy)        DP83848C_ADDRESS(dev, phy, 0x19),  DP83848C_ACCESS,    16
+#define DP83848C_BTSCR(dev, phy)         DP83848C_ADDRESS(dev, phy, 0x1A),  DP83848C_ACCESS,    16
+#define DP83848C_CDCTRL1(dev, phy)       DP83848C_ADDRESS(dev, phy, 0x1B),  DP83848C_ACCESS,    16
+#define DP83848C_EDCR(dev, phy)          DP83848C_ADDRESS(dev, phy, 0x1D),  DP83848C_ACCESS,    16
+
+
+
+
+#endif //_DP83848C_REG_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.c b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.c
new file mode 100755
index 0000000..4b64cd2
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.c
@@ -0,0 +1,8 @@
+#include "../../Common/hal_common.h"
+#include "eth_phy.h"
+
+#include "dp83848c/dp83848c_drv.c"
+#include "bcm5481/bcm5481_drv.c"
+#include "bcm5221/bcm5221_drv.c"
+#include "bcm54612e/bcm54612e_drv.c"
+#include "bcm54210e/bcm54210e_drv.c"
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.h b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.h
new file mode 100755
index 0000000..1104509
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/eth_phy/eth_phy.h
@@ -0,0 +1,27 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   eth_phy_if.h                                                                                          */
+/*            This file contains ETH PHY interfaces                                                        */
+/* Project:                                                                                                */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _ETH_PHY_IF_H
+#define _ETH_PHY_IF_H
+
+#include "../../Common/hal_ethernet.h"
+
+#include "dp83848c/dp83848c_drv.h"
+#include "bcm5481/bcm5481_drv.h"
+#include "bcm5221/bcm5221_drv.h"
+#include "bcm54612e/bcm54612e_drv.h"
+#include "bcm54210e/bcm54210e_drv.h"
+
+
+#endif //_ETH_PHY_IF_H
\ No newline at end of file
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.c b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.c
new file mode 100755
index 0000000..a35a464
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.c
@@ -0,0 +1,213 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   spi_flash_common.c                                                                                    */
+/*            This file contains Common SPI flash low-level driver                                         */
+/*  Project:                                                                                               */
+/*            Yarkon HAL                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "spi_flash_common.h"
+#include "../../../Chips/chip_if.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              API Functions                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_GetStatus                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - device index                                                                 */
+/*                  status  -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads Flash status register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_GetStatus(UINT32 dev_num, UINT8* status)
+{
+    FIU_UMA_Read(dev_num, SPI_READ_STATUS_REG_CMD, 0, 0, status, 1);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_GetID                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - device index                                                                 */
+/*                  pid0 -                                                                                 */
+/*                  pid1 -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads JEDEC standard Flash ID                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_GetID(UINT32 dev_num, UINT8 *pid0, UINT16 *pid1 )
+{
+    UINT32 data;
+	UINT32 temp;
+     
+    FIU_UMA_Read(dev_num, SPI_READ_JEDEC_ID_CMD, 0x0, FALSE, (UINT8*)&data, 3);
+
+    *pid0 = (data & 0x0000FF);
+    temp = (data & 0xFF0000) >> 16;
+    *pid1 = (data & 0x00FF00) | temp;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_Erase                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                  addr    -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs sector erase                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_SectorErase(UINT32 dev_num, UINT32 addr)
+{
+     FIU_UMA_Write(
+         dev_num,                           // only one flash device
+         SPI_WRITE_ENABLE_CMD,              // write enable transaction code
+         0,                                 // address irrelevant
+         FALSE,                             // no address for transaction 
+         NULL,                              // no write data
+         0);                                // no data
+    
+     SPI_Flash_Common_WaitTillReady(dev_num);
+    
+     FIU_UMA_Write(
+         dev_num,                           // only one flash device
+         SPI_4K_SECTOR_ERASE_CMD,           // sector erase transaction code
+         addr,                              // address relevant
+         TRUE,                              // address for transaction 
+         NULL,                              // no write data
+         0);                                // no data
+    
+    SPI_Flash_Common_WaitTillReady(dev_num);
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_BulkErase                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                  addr    -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs bulk erase of all the flash device                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_BulkErase(UINT32 dev_num)
+{
+     FIU_UMA_Write(
+         dev_num,                           // only one flash device
+         SPI_WRITE_ENABLE_CMD,              // write enable transaction code
+         0,                                 // address irrelevant
+         FALSE,                             // no address for transaction 
+         NULL,                              // no write data
+         0);                                // no data
+    
+     SPI_Flash_Common_WaitTillReady(dev_num);
+    
+     FIU_UMA_Write(
+         dev_num,                           // only one flash device
+         SPI_CHIP_ERASE_CMD,                // bulk erase transaction code
+         0,                                 // no address is needed
+         0,                                 //          " 
+         NULL,                              // no write data
+         0);                                // no data
+    
+    SPI_Flash_Common_WaitTillReady(dev_num);
+    
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_Write                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devID       - Flash device index                                                       */
+/*                  destAddr    - Local destination address                                                */
+/*                  data        - data ptr                                                                 */
+/*                  size        - data size                                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash write to the given (by index) device                       */
+/*                  The dest address can be NOT aligned to a page size, but the data must fit the current  */
+/*                  page, if the data exceeds the page it will be overlaped and written from the beginning */
+/*                  of the page (usual flash devices behavior)                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_Write(UINT32 devID, UINT32 destAddr, UINT8* data, UINT32 size)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Write Flash Using 256 Page EXTENDED MODE                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    FIU_UMA_Write(devID, SPI_WRITE_ENABLE_CMD, 0, FALSE, NULL, 0);
+    
+    SPI_Flash_Common_WaitTillReady(devID);
+
+
+    FIU_ManualWrite(devID, SPI_PAGE_PRGM_CMD, destAddr, data, size);
+
+    SPI_Flash_Common_WaitTillReady(devID);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_WaitTillReady                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine waits till the flash device is ready                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_WaitTillReady(UINT32 dev_num) 
+{
+    UINT8 busy=1;
+
+    do 
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Reading flash status register                                                                   */
+        /*-------------------------------------------------------------------------------------------------*/
+        SPI_Flash_Common_GetStatus(dev_num, &busy);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Keep only "busy" bit 0                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        busy &= 0x01;                 
+
+    } while (busy);
+}
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.h b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.h
new file mode 100755
index 0000000..ded3b58
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/common/spi_flash_common.h
@@ -0,0 +1,138 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   spi_flash_common.h                                                                                    */
+/*            This file contains Common SPI flash low-level driver interface                               */
+/*  Project:                                                                                               */
+/*            Yarkon HAL                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _FLASH_SPI_COMMON_H
+#define _FLASH_SPI_COMMON_H
+
+
+#include "defs.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Common SPI flash commands                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SPI_READ_JEDEC_ID_CMD       0x9F
+#define SPI_WRITE_ENABLE_CMD        0x06
+#define SPI_WRITE_DISABLE_CMD       0x04 
+#define SPI_READ_STATUS_REG_CMD     0x05
+#define SPI_WRITE_STATUS_REG_CMD    0x01
+#define SPI_READ_DATA_CMD           0x03
+#define SPI_PAGE_PRGM_CMD           0x02
+#define SPI_4K_SECTOR_ERASE_CMD     0x20
+#define SPI_32K_BLOCK_ERASE_CMD     0x52
+#define SPI_64K_BLOCK_ERASE_CMD     0xD8
+#define SPI_CHIP_ERASE_CMD          0xC7
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_GetStatus                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - device index                                                                 */
+/*                  status  -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads Flash status register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_GetStatus(UINT32 dev_num, UINT8* status);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_GetID                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - device index                                                                 */
+/*                  pid0 -                                                                                 */
+/*                  pid1 -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads JEDEC standard Flash ID                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_GetID(UINT32 dev_num, UINT8 *pid0, UINT16 *pid1 );
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_SectorErase                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                  addr    -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs sector erase                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_SectorErase(UINT32 dev_num, UINT32 addr);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_BulkErase                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                  addr    -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs bulk erase of all the flash device                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_BulkErase(UINT32 dev_num);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_Write                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devID       - Flash device index                                                       */
+/*                  destAddr    - Local destination address                                                */
+/*                  data        - data ptr                                                                 */
+/*                  size        - data size                                                                */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash write to the given (by index) device                       */
+/*                  The dest address can be NOT aligned to a page size, but the data must fit the current  */
+/*                  page, if the data exceeds the page it will be overlaped and written from the beginning */
+/*                  of the page (usual flash devices behavior)                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_Write(UINT32 devID, UINT32 destAddr, UINT8* data, UINT32 size);
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Common_WaitTillReady_L                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num -                                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine waits till the flash device is ready                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_Common_WaitTillReady(UINT32 dev_num);
+
+#endif //_FLASH_SPI_COMMON_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.c b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.c
new file mode 100755
index 0000000..96a5e1c
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.c
@@ -0,0 +1,757 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   spi_flash.c                                                                                           */
+/*            This file contains SPI flash logical driver                                                  */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "../../Common/hal_common.h"
+
+#ifndef NO_LIBC
+#include <string.h>
+#else
+int printf(const char* fmt, ...);
+#endif
+
+#include "spi_flash.h"
+#include "common/spi_flash_common.h"
+
+#include "../../Modules/fiu/fiu_if.h"
+#include "../../Chips/chip_if.h"
+
+//#define VERBOSE_SPI_FLASH          // Debug
+
+
+#ifdef __LINUX_KERNEL_ONLY__
+#define SPI_FLASH_SKIP_ERASE_ON_WRITE       // Kernel MTD driver Erase before write anyway.
+#endif
+
+/* Including SPI FLASH COMMON Driver Code  */
+#include "common/spi_flash_common.c"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Supported Flashes IDs                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+//                                  PID0 |  PID1
+//                                 --------------
+#define WINBOND_MF_ID               0xEF        
+    #define W25Q40_CAPACITY_ID              0x4013        
+    #define W25Q80_CAPACITY_ID              0x4014        
+    #define W25Q32_CAPACITY_ID              0x4016        
+    #define W25Q64_CAPACITY_ID              0x4017        
+    #define W25Q128_CAPACITY_ID             0x4018        
+    #define W25Q256_CAPACITY_ID             0x4019        
+    #define W25P80_CAPACITY_ID              0x2014        
+    #define W25P16_CAPACITY_ID              0x2015
+    #define W25P32_CAPACITY_ID              0x2016
+
+#define STMICRO_MF_IF               0x20
+    #define M25P16_CAPACITY_ID              0x2015
+    #define M25P32_CAPACITY_ID              0x2016
+    #define M25P128_CAPACITY_ID             0x2018
+
+#define SPANSION_MF_IF              0x01
+    #define S25FS128_CAPACITY_ID              0x2018
+    #define S25FS256_CAPACITY_ID              0x0219
+
+#define MACRONIX_MF_IF              0xC2
+    #define MX25L32_CAPACITY_ID            0x2016
+    #define MX25L64_CAPACITY_ID            0x2017
+    #define MX25L128_CAPACITY_ID           0x2018
+
+#define DUMMY_MF_IF                 0xFF
+    #define DUMMY_CAPACITY_ID              0xFFFF
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Supported flashes array                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+static const flash_t supported_flash[]=
+{
+  {MACRONIX_MF_IF, MX25L32_CAPACITY_ID,  (UINT8*)"MX25L32",  _4MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q40_CAPACITY_ID,   (UINT8*)"W25Q40",   _512KB_, _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q80_CAPACITY_ID,   (UINT8*)"W25Q80",   _1MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q32_CAPACITY_ID,   (UINT8*)"W25Q32",   _4MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q64_CAPACITY_ID,   (UINT8*)"W25Q64",   _8MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q128_CAPACITY_ID,  (UINT8*)"W25Q128",  _16MB_,  _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25Q256_CAPACITY_ID,  (UINT8*)"W25Q256",  _32MB_,  _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25P80_CAPACITY_ID,   (UINT8*)"W25P80",   _1MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25P16_CAPACITY_ID,   (UINT8*)"W25P16",   _2MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {WINBOND_MF_ID,  W25P32_CAPACITY_ID,   (UINT8*)"W25P32",   _4MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {STMICRO_MF_IF,  M25P16_CAPACITY_ID,   (UINT8*)"M25P16",   _2MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {STMICRO_MF_IF,  M25P32_CAPACITY_ID,   (UINT8*)"M25P32",   _4MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {STMICRO_MF_IF,  M25P128_CAPACITY_ID,  (UINT8*)"M25P128",  _16MB_,  _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {SPANSION_MF_IF, S25FS128_CAPACITY_ID, (UINT8*)"S25FS128", _16MB_,  _4KB_,  _512B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {SPANSION_MF_IF, S25FS256_CAPACITY_ID, (UINT8*)"S25FS256", _32MB_,  _4KB_,  _512B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {MACRONIX_MF_IF, MX25L64_CAPACITY_ID,  (UINT8*)"MX25L64",  _8MB_,   _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {MACRONIX_MF_IF, MX25L128_CAPACITY_ID, (UINT8*)"MX25L128", _16MB_,  _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase},
+  {0},
+  {DUMMY_MF_IF, DUMMY_CAPACITY_ID, (UINT8*)"Unknown-Flash!!!",  _16MB_,  _4KB_,  _256B_, 0, SPI_Flash_Common_Write, SPI_Flash_Common_SectorErase, SPI_Flash_Common_GetStatus, SPI_Flash_Common_BulkErase}
+};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Defines BASED on the supported flashes array                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAX_ERASE_BLOCK_SIZE            _256KB_
+#define MAX_PROGRAM_PAGE_SIZE           _256B_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Verbose prints                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(VERBOSE_GLOBAL) || defined(VERBOSE_SPI_FLASH)
+ #ifndef __LINUX_KERNEL_ONLY__
+  #define SPI_FLASH_MSG_DEBUG(fmt,args...)   printf(fmt ,##args)
+ #else
+  #define SPI_FLASH_MSG_DEBUG(fmt,args...)   printk(fmt ,##args)
+ #endif
+#else
+ #define SPI_FLASH_MSG_DEBUG(fmt,args...)
+#endif
+
+#ifndef __LINUX_KERNEL_ONLY__
+ #define SPI_FLASH_MSG(fmt,args...)   printf(fmt ,##args)
+#else
+ #define SPI_FLASH_MSG(fmt,args...)   printk(fmt ,##args)
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* API Variables definition                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+flash_t SPI_Flash_Devices[CONFIG_SYS_MAX_FLASH_BANKS] = {{0}};
+UINT32  SPI_Flash_TotalSize = 0;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local Variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32 SPI_Flash_BaseAddress = 0;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local functions declarations                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+INT32   SPI_Flash_Addr2Sector_L         (UINT32 dev_num, UINT32 addr);
+INT32   SPI_Flash_GetDeviceIDbyAddr_L   (UINT32 addr);
+void    SPI_Flash_WritePageAligned_L    (UINT32 dev_num, UINT8 *src, UINT32 addr, UINT32 cnt);
+INT32   SPI_Flash_GetDeviceIndexbyAddr_L(UINT32 addr);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              API Functions                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Init                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SPI flash initialization                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_Init(UINT32 flashBaseAddress)
+{
+    UINT8   pid0            = 0; 
+    UINT16  pid1            = 0;
+    UINT32  fl_idx          = 0;
+    UINT32  idx             = 0;
+    UINT32  dev_cnt         = 0;
+    UINT32  max_dev_size    = 0;
+   
+    SPI_Flash_BaseAddress   = flashBaseAddress;
+    SPI_Flash_TotalSize = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* enable flashes 0-3                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // Comment the following line since u-boot header determine which CS is enabled and if quad is enabled
+    //GCR_MuxFIU(FIU_MODULE_0,TRUE,FALSE,FALSE,FALSE,TRUE);
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking all connected SPI devices                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(fl_idx=0; fl_idx < CONFIG_SYS_MAX_FLASH_BANKS; fl_idx++ )
+    {
+        SPI_Flash_ReadPID(fl_idx, &pid0, &pid1);
+
+        SPI_FLASH_MSG_DEBUG("\nSPI_Flash: fl_idx=%d, pid0=0x%x, pid1=0x%x \n",fl_idx, pid0, pid1);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Checking all supported flash devices                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        idx = 0;
+        while(supported_flash[idx].mf_id != 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Checking if supported flash device match current SPI flash ID                               */
+            /*---------------------------------------------------------------------------------------------*/
+            if((supported_flash[idx].mf_id == pid0) && (supported_flash[idx].capacity_id == pid1))
+            {
+                dev_cnt++;
+
+                /*-----------------------------------------------------------------------------------------*/
+                /* Flash device identified, moving to next one                                             */
+                /*-----------------------------------------------------------------------------------------*/
+                break;
+            }
+
+            idx++; // continue to next in loop
+        }
+
+        if ((supported_flash[idx].mf_id == 0) && (pid0 != 0))
+        {
+			idx++; // increment to dummy device 
+        }
+		
+		// check if valid device
+		if ((pid1 & 0xFF) >=0x14 &&  (pid1 & 0xFF) <= 0x1B)
+		{
+              SPI_Flash_Devices[fl_idx]           = supported_flash[idx];
+
+#if defined (NPCM750)
+              SPI_Flash_Devices[fl_idx].startAddr = FLASH_BASE_ADDR(fl_idx);
+              if (SPI_Flash_Devices[fl_idx].chip_size > _16MB_)
+              {
+                  SPI_FLASH_MSG("\nReducing flash chip size from %lu MB to 16 MB\n", SPI_Flash_Devices[fl_idx].chip_size/_1MB_);
+                  SPI_Flash_Devices[fl_idx].chip_size = _16MB_;
+              }
+#else
+              SPI_Flash_Devices[fl_idx].startAddr = SPI_Flash_BaseAddress + SPI_Flash_TotalSize;
+#endif
+              SPI_Flash_TotalSize  += SPI_Flash_Devices[fl_idx].chip_size;
+              
+              if(max_dev_size < supported_flash[idx].chip_size)
+              {
+                  max_dev_size = supported_flash[idx].chip_size;
+              }
+			  
+			  SPI_FLASH_MSG("\nSPI_Flash%d: Found CS%d dev#%d Name[%s] ChipSize[0x%x]\n",
+							 3*(fl_idx / FIU_DEVICES_PER_MODULE),
+							 (fl_idx % FIU_DEVICES_PER_MODULE),
+							 fl_idx,
+							 SPI_Flash_Devices[fl_idx].name,
+							 SPI_Flash_Devices[fl_idx].chip_size);
+
+			  SPI_FLASH_MSG_DEBUG("\nSPI_Flash%d: Found CS%d dev#%d Name[%s] ChipSize[0x%x] SectorSize=[0x%x] PageSize[0x%x] StartAddr[0x%x]\n",
+									3*(fl_idx / FIU_DEVICES_PER_MODULE),
+									(fl_idx % FIU_DEVICES_PER_MODULE),
+									fl_idx,
+									SPI_Flash_Devices[fl_idx].name,
+									SPI_Flash_Devices[fl_idx].chip_size,
+									SPI_Flash_Devices[fl_idx].page_size,
+									SPI_Flash_Devices[fl_idx].startAddr);
+		}
+		else
+		{   
+		   /*-------------------------------------------------------------------------------------------------*/
+		   /* Flash device wasn't identified!!                                                            */
+		   /*-------------------------------------------------------------------------------------------------*/
+			 SPI_FLASH_MSG_DEBUG("\nSPI_Flash: Flash Device #%d with ID[0x%X] wasn't identified!\n", fl_idx, pid0);
+		}
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring the FIU with the total flash size                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    return FIU_Init(dev_cnt, max_dev_size, SPI_Flash_TotalSize);    
+}
+
+
+#if !defined(SPI_FLASH_SKIP_ERASE_ON_WRITE)
+void SPI_Flash_CheckAndDoEraseBoforeProgram_L(INT32 devNum, UINT32 destAddr, UINT8* data, UINT32 size)
+{
+    UINT32  start_s;
+    UINT32  end_s;    
+    UINT32  sector_size;
+    UINT32  page_size;
+    UINT32  cur_sec;
+    UINT32  char_count = 0;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* First we calculate the sectors range involved with the writing                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    start_s     = SPI_Flash_Addr2Sector_L(devNum, destAddr);
+    end_s       = SPI_Flash_Addr2Sector_L(devNum, destAddr + size - 1);
+
+    sector_size    = SPI_Flash_Devices[devNum].sector_size;
+    page_size      = SPI_Flash_Devices[devNum].page_size;
+
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Start sector = %d, End sector = %d, Sector size = %d\n", start_s, end_s, sector_size);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* We check every sector if erase is needed                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    
+    for (cur_sec = start_s; cur_sec <= end_s; ++cur_sec)
+    {
+        UINT32 check_addr;
+        UINT32 sec_start_addr = SPI_Flash_Devices[devNum].startAddr + cur_sec * sector_size;
+            
+        UINT32 start_addr = sec_start_addr > destAddr ? sec_start_addr : destAddr;
+        UINT32 end_addr   = sec_start_addr + sector_size - 1 < destAddr + size - 1 ? sec_start_addr + sector_size - 1 : destAddr + size - 1;
+
+        BOOLEAN need_programming = FALSE;
+        UINT8* tmp_src = data;
+        
+        if (char_count % 256)
+        {
+            if ((char_count % 4) == 0)
+            {
+                SPI_FLASH_MSG("#");
+            }
+        }
+        else
+        {
+            SPI_FLASH_MSG("\n\t ");
+        }
+        char_count++;
+        
+        /*---------------------------------------------------------------------------------------------*/
+        /* We check all the relevat data in the sector against the source.                             */
+        /* if the data on the flash can be converted to source data without sector erase               */
+        /* we skip directly to the writing procedure, otherwise we first erase the whole sector.       */
+        /*---------------------------------------------------------------------------------------------*/
+        for (check_addr = start_addr; check_addr <= end_addr; check_addr++, tmp_src++)
+        {
+            if ((*(UINT8*)check_addr) != (*(UINT8*)tmp_src))
+            {
+                need_programming = TRUE;
+                if ( ((*(UINT8*)check_addr) & (*(UINT8*)tmp_src)) != (*(UINT8*)tmp_src))
+                {
+                    /*-------------------------------------------------------------------------------------*/
+                    /*                                  Erase is needed!                                   */
+                    /*-------------------------------------------------------------------------------------*/
+                    UINT8   sector_buff[MAX_ERASE_BLOCK_SIZE];
+                    
+                    SPI_FLASH_MSG_DEBUG("SPI_Flash: Flashing sector %5d, Start addr = 0x%X, End addr = 0x%X\n", cur_sec, start_addr, end_addr);
+                    
+                    /*-------------------------------------------------------------------------------------*/
+                    /* First we read the sector into buffer                                                */
+                    /*-------------------------------------------------------------------------------------*/
+                    memcpy(sector_buff, (UINT8*)(sec_start_addr), sector_size);
+                    
+                    /*-------------------------------------------------------------------------------------*/
+                    /* Second apply the new data to the buffer                                             */
+                    /*-------------------------------------------------------------------------------------*/
+                    memcpy((UINT8*)(sector_buff + (start_addr - sec_start_addr)), data,     \
+                                        end_addr - start_addr + 1);
+                    
+                    /*-------------------------------------------------------------------------------------*/
+                    /* Third erase the sector                                                              */
+                    /*-------------------------------------------------------------------------------------*/
+                    SPI_Flash_SectorErase(sec_start_addr); 
+
+                    /*-------------------------------------------------------------------------------------*/
+                    /* Forth write the new sector                                                          */
+                    /*-------------------------------------------------------------------------------------*/
+                    SPI_Flash_WritePageAligned_L(devNum, sector_buff, sec_start_addr, sector_size);
+                    
+                    /*-------------------------------------------------------------------------------------*/
+                    /* finished checking current sector                                                    */
+                    /*-------------------------------------------------------------------------------------*/
+                    need_programming = FALSE;
+                    break;
+                }
+            }
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* if the above check loop finished without erasing we only need to write the data                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (need_programming)
+        {
+            tmp_src = data;
+            for (check_addr = start_addr; check_addr <= end_addr;)
+            {
+                // check if need programming
+                if ((*(UINT8*)check_addr) != (*(UINT8*)tmp_src))
+                {
+                    UINT32 current_page_size;
+                    UINT32 current_page_end = check_addr | (page_size-1);
+                                        
+                    if (current_page_end > end_addr)
+                        current_page_end = end_addr;
+                    current_page_size = current_page_end - check_addr + 1;
+                    
+                    SPI_FLASH_MSG_DEBUG("SPI_Flash: Flashing page Start addr = 0x%X, End addr = 0x%X\n", check_addr, current_page_end);
+
+                    // program to end of current page or end of data
+                    SPI_Flash_WritePageAligned_L(devNum, tmp_src, check_addr, current_page_size);
+                    check_addr += current_page_size;
+                    tmp_src += current_page_size;
+                }
+                else
+                {
+                    check_addr++;
+                    tmp_src++;
+                }
+            }
+        }
+                    
+        data += end_addr - start_addr + 1;
+    }
+        
+    if ((char_count % 256) != 1)
+    {
+        SPI_FLASH_MSG("\n\t ");
+    }
+}
+#endif
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Write                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr    - destination address on the flash                                         */
+/*                  data        - source data ptr                                                          */
+/*                  size        - source data size                                                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs logical write to the flash including smart erase sector          */
+/*                  scheduling                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_Write(UINT32 destAddr, UINT8* data, UINT32 size)
+{
+    INT32   devNum;
+
+    SPI_FLASH_MSG_DEBUG("\n");
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculating the device ID from the address                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    devNum = SPI_Flash_GetDeviceIndexbyAddr_L(destAddr);
+
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Num= %d \n", devNum);
+
+    if (devNum == -1)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if the driver was initialized                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!(SPI_Flash_Devices[devNum].FlashPageProg))
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Number %d wasn't initialized\n", devNum);    
+        return HAL_ERROR_NOT_INITIALIZED;
+    }
+
+
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Destination addr = 0x%X, Source addr = 0x%X, size = %d\n", destAddr, data, size);
+    
+#if defined(SPI_FLASH_SKIP_ERASE_ON_WRITE)
+
+    SPI_Flash_WritePageAligned_L(devNum, data, destAddr, size);
+
+#else // !defined(SPI_FLASH_SKIP_ERASE_ON_WRITE)
+    SPI_Flash_CheckAndDoEraseBoforeProgram_L(devNum, destAddr, data, size);
+#endif
+
+    return HAL_OK;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Erase                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr - address of the sector to erase                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine erase a sector from the flash                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_SectorErase(UINT32 destAddr)
+{
+    UINT32 localAddr;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculating the device ID from the address                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    INT32 devNum = SPI_Flash_GetDeviceIndexbyAddr_L(destAddr);
+
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Num= %d Erasing address 0x%X\n", devNum, destAddr);
+
+    if (devNum == -1)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if the driver was initialized                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!(SPI_Flash_Devices[devNum].FlashSectorErase))
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Number %d wasn't initialized\n", devNum);    
+        return HAL_ERROR_NOT_INITIALIZED;
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculating local address on the flash                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    localAddr = destAddr - SPI_Flash_Devices[devNum].startAddr;
+
+    if (localAddr % SPI_Flash_Devices[devNum].sector_size != 0)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Error: address for erase must point to beginning of Erase Sector                                */
+        /*-------------------------------------------------------------------------------------------------*/
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: address 0x%X for erase must point to beginning of Erase Sector\n", localAddr);
+
+        return HAL_ERROR_BAD_ADDRESS;
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Finally executing the drivers erase function                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Erasing sector from address 0x%X\n", destAddr);
+    SPI_Flash_Devices[devNum].FlashSectorErase(devNum, localAddr);
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_BulkErase                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr - address of the device                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine erase a sector from the flash                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_BulkErase(UINT32 destAddr)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Calculating the device ID from the address                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    INT32 devNum = SPI_Flash_GetDeviceIndexbyAddr_L(destAddr);   
+
+    if (devNum == -1)
+        return HAL_ERROR_BAD_DEVNUM;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if the driver was initialized                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!(SPI_Flash_Devices[devNum].FlashBulkErase))
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Number %d wasn't initialized\n", devNum);    
+        return HAL_ERROR_NOT_INITIALIZED;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Finally executing the drivers erase function                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Erasing flash device number %d\n", devNum);
+    SPI_Flash_Devices[devNum].FlashBulkErase(devNum);
+
+    return HAL_OK;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_ReadStatus                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - device number to read from                                                    */
+/*                  status - status variable to read into                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads flash status register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_ReadStatus(UINT32 devNum, UINT8 *status)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= CONFIG_SYS_MAX_FLASH_BANKS)
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Error Device Number %d\n", devNum);
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    if (!(SPI_Flash_Devices[devNum].FlashReadStatus))
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Number %d wasn't initialized\n", devNum);    
+        return HAL_ERROR_NOT_INITIALIZED;
+    }
+    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Redirecting to actual driver                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_Flash_Devices[devNum].FlashReadStatus(devNum, status);
+    
+    return HAL_OK;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_ReadPID                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - device number to read from                                                   */
+/*                  pid0    -                                                                              */
+/*                  pid1    -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads Flash device PID                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_ReadPID(UINT32 devNum, UINT8 *pid0, UINT16 *pid1 )
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Parameters check                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (devNum >= CONFIG_SYS_MAX_FLASH_BANKS)
+    {
+        SPI_FLASH_MSG_DEBUG("SPI_Flash: Error Device Number %d\n", devNum);
+        return HAL_ERROR_BAD_DEVNUM;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Redirecting to COMMON driver, as the actual driver can't be initialize yet                          */
+    /* (have to know the device ID)                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_Flash_Common_GetID(devNum, pid0, pid1);
+    
+    return HAL_OK;
+}
+
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             Local Functions                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_GetDeviceIndexbyAddr_L                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  addr - memory address to check                                                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine gets flash device index out of its memory mapped address                  */
+/*---------------------------------------------------------------------------------------------------------*/
+INT32 SPI_Flash_GetDeviceIndexbyAddr_L(UINT32 addr)
+{
+    INT32 idx     = 0;
+    
+    for (idx=0; idx<CONFIG_SYS_MAX_FLASH_BANKS; ++idx)
+    {
+        if ( (SPI_Flash_Devices[idx].startAddr <= addr) &&
+             (SPI_Flash_Devices[idx].startAddr + SPI_Flash_Devices[idx].chip_size > addr) )
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* We found the dev ID                                                                         */
+            /*---------------------------------------------------------------------------------------------*/
+            return idx;
+        }
+
+    }
+    SPI_FLASH_MSG_DEBUG("SPI_Flash: Device Number %d wasn't found\n", idx);
+    return -1;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Addr2Sector_L                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - Device index                                                                 */
+/*                  addr    - Memory mapped address                                                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine converts given address mapped to flash and returns the erase sector index */
+/*                  related to the given memory address                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+INT32 SPI_Flash_Addr2Sector_L(UINT32 dev_num, UINT32 addr)
+{
+    return (addr - SPI_Flash_Devices[dev_num].startAddr) / SPI_Flash_Devices[dev_num].sector_size;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_WritePageAligned_L                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev_num - Device index                                                                 */
+/*                  src     - Source data address                                                          */
+/*                  addr    - Destination address                                                          */
+/*                  cnt     - Data size                                                                    */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash page programming by pages chunks                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void SPI_Flash_WritePageAligned_L(UINT32 dev_num, UINT8 *src, UINT32 addr, UINT32 cnt)
+{
+    UINT32  local_addr      = addr - SPI_Flash_Devices[dev_num].startAddr;
+    UINT32  pageSize        = SPI_Flash_Devices[dev_num].page_size;
+    UINT32  actual_size     = 0;
+
+    if(cnt != 0)
+    {
+        while (cnt)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Calculating the size from current address to the start of the next page                     */
+            /*---------------------------------------------------------------------------------------------*/
+            actual_size = ((((local_addr)/pageSize) + 1)*pageSize) - (local_addr);
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* If we smaller amount to write                                                               */
+            /*---------------------------------------------------------------------------------------------*/
+            if (actual_size > cnt)
+                actual_size = cnt;
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Executing the Page Programming                                                              */
+            /*---------------------------------------------------------------------------------------------*/
+            SPI_Flash_Devices[dev_num].FlashPageProg(dev_num, local_addr, src, actual_size);
+            
+            /*---------------------------------------------------------------------------------------------*/
+            /* Updating loop variables                                                                     */
+            /*---------------------------------------------------------------------------------------------*/
+            src         += actual_size;
+            local_addr  += actual_size;
+            cnt         -= actual_size;
+        }
+    }
+}
+
+
+
diff --git a/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.h b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.h
new file mode 100755
index 0000000..188df45
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Peripherals/spi_flash/spi_flash.h
@@ -0,0 +1,152 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   spi_flash.h                                                                                           */
+/*            This file contains interface to SPI Flash driver                                             */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef _FLAHS_SPI_H
+#define _FLAHS_SPI_H
+
+#include "defs.h"
+#include "../../Common/hal_error.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Flash Device Class                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct flash_t
+{
+    UINT32          mf_id;
+    UINT32          capacity_id;
+    UINT8*          name;
+    UINT32          chip_size;
+    UINT32          sector_size;
+    UINT32          page_size;
+    UINT32          startAddr;
+
+    void            (*FlashPageProg)    (UINT32 devID, UINT32 destAddr, UINT8* data, UINT32 size);
+    void            (*FlashSectorErase) (UINT32 devID, UINT32 destAddr);
+    void            (*FlashReadStatus)  (UINT32 devID, UINT8 *statusReg);
+    void            (*FlashBulkErase)   (UINT32 devID);
+
+}flash_t;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* API Variables                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+extern flash_t SPI_Flash_Devices[CONFIG_SYS_MAX_FLASH_BANKS];
+extern UINT32  SPI_Flash_TotalSize;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              API Functions                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Init                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flashBaseAddress    - base address on the flash                                        */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs SPI flash initialization                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_Init(UINT32 flashBaseAddress);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_Write                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr    - destination address on the flash                                         */
+/*                  data        - source data ptr                                                          */
+/*                  size        - source data size                                                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs logical write to the flash including smart erase sector          */
+/*                  scheduling                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_Write(UINT32 destAddr, UINT8* data, UINT32 size);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_SectorErase                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr - address of the sector to erase                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine erase a sector from the flash                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_SectorErase(UINT32 destAddr);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_BulkErase                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  destAddr - address of the device                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine erase a sector from the flash                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_BulkErase(UINT32 destAddr);
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_ReadStatus                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum - device number to read from                                                    */
+/*                  status - status variable to read into                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads flash status register                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_ReadPID(UINT32 devNum, UINT8 *pid0, UINT16 *pid1 );
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SPI_Flash_ReadPID                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum  - device number to read from                                                   */
+/*                  pid0    -                                                                              */
+/*                  pid1    -                                                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads Flash device PID                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+HAL_STATUS SPI_Flash_ReadStatus(UINT32 devNum, UINT8 *status);
+
+
+
+
+#endif //_FLAHS_SPI_H
+
diff --git a/board/nuvoton/common/BMC_HAL/Tools/erase_unused_files.pl b/board/nuvoton/common/BMC_HAL/Tools/erase_unused_files.pl
new file mode 100755
index 0000000..626abb8
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Tools/erase_unused_files.pl
@@ -0,0 +1,206 @@
+# The script erases modules/chips/drivers that are NOT used by the given chips
+use File::Path;
+
+#Retriving input
+my $bmc_root = shift;
+my @preserve = @ARGV;
+
+#Input check
+if (($bmc_root eq "") or (@preserve == 0))
+{
+    usage();
+    exit(1);
+}
+
+my @save_files = ();
+my @erased_files = ();
+
+# Finding all the files that we need to preserve
+foreach $chip (@preserve)
+{
+    my @file_list = `perl modules_by_chip.pl $bmc_root $chip 1`;
+    chomp(@file_list);
+
+    # Adding unique file names to the list (avoid file duplication)
+    my(%work);
+    @work{@save_files, @file_list} = undef;
+    @save_files = sort keys %work;
+}
+
+# Erasing unused modules
+erase_unused_modules($bmc_root, "Modules");
+# Erasing unused chip files
+erase_unused_chips($bmc_root, "Chips");
+# Erasing driver dependencies
+erase_unused_drivers($bmc_root, "Drivers");
+
+
+
+# Erases unneeded modules
+sub erase_unused_modules
+{
+    my $root = shift;
+    my $dir = shift;
+    
+    opendir (DIR, "$root/$dir") or die "Unable to open $root/$dir: $!";
+    my @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    closedir (DIR);
+
+    for $file(@files) 
+    {
+        if (-d ($root."/".$dir."/".$file)) 
+        {
+            erase_unused_modules($root, "$dir/$file");
+        } 
+        else 
+        { 
+            if (not is_in_list($dir."/".$file, @save_files) == 1)
+            {
+                # Erasing unused files
+                push @erased_files, "$dir/$file";
+                print "Erasing file  : $dir/$file\n";
+                unlink "$root/$dir/$file" or print "$!\n";
+            }
+        }
+    }
+
+    # Checking if directory is empty and we can erase it as well
+    opendir (DIR, "$root/$dir") or die "Unable to open $root/$dir: $!";
+    @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    closedir (DIR);
+    
+    if (@files == 0)
+    {
+        print "Erasing dir   : $dir\n";
+        rmdir $root."/".$dir or print "$!\n";
+    }
+}
+
+# Erases unneeded chip files
+sub erase_unused_chips
+{
+    my $root = shift;
+    my $dir = shift;
+
+    opendir (DIR, "$root/$dir") or die "Unable to open $root/$dir: $!";
+    my @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    closedir (DIR);
+    
+    foreach $file (@files)
+    {
+        if (-d "$root/$dir/$file")
+        {
+            if (not is_in_list($file, @preserve))
+            {
+                print "Erasing chip  : $dir/$file\n";
+                rmtree ( "$root/$dir/$file") or print "$!\n";
+            }
+        }
+    }
+}
+
+# Erases drivers that are dependent on removed modules
+sub erase_unused_drivers
+{
+    my $root = shift;
+    my $dir = shift;
+    
+    opendir (DIR, "$root/$dir") or die "Unable to open $root/$dir: $!";
+    my @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    closedir (DIR);
+    
+    foreach $file (@files)
+    {
+        if (-d "$root/$dir/$file")
+        {
+            if (is_driver_dirty("$root/$dir/$file", "../.."))
+            {
+                print "Erasing driver: $dir/$file\n";
+                rmtree ( "$root/$dir/$file") or print "$!\n";
+            }
+        }
+    }
+}
+
+
+# Checking if given Driver depends on modules that were erased, 
+# returns true if it is or false otherwise
+sub is_driver_dirty
+{
+    my $root = shift;
+    my $level = shift;
+    
+    printf ("checking $root with $level\n");
+    
+    opendir (DIR, "$root") or die "Unable to open $root: $!";
+    my @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    closedir (DIR);
+    
+    foreach $file (@files)
+    {
+        if (-d "$root/$file")
+        {
+            if (is_driver_dirty("$root/$file", "$level/.."))
+            {
+                return 1;
+            }
+        }
+        else
+        {
+            # Openning chip file
+            open FILE, "$root/$file" or die "Cannon open $root/$file!\n";
+            my @drv_file = <FILE>;
+            close FILE;
+
+            # extracting includes from files
+            foreach $line(@drv_file)
+            {
+                #using some voodoo regexp to extract the information
+                if ($line =~ /^(\s*)#include(\s+)([\<\"])(\s*)($level\/)(.+)([\>\"])(.*)/)
+                {
+                    my $used_module = $6;
+                    
+                    # if the included module was erased, mark the driver as dirty
+                    if (not -e "$bmc_root/$used_module")
+                    {
+                        return 1;
+                    }
+                }
+            }
+                        
+        }
+    }
+    
+    return 0;
+}
+
+# Checking if given element included in given list
+sub is_in_list
+{
+    my $element = shift;
+    my @list = @_;
+    
+    foreach $item (@list)
+    {
+        if ($item eq $element)
+        {
+            return 1;
+        }
+    }
+    
+    return 0;
+}
+
+
+
+# Usage information
+sub usage
+{
+    print "\n-= Unused files erase BMC Utility =-\n\n";
+    print "Usage:\n";
+    print "perl erase_unused_files.pl <BMC ROOT> <CHIP NAME1> [CHIP_NAME2] ...\n";
+    print "\nOptions:\n\n";
+    print "<BMC ROOT>         - Path to the root directory of BMC HAL\n";
+    print "<CHIP NAMEx>       - Name of one or more chips that their dependencies\n";
+    print "                     won't be erased from the BMC modules/chips/drivers\n";
+}
\ No newline at end of file
diff --git a/board/nuvoton/common/BMC_HAL/Tools/modules_by_chip.pl b/board/nuvoton/common/BMC_HAL/Tools/modules_by_chip.pl
new file mode 100755
index 0000000..248317f
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/Tools/modules_by_chip.pl
@@ -0,0 +1,113 @@
+# The script lists all the module files for a given chip name
+
+#!perl
+
+# Reading chip_name parameter
+my $bmc_root        = shift;
+my $chip_name       = shift;
+my $operation_type  = shift;
+my $regexp          = shift;
+
+# Checking must parameters
+if (($bmc_root eq "") or ($chip_name eq ""))
+{
+    usage();
+    exit(1);
+}
+
+if (($operation_type ne "") and ($operation_type != 0) and ($operation_type != 1))
+{
+    print "Operation type must be 0 or 1\n";
+    exit(1);
+}
+
+# if regural expression wasn't passed, we make it to match any input
+$regexp = qr/(.*)/          if ($regexp eq "");
+$regexp = qr/$regexp/       if ($regexp eq "");
+
+# Openning chip file
+open CHIP_FILE, "$bmc_root/Chips/$chip_name/$chip_name.h" or die "Cannon open Chips/$chip_name/$chip_name.h!\n";
+
+# Reading chip file content
+my @chip_file = <CHIP_FILE>;
+
+my @modules = ();
+my @module_files = ();
+
+# Extracting modules from chip definition file
+foreach $line(@chip_file)
+{
+    #using some voodoo regexp to extract the information
+    if ($line =~ /^#define(\s+)(\w+)(_MODULE_TYPE)(\s+)(\w+)/)
+    {
+        push @modules, [lc($2), $5];
+    }
+}
+
+# Emitting modules
+foreach $mod (@modules)
+{
+    if ($operation_type == 0)
+    {
+        printf "$$mod[0]\t\t$$mod[1]\n" if "$$mod[0]\t\t$$mod[1]" =~ $regexp;
+    }
+    else
+    {
+        # printing interface files
+        print_dir($bmc_root, "Modules/$$mod[0]", 0);
+        #printing driver content
+        print_dir($bmc_root, "Modules/$$mod[0]/$$mod[1]", 1);
+    }
+}
+
+
+sub usage
+{
+    print "\n-= Modules by chip BMC Utility =-\n\n";
+    print "Usage:\n";
+    print "perl modules_by_chip.pl <BMC ROOT> <CHIP NAME> [Operation Mode] [RegExp]\n";
+    print "\nOptions:\n\n";
+    print "<BMC ROOT>         - Path to the root directory of BMC HAL\n";
+    print "<CHIP NAME>        - Name of the chip that included in Chips directory\n";
+    print "[ Operation Mode ] - If omitted or '0' the script emits module names and it types\n";
+    print "                     If equal '1' or higher the script emits modules file list\n";
+    print "[ RegExp ]         - Optional perl regular expression that will be activated \n";
+    print "                     on each output line\n";
+}
+
+
+sub print_dir
+{
+    my $prefix_dir = shift;
+    my $dir = shift;
+    my $emit_subdirs = shift;
+    
+    # Open the directory.
+    opendir (DIR, "$prefix_dir/$dir") or die "Unable to open $prefix_dir/$dir: $!";
+    # Get files
+    my @files = grep { !/^\.{1,2}$/ } readdir (DIR);
+    # Close the directory.
+    closedir (DIR);
+
+    my @path_files = map { $path . '\\' . $_ } @files;
+
+    for (@files) 
+    {
+        # If the file is a directory
+        if (-d ($prefix_dir."/".$dir."/".$_)) 
+        {
+            # recursevly printing the directories if ordered
+            print_dir($prefix_dir, "$dir/$_", $emit_subdirs) unless ($emit_subdir == 0);
+        } 
+        else 
+        { 
+            # creating file path
+            my $file_with_dir = $dir . "/" . $_ ;
+            
+            # emitting the file
+            print $file_with_dir . "\n" if $file_with_dir =~ $regexp;
+        }
+    }
+    
+    return @output;
+}
diff --git a/board/nuvoton/common/BMC_HAL/version.h b/board/nuvoton/common/BMC_HAL/version.h
new file mode 100755
index 0000000..9a53806
--- /dev/null
+++ b/board/nuvoton/common/BMC_HAL/version.h
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   version.h                                                                                             */
+/*            This file contains version number of BMC HAL                                                 */
+/*  Project:                                                                                               */
+/*            BMC HAL                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define BMC_HAL_MAJOR   0
+#define BMC_HAL_MINOR   3
+#define BMC_HAL_REV     2
+
+#define BMC_HAL_VERSION         MAKE32(MAKE16(BMC_HAL_REV, BMC_HAL_MINOR), MAKE16(BMC_HAL_MAJOR, 0x00))
+#define BMC_HAL_VERSION_STR     STRINGX(BMC_HAL_MAJOR) "." STRINGX(BMC_HAL_MINOR) "." STRINGX(BMC_HAL_REV)
+
+
diff --git a/board/nuvoton/common/Makefile b/board/nuvoton/common/Makefile
new file mode 100755
index 0000000..07b5fba
--- /dev/null
+++ b/board/nuvoton/common/Makefile
@@ -0,0 +1,11 @@
+
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= nuvoton_aic.o nuvoton_serial.o nuvoton_eth.o nuvoton_timer.o nuvoton_flash.o nuvoton_init.o nuvoton_low_level.o
+obj-$(CONFIG_USB_HOST)	+= nuvoton_usb.o
+
diff --git a/board/nuvoton/common/SWC_DEFS/defs.h b/board/nuvoton/common/SWC_DEFS/defs.h
new file mode 100755
index 0000000..b29b865
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs.h
@@ -0,0 +1,29 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs.h                                                                                                */
+/*            This file contains NTIL generic types, macros, constants, utilities and error codes          */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __DEFS_H__
+#define __DEFS_H__
+
+#include "defs_types.h"
+#include "defs_access.h"
+#include "defs_utils.h"
+#include "defs_errors.h"
+#include "defs_secured.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             defs.h Version                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_H_VERSION      1.83
+
+#endif /* __DEFS_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_access.h b/board/nuvoton/common/SWC_DEFS/defs_access.h
new file mode 100755
index 0000000..a35449b
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_access.h
@@ -0,0 +1,312 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_access.h                                                                                         */
+/*            This file contains NTIL hardware registers access and field manipulation macros              */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __ACCESS_H__
+#define __ACCESS_H__
+
+#include "defs_internal.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                      REGISTERS AND VARIABLES ACCESS, BIT AND FIELD OPERATION MACROS                     */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Generic registers access macros assuming registers database defined as follows: (see Coding Standards   */
+/* document Chapter 12 for detailed description)                                                           */
+/*                                                                                                         */
+/* Module defintition:                                                                                     */
+/* ------------------                                                                                      */
+/*                                                                                                         */
+/* #define <MODULE>_BASE_ADDR          (<module_base_addr> )             these definition should be kept   */
+/*                                                                       in  a <chip>.h file, since it is  */
+/*                                                                       chip specific                     */
+/*                                                                                                         */
+/* #define <MODULE>_ACCESS             (<module_access_type> )           same name as access macros        */
+/*                                                                       name,i.e MEM, IO, INDEXDATA, etc. */
+/*                                                                       The rest of the definitions       */
+/*                                                                       should be kept in a <hw_module>.h */
+/*                                                                       file since they are module        */
+/*                                                                       specific                          */
+/*                                                                                                         */
+/* Regsiter defintition:                                                                                   */
+/* --------------------                                                                                    */
+/*                                                                                                         */
+/* #define <MY_REG_1>              (<MODULE>_BASE_ADDR + <offset>), <ACCESS TYPE>, <8/16/32>               */
+/*                                                                                                         */
+/* Fields defintition:                                                                                     */
+/* -------------------                                                                                     */
+/*                                                                                                         */
+/* #define <MY_REG_1_FIELD_1>   <field 1 position>, <field 1 size>                                         */
+/* #define <MY_REG_1_FIELD_2>   <field 2 position>, <field 2 size>                                         */
+/* ...                                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* When there is a definition of registers as described above, manipulations on registers and fields can   */
+/* be done in the following ways:                                                                          */
+/*                                                                                                         */
+/* 1. The registers can be accessed directly using the following macros:                                   */
+/*                                                                                                         */
+/*          REG_READ(reg)                                                                                  */
+/*          REG_WRITE(reg,val)                                                                             */
+/*                                                                                                         */
+/* 2. Registers field can be accessed using the following macros, whose internal implementation access the */
+/*    register using REG_READ and REG_WRITE macors (implicit read-modify-write)                            */
+/*                                                                                                         */
+/*                                                                                                         */
+/*          READ_REG_FIELD(reg, field)                                                                     */
+/*          SET_REG_FIELD(reg, field, value)                                                               */
+/*                                                                                                         */
+/*                                                                                                         */
+/* 3. For registers field manipulation via explicit read-modify-write procedure on a variable, use the     */
+/*    following macros:                                                                                    */
+/*                                                                                                         */
+/*          READ_VAR_FIELD(var, field)                                                                     */
+/*          SET_VAR_FIELD(var, field, value)                                                               */
+/*                                                                                                         */
+/*                                                                                                         */
+/* 4. For the cases when the fields are single bits and are stored in a variable rather than in a constant,*/
+/*    the following sets of macros can be used:                                                            */
+/*                                                                                                         */
+/*          SET_REG_BIT(reg, bit_no)                                                                       */
+/*          READ_REG_BIT(reg, bit_no)                                                                      */
+/*          CLEAR_REG_BIT(reg, bit_no)                                                                     */
+/*                                                                                                         */
+/*          SET_VAR_BIT(var, bit_no)                                                                       */
+/*          READ_VAR_BIT(var, bit_no)                                                                      */
+/*          CLEAR_VAR_BIT(var, bit_no                                                                      */
+/*                                                                                                         */
+/* 5. For the cases where masks that should be written to the registers are variables, one may use the     */
+/*    the following macros. These macros should be used rarely, only in the cases where the usual method   */
+/*    of fields defitinions can not be used:                                                               */
+/*                                                                                                         */
+/*          SET_VAR_MASK(var, bit_mask)                                                                    */
+/*          READ_VAR_MASK(var, bit_mask)                                                                   */
+/*          CLEAR_VAR_MASK(var, bit_mask)                                                                  */
+/*                                                                                                         */
+/*          SET_REG_MASK(reg, bit_mask)                                                                    */
+/*          READ_REG_MASK(reg, bit_mask)                                                                   */
+/*          CLEAR_REG_MASK(reg, bit_mask)                                                                  */
+/*                                                                                                         */
+/*                                                                                                         */
+/* 6. Sometimes it is required to just get a mask (filled with 1b) that fits a certain field without       */
+/*    writing a value to it. For this purpose use the macro                                                */
+/*                                                                                                         */
+/*          MASK_FIELD(field)                                                                              */
+/*                                                                                                         */
+/* 7. For building a value of a mask without writing to actual register or value, use:                     */
+/*                                                                                                         */
+/*          BUILD_FIELD_VAL(field, value)                                                                  */
+/*                                                                                                         */
+/*    This macro is useful when several fields of register/variable are required to be set at a time.      */
+/*    In this case, an ORed chain of BUILD_FIELD_VAL invocations will be written to the                    */
+/*    register/variable                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Direct register access                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define      REG_READ(reg)                                                                                 \
+            _REG_READ_AUX_(_GET_REG_ADDR(reg), _GET_REG_ACCESSTYPE(reg), _GET_REG_SIZE(reg))
+
+#define      REG_WRITE(reg,val)                                                                            \
+            _REG_WRITE_AUX_((val),_GET_REG_ADDR(reg),_GET_REG_ACCESSTYPE(reg), _GET_REG_SIZE(reg))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Get field of a register / variable                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define READ_REG_FIELD(reg, field)                                                                         \
+    _READ_FIELD(REG_READ(_GET_REG(reg)), _GET_REG_SIZE(reg), _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))
+
+#ifdef CPU_64_BIT
+#define READ_VAR_FIELD(var, field)                                                                         \
+   ((sizeof(var) == 8) ? (_READ_FIELD(var, 64, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))) :           \
+   ((sizeof(var) == 4) ? (_READ_FIELD(var, 32, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))) :           \
+   ((sizeof(var) == 2) ? (_READ_FIELD(var, 16, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))) :           \
+                         (_READ_FIELD(var,  8, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))))))
+#else
+#define READ_VAR_FIELD(var, field)                                                                         \
+   ((sizeof(var) == 4) ? (_READ_FIELD(var, 32, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))) :           \
+   ((sizeof(var) == 2) ? (_READ_FIELD(var, 16, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field))) :           \
+                         (_READ_FIELD(var,  8, _GET_FIELD_SIZE(field), _GET_FIELD_POS(field)))))
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Set field of a register / variable                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_REG_FIELD(reg, field, value)                                                                   \
+    _SET_REG_FIELD_SIZE(_GET_REG(reg),_GET_FIELD_SIZE(field),_GET_FIELD_POS(field),(value))
+
+
+#define SET_VAR_FIELD(var, field, value)                                                                   \
+    _SET_VAR_FIELD(var,_GET_FIELD_SIZE(field), _GET_FIELD_POS(field), (value))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Variable bit operation macros                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef CPU_64_BIT
+#define SET_VAR_BIT(var, nb)                                                                               \
+   ((sizeof(var) == 8) ? ((var) |= ((UINT64)0x1<<(nb))):                                                   \
+   ((sizeof(var) == 4) ? ((var) |= ((UINT32)0x1<<(nb))):                                                   \
+   ((sizeof(var) == 2) ? ((var) |= ((UINT16)0x1<<(nb))):                                                   \
+                         ((var) |= (        0x1<<(nb))))))
+#else
+#define SET_VAR_BIT(var, nb)                                                                               \
+   ((sizeof(var) == 4) ? ((var) |= ((UINT32)0x1<<(nb))):                                                   \
+   ((sizeof(var) == 2) ? ((var) |= ((UINT16)0x1<<(nb))):                                                   \
+                         ((var) |= (        0x1<<(nb)))))
+
+#endif
+
+#define READ_VAR_BIT(var, nb)      (((var) >> (nb)) & 0x1)
+
+#ifdef CPU_64_BIT
+#define CLEAR_VAR_BIT(var, nb)                                                                             \
+    ((sizeof(var) == 8) ? ((var) &= (~((UINT64)0x1<<(nb)))):                                               \
+    ((sizeof(var) == 4) ? ((var) &= (~((UINT32)0x1<<(nb)))):                                               \
+    ((sizeof(var) == 2) ? ((var) &= (~((UINT16)0x1<<(nb)))):                                               \
+                          ((var) &= (~(        0x1<<(nb)))))))
+#else
+#define CLEAR_VAR_BIT(var, nb)                                                                             \
+    ((sizeof(var) == 4) ? ((var) &= (~((UINT32)0x1<<(nb)))):                                               \
+    ((sizeof(var) == 2) ? ((var) &= (~((UINT16)0x1<<(nb)))):                                               \
+                          ((var) &= (~(        0x1<<(nb))))))
+#endif
+						  
+
+#define MASK_BIT(nb)               (1UL<<(nb))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register bit operation macros                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_REG_BIT(reg, nb)                                                                               \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) | ((_CASTING_FROM(_GET_REG_SIZE(reg)))0x1<<(nb))))
+
+#define READ_REG_BIT(reg, nb)                                                                              \
+    (((REG_READ(_GET_REG(reg))>>(nb)) & ((_CASTING_FROM(_GET_REG_SIZE(reg)))0x1)))
+
+#define CLEAR_REG_BIT(reg, nb)                                                                             \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) & (~((_CASTING_FROM(_GET_REG_SIZE(reg)))0x1<<(nb)))))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Variable mask operation macros                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_VAR_MASK(var, bit_mask)       ((var) |= (bit_mask))
+
+#define READ_VAR_MASK(var, bit_mask)      ((var) &  (bit_mask))
+
+#define CLEAR_VAR_MASK(var, bit_mask)     ((var) &= (~(bit_mask)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Register mask operation macros                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_REG_MASK(reg, bit_mask)                                                                        \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) | (bit_mask)))
+
+#define READ_REG_MASK(reg, bit_mask)                                                                       \
+    (REG_READ(_GET_REG(reg)) & (bit_mask))
+
+#define CLEAR_REG_MASK(reg, bit_mask)                                                                      \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) & (~(bit_mask))))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Build a mask of a register / variable field                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MASK_FIELD(field)                                                                                  \
+    _MASK_FIELD(_GET_FIELD_SIZE(field), _GET_FIELD_POS(field))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Expand the value of the given field into its correct position                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define BUILD_FIELD_VAL(field, value)                                                                      \
+    _BUILD_FIELD_VAL(_GET_FIELD_SIZE(field), _GET_FIELD_POS(field), (value))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Getting info about registers and fields                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  REG_ADDR(reg)                _GET_REG_ADDR(reg)
+#define  GET_FIELD(pos,size)           pos,size
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                SFR ACCESS,BIT AND FIELD OPERATION MACROS                                */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR Handling.                                                                                           */
+/* KEIL and COP8 handle SFRs as VARs, other tools may handle them as REGs                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#if (defined (__C51__) && defined (__KEIL__)) || defined (__COP8_IAR__)     /* KEIL / COP8                 */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Direct SFR access                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SFR_READ(sfr)                           (sfr)
+#define SFR_WRITE(sfr, val)                      sfr = (val)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR fields manipulation                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define READ_SFR_FIELD(sfr, field)              READ_VAR_FIELD(sfr, _GET_FIELD(field))
+#define SET_SFR_FIELD(sfr, field, value)        SET_VAR_FIELD(sfr, _GET_FIELD(field), (value))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR non-constant bit operation macros                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_SFR_BIT(sfr, nb)                    SET_VAR_BIT(sfr, nb)
+#define READ_SFR_BIT(sfr, nb)                   READ_VAR_BIT(sfr, nb)
+#define CLEAR_SFR_BIT(sfr, nb)                  CLEAR_VAR_BIT(sfr, nb)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR mask operation macros                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_SFR_MASK(sfr, bit_mask)             SET_VAR_MASK(sfr, bit_mask)
+#define READ_SFR_MASK(sfr, bit_mask)            READ_VAR_MASK(sfr, bit_mask)
+#define CLEAR_SFR_MASK(sfr, bit_mask)           CLEAR_VAR_MASK(sfr, bit_mask)
+
+#else
+/*---------------------------------------------------------------------------------------------------------*/
+/* Direct SFR access                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SFR_READ(sfr)                           REG_READ(_GET_REG(sfr))
+#define SFR_WRITE(sfr, val)                     REG_WRITE(_GET_REG(sfr), (val))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR fields manipulation                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define READ_SFR_FIELD(sfr, field)              READ_REG_FIELD(_GET_REG(sfr), _GET_FIELD(field))
+#define SET_SFR_FIELD(sfr, field, value)        SET_REG_FIELD(_GET_REG(sfr), _GET_FIELD(field), (value))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR non-constant bit operation macros                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_SFR_BIT(sfr, nb)                    SET_REG_BIT(_GET_REG(sfr), nb)
+#define READ_SFR_BIT(sfr, nb)                   READ_REG_BIT(_GET_REG(sfr), nb)
+#define CLEAR_SFR_BIT(sfr, nb)                  CLEAR_REG_BIT(_GET_REG(sfr), nb)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SFR mask operation macros                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SET_SFR_MASK(sfr, bit_mask)             SET_REG_MASK(_GET_REG(sfr), bit_mask)
+#define READ_SFR_MASK(sfr, bit_mask)            READ_REG_MASK(_GET_REG(sfr), bit_mask)
+#define CLEAR_SFR_MASK(sfr, bit_mask)           CLEAR_REG_MASK(_GET_REG(sfr), bit_mask)
+
+#endif
+
+
+
+#endif /* __ACCESS_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_core_arm.h b/board/nuvoton/common/SWC_DEFS/defs_core_arm.h
new file mode 100755
index 0000000..8cbe433
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_core_arm.h
@@ -0,0 +1,433 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_core_arm.h                                                                                       */
+/*            This file contains definitions for ARM core and its compilers                                */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DEFS_ARM_H_
+#define _DEFS_ARM_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent types                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef UINT32              UINT;                       /* Native type of the core that fits the core's    */
+typedef INT32               INT;                        /* internal registers                              */
+typedef UINT                BOOLEAN;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent PTR definitions                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define REG8                volatile  UINT8
+#define REG16               volatile  UINT16
+#define REG32               volatile  UINT32
+
+#define PTR8                REG8 *
+#define PTR16               REG16 *
+#define PTR32               REG32 *
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent MEM definitions                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MEMR8(a)            (*(PTR8) (a))
+#define MEMR16(a)           (*(PTR16)(a))
+#define MEMR32(a)           (*(PTR32)(a))
+
+#define MEMW8(a,v)          ((*((PTR8)  (a))) = ((UINT8)(v)))
+#define MEMW16(a,v)         ((*((PTR16) (a))) = ((UINT16)(v)))
+#define MEMW32(a,v)         ((*((PTR32) (a))) = ((UINT32)(v)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent IO definitions                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOR8(a)             MEMR8(a)
+#define IOR16(a)            MEMR16(a)
+#define IOR32(a)            MEMR32(a)
+
+#define IOW8(a,v)           MEMW8(a, v)
+#define IOW16(a,v)          MEMW16(a, v)
+#define IOW32(a,v)          MEMW32(a, v)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Inline functions                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _INLINE_                                __inline
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt Service Routines                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(__ARMCC_VERSION)
+#define _ISR_                                   __irq 
+#elif defined (__GNUC__)
+#define _ISR_                                   __attribute__((interrupt))
+#else
+#warning Warning: _ISR_ macro is not defined for current compiler
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Variables alignment                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _ALIGN_(x, decl)                        decl __attribute__((aligned(x)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Variables packing                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _PACK_(decl)                            decl __attribute__((packed))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Declare a variable as zero-initialized                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _ZI_(decl)                              decl __attribute__((zero_init))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Declare a variable within a user-defined section                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _SECTION_(secname, decl)                decl __attribute__((section(secname)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Define a variable at a fixed memory address                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _AT_(addr, decl)                        decl __attribute__((at(addr)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Inform the compiler that the function does not return                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _NORET_(decl)                           decl __attribute__ ((noreturn))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Inform the compiler that the function does not return even if t reaches an explicit or implicit return  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _NORET_SPEC_(decl)                      __declspec (noreturn) decl
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Call a function at addr                                                                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (__thumb__)
+#define FUNC_CALL(addr)                         (((void (*)(void))(addr | 0x01))())
+#else
+#define FUNC_CALL(addr)                         (((void (*)(void))(addr | 0x00))())
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                    ARMCC windows compiler(s) support                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(__ARMCC_VERSION)
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Interrrupt macros                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    #define ENABLE_INTERRUPTS()             __enable_irq()
+    #define DISABLE_INTERRUPTS()            __disable_irq()
+    #define INTERRUPTS_SAVE_DISABLE(var)    { var = __disable_irq(); }
+    #define INTERRUPTS_RESTORE(var)         { if (!var) { __enable_irq(); } }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Assertion macros                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    #ifndef ASSERT
+    #ifdef DEBUG
+        #if defined (__TARGET_ARCH_4)   || (__TARGET_ARCH_4T)
+            #define ASSERT(cond)    {if (!(cond)) for(;;) ;}
+        #else
+            #define ASSERT(cond)    {if (!(cond)) {__breakpoint(0);}}
+        #endif
+    #else
+        #define ASSERT(cond)
+    #endif
+    #endif
+
+    #if defined (__thumb__)
+        /*-------------------------------------------------------------------------------------------------*/
+        /*                                      THUMB INSTRUCTION SET                                      */
+        /*                          Inline assembly instructions are NOT allowed                           */
+        /*-------------------------------------------------------------------------------------------------*/
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* CPU power management                                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if (__TARGET_ARCH_THUMB > 2)
+            #define CPU_IDLE()                          __wfi()
+        #endif
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Cache macros                                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if (__TARGET_ARCH_THUMB > 3)
+            static __inline __asm UINT32 __defs_getCP15(void)
+            {
+                MRC  p15, 0, r0, c1, c0;
+                BX   lr;
+            }
+
+            static __inline __asm void __defs_setCP15(UINT32 val)
+            {
+                MCR  p15, 0, r0, c1, c0;
+                BX   lr;
+            }
+
+            #define ICACHE_SAVE_DISABLE(var)    {var = __defs_getCP15(); __defs_setCP15( var & (~0x1000)); }
+            #define ICACHE_SAVE_ENABLE(var)     {var = __defs_getCP15(); __defs_setCP15( var | 0x1000); }
+            #define ICACHE_RESTORE(var)         __defs_setCP15(var)
+        #endif
+    #else
+        /*-------------------------------------------------------------------------------------------------*/
+        /*                                       ARM INSTRUCTION SET                                       */
+        /*                             Inline assemly instructions are allowed                             */
+        /*-------------------------------------------------------------------------------------------------*/
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* CPU power management                                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if defined (__TARGET_ARCH_4)   || (__TARGET_ARCH_4T) || (__TARGET_ARCH_5T) || (__TARGET_ARCH_5TE) || \
+                    (__TARGET_ARCH_5TEJ)|| (__TARGET_ARCH_6)  || (__TARGET_ARCH_6_M)|| (__TARGET_ARCH_6S_M)|| \
+                    (__TARGET_ARCH_6K)  || (__TARGET_ARCH_6T2)|| (__TARGET_ARCH_6Z) || (__ARM_ARCH_7J__)
+
+            #define CPU_IDLE()          {                                                       \
+                                            UINT32 __armcc_temp_var = 0;                        \
+                                            __asm   {                                           \
+                                                        MCR p15, 0, __armcc_temp_var, c7, c0, 4;\
+                                                    }                                           \
+                                        }
+        #else
+            #define CPU_IDLE()          __wfi()
+        #endif
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Cache macros                                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        #define ICACHE_SAVE_DISABLE(var) {                                                  \
+                                            UINT32 __armcc_temp_var;                        \
+                                            __asm{ MRC  p15, 0, var, c1, c0;                \
+                                                   BIC  __armcc_temp_var, var, 0x1000;      \
+                                                   MCR  p15, 0, __armcc_temp_var, c1, c0; } \
+                                         }
+
+        #define ICACHE_SAVE_ENABLE(var)  {                                                  \
+                                            UINT32 __armcc_temp_var;                        \
+                                            __asm{ MRC  p15, 0, var, c1, c0;                \
+                                                   ORR  __armcc_temp_var, var, 0x1000;      \
+                                                   MCR  p15, 0, __armcc_temp_var, c1, c0; } \
+                                         }
+
+
+        #define ICACHE_RESTORE(var)         __asm{ MCR  p15, 0, var, c1, c0 }
+
+
+        #define SET_CR(var)                 __asm{ MCR  p15, 0, var, c1, c0 }
+
+        #define ISB()                       __asm{ ISB }
+        #define DSB()                       __asm{ DSB }
+        #define NOP()                       __asm{ NOP }
+
+    #endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                     GNU GCC based compilers support                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (__GNUC__)
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Assertion macros                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    #ifndef ASSERT
+    #ifdef DEBUG
+        #if defined (__ARM_ARCH_2__)   || (__ARM_ARCH_3__)   || (__ARM_ARCH_3M__)  || (__ARM_ARCH_4__)   || \
+                    (__ARM_ARCH_4T__)
+            #define ASSERT(cond)    {if (!(cond)) for(;;) ;}
+        #else
+            #define ASSERT(cond)    {if (!(cond))  {__asm   __volatile__ ( "BKPT #0" );} }
+        #endif
+    #else
+        #define ASSERT(cond)
+    #endif
+    #endif
+
+    #if defined (__thumb__)
+        /*-------------------------------------------------------------------------------------------------*/
+        /*                                      THUMB INSTRUCTION SET                                      */
+        /*                          Some assembly instructions are not available                           */
+        /*-------------------------------------------------------------------------------------------------*/
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* CPU power management                                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if defined (__ARM_ARCH_2__)   || (__ARM_ARCH_3__)   || (__ARM_ARCH_3M__)  || (__ARM_ARCH_4__)   || \
+                    (__ARM_ARCH_4T__)  || (__ARM_ARCH_5T__)  || (__ARM_ARCH_5TE__) || (__ARM_ARCH_5TEJ__)|| \
+                    (__ARM_ARCH_6J__)  || (__ARM_ARCH_7J__)
+            /*---------------------------------------------------------------------------------------------*/
+            /* Not supported by architecture with Thumb instructions                                       */
+            /*---------------------------------------------------------------------------------------------*/
+            #define CPU_IDLE()
+
+        #elif defined (__ARM_ARCH_6_M__) || (__ARM_ARCH_6__)  || (__ARM_ARCH_6S_M__) ||                     \
+                      (__ARM_ARCH_6K__)  || (__ARM_ARCH_6T2__)
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Supported via CP15                                                                          */
+            /*---------------------------------------------------------------------------------------------*/
+            #define CPU_IDLE()                          __asm   __volatile__ (                              \
+                                                                                "MOV r0, #0 \n\t"           \
+                                                                                "MCR p15, 0, r0, c7, c0, 4" \
+                                                                                ::: "r0", "cc" )
+        #else
+            /*---------------------------------------------------------------------------------------------*/
+            /* Supported with WFI instruction                                                              */
+            /*---------------------------------------------------------------------------------------------*/
+            #define CPU_IDLE()                          __asm__ __volatile__("WFI")
+        #endif
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Interrrupt macros                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if defined (__ARM_ARCH_4__) || (__ARM_ARCH_4T__) || (__ARM_ARCH_5T__) || (__ARM_ARCH_5TE__) || (__ARM_ARCH_5TEJ__)
+
+            /*---------------------------------------------------------------------------------------------*/
+            /* Not supported with Thumb instructions                                                       */
+            /*---------------------------------------------------------------------------------------------*/
+
+        #elif defined (__ARM_ARCH_6J__) || (__ARM_ARCH_6ZK__)  || (__ARM_ARCH_7J__)
+            /*---------------------------------------------------------------------------------------------*/
+            /* Support for CPSIE instruction                                                               */
+            /*---------------------------------------------------------------------------------------------*/
+            #define ENABLE_INTERRUPTS()             __asm__ __volatile__("CPSIE i")
+            #define DISABLE_INTERRUPTS()            __asm__ __volatile__("CPSID i")
+            #define INTERRUPTS_SAVE_DISABLE(var)    DISABLE_INTERRUPTS()
+            #define INTERRUPTS_RESTORE(var)         ENABLE_INTERRUPTS()
+
+        #else
+            /*---------------------------------------------------------------------------------------------*/
+            /* Full assembly support with Thumb2                                                           */
+            /*---------------------------------------------------------------------------------------------*/
+            #define ENABLE_INTERRUPTS()       __asm__ __volatile__(                         \
+                                                    "MRS    r6, APSR     \n\t"              \
+                                                    "MOV    r5, #0x80    \n\t"              \
+                                                    "BIC    r6,r6,r5     \n\t"              \
+                                                    "MSR    APSR_nzcvq,r6  " ::: "r6", "r5", "cc" )
+
+            #define DISABLE_INTERRUPTS()      __asm__ __volatile__(                         \
+                                                    "MRS    r6, APSR     \n\t"              \
+                                                    "MOV    r5, #0x80    \n\t"              \
+                                                    "ORR    r6, r6,r5    \n\t"              \
+                                                    "MSR    APSR_nzcvq, r6 " ::: "r6", "r5", "cc")
+
+            #define INTERRUPTS_SAVE_DISABLE(var)  __asm__ __volatile__(                     \
+                                                    "MRS    %[val], APSR     \n\t"          \
+                                                    "MOV    r6, #0x80        \n\t"          \
+                                                    "ORR    r6, %[val],r6    \n\t"          \
+                                                    "MSR    APSR_nzcvq,r6  "                \
+                                                    :[val] "+r" (var):: "r6", "cc")
+
+            #define INTERRUPTS_RESTORE(var)   __asm__ __volatile__(                         \
+                                                    "MSR    APSR_nzcvq,%[val]  "            \
+                                                    : [val]"+r"(var) )
+        #endif
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Cache macros                                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if defined (__ARM_ARCH_2__)  || (__ARM_ARCH_3__)   || (__ARM_ARCH_3M__) || (__ARM_ARCH_4__)    ||  \
+                    (__ARM_ARCH_4T__) || (__ARM_ARCH_5TE__) || (__ARM_ARCH_5T__) || (__ARM_ARCH_5TEJ__ )||  \
+                    (__ARM_ARCH_6J__) || (__ARM_ARCH_6ZK__) || (__ARM_ARCH_6K__) || (__ARM_ARCH_6M__)  || (__ARM_ARCH_7J__)
+            /*---------------------------------------------------------------------------------------------*/
+            /* Not supported by architecture                                                               */
+            /*---------------------------------------------------------------------------------------------*/
+        #else
+            #define ICACHE_SAVE_DISABLE(var)  __asm__ __volatile__(                         \
+                                                    "MRC  p15, 0, %[val], c1, c0 \n\t"      \
+                                                    "BIC  r6, %[val], #0x1000     \n\t"     \
+                                                    "MCR  p15, 0, r6, c1, c0 "              \
+                                                    :[val] "+r" (var):: "r6", "cc")
+
+            #define ICACHE_SAVE_ENABLE(var)   __asm__ __volatile__(                         \
+                                                    "MRC  p15, 0, %[val], c1, c0 \n\t"      \
+                                                    "ORR  r6, %[val], #0x1000     \n\t"     \
+                                                    "MCR  p15, 0, r6, c1, c0 "              \
+                                                    :[val] "+r" (var):: "r6", "cc")
+
+            #define ICACHE_RESTORE(var)       __asm__ __volatile__(                         \
+                                                    "MCR  p15, 0, %[val], c1, c0"           \
+                                                    : [val]"+r"(var) )
+        #endif
+    #else
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /*                                       ARM INSTRUCTION SET                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* CPU power management                                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        #if defined (__ARM_ARCH_2__)   || (__ARM_ARCH_3__)   || (__ARM_ARCH_3M__)   || (__ARM_ARCH_4__)   ||\
+                    (__ARM_ARCH_4T__)  || (__ARM_ARCH_5T__)  || (__ARM_ARCH_5TE__)  || (__ARM_ARCH_5TEJ__)||\
+                    (__ARM_ARCH_6_M__) || (__ARM_ARCH_6__)   || (__ARM_ARCH_6S_M__) || (__ARM_ARCH_6J__)  ||\
+                    (__ARM_ARCH_6T2__)  || (__ARM_ARCH_7J__)
+            #define CPU_IDLE()                          __asm   __volatile__ (                              \
+                                                                                "MOV r0, #0 \n\t"           \
+                                                                                "MCR p15, 0, r0, c7, c0, 4" \
+                                                                                ::: "r0", "cc" )
+        #else
+            #define CPU_IDLE()                          __asm__ __volatile__("WFI")
+        #endif
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Interrrupt macros                                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        #define ENABLE_INTERRUPTS()       __asm__ __volatile__(                         \
+                                                "MRS    r6, APSR     \n\t"              \
+                                                "BIC    r6,r6,#0x80  \n\t"              \
+                                                "MSR    APSR_nzcvq,r6  " ::: "r6", "cc" )
+
+        #define DISABLE_INTERRUPTS()      __asm__ __volatile__(                         \
+                                                "MRS    r6, APSR     \n\t"              \
+                                                "ORR    r6, r6,#0x80 \n\t"              \
+                                                "MSR    APSR_nzcvq, r6 " ::: "r6", "cc")
+
+        #define INTERRUPTS_SAVE_DISABLE(var)  __asm__ __volatile__(                     \
+                                                "MRS    %[val], APSR     \n\t"          \
+                                                "ORR    r6, %[val],#0x80 \n\t"          \
+                                                "MSR    APSR_nzcvq,r6  "                \
+                                                :[val] "+r" (var):: "r6", "cc")
+
+        #define INTERRUPTS_RESTORE(var)   __asm__ __volatile__(                         \
+                                                "MSR    APSR_nzcvq,%[val]  "            \
+                                                : [val]"+r"(var) )
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Cache macros                                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        #define ICACHE_SAVE_DISABLE(var)  __asm__ __volatile__(                         \
+                                                "MRC  p15, 0, %[val], c1, c0 \n\t"      \
+                                                "BIC  r6, %[val], #0x1000     \n\t"     \
+                                                "MCR  p15, 0, r6, c1, c0 "              \
+                                                :[val] "+r" (var):: "r6", "cc")
+
+        #define ICACHE_SAVE_ENABLE(var)   __asm__ __volatile__(                         \
+                                                "MRC  p15, 0, %[val], c1, c0 \n\t"      \
+                                                "ORR  r6, %[val], #0x1000     \n\t"     \
+                                                "MCR  p15, 0, r6, c1, c0 "              \
+                                                :[val] "+r" (var):: "r6", "cc")
+
+        #define ICACHE_RESTORE(var)       __asm__ __volatile__(                         \
+                                                "MCR  p15, 0, %[val], c1, c0"           \
+                                                : [val]"+r"(var) )
+    #endif
+
+#else
+    #warning Warning: x_INTERRUPTS and ICHACHE_x macros are not defined for current compiler
+#endif
+
+
+#endif /* _DEFS_ARM_H_ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_core_default.h b/board/nuvoton/common/SWC_DEFS/defs_core_default.h
new file mode 100755
index 0000000..9a31df5
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_core_default.h
@@ -0,0 +1,249 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2012-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_core_default.h                                                                                   */
+/*            This file contains stub default definitions for core access                                  */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DEFS_DEFAULT_H_
+#define _DEFS_DEFAULT_H_
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default REG definitions                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef REG8
+#define REG8                volatile UINT8
+#endif
+
+#ifndef REG16
+#define REG16               volatile UINT16
+#endif
+
+#ifndef REG32
+#define REG32               volatile UINT32
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default PTR definitions                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef PTR8
+#define PTR8                REG8 *
+#endif
+
+#ifndef PTR16
+#define PTR16               REG16 *
+#endif
+
+#ifndef PTR32
+#define PTR32               REG32*
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent MEM definitions                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef MEMR8
+#define MEMR8(a)            (*(PTR8) (a))
+#endif
+
+#ifndef MEMR16
+#define MEMR16(a)           (*(PTR16)(a))
+#endif
+
+#ifndef MEMR32
+#define MEMR32(a)           (*(PTR32)(a))
+#endif
+
+#ifndef MEMW8
+#define MEMW8(a,v)          (*((PTR8)  (a))) = ((UINT8)(v))
+#endif
+
+#ifndef MEMW16
+#define MEMW16(a,v)         (*((PTR16) (a))) = ((UINT16)(v))
+#endif
+
+#ifndef MEMW32
+#define MEMW32(a,v)         (*((PTR32) (a))) = ((UINT32)(v))
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core dependent IO definitions                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef IOR8
+#define IOR8(a)             MEMR8(a)
+#endif
+
+#ifndef IOR16
+#define IOR16(a)            MEMR16(a)
+#endif
+
+#ifndef IOR32
+#define IOR32(a)            MEMR32(a)
+#endif
+
+#ifndef IOW8
+#define IOW8(a,v)           MEMW8(a, v)
+#endif
+
+#ifndef IOW16
+#define IOW16(a,v)          MEMW16(a, v)
+#endif
+
+#ifndef IOW32
+#define IOW32(a,v)          MEMW32(a, v)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupts macros                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef ENABLE_INTERRUPTS
+#define ENABLE_INTERRUPTS()
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Disable interrupts                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef DISABLE_INTERRUPTS
+#define DISABLE_INTERRUPTS()
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Preserve interrupt state and disable                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef INTERRUPTS_SAVE_DISABLE
+#define INTERRUPTS_SAVE_DISABLE(var)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Restore saved interrupt state - E bit only                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef INTERRUPTS_RESTORE
+#define INTERRUPTS_RESTORE(var)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Set vector table pointer                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef INTERRUPTS_SET_VECTOR_TABLE
+#define INTERRUPTS_SET_VECTOR_TABLE(table)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Cache macros                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef ICACHE_SAVE_DISABLE
+#define ICACHE_SAVE_DISABLE(var)
+#endif
+
+#ifndef ICACHE_SAVE_ENABLE
+#define ICACHE_SAVE_ENABLE(var)
+#endif
+
+#ifndef ICACHE_RESTORE
+#define ICACHE_RESTORE(var)
+#endif
+
+#ifndef DCACHE_SAVE_DISABLE
+#define DCACHE_SAVE_DISABLE(var)
+#endif
+
+#ifndef DCACHE_SAVE_ENABLE
+#define DCACHE_SAVE_ENABLE(var)
+#endif
+
+#ifndef DCACHE_RESTORE
+#define DCACHE_RESTORE(var)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Call a function at addr                                                                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef FUNC_CALL
+#define FUNC_CALL(addr)     (((void (*)(void))(addr))())
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* CPU power management                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef CPU_IDLE
+#define CPU_IDLE()
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Assertion macros                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef ASSERT
+#ifndef ASSERT
+#define ASSERT(cond)
+#endif
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                   CORE AND COMPILER SPECIFIC KEYWORDS                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _MEM_TYPE_BIT_
+#define _MEM_TYPE_BIT_
+#endif
+
+#ifndef _MEM_TYPE_FAST_
+#define _MEM_TYPE_FAST_
+#endif
+
+#ifndef _MEM_TYPE_MEDFAST_
+#define _MEM_TYPE_MEDFAST_
+#endif
+
+#ifndef _MEM_TYPE_MEDSLOW_
+#define _MEM_TYPE_MEDSLOW_
+#endif
+
+#ifndef _MEM_TYPE_SLOW_
+#define _MEM_TYPE_SLOW_
+#endif
+
+#ifndef _CONST_TYPE_
+#define _CONST_TYPE_            const
+#endif
+
+#ifndef _INLINE_
+#define _INLINE_                inline
+#endif
+
+#ifndef _ALIGN_
+#define _ALIGN_(x, decl)        decl
+#endif
+
+#ifndef _PACK_
+#define _PACK_(decl)            decl
+#endif
+
+#ifndef _ZI_
+#define _ZI_(decl)              decl
+#endif
+
+#ifndef _SECTION_
+#define _SECTION_(secname,decl) decl
+#endif
+
+#ifndef _AT_
+#define _AT_(addr, decl)        decl
+#endif
+
+#ifndef _NORET_
+#define _NORET_(decl)           decl
+#endif
+
+#ifndef _NORET_SPEC_
+#define _NORET_SPEC_(decl)      decl
+#endif
+
+#endif /*_DEFS_DEFAULT_H_ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_errors.h b/board/nuvoton/common/SWC_DEFS/defs_errors.h
new file mode 100755
index 0000000..bbc5dd4
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_errors.h
@@ -0,0 +1,262 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_errors.h                                                                                         */
+/*            This file contains NTIL standard error codes set                                             */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __ERRORS_H__
+#define __ERRORS_H__
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                               ERROR CODES                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+#if defined LARGE_HAMMING_DISTANCE
+   DEFS_STATUS_OK                                = 0xA5A5,
+   DEFS_STATUS_FAIL                              = 0x5A5A,
+#else
+   DEFS_STATUS_OK                                = 0x00,
+   DEFS_STATUS_FAIL                              = 0x01,
+#endif
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Parameters validity                                                                                  */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_INVALID_PARAMETER                 = 0x10,
+
+   DEFS_STATUS_INVALID_DATA_SIZE                 = 0x11,
+   DEFS_STATUS_PARAMETER_OUT_OF_RANGE            = 0x12,
+   DEFS_STATUS_INVALID_DATA_FIELD                = 0x13,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Response                                                                                             */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_RESPONSE_CANT_BE_PROVIDED         = 0x20,
+
+   DEFS_STATUS_SYSTEM_BUSY                       = 0x21,
+   DEFS_STATUS_SYSTEM_NOT_INITIALIZED            = 0x22,
+   DEFS_STATUS_SYSTEM_IN_INCORRECT_STATE         = 0x23,
+   DEFS_STATUS_RESPONSE_TIMEOUT                  = 0x24,
+   DEFS_STATUS_RESPONSE_ABORT                    = 0x25,
+   DEFS_STATUS_BAD_CHECKSUM                      = 0x26,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Security                                                                                             */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_SECURITY_ERROR                    = 0x30,
+
+   DEFS_STATUS_UNSUFFIENT_PRIVILEDGE_LEVEL       = 0x31,
+   DEFS_STATUS_AUTHENTICATION_FAIL               = 0x32,
+   DEFS_STATUS_BAD_SIGNATURE                     = 0x33,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Communication                                                                                        */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_COMMUNICATION_ERROR               = 0x40,
+
+   DEFS_STATUS_NO_CONNECTION                     = 0x41,
+   DEFS_STATUS_CANT_OPEN_CONNECTION              = 0x42,
+   DEFS_STATUS_CONNECTION_ALREADY_OPEN           = 0x43,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Hardware                                                                                             */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_HARDWARE_ERROR                    = 0x50,
+
+   DEFS_STATUS_IO_ERROR                          = 0x51,
+   DEFS_STATUS_CLK_ERROR                         = 0x52,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Resource Allocation                                                                                  */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_RESOURCE_ERROR                    = 0x60,
+
+   DEFS_STATUS_ALLOCATION_FAILED                 = 0x61,
+
+   /*------------------------------------------------------------------------------------------------------*/
+   /* Custom error codes                                                                                   */
+   /*------------------------------------------------------------------------------------------------------*/
+   DEFS_STATUS_CUSTOM_ERROR_00                   = 0xF0,
+   DEFS_STATUS_CUSTOM_ERROR_01                   = 0xF1,
+   DEFS_STATUS_CUSTOM_ERROR_02                   = 0xF2,
+   DEFS_STATUS_CUSTOM_ERROR_03                   = 0xF3,
+   DEFS_STATUS_CUSTOM_ERROR_04                   = 0xF4,
+   DEFS_STATUS_CUSTOM_ERROR_05                   = 0xF5,
+   DEFS_STATUS_CUSTOM_ERROR_06                   = 0xF6,
+   DEFS_STATUS_CUSTOM_ERROR_07                   = 0xF7,
+   DEFS_STATUS_CUSTOM_ERROR_08                   = 0xF8,
+   DEFS_STATUS_CUSTOM_ERROR_09                   = 0xF9,
+   DEFS_STATUS_CUSTOM_ERROR_10                   = 0xFA,
+   DEFS_STATUS_CUSTOM_ERROR_11                   = 0xFB,
+   DEFS_STATUS_CUSTOM_ERROR_12                   = 0xFC,
+   DEFS_STATUS_CUSTOM_ERROR_13                   = 0xFD,
+   DEFS_STATUS_CUSTOM_ERROR_14                   = 0xFE,
+   DEFS_STATUS_CUSTOM_ERROR_15                   = 0xFF
+} DEFS_STATUS;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              ERROR MACROS                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_STATUS_RET_CHECK                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks if give function returns DEFS_STATUS error, and returns the error    */
+/*                  immediately                                                                            */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    DEFS_STATUS myFunc(INT p1, INT p2);                                                                  */
+/*                                                                                                         */
+/*    DEFS_STATUS otherFunc                                                                                */
+/*    {                                                                                                    */
+/*        ...                                         // Some code                                         */
+/*        DEFS_STATUS_RET_CHECK(myFunc(p1,p2));       // Executing myFunc                                  */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_STATUS_RET_CHECK(func)                                 \
+{                                                                   \
+    DEFS_STATUS ret;                                                \
+                                                                    \
+    if ((ret = func) != DEFS_STATUS_OK)                             \
+    {                                                               \
+       return ret;                                                  \
+    }                                                               \
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_STATUS_RET_CHECK_ACTION                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                  action  - Action done if function doesn't return DEFS_STATUS_OK                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks if give function returns DEFS_STATUS error, if not in performs       */
+/*                  a pre-defined action                                                                   */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFirstFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        ...                                                // Some code                                  */
+/*        DEFS_STATUS_RET_CHECK(myFunc(p1,p2), break);       // Executing myFunc, doing action on failure  */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_STATUS_RET_CHECK_ACTION(func, action)                  \
+{                                                                   \
+    if (func != DEFS_STATUS_OK)                                     \
+    {                                                               \
+        action;                                                     \
+    }                                                               \
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_STATUS_COND_CHECK                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    - Condition to check                                                           */
+/*                  err     - Error to through if condition is not met                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks given condition and returns the given error if condition was not   */
+/*                  met                                                                                    */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    DEFS_STATUS myFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        DEFS_STATUS_COND_CHECK(ptr, DEFS_STATUS_INVALID_PARAMETER);                                      */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_STATUS_COND_CHECK(cond, err)                           \
+{                                                                   \
+    if (!(cond))                                                    \
+    {                                                               \
+        return err;                                                 \
+    }                                                               \
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_STATUS_COND_CHECK_ACTION                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    - Condition to check                                                           */
+/*                  action  - Action done if condition is not met                                          */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks given condition and performs required actionif condition was not   */
+/*                  met                                                                                    */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFunc(void* ptr)                                                                             */
+/*    {                                                                                                    */
+/*        STATUS_COND_CHECK(ptr, break);                                                                   */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_STATUS_COND_CHECK_ACTION(cond, action)                 \
+{                                                                   \
+    if (!(cond))                                                    \
+    {                                                               \
+        action;                                                     \
+    }                                                               \
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_STATUS_RET_ASSERT                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func        - Function to check                                                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine puts ASSERT on function return status                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef DEBUG
+    #define DEFS_STATUS_RET_ASSERT(func)        ASSERT(func == DEFS_STATUS_OK)
+#else
+    #define DEFS_STATUS_RET_ASSERT(func)        (void)func
+#endif
+
+
+#endif /* __ERRORS_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_internal.h b/board/nuvoton/common/SWC_DEFS/defs_internal.h
new file mode 100755
index 0000000..47c808b
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_internal.h
@@ -0,0 +1,96 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_internal.h                                                                                       */
+/*            This file contains internal auxililary macros used in common NTIL definitions                */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __DEFS_INTERNAL_H__
+#define __DEFS_INTERNAL_H__
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Auxiliary macros (not part of the interface)                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _REG_READ_AUX_(addr,type,size)              _REG_ACCESS_FORM1(type,R,size,addr)
+#define _REG_WRITE_AUX_(val,addr,type,size)         _REG_ACCESS_FORM2(type,W,size,addr,val)
+
+#define _REG_ACCESS_FORM1(type,rw,size,arg)         type##rw##size((arg))
+#define _REG_ACCESS_FORM2(type,rw,size,arg1,arg2)   type##rw##size((arg1), (arg2))
+#define _CASTING_FROM(size)                         _CASTING_FROM2(UINT,size)
+#define _CASTING_FROM2(type,size)                   type##size
+
+#define _GET_REG(addr,accesstype,size)              addr,accesstype,size
+#define _GET_REG_ADDR(addr,accesstype,size)         addr
+#define _GET_REG_ACCESSTYPE(addr,accesstype,size)   accesstype
+#define _GET_REG_SIZE(addr,accesstype,size)         size
+
+#define _GET_FIELD(pos,size)                        pos,size
+#define _GET_FIELD_POS(pos,size)                    pos
+#define _GET_FIELD_SIZE(pos,size)                   size
+
+
+#define _READ_FIELD(reg, reg_size, size, position) \
+    (((reg)>>(position)) & ((((_CASTING_FROM(reg_size))1)<<(size))-1))
+
+#define _SET_REG_FIELD(reg, size, position, value)    \
+    REG_WRITE(_GET_REG(reg),(((REG_READ(_GET_REG(reg))) &(~((((_CASTING_FROM(_GET_REG_SIZE(reg)))1<<(size))-1)<<(position))))\
+    | (((((_CASTING_FROM(_GET_REG_SIZE(reg)))1<<(size))-1) & (value))<<(position))))
+
+#define  _SET_REG_FIELD_SIZE(reg,size,position,value)                                                                   \
+    if (size == 1)                                                                                                      \
+    {                                                                                                                   \
+        if (value == 1)                                                                                                 \
+        {                                                                                                               \
+            _SET_REG_BIT_FIELD(_GET_REG(reg), position);                                                                \
+        }                                                                                                               \
+        else                                                                                                            \
+        {                                                                                                               \
+            _CLEAR_REG_BIT_FIELD(_GET_REG(reg), position);                                                              \
+        }                                                                                                               \
+   }                                                                                                                    \
+   else                                                                                                                 \
+   {                                                                                                                    \
+      _SET_REG_FIELD(_GET_REG(reg),size,position,value);                                                                \
+   }
+
+#ifdef CPU_64_BIT
+#define _SET_VAR_FIELD(var,size,position,value)                                                                                                 \
+   ((sizeof(var) == 8) ?   ((var) = ((var) & (~((((UINT64)1<<(size))-1)<<(position))))  | (((((UINT64)1<<(size))-1) & (value))<<(position))) :  \
+   ((sizeof(var) == 4) ?   ((var) = ((var) & (~((((UINT32)1<<(size))-1)<<(position))))  | (((((UINT32)1<<(size))-1) & (value))<<(position))) :  \
+   ((sizeof(var) == 2) ?   ((var) = ((var) & (~((((UINT16)1<<(size))-1)<<(position))))  | (((((UINT16)1<<(size))-1) & (value))<<(position))) :  \
+                           ((var) = ((var) & (~(((        1<<(size))-1)<<(position))))  | ((((        1<<(size))-1) & (value))<<(position))))))
+#else
+#define _SET_VAR_FIELD(var,size,position,value)                                                                                                 \
+   ((sizeof(var) == 2) ?   ((var) = ((var) & (~((((UINT16)1<<(size))-1)<<(position))))  | (((((UINT16)1<<(size))-1) & (value))<<(position))) :  \
+   ((sizeof(var) == 4) ?   ((var) = ((var) & (~((((UINT32)1<<(size))-1)<<(position))))  | (((((UINT32)1<<(size))-1) & (value))<<(position))) :  \
+                           ((var) = ((var) & (~(((        1<<(size))-1)<<(position))))  | ((((        1<<(size))-1) & (value))<<(position)))))
+#endif						   
+						   
+
+#define _SET_REG_BIT_FIELD(reg, position)    \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) |((_CASTING_FROM(_GET_REG_SIZE(reg)))1<<(position))))
+
+#define _READ_REG_BIT_FIELD(reg, position)    \
+    (((reg)>>(position)) & (_CASTING_FROM(_GET_REG_SIZE(reg))1)
+
+#define _CLEAR_REG_BIT_FIELD(reg, position)    \
+    REG_WRITE(_GET_REG(reg),((REG_READ(_GET_REG(reg))) & (~((_CASTING_FROM(_GET_REG_SIZE(reg)))1<<(position)))))
+
+#define _MASK_FIELD(size, position)   \
+    (((1UL<<(size))-1)<<(position))
+
+#define _BUILD_FIELD_VAL(size, position, value)   \
+    ((((1UL<<(size))-1) & (value)) << (position))
+
+
+
+#endif
+
diff --git a/board/nuvoton/common/SWC_DEFS/defs_os_linux.h b/board/nuvoton/common/SWC_DEFS/defs_os_linux.h
new file mode 100755
index 0000000..f54c142
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_os_linux.h
@@ -0,0 +1,91 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_os_linux.h                                                                                       */
+/*            This file contains definitions for Linux kernel API                                          */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DEFS_LINUX_KERNEL_H_
+#define _DEFS_LINUX_KERNEL_H_
+
+#include <asm/io.h>
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent types                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef unsigned int        UINT;                       /* Native type of the core that fits the core's    */
+typedef int                 INT;                        /* internal registers                              */
+typedef UINT                BOOLEAN;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent PTR definitions                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define REG8                volatile  UINT8
+#define REG16               volatile  UINT16
+#define REG32               volatile  UINT32
+
+#define PTR8                REG8 *
+#define PTR16               REG16 *
+#define PTR32               REG32 *
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent MEM definitions                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MEMR8(a)            ioread8((UINT8*)a)
+#define MEMR16(a)           ioread16((UINT16*)a)
+#define MEMR32(a)           ioread32((UINT32*)a)
+
+#define MEMW8(a,v)          iowrite8( (v), ((UINT8*)a))
+#define MEMW16(a,v)         iowrite16((v), ((UINT16*)a))
+#define MEMW32(a,v)         iowrite32((v), ((UINT32*)a))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent IO definitions                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IOR8(a)             inb(a)
+#define IOR16(a)            inw(a)
+#define IOR32(a)            inl(a)
+
+#define IOW8(a,v)           outb((v), (a))
+#define IOW16(a,v)          outw((v), (a))
+#define IOW32(a,v)          outl((v), (a))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupts macros                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/* Not Supported on ALL architectures                                                                      */
+#define ENABLE_INTERRUPTS()                 local_irq_enable()
+#define DISABLE_INTERRUPTS()                local_irq_disable()
+
+/* Supported on ALL architectures                                                                          */
+#define INTERRUPTS_SAVE_DISABLE(var)        local_irq_save(var)
+#define INTERRUPTS_RESTORE(var)             local_irq_restore(var)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Cache macros                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ICACHE_SAVE_DISABLE(var)            var=0
+#define ICACHE_SAVE_ENABLE(var)             var=0
+#define ICACHE_RESTORE(var)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Assertion macros                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef ASSERT
+#ifdef DEBUG
+#define ASSERT(cond)  {if (!(cond)) for(;;) ;}           /* infinite loop                                  */
+#else
+#define ASSERT(cond)
+#endif
+#endif
+
+#endif /* _DEFS_LINUX_KERNEL_H_ */
+
diff --git a/board/nuvoton/common/SWC_DEFS/defs_os_linux_app.h b/board/nuvoton/common/SWC_DEFS/defs_os_linux_app.h
new file mode 100755
index 0000000..f6ee504
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_os_linux_app.h
@@ -0,0 +1,33 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   defs_os_linux_app.h                                                                                   */
+/*            This file contains definitions for Linux OS Applications                                     */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _DEFS_LINUX_APP_H_
+#define _DEFS_LINUX_APP_H_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent types                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef unsigned int        UINT;                       /* Native type of the core that fits the core's    */
+typedef int                 INT;                        /* internal registers                              */
+typedef UINT                BOOLEAN;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OS dependent PTR definitions                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PTR8                (volatile  UINT8  *)
+#define PTR16               (volatile  UINT16 *)
+#define PTR32               (volatile  UINT32 *)
+
+
+#endif /* _DEFS_LINUX_APP_H_ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_secured.h b/board/nuvoton/common/SWC_DEFS/defs_secured.h
new file mode 100755
index 0000000..7c08de6
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_secured.h
@@ -0,0 +1,382 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2016 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*    defs_utils.h                                                                                         */
+/*            This file contains NTIL security utilities                                                   */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __DEFS_SECURED_H__
+#define __DEFS_SECURED_H__
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                              Secured constants with large hamming distance                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Secured constants with large hamming distance                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SECURED_NULL        ((void*)(0xaa55))
+
+typedef enum
+{
+    SECURED_TRUE  = 0x9696,
+    SECURED_FALSE = 0x6969
+} SECURED_BOOLEAN_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                         Secured utility macros                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                  Secured condition checking utilities                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_COND_CHECK                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    -  condition to check. Variables involved in the condition should be defined   */
+/*                            'volatile' in the caller code                                                */
+/*                                                                                                         */
+/* Returns:         boolean indicating condition satisfaction                                              */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks a condition in a secured manner                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_COND_CHECK(cond)         ((cond) && (cond))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_COND_CHECK_RET                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    - Condition to check                                                           */
+/*                  err     - Error to return if condition is not met                                      */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks a condition securely and returns the required error if the         */
+/*                  condition was not met                                                                  */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    DEFS_STATUS myFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        DEFS_STATUS_COND_CHECK(ptr, DEFS_STATUS_INVALID_PARAMETER);                                      */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_COND_CHECK_RET(cond, err)                                                                 \
+{                                                                                                          \
+    if (!DEFS_SEC_COND_CHECK(cond))                                                                        \
+    {                                                                                                      \
+        return err;                                                                                        \
+    }                                                                                                      \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_COND_CHECK_FAIL                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond        - Condition to check                                                       */
+/*                  failureFunc - A function that should be called in case the condition failed            */
+/*                  ..          - parameters to failure function                                           */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine checks a condition securely and calls failure function if the             */
+/*                  condition was not met                                                                  */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    DEFS_STATUS myFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        DEFS_SEC_COND_CHECK_FAIL(x==5, DEFS_STATUS_INVALID_PARAMETER, FAIL_log);                         */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_COND_CHECK_FAIL(cond, failureFunc, ...)                                                   \
+{                                                                                                          \
+    if (!DEFS_SEC_COND_CHECK(cond))                                                                        \
+    {                                                                                                      \
+        failureFunc(__VA_ARGS__);                                                                          \
+    }                                                                                                      \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_COND_CHECK_ACTION                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    - Condition to check                                                           */
+/*                  action  - An action to be performed on failure                                         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks a condition securely and performs an action in case of error         */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFunc(void* ptr)                                                                             */
+/*    {                                                                                                    */
+/*        DEFS_SEC_COND_CHECK_ACTION(ptr, myaction);                                                       */
+/*        ...                                                                                              */
+/*                                                                                                         */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_COND_CHECK_ACTION(cond, action)                                                           \
+    if (DEFS_SEC_COND_CHECK(cond))                                                                         \
+    {                                                                                                      \
+        action;                                                                                            \
+    }                                                                                                      \
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_COND_CHECK_GOTO                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  cond    - Condition to check                                                           */
+/*                  endlabel  - Label to jump to if the condition is not met                               */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks a condition securely and jumps to a label in case of error           */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFunc(void* ptr)                                                                             */
+/*    {                                                                                                    */
+/*        DEFS_STATUS_CHECK_RETVAL_GOTO(ptr, myFuncCleanup);                                               */
+/*        ...                                                                                              */
+/*                                                                                                         */
+/* myFuncCleanup:                                                                                          */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_COND_CHECK_GOTO(cond, endlabel)                                                           \
+    DEFS_SEC_COND_CHECK_ACTION(cond, goto endlabel)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_FUNC_CHECK_RET                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro runs a function and securely makes sure it returns DEFS_STATUS_OK.          */
+/*                  Otherwise it returns the error returned by the function.                               */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    DEFS_STATUS myFunc(INT p1, INT p2);                                                                  */
+/*                                                                                                         */
+/*    DEFS_STATUS otherFunc                                                                                */
+/*    {                                                                                                    */
+/*        ...                                             // Some code                                     */
+/*        DEFS_SEC_FUNC_CHECK_RET(myFunc(p1,p2));         // Executing myFunc                              */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_FUNC_CHECK_RET(func)                                                                      \
+{                                                                                                          \
+    volatile status rc = DEFS_STATUS_FAIL;                                                                 \
+    rc = func;                                                                                             \
+                                                                                                           \
+    if (!DEFS_SEC_COND_CHECK(rc == DEFS_STATUS_OK))                                                        \
+    {                                                                                                      \
+        return rc;                                                                                         \
+    }                                                                                                      \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_FUNC_CHECK_FAIL                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func        - function to check                                                        */
+/*                  failureFunc - a function that should be called in case the function "func" failed      */
+/*                  ..          - parameters to failure function                                           */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks securely if given function returns DEFS_STATUS_OK,                   */
+/*                  Otherwise it calls failure function                                                    */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFirstFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        ...                                                // Some code                                  */
+/*        DEFS_SEC_FUNC_CHECK_FAIL(myFunc(p1,p2), MY_ERROR, FAIL_Log);                                     */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_FUNC_CHECK_FAIL(func, failureFunc, ...)                                                   \
+{                                                                                                          \
+    volatile status rc = DEFS_STATUS_FAIL;                                                                 \
+    rc = func;                                                                                             \
+                                                                                                           \
+    if (!DEFS_SEC_COND_CHECK(rc == DEFS_STATUS_OK))                                                        \
+    {                                                                                                      \
+        failureFunc(__VA_ARGS__);                                                                          \
+    }                                                                                                      \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_FUNC_CHECK_ACTION                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                  action  - Action done if function doesn't return DEFS_STATUS_OK                        */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks securely if given function returns DEFS_STATUS_OK,                   */
+/*                  Otherwise it performs a pre-defined action                                             */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFirstFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        ...                                                // Some code                                  */
+/*        DEFS_SEC_FUNC_CHECK_ACTION(myFunc(p1,p2), break);  // Executing myFunc, doing action on failure  */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_FUNC_CHECK_ACTION(func, action)                                                           \
+{                                                                                                          \
+    volatile status rc = DEFS_STATUS_FAIL;                                                                 \
+    rc = func;                                                                                             \
+                                                                                                           \
+    if (!DEFS_SEC_COND_CHECK(rc == DEFS_STATUS_OK))                                                        \
+    {                                                                                                      \
+        action;                                                                                            \
+    }                                                                                                      \
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_SEC_FUNC_CHECK_GOTO                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                  endlabel  - Label to jump to if the function return code is not DEFS_STATUS_OK         */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro runs a function securely and jumps to a label in case of error              */
+/*                                                                                                         */
+/* Example:                                                                                                */
+/*                                                                                                         */
+/*    status myFirstFunc(void* ptr)                                                                        */
+/*    {                                                                                                    */
+/*        ...                                                // Some code                                  */
+/*        DEFS_SEC_FUNC_CHECK_GOTO(myFunc(p1,p2), myLabel);  // Executing myFunc, jump a label on failure  */
+/*        ...                                                                                              */
+/*    }                                                                                                    */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_SEC_FUNC_CHECK_GOTO(func, endlabel)                                                           \
+    DEFS_SEC_FUNC_CHECK_ACTION(func, goto endlabel)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                               Secured Execution of a function from pointer                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Call the macro in the following way:                                                                    */
+/* SEC_EXECUTE_FUNC( func, (arg1, arg2))                                                                   */
+/* SEC_EXECUTE_FUNC_RET( retvar, func, (arg1, arg2, arg3))                                                 */
+/* SEC_EXECUTE_FUNC_RET_VALUE( func, (arg1, arg2, arg3), default_return_value)                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SEC_EXECUTE_FUNC(func, args)                \
+    if (func != SECURED_NULL)                       \
+    {                                               \
+        func args;                                  \
+    }
+
+#define SEC_EXECUTE_FUNC_RET(ret, func, args)       \
+    if (func != SECURED_NULL)                       \
+    {                                               \
+        ret = func args;                            \
+    }
+
+#define SEC_EXECUTE_FUNC_RET_VALUE(func, args, default_value)   ((func != SECURED_NULL)? func args : default_value)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                     Secured flow control utilities                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_FLOW_MONITOR_DECLARE                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro declares a typically local varible representing flow counter                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_FLOW_MONITOR_DECLARE()      volatile int flowCounter = 0
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_FLOW_MONITOR_INCREMENT                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro increments the flow counters. Typically called in critical point of the     */
+/*                  flow. This point is defined as one that is important to make sure the flow indeed      */
+/*                  passed by                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_FLOW_MONITOR_INCREMENT()    flowCounter++
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           DEFS_FLOW_MONITOR_COMPARE                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  x           - an expected value of flow counter. This typically would be a constant    */
+/*                                defined in the code                                                      */
+/*                  failureFunc - a function that should be called in case the flow has been compromised   */
+/*                                the functions receives variable number of parameters                     */
+/*                  ...         - parameters to the failure function                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This securely compares the value of actual flow counter with its expected value and    */
+/*                  calls a failure function if the comparison fails                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DEFS_FLOW_MONITOR_COMPARE(x, failureFunc, ...)                                                      \
+                         if (DEFS_SEC_COND_CHECK(x != flowCounter))                                         \
+                         {                                                                                  \
+                            failureFunc(__VA_ARGS__);                                                       \
+                         }                                                                                  \
+
+
+#endif /* __DEFS_SECURED_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_types.h b/board/nuvoton/common/SWC_DEFS/defs_types.h
new file mode 100755
index 0000000..c6ce5c3
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_types.h
@@ -0,0 +1,202 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*    defs_types.h                                                                                         */
+/*            This file contains NTIL generic types, including compiler and core dependent                 */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __TYPES_H__
+#define __TYPES_H__
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                CONSTANTS                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef  FALSE
+#define  FALSE      (BOOLEAN)0
+#endif
+
+#ifndef  TRUE
+#define  TRUE       (BOOLEAN)1
+#endif
+
+#ifndef  NULL
+#define  NULL       0
+#endif
+
+#define ENABLE      1
+#define DISABLE     0
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                        GENERIC TYPES DEFINITIONS                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef unsigned char  UINT8;                       /* Unsigned  8 bit quantity                            */
+typedef signed   char  INT8;                        /* Signed    8 bit quantity                            */
+typedef unsigned short UINT16;                      /* Unsigned 16 bit quantity                            */
+typedef short          INT16;                       /* Signed   16 bit quantity                            */
+typedef float          FP32;                        /* Single precision floating point
+
+*/
+typedef double         FP64;                        /* Double precision floating point                     */
+
+#if defined (WDFAPI) || defined (_WIN32)
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* UINT32, INT32, UINT64, INT64 are defined for Windows OS                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+#else
+
+#ifdef __LP64__
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* unsigned long is 64bit (mostly on 64bit Linux systems)                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    typedef unsigned int    UINT32;                 /* Unsigned 32 bit quantity                            */
+    typedef signed   int    INT32;                  /* Signed   32 bit quantity                            */
+    typedef unsigned long   UINT64;                 /* Unsigned 64 bit quantity                            */
+    typedef signed   long   INT64;                  /* Signed 64 bit quantity                              */
+
+ #else
+ 
+    #if ((~0ULL>>1) == 0x7FFFFFFFLL) || defined (__CR16C__)
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* unsigned long is 32bit (32bit Linux, 32bit Windows and 64bit Windows                                */
+        /*-----------------------------------------------------------------------------------------------------*/
+        typedef unsigned long   UINT32;                 /* Unsigned 32 bit quantity                            */
+        typedef signed   long   INT32;                  /* Signed   32 bit quantity                            */
+    #else
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* unsigned int is 32bit for linux kernel and uboot                                                    */
+        /*-----------------------------------------------------------------------------------------------------*/
+        typedef unsigned int   UINT32;                 /* Unsigned 32 bit quantity                            */
+        typedef signed   int   INT32;                  /* Signed   32 bit quantity                            */
+    #endif
+ 
+    #if ((~0ULL>>1) == 0x7FFFFFFFLL)
+        /*-------------------------------------------------------------------------------------------------*/
+        /* long long type is 32bit                                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        typedef UINT32              UINT64[2];      /* Unsigned 64 bit quantity                            */
+        typedef INT32               INT64[2];       /* Signed 64 bit quantity                              */
+    #else
+        /*-------------------------------------------------------------------------------------------------*/
+        /* long long type is 64bit                                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        typedef unsigned long long  UINT64;         /* Unsigned 64 bit quantity                            */
+        typedef long long           INT64;          /* Signed 64 bit quantity                              */
+    #endif
+
+#endif
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/*                               OS OR CORE HW ACCESS DEFINITIONS AND TYPES                                */
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Description:                                                                                            */
+/*   HW specific code can reside in 2 different environments:                                              */
+/*      1. OS/framework/test environment - The code doesn't access the HW registers directly but rather    */
+/*                                         uses OS/framework services that wraps the needed HW accesses    */
+/*      2. Standalone code -               The code can access directly the HW registers                   */
+/*                                                                                                         */
+/*   Therefore the HW access definitions are divided into 2 types: OS and CORE.                            */
+/*   The OS definitions must always precede the CORE definitions                                           */
+/*   For example, code that compiles for Linux kernel runnig or ARM must include the Linux kernel          */
+/*   definitions rather than ARM ones, as it must use the Linux Kernel HW access wrapping functions        */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                          OS / framework/test environment dependent definitions                          */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Windows Driver Foundation                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (WDFAPI)
+#include "defs_os_wdf.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* TestEC Core and PC                                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (__TESTEC__)
+#include "defs_os_testec.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Windows OS Applications                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (_WIN32)
+#include "defs_os_windows.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Linux Kernel                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (KBUILD_STR) && defined(__KERNEL__) && !defined(__UBOOT__)
+#define __LINUX_KERNEL_ONLY__
+#include "defs_os_linux.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Linux Application                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (__LINUX_APP__)
+#include "defs_os_linux_app.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       Core dependent definitions                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core: x86                                                                                               */
+/* Supported Tools: Watcom tools for DOS                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (__WATCOMC__) && defined (__X86__)
+#include "defs_core_x86.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core: CR16                                                                                              */
+/* Supported Tools: NSC tools                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (__CR16C__)
+#include "defs_core_cr16.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core: 8051                                                                                              */
+/* Supported Tools: Keil tools                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif (defined (__C51__) && defined (__KEIL__))
+#include "defs_core_8051.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core: ARM                                                                                               */
+/* Supported Tools: GCC 3.1 (based) and above, RVDS 3.0 for windows and above                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined (_ARM_) || defined (__arm__) || defined (__arm) || defined (__thumb__)
+#include "defs_core_arm.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core: COP8                                                                                              */
+/* Supported Tools: IAR tools                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#elif defined(__TID__) && (((__TID__ >> 8) & 0x7F) == 0x58) && defined(__IAR_SYSTEMS_ICC__)
+#include "defs_core_cop8.h"
+
+#else
+/*---------------------------------------------------------------------------------------------------------*/
+/* Unsupported OS or CORE                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#error "Unsupported OS or Core architecture"
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default definitions                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "defs_core_default.h"
+
+
+#endif /* __TYPES_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/defs_utils.h b/board/nuvoton/common/SWC_DEFS/defs_utils.h
new file mode 100755
index 0000000..6a8d1bc
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/defs_utils.h
@@ -0,0 +1,441 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation Confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2010-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*    defs_utils.h                                                                                         */
+/*            This file contains NTIL utilities and constants                                              */
+/* Project:                                                                                                */
+/*            SWC DEFS                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __UTILS_H__
+#define __UTILS_H__
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                MEMORY ORGANIZATION, LITTLE vs BIG ENDIAN                                */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Swap high byte and low byte                                                                             */
+/* SWAP16 operation example:                                                                               */
+/* 16bit source: <byte2><byte1>                                                                            */
+/* 16bit result: <byte1><byte2>                                                                            */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SWAP16(u16)                                                                                         \
+            ( ((UINT16)((u16) & 0x00FF) << 8)                                                               \
+            | (((UINT16)(u16) & 0xFF00) >> 8))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Swap high word and low word                                                                             */
+/* SWAP32 operation example:                                                                               */
+/* 32bit source: <word2><word1>                                                                            */
+/* 32bit result: <word1><word2>                                                                            */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SWAP32(u32)                                                                                        \
+            ( ((UINT32)((u32) & 0x0000FFFF) << 16)                                                         \
+            | (((UINT32)(u32) & 0xFFFF0000) >> 16))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Swap high word and low word                                                                             */
+/* SWAP64 operation example:                                                                               */
+/* 64bit source: <dword2><dword1>                                                                          */
+/* 64bit result: <dword1><dword2>                                                                          */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SWAP64(u64)                                                                                        \
+            ( ((UINT64)((u64) & 0x00000000FFFFFFFF) << 32)                                                 \
+            | (((UINT64)(u64) & 0xFFFFFFFF00000000) >> 32))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Make byte value from 2 nibble values                                                                    */
+/* MAKE8 operation example:                                                                                */
+/* Two 4bit sources: <nibble1>, <nibble2>                                                                  */
+/* 8bit result:     <nibble2><nibble1>                                                                     */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAKE8(nlo, nhi)                                                                                    \
+    ((UINT8)(((UINT8)(nlo)) | (((UINT8)(nhi)) << 4)))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Make word value from 2 byte values                                                                      */
+/* MAKE16 operation example:                                                                               */
+/* Two 8bit sources: <byte1>, <byte2>                                                                      */
+/* 16bit result:     <byte2><byte1>                                                                        */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAKE16(blo, bhi)                                                                                    \
+    ((UINT16)(((UINT8)(blo)) | (((UINT16)(bhi)) << 8)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Make long value from 2 word values                                                                      */
+/* MAKE32 operation example:                                                                               */
+/* Two 16bit sources: <word1>, <word2>                                                                     */
+/* 32bit result:      <word2><word1>                                                                       */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAKE32(wlo, whi)                                                                                   \
+    ((UINT32)(((UINT16)(wlo)) | (((UINT32)(whi)) << 16)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Make long long value from 2 long values                                                                 */
+/* MAKE64 operation example:                                                                               */
+/* Two 32bit sources: <word1>, <word2>                                                                     */
+/* 64bit result:      <word2><word1>                                                                       */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAKE64(llo, lhi)                                                                                   \
+    ((UINT64)(((UINT32)(llo)) | (((UINT64)(lhi)) << 32)))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Big to Little endian convertor - 16 bit                                                                 */
+/* LE16 operation example:                                                                                 */
+/* 16bit source: <byte2><byte1>                                                                            */
+/* 16bit result: <byte1><byte2>                                                                            */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define LE16(u16)                                                                                          \
+(  ((UINT16)((u16) &   0xFF) << 8)                                                                         \
+|  (((UINT16)(u16) & 0xFF00) >> 8)                                                                         \
+)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Big to Little endian convertor - 32 bit                                                                 */
+/* LE32 operation example:                                                                                 */
+/* 32bit source: <byte4><byte3><byte2><byte1>                                                              */
+/* 32bit result: <byte1><byte2><byte3><byte4>                                                              */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define LE32(u32)                                                                                          \
+    MAKE32(LE16(MSW(u32)), LE16(LSW(u32)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                                                                         */
+/* Big to Little endian convertor - 64 bit                                                                 */
+/* LE64 operation example:                                                                                 */
+/* 64bit source: <byte8><byte7><byte6><byte5><byte4><byte3><byte2><byte1>                                  */
+/* 64bit result: <byte1><byte2><byte3><byte4><byte5><byte6><byte7><byte8>                                  */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define LE64(u64)                                                                                          \
+    MAKE64(LE32(MSD(u64)), LE32(LSD(u64)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Extracting Nibble - 4 bit: MSN, LSN                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MSN(u8)        ((UINT8)((UINT8)(u8) >> 4))
+#define LSN(u8)        ((UINT8)((UINT8)u8 & 0x0F))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Extracting Byte - 8 bit: MSB, LSB                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MSB(u16)        ((UINT8)((UINT16)(u16) >> 8))
+#define LSB(u16)        ((UINT8)(u16))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Extracting Word - 16 bit: MSW, LSW                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MSW(u32)        ((UINT16)((UINT32)(u32) >> 16))
+#define LSW(u32)        ((UINT16)(u32))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Extracting Double Word - 32 bit: MSD, LSD                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MSD(u64)        ((UINT32)((UINT64)(u64) >> 32))
+#define LSD(u64)        ((UINT32)(u64))
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Extracting bytes from DWORD - 32 bit                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MSB0(u32)       ((UINT8)(((UINT32)(u32) & 0xFF000000) >> 24))
+#define MSB1(u32)       ((UINT8)(((UINT32)(u32) & 0xFF0000) >> 16))
+#define MSB2(u32)       ((UINT8)(((UINT16)(u32) & 0xFF00) >> 8))
+#define MSB3(u32)       ((UINT8)((u32) & 0xFF))
+
+#define LSB0(u32)       MSB3(u32)
+#define LSB1(u32)       MSB2(u32)
+#define LSB2(u32)       MSB1(u32)
+#define LSB3(u32)       MSB0(u32)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             UTILITY MACROS                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+#define _CONCAT2(a,b)           a##b
+#define _STRINGX(x)             #x
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Concatenate strings macros                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONCAT2(a,b)            _CONCAT2(a,b)
+#define CONCAT3(a,b,c)          CONCAT2(a,CONCAT2(b,c))
+#define CONCAT4(a,b,c,d)        CONCAT2(a,CONCAT3(b,c,d))
+#define CONCAT5(a,b,c,d,e)      CONCAT2(a,CONCAT4(b,c,d,e))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Transform constant to string                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define STRINGX(x)              _STRINGX(x)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate maximum value                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MAX(a, b)               ((a)>(b) ? (a) : (b))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate minimum value                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MIN(a, b)               ((a)<(b) ? (a) : (b))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate absolute value                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ABS(a)                  ((a)>(0) ? (a) : -(a))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate modulus                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define MOD(a,b)                ((a) - ((a)/(b))*(b))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate integer division with rounding                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DIV_ROUND(a, b)         (((a) + ((b)/2)) / (b))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate integer division with rounding up                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DIV_CEILING(a, b)       (((a) + ((b)-1)) / (b))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate average of two integers                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define AVG(a,b)                DIV_ROUND(((a)+(b)),2)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate square                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SQR(a)                  ((a)*(a))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate LOG                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define LOG_1(n)                (((n) >= 2) ? 1 : 0)
+#define LOG_2(n)                (((n) >= 1<<2) ? (2 + LOG_1((n)>>2)) : LOG_1(n))
+#define LOG_4(n)                (((n) >= 1<<4) ? (4 + LOG_2((n)>>4)) : LOG_2(n))
+#define LOG_8(n)                (((n) >= 1<<8) ? (8 + LOG_4((n)>>8)) : LOG_4(n))
+#define LOG(n)                  (((n) >= 1<<16) ? (16 + LOG_8((n)>>16)) : LOG_8(n))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Determine if number is even                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IS_EVEN(a)              ((a)%2 == 0)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Determine if number is odd                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define IS_ODD(a)               (!IS_EVEN(a))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Calculate size of statically declared array                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifndef ARRAY_SIZE
+#if defined (__LINUX_KERNEL_ONLY__)
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))
+#else
+#define ARRAY_SIZE(a)   (sizeof(a) / sizeof((a)[0]))
+#endif
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* calculate alignment of address (1, 2 or 4)                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ALIGNMENT(a)            (((((UINT32)(a)) % 4) == 1) ? 1 : (4 - (((UINT32)(a)) % 4)))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Round (up) the number (val) on the (n) boundary. (n) must be power of 2                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROUND_UP(val, n)     ( ((val)+(n)-1) & ~((n)-1) )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Round (down) the number(val)on the (n) boundary. (n) must be power of 2                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROUND_DOWN(val, n)   (  (val)        & ~((n)-1) )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Round (up) the number (val) to the nearest power of 2 (pow)                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ROUND_UP_POWER2(val, pow)    {                                                                     \
+                                         pow = val;                                                        \
+                                         pow--;                                                            \
+                                         pow |= pow >> 1;                                                  \
+                                         pow |= pow >> 2;                                                  \
+                                         pow |= pow >> 4;                                                  \
+                                         pow |= pow >> 8;                                                  \
+                                         pow |= pow >> 16;                                                 \
+                                         pow++;                                                            \
+                                     }
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Atomic operation                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ATOMIC_OP(exp)       {                                                                             \
+                                INT var = 0;                                                               \
+                                INTERRUPTS_SAVE_DISABLE(var);                                              \
+                                exp;                                                                       \
+                                INTERRUPTS_RESTORE(var);                                                   \
+                             }
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Execution of a function from pointer                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/* Call the macro in the following way:                                                                    */
+/* EXECUTE_FUNC( func, (arg1, arg2))                                                                       */
+/* EXECUTE_FUNC_RET( retvar, func, (arg1, arg2, arg3))                                                     */
+/* EXECUTE_FUNC_RET_VALUE( func, (arg1, arg2, arg3), default_return_value)                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EXECUTE_FUNC(func, args)                    \
+    if (func != NULL)                               \
+    {                                               \
+        func args;                                  \
+    }
+
+#define EXECUTE_FUNC_RET(ret, func, args)           \
+    if (func != NULL)                               \
+    {                                               \
+        ret = func args;                            \
+    }
+
+#define EXECUTE_FUNC_RET_VALUE(func, args, default_value)   ((func != NULL)? func args : default_value)
+
+#define JUMP_TO_ADDRESS(addr)      ((void(*)(void))(addr))()
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Generic Array structure                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    UINT32* array;
+    UINT32  arraySize;
+} ARRAY_32_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                            MEASUREMENT UNITS                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Capacity (basic unit : byte)                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define   _1B_            1UL
+#define   _2B_            (   2 * _1B_   )
+#define   _4B_            (   2 * _2B_   )
+#define   _8B_            (   2 * _4B_   )
+#define  _16B_            (   2 * _8B_   )
+#define  _32B_            (   2 * _16B_  )
+#define  _64B_            (   2 * _32B_  )
+#define _128B_            (   2 * _64B_  )
+#define _256B_            (   2 * _128B_ )
+#define _512B_            (   2 * _256B_ )
+
+#define   _1KB_           (1024 * _1B_    )
+#define   _2KB_           (   2 * _1KB_   )
+#define   _4KB_           (   2 * _2KB_   )
+#define   _8KB_           (   2 * _4KB_   )
+#define  _16KB_           (   2 * _8KB_   )
+#define  _32KB_           (   2 * _16KB_  )
+#define  _64KB_           (   2 * _32KB_  )
+#define _128KB_           (   2 * _64KB_  )
+#define _256KB_           (   2 * _128KB_ )
+#define _512KB_           (   2 * _256KB_ )
+
+#define   _1MB_           (1024 * _1KB_   )
+#define   _2MB_           (   2 * _1MB_   )
+#define   _4MB_           (   2 * _2MB_   )
+#define   _8MB_           (   2 * _4MB_   )
+#define  _16MB_           (   2 * _8MB_   )
+#define  _32MB_           (   2 * _16MB_  )
+#define  _64MB_           (   2 * _32MB_  )
+#define _128MB_           (   2 * _64MB_  )
+#define _256MB_           (   2 * _128MB_ )
+#define _512MB_           (   2 * _256MB_ )
+
+#define   _1GB_           (1024 * _1MB_   )
+#define   _2GB_           (   2 * _1GB_   )
+#define   _4GB_           (   2 * _2GB_   )
+#define   _8GB_           (   2 * _4GB_   )
+#define  _16GB_           (   2 * _8GB_   )
+#define  _32GB_           (   2 * _16GB_  )
+#define  _64GB_           (   2 * _32GB_  )
+#define _128GB_           (   2 * _64GB_  )
+#define _256GB_           (   2 * _128GB_ )
+#define _512GB_           (   2 * _256GB_ )
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Frequency (basic unit : hertz)                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _1Hz_           1UL
+#define _1KHz_          (1000 * _1Hz_ )
+#define _1MHz_          (1000 * _1KHz_)
+#define _1GHz_          (1000 * _1MHz_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Voltage (basic unit : millivolt)                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _1mV_           1UL
+#define _1V_            (1000 * _1mV_)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Time                                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define _1USEC_IN_NSEC_     1000UL
+
+#define _1MSEC_IN_USEC_     1000UL
+#define _1MSEC_IN_NSEC_     ((_1MSEC_IN_USEC_) * (_1USEC_IN_NSEC_))
+
+#define _1SEC_IN_MSEC_      1000UL
+#define _1SEC_IN_USEC_      ((_1SEC_IN_MSEC_) * (_1MSEC_IN_USEC_))
+#define _1SEC_IN_NSEC_      ((_1SEC_IN_MSEC_) * (_1MSEC_IN_NSEC_))
+
+#define _1MIN_IN_SEC_       60UL
+#define _1MIN_IN_MSEC_      ((_1MIN_IN_SEC_) * (_1SEC_IN_MSEC_))
+#define _1MIN_IN_USEC_      ((_1MIN_IN_SEC_) * (_1SEC_IN_USEC_))
+#define _1MIN_IN_NSEC_      ((_1MIN_IN_SEC_) * (_1SEC_IN_NSEC_))
+
+#define _1HOUR_IN_MIN_      60UL
+#define _1HOUR_IN_SEC_      ((_1HOUR_IN_MIN_) * (_1MIN_IN_SEC_))
+#define _1HOUR_IN_MSEC_     ((_1HOUR_IN_MIN_) * (_1MIN_IN_MSEC_))
+#define _1HOUR_IN_USEC_     ((_1HOUR_IN_MIN_) * (_1MIN_IN_USEC_))
+#define _1HOUR_IN_NSEC_     ((_1HOUR_IN_MIN_) * (_1MIN_IN_NSEC_))
+
+#define _1DAY_IN_HOURS_     24UL
+#define _1DAY_IN_MIN_       ((_1DAY_IN_HOURS_) * (_1HOUR_IN_MIN_))
+#define _1DAY_IN_SEC_       ((_1DAY_IN_HOURS_) * (_1HOUR_IN_SEC_))
+#define _1DAY_IN_MSEC_      ((_1DAY_IN_HOURS_) * (_1HOUR_IN_MSEC_))
+#define _1DAY_IN_USEC_      ((_1DAY_IN_HOURS_) * (_1HOUR_IN_USEC_))
+#define _1DAY_IN_NSEC_      ((_1DAY_IN_HOURS_) * (_1HOUR_IN_NSEC_))
+
+#endif /* __UTILS_H__ */
diff --git a/board/nuvoton/common/SWC_DEFS/swc-defs.lnt b/board/nuvoton/common/SWC_DEFS/swc-defs.lnt
new file mode 100755
index 0000000..668c0e7
--- /dev/null
+++ b/board/nuvoton/common/SWC_DEFS/swc-defs.lnt
@@ -0,0 +1,56 @@
+//    swc-defs.lnt
+//    PC-Lint Options for the SWC_DEFS Software Component
+
+//    This file contains options to allow PC-Lint to process header
+//    files for the Software Definitions (SWC_DEFS).
+//
+//    lint-nt  swc-defs.lnt
+//
+
+-emacro(*,DISABLE_INTERRUPTS,ENABLE_INTERRUPTS)
+-emacro(*,INTERRUPTS_SAVE_DISABLE,INTERRUPTS_RESTORE)
+-emacro(*,ATOMIC_OP)
+-emacro(*,ASSERT)
+-emacro(*,CPU_IDLE)
+
+-emacro(747,REG_WRITE)  // Significant prototype coercion (long to unsigned char/short)
+                        // warning is generated when register size is 8/16 bits, value is casted to unsigned char/short
+
+-emacro(732,REG_WRITE)  // Loss of sign (short to unsigned short)
+                        // warning is generated when value is declared as short (INT16) but casted to unsigned short (UINT16)
+
+-emacro(506,SET_VAR_FIELD,SET_REG_FIELD,SET_VAR_BIT,CLEAR_VAR_BIT,READ_VAR_FIELD)   // These macros use a constant Boolean expression which is 
+                                                                                    // evaluated the same way each time (sizeof(var) == 2)
+
+-emacro(712,SET_VAR_FIELD,SET_VAR_BIT,CLEAR_VAR_BIT)    // Loss of precision (assignment) (unsigned long to unsigned short/char)
+                                                        // This is due to UINT32 casting used in these macros
+
+-emacro(737,SET_VAR_FIELD,SET_REG_FIELD)                // Loss of sign in promotion from int to unsigned int (using enums in field macros)
+
+-emacro(734,SET_VAR_FIELD,SET_VAR_BIT,CLEAR_VAR_BIT)    // Loss of precision (assignment) (32 bits to 8 bits)
+                                                        // This is due to the UINT32 casting used in these macros, regardless of the 
+                                                        // actual variable size used.
+
+-emacro(734,SET_REG_FIELD,SET_REG_BIT)	                // Loss of precision (15 bits to 8 bits)
+                                                        // The fixed '0x1' expression used in these macros ignores the UINT8 casting and uses INT (short)
+
+-emacro(502,CLEAR_VAR_BIT,CLEAR_REG_BIT,SET_REG_FIELD)  // Expected unsigned type (Unary ~ applied to signed quantities).
+                                                        // The case where sizeof(var) == 1 does not use casting, hence is regarded as signed.
+                                                        // Casting to 'UINT8' does not remove the warning.
+                                                        // Casting to 'unsigned' removes the warning.
+
+-emacro(774,SET_REG_FIELD)                             // Boolean within 'if' always evaluates to True
+                                                        
+-emacro(778,SET_REG_FIELD,SET_VAR_FIELD,ASSERT)         // Constant expression evaluates to 0 in operation ...
+                                                        // When the 'value' parameter always evaluates to 0 following a mathematical operation.
+                                                        // e.g., (FLASH_DIVIDER - 1), where FLASH_DIVIDER always evaluates to 1.
+
+//+fpm  // Used to suppress Loss of Precision messages (#734).
+        // These messages are derived from using the BITS AND FIELDS OPERATIONS in defs.h.
+        // User is responsible to make sure there is no unwanted truncation.
+        // Examples:
+        // 1. UINT8 a, b;
+        // a = (b << 4);	// Info 734: Loss of precision (12 bits to 8 bits)
+        //
+        // 2. #define	FIELD_P    8
+        // SET_VAR_FIELD(reg, FIELD, value);	// Info 734: Loss of precision (24 bits to 16 bits)
diff --git a/board/nuvoton/common/config.mk b/board/nuvoton/common/config.mk
new file mode 100755
index 0000000..0e4c98a
--- /dev/null
+++ b/board/nuvoton/common/config.mk
@@ -0,0 +1,45 @@
+#Common TextBase address
+#CONFIG_SYS_TEXT_BASE = 0x01400000
+
+#Common include search pathes
+PLATFORM_CPPFLAGS += -I$(srctree)/
+PLATFORM_CPPFLAGS += -I$(srctree)/board/nuvoton/common/BMC_HAL/Chips
+PLATFORM_CPPFLAGS += -I$(srctree)/board/nuvoton/common/SWC_DEFS
+
+# We don't use LIBC in this project
+PLATFORM_CPPFLAGS += -DNO_LIBC
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DBOARD_NAME=$(BOARD_NAME)
+PLATFORM_CPPFLAGS += -DEXTERNAL_INCLUDE_FILE=$(srctree)/board/nuvoton/common/nuvoton_hal.h
+
+#Common optimizations flags
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCAT
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCAT
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCHR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRRCHR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRLEN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNLEN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRDUP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSPN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRPBRK
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRTOK
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSEP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSWAB
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMSET
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_BCOPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMMOVE
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMSCAN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSTR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCHR
+
+
+
+
+
diff --git a/board/nuvoton/common/nuvoton_aic.c b/board/nuvoton/common/nuvoton_aic.c
new file mode 100755
index 0000000..a37f5ff
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_aic.c
@@ -0,0 +1,43 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_aic.c                                                                                         */
+/*            This file contains implementation of AIC module for U-Boot                                   */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "config.h"
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt Handler Table                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        do_irq                                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main IRQ handler                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_IRQ
+void do_irq(void)
+{
+    AIC_Isr();
+}
+#endif
+
+
diff --git a/board/nuvoton/common/nuvoton_eth.c b/board/nuvoton/common/nuvoton_eth.c
new file mode 100755
index 0000000..3b28fb2
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_eth.c
@@ -0,0 +1,103 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_eth.c                                                                                         */
+/*            This file contains Ehternet module implementation                                            */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <netdev.h>
+#include <phy.h>
+#include "miiphy.h"
+
+#include "BMC_HAL/Boards/board.h"
+
+void CLK_ConfigureGMACClock (UINT32 ethNum);
+void CLK_ResetGMAC (UINT32 deviceNum);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function forward declarations                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+int   nuvoton_eth_recv    (struct eth_device *dev);
+
+extern int nuc970_eth_register(ulong base_addr, unsigned int dev_num);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        board_eth_init                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  bis -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs ethernet module initialization                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_eth_init(bd_t *bis)
+{
+    UINT32              devNum;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring every ETH device                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+#if defined(CONFIG_NUC970_ETH)
+    for(devNum=0; devNum < CHIP_NUM_OF_EMC_ETH; devNum++)
+    {
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Enable Clock                                                                                   */
+        /*-----------------------------------------------------------------------------------------------------*/
+        CLK_ConfigureEMCClock(devNum);
+
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Muxing RMII MDIO                                                                                    */
+        /*-----------------------------------------------------------------------------------------------------*/
+        GCR_Mux_RMII(devNum);
+
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Reset EMC module                                                                                     */
+        /*-----------------------------------------------------------------------------------------------------*/
+        CLK_ResetEMC(devNum);
+        nuc970_eth_register((UINT32)EMC_BASE_ADDR(devNum), devNum);
+    }
+#endif  /* CONFIG_NUC970_ETH */
+
+#if defined(CONFIG_ETH_DESIGNWARE)
+    for(devNum=0; devNum < CHIP_NUM_OF_GMAC_ETH; devNum++)
+    {                             
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* enabling the GMAC clocks                                                                            */
+        /*-----------------------------------------------------------------------------------------------------*/
+        CLK_ConfigureGMACClock(devNum+2);
+
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Setting ETH muxing                                                                                  */
+        /*-----------------------------------------------------------------------------------------------------*/
+
+        GCR_Mux_GMII(devNum+2);
+
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Reseting the device                                                                                 */
+        /*-----------------------------------------------------------------------------------------------------*/
+        //        GMAC_Reset_L(devNum);
+        CLK_ResetGMAC(devNum+2);
+
+        if (designware_initialize( (UINT32)GMAC_BASE_ADDR(devNum), PHY_INTERFACE_MODE_RGMII) < 0)
+            return -1;
+    }
+#endif  /* CONFIG_DESIGNWARE_ETH */
+
+    return 0;
+}
+
+
diff --git a/board/nuvoton/common/nuvoton_flash.c b/board/nuvoton/common/nuvoton_flash.c
new file mode 100755
index 0000000..70f6123
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_flash.c
@@ -0,0 +1,195 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_flash.c                                                                                       */
+/*            This file contains flash api for U-BOOT                                                      */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "common.h"
+#include "config.h"
+#include "spi.h"
+#include "flash.h"
+#include "linux/sizes.h"
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Boards/board.h"
+
+#ifndef CONFIG_SYS_NO_FLASH
+/*---------------------------------------------------------------------------------------------------------*/
+/* Flash info array                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash initialization                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+unsigned long flash_init (void)
+{
+    INT32 idx         = 0;
+    INT32 sect_idx    = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing the SPI Flash                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_Flash_Init(CONFIG_FLASH_BASE);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Constructing the flash_info array                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+	/* Init: no FLASHes known */
+	for (idx = 0; idx < CONFIG_SYS_MAX_FLASH_BANKS; ++idx) {
+		flash_info[idx].flash_id = FLASH_UNKNOWN;
+	}
+
+    for (idx=0; idx < CONFIG_SYS_MAX_FLASH_BANKS; ++idx)
+    {
+        if (SPI_Flash_Devices[idx].mf_id != 0)
+        {
+            flash_info[idx].size            = SPI_Flash_Devices[idx].chip_size;
+            flash_info[idx].sector_count    = SPI_Flash_Devices[idx].chip_size/SPI_Flash_Devices[idx].sector_size;
+            flash_info[idx].flash_id        = SPI_Flash_Devices[idx].capacity_id << 16 | SPI_Flash_Devices[idx].mf_id;
+
+            for(sect_idx=0; sect_idx < flash_info[idx].sector_count; sect_idx++)
+            {
+                flash_info[idx].start[sect_idx] = SPI_Flash_Devices[idx].startAddr +              \
+                                                  SPI_Flash_Devices[idx].sector_size * sect_idx;
+                flash_info[idx].protect[sect_idx] = 0;
+            }
+        }
+    }
+
+    return SPI_Flash_TotalSize;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_print_info                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr - pointer to the flash into entry                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine  prints info about the given flash device                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void flash_print_info (flash_info_t *flash_info_ptr)
+{
+    INT32 sect_idx;
+
+    printf(" size : [0x%lx]",    flash_info_ptr->size);
+    printf(" sect count : [%d]", flash_info_ptr->sector_count);
+    printf(" id : [0x%lx]\n",    flash_info_ptr->flash_id);
+
+    for(sect_idx=0; sect_idx < flash_info_ptr->sector_count; sect_idx++)
+    {
+        printf("[0x%lx][%s]",
+                flash_info_ptr->start[sect_idx],
+                (flash_info_ptr->protect[sect_idx])?"(RO)":"(RW)");
+
+        if(sect_idx + 1 % 6 == 0)
+        {
+            printf("\n");
+        }
+    }
+
+    printf("\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_erase                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr  - pointer to flash device info entry                                   */
+/*                  s_first         - first erase sector index                                             */
+/*                  s_last          - last erase sector index                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash erase inside given flash device                            */
+/*---------------------------------------------------------------------------------------------------------*/
+int flash_erase (flash_info_t * flash_info_ptr, int s_first, int s_last)
+{
+    HAL_STATUS ret = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if we need erase whole flash device                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((s_first == 0) && ((s_last + 1) == flash_info_ptr->sector_count))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If we do, we execute optimized erase                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        ret = SPI_Flash_BulkErase(flash_info_ptr->start[s_first]);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Otherwise we erase sectors in the range                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        UINT32 sect_idx = 0;
+        for(sect_idx = s_first; sect_idx <= s_last; ++sect_idx)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Erase it using SPI Flash driver                                                             */
+            /*---------------------------------------------------------------------------------------------*/
+            ret += SPI_Flash_SectorErase(flash_info_ptr->start[sect_idx]);
+        }
+    }
+
+    if (ret == HAL_OK)
+        return 0;
+    else
+        return -ret;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        write_buff                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr  - flash device info                                                    */
+/*                  addr            - destination address on a flash                                       */
+/*                  src             - source address                                                       */
+/*                  cnt             - source data size                                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes a buffer to the flash                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int write_buff (flash_info_t *flash_info_ptr, uchar *src, ulong addr, ulong cnt)
+{
+    INT ret;
+
+    if ((ret = SPI_Flash_Write((UINT32)addr, src, cnt)) == HAL_OK)
+        return 0;
+    else
+        return -ret;
+}
+#endif
+
+
diff --git a/board/nuvoton/common/nuvoton_hal.h b/board/nuvoton/common/nuvoton_hal.h
new file mode 100755
index 0000000..9a7173a
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_hal.h
@@ -0,0 +1,26 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_hal.h                                                                                         */
+/*            This file contains HAL configurations from U-Boot                                            */
+/* Project:                                                                                                */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#undef GMAC_MODULE_TYPE
+#undef EMC_MODULE_TYPE
+#undef MC_MODULE_TYPE
+#undef AES_MODULE_TYPE
+#undef DES_MODULE_TYPE
+#undef MC_MODULE_TYPE
+#undef VCD_MODULE_TYPE
+#undef ECE_MODULE_TYPE
+#undef PSPI_MODULE_TYPE
+#undef SHM_MODULE_TYPE
+#undef SD_MODULE_TYPE
+#undef GPIO_MODULE_TYPE
diff --git a/board/nuvoton/common/nuvoton_init.c b/board/nuvoton/common/nuvoton_init.c
new file mode 100755
index 0000000..e6036ff
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_init.c
@@ -0,0 +1,186 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_misc.c                                                                                        */
+/*            This file contains misc U-Boot interface functions                                           */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include <config.h>
+#include <common.h>
+#include <sdhci.h>
+#include <asm/arch/npcm750_sdhci.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+#include "BMC_HAL/version.h"
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        reset_cpu                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine makes CPU reset                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void reset_cpu (ulong addr)
+{
+    TIMER_WatchdogReset(TIMER5_DEV);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        checkboard                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Check Board Identity                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int checkboard(void)
+{
+
+    char *s = getenv("serial#");
+    if (s != NULL)
+    {
+        printf("Board serial# ");
+        printf(s);
+    }
+    printf("\n");
+
+    return (0);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        dram_init                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs dram initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int dram_init (void)
+{
+	
+#if 0    // Trego - Done in Boot-Block
+   CLK_ConfigurePCIClock();            // For DDR config
+
+   MC_ConfigureDDR();                  // For DDR and debugger only perpose
+#endif   
+
+  
+   
+
+   gd->ram_size = GCR_PowerOn_GetMemorySize();
+	
+   return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        interrupt_init                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs interrupt initialization                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+int arch_interrupt_init (void)
+{
+
+    AIC_Initialize();
+    timer_init();
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_common_info                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints board independent info                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void print_common_info(void)
+{
+    printf("HAL ver : v%s\n", BMC_HAL_VERSION_STR);
+    printf("\n");
+    printf("Board: %s\n", STRINGX(BOARD_NAME));
+    printf("Chip : %s\n", STRINGX(CHIP_NAME));
+    printf("Core : %s\n", STRINGX(CORE_TYPE));
+    printf("\n");
+    printf("CPU Freq:    % 4ldMHz\n", CLK_GetCPUFreq()/1000000L);
+    printf("Memory Freq: % 4ldMHz\n", CLK_GetMemoryFreq()/1000000L);
+    printf("SPI0 Freq:   % 4ldMHz\n", CLK_GetSPIFreq(0)/1000000L);
+    printf("SPI3 Freq:   % 4ldMHz\n", CLK_GetSPIFreq(3)/1000000L);
+    printf("APB1 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(1)/1000000L);
+    printf("APB2 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(2)/1000000L);
+    printf("APB3 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(3)/1000000L);
+    printf("APB4 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(4)/1000000L);
+    printf("APB5 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(5)/1000000L);
+    printf("CP Freq:     % 4ldMHz\n", CLK_GetCPFreq()/1000000L);
+    printf("\n");
+
+}
+
+#ifdef CONFIG_NPCMX50_SDHCI
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        board_mmc_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      board info                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine init mmc                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_mmc_init(bd_t *bd)
+{
+    int ret = 0;
+
+	ret = npcmx50_mmc_init();
+	
+	return ret;
+}
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        misc_init_r                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  PLEASE READ WITH CARE                                                                  */
+/*                                                                                                         */
+/*                  This routine is serves very important purpose and shouldn't be removed from this file. */
+/*                  The problem with current U-Boot implementation is that "board_eth_init" function is    */
+/*                  defined as weak reference inside U-Boot code.                                          */
+/*                  The archiver that makes a library out of this modules won't include "board_eth_init"   */
+/*                  function because it already resolved it elswhere DESPITE the fact it was declared as   */
+/*                  WEAK REFERENCE                                                                         */
+/*                  This function that is actually being called by U-Boot code explicitly (without week    */
+/*                  referencing) "prioritizes" this module in the function resolution process and causes   */
+/*                  the archiver to take the correct (our) implementation of "board_eth_init"              */
+/*---------------------------------------------------------------------------------------------------------*/
+int misc_init_r (void)
+{
+    return 0;
+}
diff --git a/board/nuvoton/common/nuvoton_low_level.S b/board/nuvoton/common/nuvoton_low_level.S
new file mode 100755
index 0000000..8c6e62d
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_low_level.S
@@ -0,0 +1,75 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_low_level_init.S                                                                            */
+/*            This file contains nuvoton low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include <config.h>
+#include <version.h>
+
+
+
+
+.globl lowlevel_init
+lowlevel_init:
+
+/*
+;----------------------------------------------------------
+; Execute board dependent low level code
+; Configuring Memory if needed
+;----------------------------------------------------------
+*/
+#ifdef CONFIG_BOARD_LOWLEVEL_INIT
+	mov 	r11, lr
+	bl	board_lowlevel_init	
+	mov		lr, r11
+#endif 
+
+
+#if 0    // Trego - removed redundant code, already done in uboot.
+/*      
+;----------------------------------------------------------
+; Disable Interrupt, This is for safe ...
+;----------------------------------------------------------
+*/
+    MRS     r0, CPSR
+    ORR     r0, r0, #0xC0
+    MSR     CPSR_c, r0
+
+
+/*
+;----------------------------------------------------------
+; Set mode to SVC, interrupts disabled (just paranoid)
+;----------------------------------------------------------
+*/
+    MRS   r0, cpsr
+    BIC   r0, r0, #0xF0000000
+    BIC   r0, r0, #0x1F
+    ORR   r0, r0, #0xD3
+    MSR   cpsr_fc, r0
+
+    
+/*
+;----------------------------------------------------------
+; Enabling Instruction Cache
+;----------------------------------------------------------
+*/
+    MRC     p15, 0, r0, c1, c0          /* get control register   */
+    ORR     r0, r0, #0x00001000         /* I-cache                */
+    MCR     p15, 0, r0, c1, c0          /* enable I cache         */
+#endif
+/*
+;----------------------------------------------------------
+; --- back to arch calling code 
+;----------------------------------------------------------
+*/
+    MOV     pc,     lr
diff --git a/board/nuvoton/common/nuvoton_serial.c b/board/nuvoton/common/nuvoton_serial.c
new file mode 100755
index 0000000..a00dbaa
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_serial.c
@@ -0,0 +1,156 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_serial.c                                                                                      */
+/*            This file contains implementation of serial driver for U-Boot                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <serial.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+#define UART_DEV UART3_DEV
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_init                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs UART initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_init(void)
+{
+    // in NPCM750 the BootBlock already configured the UART and the muxes were done according to GPIO and board type
+#ifndef NPCM750
+    UART_Init(UART_DEV, UART_MUX_MODE3_HSP1_UART1__HSP2_UART2__UART3_SI2, CONFIG_BAUDRATE);
+#endif
+    return 0;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_putc                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+void nuvoton_serial_putc( const char c )
+{
+    UART_PutC(UART_DEV, c);
+
+    if (c == '\n')
+    {
+        UART_PutC(UART_DEV, '\r');
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_puts                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  s - string to write to UART                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes whole string to UART                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void nuvoton_serial_puts( const INT8 *s )
+{
+  while (*s)
+  {
+    serial_putc( *s++ );
+  }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_getc                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_getc( void )
+{
+    return UART_GetC(UART_DEV);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_tstc                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char on UART                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_tstc( void )
+{
+    return UART_TestRX(UART_DEV);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_setbrg                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a stub                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void nuvoton_serial_setbrg( void )
+{
+}
+
+static struct serial_device nuvoton_serial_drv = {
+	.name	= "nuvoton_serial",
+	.start	= nuvoton_serial_init,
+	.stop	= NULL,
+	.setbrg	= nuvoton_serial_setbrg,
+	.putc	= nuvoton_serial_putc,
+	.puts	= default_serial_puts,
+	.getc	= nuvoton_serial_getc,
+	.tstc	= nuvoton_serial_tstc,
+};
+
+void nuvoton_serial_initialize(void)
+{
+	serial_register(&nuvoton_serial_drv);
+}
+
+__weak struct serial_device *default_serial_console(void)
+{
+	return &nuvoton_serial_drv;
+}
diff --git a/board/nuvoton/common/nuvoton_timer.c b/board/nuvoton/common/nuvoton_timer.c
new file mode 100755
index 0000000..cfd6c09
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_timer.c
@@ -0,0 +1,167 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_timer.c                                                                                       */
+/*            This file contains timer module implementation                                               */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        timer_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs timer initialization                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int timer_init (void)
+{
+    TIMER_StartPeriodic(TIMER0_DEV, CONFIG_SYS_HZ, NULL, NULL);
+
+    return 0;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        reset_timer                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs timer reset                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void reset_timer (void)
+{
+    TIMER_Reset(TIMER0_DEV);
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_timer                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns timer value normalized with base                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+ulong get_timer (ulong base)
+{
+	return TIMER_GetTick(TIMER0_DEV) - base;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_ticks                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns number of ticks                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+unsigned long long get_ticks(void)
+{
+    return get_timer(0);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        udelay                                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  usec -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine delay x useconds AND perserve advance timstamp value                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void __udelay (unsigned long usec)
+{
+    CLK_Delay_MicroSec((UINT32)usec);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_tbclk                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  usec -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the number of timer ticks per second                              */
+/*---------------------------------------------------------------------------------------------------------*/
+ulong get_tbclk (void)
+{
+    return CONFIG_SYS_HZ;
+}
+
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Tick Tock function: get elapsed time using the 25MHz HW internal counter                                */
+/*---------------------------------------------------------------------------------------------------------*/
+
+UINT32          gTimeTick[2];
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        Tick                                                                                   */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  time tick  (start counting time)                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+void Tick (void)
+{
+    CLK_GetTimeStamp(gTimeTick);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        Tock                                                                                   */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  time tock  (stop and print time since the Tick)                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void Tock (void)
+{
+    ulong          time_tock = 0;
+
+    time_tock = CLK_Delay_Since(0, gTimeTick);
+    printf(" =>UBOOT last command run for %ld us.\n", time_tock);
+}
+
+
+
+
diff --git a/board/nuvoton/common/nuvoton_usb.c b/board/nuvoton/common/nuvoton_usb.c
new file mode 100755
index 0000000..3f66fca
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_usb.c
@@ -0,0 +1,107 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_serial.c                                                                                      */
+/*            This file contains implementation of serial driver for U-Boot                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <usb.h>
+#include "../../../drivers/usb/host/ehci.h"
+#include <asm/io.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+#define USB_HOST_BA				(USBH_EHCI_BASE_ADDR+0x100)  // changed by az
+
+
+#define  IPSRST2                        (CLK_BASE_ADDR + 0x24)
+#define IPSRST2_USBHOST_BIT_POS  26
+
+#define  IPSRST3                        (CLK_BASE_ADDR + 0x34)
+#define IPSRST3_USBPHY1_BIT_POS  24
+#define IPSRST3_USBPHY2_BIT_POS  25
+
+
+#define  USBTEST                        (GCR_BASE_ADDR + 0x140)
+#define USBTEST_USB1PHYCTL_BIT_POS  28
+
+#define  USB2TEST                       (GCR_BASE_ADDR + 0x144)
+#define USBTEST_USB2PHYCTL_BIT_POS  28
+
+#define SET_BIT_IN_REG(reg,bit_pos)  writel(readl(reg) |   (1 <<  bit_pos) ,reg);
+#define CLR_BIT_IN_REG(reg,bit_pos)  writel(readl(reg) & (~(1 <<  bit_pos)) ,reg);
+/*
+ * EHCI host controller init
+ */
+int ehci_hcd_init(int index, enum usb_init_type init,
+                struct ehci_hccr **hccr, struct ehci_hcor **hcor)
+{
+// 	// loopback
+// 	regVal=*((volatile uint32_t *)(REG_INTCR3));
+// 	*((volatile uint32_t *)(REG_INTCR3)) = regVal | 0x01000000;
+
+ 	// reset host
+	SET_BIT_IN_REG(IPSRST2, IPSRST2_USBHOST_BIT_POS);
+ 	mdelay(20);
+
+
+ 	// enable phy
+ 	CLR_BIT_IN_REG(IPSRST3, IPSRST3_USBPHY1_BIT_POS);
+ 	CLR_BIT_IN_REG(IPSRST3, IPSRST3_USBPHY2_BIT_POS);
+  	mdelay(20);
+
+  	// set RS (Reset Sequence) bit
+  	SET_BIT_IN_REG(USBTEST, USBTEST_USB1PHYCTL_BIT_POS);
+  	SET_BIT_IN_REG(USB2TEST, USBTEST_USB2PHYCTL_BIT_POS);
+  	mdelay(20);
+
+ 	// enable host
+	CLR_BIT_IN_REG(IPSRST2, IPSRST2_USBHOST_BIT_POS);
+ 	mdelay(20);
+
+
+	// az	if (utmi_init() < 0)
+// az		return -1;
+	// enable D-CACHE
+	//unsigned int R0;
+	  asm volatile(	"MRC     p15, 0, R0, c1, c0, 0\n"  );
+	  asm volatile(	"ORR     R0, R0, #(0x1  <<2)\n"  );
+	  asm volatile(	"MCR     p15, 0, R0, c1, c0, 0\n"  );
+
+	*hccr = (struct ehci_hccr *)(USB_HOST_BA);
+	*hcor = (struct ehci_hcor *)((uint32_t) *hccr
+			+ HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
+
+//	debug("armada100-ehci: init hccr %x and hcor %x hc_length %d\n",
+//		(uint32_t)*hccr, (uint32_t)*hcor,
+//		(uint32_t)HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+//az - usb
+int board_usb_init(int index, enum usb_init_type init)
+{
+	return 0;
+}
+
+
+/*
+ * EHCI host controller stop
+ */
+int ehci_hcd_stop(int index)
+{
+	return 0;
+}
diff --git a/common/Makefile b/common/Makefile
old mode 100644
new mode 100755
index 491c565..aad16e6
--- a/common/Makefile
+++ b/common/Makefile
@@ -107,6 +107,8 @@ obj-$(CONFIG_CMD_FPGAD) += cmd_fpgad.o
 obj-$(CONFIG_CMD_FS_GENERIC) += cmd_fs.o
 obj-$(CONFIG_CMD_FUSE) += cmd_fuse.o
 obj-$(CONFIG_CMD_GETTIME) += cmd_gettime.o
+obj-$(CONFIG_CMD_GMAC) += cmd_gmac.o
+obj-$(CONFIG_CMD_RNG) += cmd_rng.o
 obj-$(CONFIG_CMD_GPIO) += cmd_gpio.o
 obj-$(CONFIG_CMD_I2C) += cmd_i2c.o
 obj-$(CONFIG_CMD_IOTRACE) += cmd_iotrace.o
@@ -194,6 +196,7 @@ obj-$(CONFIG_CMD_SPL) += cmd_spl.o
 obj-$(CONFIG_CMD_ZIP) += cmd_zip.o
 obj-$(CONFIG_CMD_ZFS) += cmd_zfs.o
 
+
 # others
 obj-$(CONFIG_BOOTSTAGE) += bootstage.o
 obj-$(CONFIG_CONSOLE_MUX) += iomux.o
diff --git a/common/board_f.c b/common/board_f.c
old mode 100644
new mode 100755
index 613332e..c2fcb64
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -458,6 +458,7 @@ static int reserve_uboot(void)
 	gd->relocaddr &= ~(65536 - 1);
 #endif
 
+	gd->relocaddr += CONFIG_SYS_TEXT_BASE & 0xFF;     // Trego - Keep original alignments since we relocate from CONFIG_SYS_TEXT_BASE
 	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10,
 	      gd->relocaddr);
 
@@ -796,8 +797,10 @@ static init_fnc_t init_sequence_f[] = {
 #endif
 #if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
 		defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32)
+#ifndef NPCM750     /* Done in interrupt_init */
 	timer_init,		/* initialize timer */
 #endif
+#endif
 #ifdef CONFIG_SYS_ALLOC_DPRAM
 #if !defined(CONFIG_CPM2)
 	dpram_init,
diff --git a/common/board_r.c b/common/board_r.c
old mode 100644
new mode 100755
index f8c1baa..f27a0f5
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -783,9 +783,6 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_CMD_ONENAND
 	initr_onenand,
 #endif
-#ifdef CONFIG_GENERIC_MMC
-	initr_mmc,
-#endif
 #ifdef CONFIG_HAS_DATAFLASH
 	initr_dataflash,
 #endif
@@ -842,6 +839,9 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init,
 #endif
+#ifdef CONFIG_GENERIC_MMC
+	initr_mmc,      /* Trego - MMC Must be after enable_interrupts */
+#endif
 #ifdef CONFIG_CMD_SCSI
 	INIT_FUNC_WATCHDOG_RESET
 	initr_scsi,
diff --git a/common/cmd_cache.c b/common/cmd_cache.c
old mode 100644
new mode 100755
index 37ab345..95fc0aa
--- a/common/cmd_cache.c
+++ b/common/cmd_cache.c
@@ -12,8 +12,372 @@
 #include <command.h>
 #include <linux/compiler.h>
 
+volatile u32 memtest_pattern = 0x01;
+
+volatile u32 memtest_chunk_size = 1024*1024;
+volatile u32 memtest_src_addr = 0x600000;
+volatile u32 memtest_dst_addr = 0xA00000;
+
+
+#if defined (NPCM750)
+#define GDMA0_BASE                 0xF0850000      /* GDMA0  */
+#define GDMA1_BASE                 0xF0851000      /* GDMA1  */
+#define GDMA2_BASE                 0xF0852000      /* GDMA2  */
+#define GDMA3_BASE                 0xF0853000      /* GDMA3  */
+#endif
+
+void set_memory(u32 start, u32 size, u8 start_pattern)
+{
+	u8 *src = (u8 *)start;
+	int i;
+	for (i=0; i<size; i++)
+		src[i] = start_pattern++;
+}
+
+int validate_memory(u32 start, u32 size, u8 start_pattern)
+{
+	u8 *src = (u8 *)start;
+	int i;
+	for (i=0; i<size; i++) {
+		if(src[i] != start_pattern++) {
+			printf("memory error at %08x:%02x start_pattern=%d \n", start+i, src[i],--start_pattern);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+void my_memcpy(u32 source, u32 dest, u32 size)
+{
+#if 0
+	memcpy((void *)dest, (void *)source, size);
+#else
+
+	u8 *src = (u8 *)source;
+	u8 *dst = (u8 *)dest;
+	int i;
+	for (i=0; i<size; i++)
+		dst[i] = src[i];
+#endif
+}
+
+u32 my_memread(u32 source, u32 size)
+{
+	int i;
+	u32 *ptr = (u32 *) source;
+	u32 sigma = 0;
+
+	for (i = 0, sigma = 0; i < size/4; i++)
+	    sigma += *(ptr + i);
+
+	return sigma;
+}
+
+static void nothing(u32 temp)
+{
+    return;
+}
+
+
+void test_basic_performance(void)
+{
+	u32 i,j,chunk_size = 4096;
+	u32 loops = 4096;
+	u32 temp;
+    UINT32 iUsCnt_start[2], iUsCnt_end[2];
+    u32 ticks;
+	
+	for (j=0; j<10; j++)
+	{
+		chunk_size <<= 1;
+		loops >>=1;
+		/* Setup the buffer */
+		temp = my_memread(memtest_src_addr, chunk_size);
+	
+		CLK_GetTimeStamp(iUsCnt_start);
+		for (i = 0; i < loops; i++)
+			temp = my_memread(memtest_src_addr, chunk_size);
+
+		CLK_GetTimeStamp(iUsCnt_end);
+		ticks = ((EXT_CLOCK_FREQUENCY_MHZ * _1MHz_ * (iUsCnt_end[1] - iUsCnt_start[1])) + iUsCnt_end[0] - iUsCnt_start[0])/EXT_CLOCK_FREQUENCY_MHZ;
+		printf("Duration = %8d usec loops= %4d ",ticks, loops );
+		printf("Chunk Size = %5d KB: Performance %6d KBps \n", chunk_size/1024, chunk_size*loops*100/ticks*10);
+        nothing(temp);
+	}
+}
+
+void test_basic_copy(void)
+{
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_basic_copy failed\n");
+	else
+		puts("test_basic_copy success\n");
+}
+
+void test_inval_d_range(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_inval_d_range success\n");
+	else
+		puts("test_inval_d_range failed\n");
+}
+
+void test_flush_d_range(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	flush_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_flush_d_range failed\n");
+	else
+		puts("test_flush_d_range success\n");
+}
+
+void test_flush_d_all(void)
+{
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	flush_dcache_all();
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	flush_dcache_all();
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_flush_d_all failed\n");
+	else
+		puts("test_flush_d_all success\n");
+}
+
+
+void test_inval_d_all(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	puts("test_inval_d_all - destructive test - expect a crash after this. If there is a crash test is successful!\n");
+	invalidate_dcache_all();
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_inval_d_all failed\n");
+	else
+		puts("test_inval_d_all success\n");
+}
+
+
+#if defined (NPCM750)               // Only Poleg
+#define TEST_BUF_SIZE (1024*256)
+
+void l2_cache_test(void)
+{
+	int i, j;
+	u32 *ptr = (u32 *) 0x400000;
+	volatile u64 sigma = 0;
+
+	/* Setup the buffer */
+	for (i = 0; i < TEST_BUF_SIZE; i++) {
+		*(ptr + i) = i;
+	}
+
+	flush_dcache_range((u32) ptr, (u32) ptr + (TEST_BUF_SIZE * sizeof(u32)));
+
+	/* Here data at Cache is in sync with SDRAM */
+	for (j = 0; j < 5000; j++) 
+	{
+		for (i = 0, sigma = 0; i < TEST_BUF_SIZE; i++)
+		{
+			sigma += *(ptr + i);
+        }
+		
+		if (!(j % 500))
+		{
+			puts(".");
+    		printf("sigma: 0x%llx\n", sigma);
+        }
+	}
+
+	printf("total sigma: 0x%llx\n", sigma);
+}
+
+#define CP15_PRINT(crn, opc1, crm, opc2) \
+    asm volatile("mrc p15, "#opc1", %0, "#crn", "#crm", "#opc2"" : "=r" (reg_val)); \
+	printf("mrc p15, "#opc1", "#crn", "#crm", "#opc2" = 0x%08X\n", reg_val)
+
+void cp15_regs(void)
+{
+	u32 reg_val=0;
+
+
+	CP15_PRINT(c0, 0, c0, 0);
+	CP15_PRINT(c0, 0, c0, 1);
+	CP15_PRINT(c0, 0, c0, 2);
+	CP15_PRINT(c0, 0, c0, 3);
+	CP15_PRINT(c0, 0, c0, 5);
+	CP15_PRINT(c0, 0, c0, 6);
+    
+	CP15_PRINT(c0, 0, c1, 0);
+	CP15_PRINT(c0, 0, c1, 1);
+	CP15_PRINT(c0, 0, c1, 2);
+	CP15_PRINT(c0, 0, c1, 3);
+	CP15_PRINT(c0, 0, c1, 4);
+	CP15_PRINT(c0, 0, c1, 5);
+	CP15_PRINT(c0, 0, c1, 6);
+	CP15_PRINT(c0, 0, c1, 7);
+    
+	CP15_PRINT(c0, 0, c2, 0);
+	CP15_PRINT(c0, 0, c2, 1);
+	CP15_PRINT(c0, 0, c2, 2);
+	CP15_PRINT(c0, 0, c2, 3);
+	CP15_PRINT(c0, 0, c2, 4);
+    
+	CP15_PRINT(c0, 1, c0, 0);
+	CP15_PRINT(c0, 1, c0, 1);
+	CP15_PRINT(c0, 1, c0, 7);
+	
+	CP15_PRINT(c0, 2, c0, 0);
+
+	CP15_PRINT(c1, 0, c0, 0);
+	CP15_PRINT(c1, 0, c0, 1);
+	CP15_PRINT(c1, 0, c0, 2);
+	CP15_PRINT(c1, 0, c1, 0);
+	CP15_PRINT(c1, 0, c1, 1);
+	CP15_PRINT(c1, 0, c1, 2);
+    CP15_PRINT(c1, 0, c1, 3);
+    
+	CP15_PRINT(c2, 0, c0, 0);
+	CP15_PRINT(c2, 0, c0, 1);
+	CP15_PRINT(c2, 0, c0, 2);
+    
+	CP15_PRINT(c3, 0, c0, 0);
+    
+	CP15_PRINT(c5, 0, c0, 0);
+	CP15_PRINT(c5, 0, c0, 1);
+	CP15_PRINT(c5, 0, c1, 0);
+	CP15_PRINT(c5, 0, c1, 1);
+    
+	CP15_PRINT(c6, 0, c0, 0);
+	CP15_PRINT(c6, 0, c0, 2);
+    
+	CP15_PRINT(c7, 0, c4, 0);
+    
+	CP15_PRINT(c10, 0, c0, 0);
+	CP15_PRINT(c10, 0, c2, 0);
+	CP15_PRINT(c10, 0, c2, 1);
+    
+	CP15_PRINT(c11, 0, c0, 0);
+	CP15_PRINT(c11, 0, c0, 2);
+	CP15_PRINT(c11, 0, c0, 4);
+	CP15_PRINT(c11, 0, c1, 0);
+	CP15_PRINT(c11, 0, c1, 1);
+    
+	CP15_PRINT(c12, 0, c0, 0);
+	CP15_PRINT(c12, 0, c0, 2);
+	CP15_PRINT(c12, 0, c1, 0);
+	CP15_PRINT(c12, 0, c1, 2);
+    
+	CP15_PRINT(c15, 0, c0, 0);
+	CP15_PRINT(c15, 0, c1, 0);
+	CP15_PRINT(c15, 4, c0, 0);
+	CP15_PRINT(c15, 5, c5, 2);
+	CP15_PRINT(c15, 5, c6, 2);
+	CP15_PRINT(c15, 5, c7, 2);
+}
+
+
+#endif
+
+void gdma0_transfer(u32 source, u32 dest, u32 size)
+{
+    u32 control = 0x2201;   // Singel Mode 4 byte 4 times  burst of 16 bytes.
+	
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x04) ) = source; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x08) ) = dest; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x0C) ) = size; 
+
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) = control; 
+   control |= 0x10000;
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) = control;
+  
+//   while ((*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) & (u32)0x10000 );
+
+}
+
+
+void gdma1_transfer(u32 source, u32 dest, u32 size)
+{
+    u32 control = 0x2201;   // Singel Mode 4 byte 4 times  burst of 16 bytes.
+	
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x24) ) = source; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x28) ) = dest; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x2C) ) = size; 
+
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) = control; 
+   control |= 0x10000;
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) = control;
+  
+//   while ((*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) & (u32)0x10000 );
+
+}
+
+
+void gdma_mem_test(u32 src_addr, u32 dst_addr, u32 chunk_size)
+{
+
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr);
+	printf("dst_addr 0x%x\n", dst_addr);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr, chunk_size, memtest_pattern);
+	
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr + 0x100000);
+	printf("dst_addr 0x%x\n", dst_addr + 0x100000);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr + 0x100000, chunk_size, memtest_pattern);
+
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr + 0x200000);
+	printf("dst_addr 0x%x\n", dst_addr + 0x200000);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr + 0x200000, chunk_size, memtest_pattern);
+	
+	gdma0_transfer(src_addr, dst_addr, chunk_size);
+	gdma1_transfer(src_addr + 0x100000, dst_addr + 0x100000, chunk_size);
+	my_memcpy(src_addr + 0x200000, dst_addr + 0x200000, chunk_size);
+
+    while ((*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) & (u32)0x10000 );   // GDMA0
+    while ((*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) & (u32)0x10000 );   // GDMA1
+
+	if(validate_memory(dst_addr + 0x200000, chunk_size, memtest_pattern))
+		puts("mem_mem_test failed\n");
+	else
+		puts("mem_mem_test success\n");
+
+	if(validate_memory(dst_addr + 0x100000, chunk_size, --memtest_pattern))
+		puts("gdma1_mem_test failed\n");
+	else
+		puts("gdma1_mem_test success\n");
+
+	if(validate_memory(dst_addr, chunk_size, --memtest_pattern))
+		puts("gdma0_mem_test failed\n");
+	else
+		puts("gdma0_mem_test success\n");
+}
+
+
 static int parse_argv(const char *);
 
+// Trego- We use function at arch/arm/cpu/armv7/cache_v7.c
 void __weak invalidate_icache_all(void)
 {
 	/* please define arch specific invalidate_icache_all */
@@ -46,6 +410,7 @@ static int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+// Trego- We use function at arch/arm/lib/cache.c
 void __weak flush_dcache_all(void)
 {
 	puts("No arch specific flush_dcache_all available!\n");
@@ -69,7 +434,7 @@ static int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 		break;
 	case 1:			/* get status */
-		printf("Data (writethrough) Cache is %s\n",
+		printf("Data (write-back) Cache is %s\n",
 			dcache_status() ? "ON" : "OFF");
 		return 0;
 	default:
@@ -90,7 +455,72 @@ static int parse_argv(const char *s)
 	return -1;
 }
 
+int do_icache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+
+    printf("I-Cache test not implemented \n");
+
+	return 0;
+}
+
+int do_dcache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+ 	test_basic_copy();
+	test_flush_d_range();
+	test_inval_d_range();
+	test_flush_d_all();
+	test_inval_d_all();
+	
+	return 0;
+}
+
+int do_cache_perf_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	test_basic_performance();
+
+	return 0;
+}
+
+int do_gdma_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 src, dst, size;
+
+
+	if (argc > 1)
+		src = simple_strtoul(argv[1], NULL, 16);
+	else
+		src = memtest_src_addr;
+
+	if (argc > 2)
+		dst = simple_strtoul(argv[2], NULL, 16);
+	else
+		dst = memtest_dst_addr;
+
+	if (argc > 3)
+		size = (ulong)simple_strtoul(argv[3], NULL, 16);
+	else
+		size = memtest_chunk_size;
+	
+	gdma_mem_test(src, dst, size);
+
+	return 0;
+}
 
+#if defined (NPCM750)               // Only Poleg
+int do_l2_cache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	l2_cache_test();
+
+	return 0;
+}
+
+int do_cp15_regs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cp15_regs();
+
+	return 0;
+}
+#endif
 U_BOOT_CMD(
 	icache,   2,   1,     do_icache,
 	"enable or disable instruction cache",
@@ -104,3 +534,40 @@ U_BOOT_CMD(
 	"[on, off, flush]\n"
 	"    - enable, disable, or flush data (writethrough) cache"
 );
+
+U_BOOT_CMD(
+	dcache_test,   1,   1,     do_dcache_test,
+	"D-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	icache_test,   1,   1,     do_icache_test,
+	"I-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	cache_perf_test,   1,   1,     do_cache_perf_test,
+	"Cache performance test",
+	""
+);
+ 
+U_BOOT_CMD(
+	gdma_test,   4,   1,     do_gdma_test,
+	"GDMA test",
+	"<source> <destination> <size>"
+);
+#if defined (NPCM750)               // Only Poleg
+U_BOOT_CMD(
+	l2_cache_test,   1,   1,     do_l2_cache_test,
+	"L2-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	cp15_regs,   1,   1,     do_cp15_regs,
+	"CP15-REG's read",
+	""
+);
+#endif
\ No newline at end of file
diff --git a/common/cmd_fuse.c b/common/cmd_fuse.c
old mode 100644
new mode 100755
index d4bc0f6..0d4cc9f
--- a/common/cmd_fuse.c
+++ b/common/cmd_fuse.c
@@ -44,7 +44,7 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	const char *op = argc >= 2 ? argv[1] : NULL;
 	int confirmed = argc >= 3 && !strcmp(argv[2], "-y");
-	u32 bank, word, cnt, val;
+	u32 bank, word, cnt, val=0;
 	int ret, i;
 
 	argc -= 2 + confirmed;
@@ -63,13 +63,13 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 		printf("Reading bank %u:\n", bank);
 		for (i = 0; i < cnt; i++, word++) {
 			if (!(i % 4))
-				printf("\nWord 0x%.8x:", word);
+				printf("\nWord %d:", word);
 
 			ret = fuse_read(bank, word, &val);
 			if (ret)
 				goto err;
 
-			printf(" %.8x", val);
+			printf(" 0x%.2x", val);
 		}
 		putc('\n');
 	} else if (!strcmp(op, "sense")) {
@@ -81,13 +81,13 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 		printf("Sensing bank %u:\n", bank);
 		for (i = 0; i < cnt; i++, word++) {
 			if (!(i % 4))
-				printf("\nWord 0x%.8x:", word);
+				printf("\nWord %d:", word);
 
 			ret = fuse_sense(bank, word, &val);
 			if (ret)
 				goto err;
 
-			printf(" %.8x", val);
+			printf(" %.2x", val);
 		}
 		putc('\n');
 	} else if (!strcmp(op, "prog")) {
@@ -98,7 +98,7 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 			if (strtou32(argv[i], 16, &val))
 				return CMD_RET_USAGE;
 
-			printf("Programming bank %u word 0x%.8x to 0x%.8x...\n",
+			printf("Programming bank %u word=%d val=0x%.2x...\n",
 					bank, word, val);
 			if (!confirmed && !confirm_prog())
 				return CMD_RET_FAILURE;
@@ -114,8 +114,8 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 			if (strtou32(argv[i], 16, &val))
 				return CMD_RET_USAGE;
 
-			printf("Overriding bank %u word 0x%.8x with "
-					"0x%.8x...\n", bank, word, val);
+			printf("Overriding bank %u word %d with "
+					"0x%.2x...\n", bank, word, val);
 			ret = fuse_override(bank, word, val);
 			if (ret)
 				goto err;
diff --git a/common/cmd_gmac.c b/common/cmd_gmac.c
new file mode 100755
index 0000000..d201ebf
--- /dev/null
+++ b/common/cmd_gmac.c
@@ -0,0 +1,604 @@
+#if 0
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   cmd_gmac.c                                                                                            */
+/*            This file contains GMAC test commands                                                        */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include <common.h>
+#include <command.h>
+#include <net.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+#include "BMC_HAL/Modules/gmac/Yarkon_IP/gmac_drv.h"
+
+#ifdef CONFIG_CMD_GMAC
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Sellecting GMAC port                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EMC_TYPE                0
+#define GMAC_TYPE               1
+
+#if     CONCAT2(ETH0_TYPE, _TYPE) == GMAC_TYPE
+    #define GMAC_TEST_PORT   0
+#elif   CONCAT2(ETH1_TYPE, _TYPE) == GMAC_TYPE
+    #define GMAC_TEST_PORT   1
+#else
+    #error GMAC Port was not defined!
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local defines                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GMAC_TEST_BUFFER_SIZE   128
+#define GMAC_TEST_BUFFER_NUM    1
+#define GMAC_TEST_SEED          0xFA462131
+
+#define GMAC_TEST_BUFF_WAITING  0
+#define GMAC_TEST_BUFF_SUCC     1
+#define GMAC_TEST_BUFF_FAIL     2
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local Variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+// For loopback test
+static UINT8 gmac_test_mac[] = {0x00, 0x16, 0x46 ,0x9d, 0xcc, 0xc3 };
+static UINT8 gmac_test_buffer[GMAC_TEST_BUFFER_NUM][GMAC_TEST_BUFFER_SIZE] = {{0}};
+static UINT8 gmac_test_sync  [GMAC_TEST_BUFFER_NUM] = {0};
+static UINT8 gmac_test_curbuf = 0;
+
+// for buffer test
+static UINT32 gmac_test_buff_ptr    = 0;
+static UINT32 gmac_test_buff_size   = 0;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ICMP stuff for PING                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    // Ethernet
+    UINT16  padding;
+
+    UINT8   mac_dest[6];
+    UINT8   mac_src[6];
+    UINT8   eth_type[2];
+
+    // IP
+    UINT8   ip_ver;
+    UINT8   ip_type;
+    UINT16  length;
+    UINT16  ip_id;
+    UINT16  ip_flags;
+    UINT8   ip_ttl;
+    UINT8   ip_protocol;
+    UINT16  ip_checksum;
+    UINT32  ip_addr_src;
+    UINT32  ip_addr_dest;
+
+    // ICMP
+    UINT8   icmp_type;
+    UINT8   icmp_code;
+    UINT16  icmp_checksum;
+    UINT16  icmp_ident;
+    UINT16  icmp_seq;
+}  ICMP_packet_t;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default ICMP ping request packet                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+ICMP_packet_t ICMP_packet =
+
+{
+    0x0000,
+
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},     // Dest MAC
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},     // Src MAC
+    {0x8,  0x0},                              // ETH type
+
+    0x45,    0x0,     0x1C00,
+    0x0100,          0x0040,
+    0xFF,    0x1,     0x0000,
+    0x00000000,
+    0x00000000,
+
+    0x8,     0x0,     0xFEF7,
+    0x0000,     0x0100,
+};
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Simple non-cryptographic random function implementation                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct rand_strct {UINT32 a; UINT32 b; UINT32 c; UINT32 d; } rand_device_t;
+#define rand_rot(x,k) (((x)<<(k))|((x)>>(32-(k))))
+
+UINT32 RandGet( rand_device_t *x )
+{
+    UINT32 e = x->a - rand_rot(x->b, 27);
+    x->a = x->b ^ rand_rot(x->c, 17);
+    x->b = x->c + x->d;
+    x->c = x->d + e;
+    x->d = e + x->a;
+    return x->d;
+}
+
+void RandInit( rand_device_t *x, UINT32 seed )
+{
+    UINT32 i;
+    x->a = 0xf1ea5eed, x->b = x->c = x->d = seed;
+    for (i=0; i<20; ++i)
+    {
+        RandGet(x);
+    }
+}
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_LoopbackCallback                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for loopback test                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtest_LoopbackCallback(UINT8* buffer, UINT32 size)
+{
+    UINT8 i = 0;
+
+    printf("Executing loopback test callback\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If size is different definetly something wrong                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (size != GMAC_TEST_BUFFER_SIZE)
+    {
+        gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_FAIL;
+
+        printf("GMAC buffer test: received buffer size (0x%lX) not much the expected (0x%X)", \
+                size, GMAC_TEST_BUFFER_SIZE);
+        return;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking the buffer content                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<size; ++i)
+    {
+        if (gmac_test_buffer[gmac_test_curbuf][i] != buffer[i])
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If buffer is different, we mark it as failure                                               */
+            /*---------------------------------------------------------------------------------------------*/
+            gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_FAIL;
+            return;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If everything is OK, we marked the buffer as succefull                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_SUCC;
+
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_bufferCallback                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for buffer send test                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtest_bufferCallback(UINT32* buffer, UINT32 size)
+{
+    UINT8 i = 0;
+
+    printf("Executing buffer test callback\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking buffer size                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (size != gmac_test_buff_size)
+    {
+        printf("GMAC buffer test: received buffer size (0x%lX) not much the expected (0x%lX)", \
+                size, gmac_test_buff_size);
+        return;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking the buffer content                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<size; ++i)
+    {
+        if (((UINT8*)gmac_test_buff_ptr)[i] != buffer[i])
+        {
+            printf("GMAC buffer test: received buffer element (0x%lX) not much the expected (0x%X) in offset %d", \
+                    buffer[i], ((UINT8*)gmac_test_buff_ptr)[i], i);
+            return;
+        }
+    }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_loopback                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  internal -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GMAC loopback test                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 GMACtest_loopback(BOOLEAN internal)
+{
+    UINT32         i = 0;
+    UINT32         j = 0;
+    rand_device_t  RandDevice;
+
+
+    printf("-----==== GMAC Loopback test ====-----\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing random device                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    RandInit(&RandDevice, GMAC_TEST_SEED);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing test buffers                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<GMAC_TEST_BUFFER_NUM; ++i)
+    {
+        gmac_test_sync[i] = GMAC_TEST_BUFF_WAITING;
+
+        for (j=0; j<GMAC_TEST_BUFFER_SIZE; ++j)
+        {
+           gmac_test_buffer[i][j] = RandGet(&RandDevice) & 0xFF;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing GMAC Driver                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Initialize(GMAC_TEST_PORT, TRUE, (ETH_Rx_Callback_t)GMACtest_LoopbackCallback, gmac_test_mac);
+
+    if (internal)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting internal loopback if needed                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_LoopbackInternalMode(GMAC_TEST_PORT, TRUE);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking loop                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<GMAC_TEST_BUFFER_NUM; ++i)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting current buffer                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        gmac_test_curbuf = i;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Sending the buffer to GMAC driver                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_Send(GMAC_TEST_PORT, &gmac_test_buffer[i], GMAC_TEST_BUFFER_SIZE);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Waiting for callback execution                                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        //while(gmac_test_sync[i] == GMAC_TEST_BUFF_WAITING);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Callback executed, checking the result                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (gmac_test_sync[i] == GMAC_TEST_BUFF_FAIL)
+        {
+            printf("Buffer %ld failed in verification\n", i);
+            return 1;
+        }
+    }
+
+
+    return 0;
+}
+
+
+UINT32 GMACtest_sendbuffer(void* buffer, UINT32 size, BOOLEAN internal)
+{
+    printf("-----==== GMAC Buffer test ====-----\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing GMAC Driver                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Initialize(GMAC_TEST_PORT, TRUE, (ETH_Rx_Callback_t)GMACtest_bufferCallback, gmac_test_mac);
+
+    if (internal)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting internal loopback if needed                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_LoopbackInternalMode(GMAC_TEST_PORT, TRUE);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting parapeters for the callback                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    gmac_test_buff_ptr  = (UINT32)buffer;
+    gmac_test_buff_size = size;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Sending the buffer to GMAC driver                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Send(GMAC_TEST_PORT, buffer, size);
+
+    return 0;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_getMAC                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  mac -                                                                                  */
+/*                  str -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine parse MAC string into MAC array                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static void GMACtest_getMAC(char* str, UINT8* mac)
+{
+    char *s;
+    char *e;
+    INT32 x;
+
+    s = str;
+
+    for (x = 0; x < 6; ++x)
+    {
+        mac[x] = (UINT32)simple_strtoul(s, &e, 16);
+
+        if (s)
+        {
+            s = (*e) ? e + 1 : e;
+        }
+    }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtes_ping_callback                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  data -                                                                                 */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for GMAC ping test                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtes_ping_callback(UINT32* data, UINT32 size)
+{
+    UINT32 i=0;
+    UINT8* d = (UINT8*)data;
+
+    printf("Returned Size = %ld Data=", size);
+    for (i=0; i<size; i++)
+    {
+        printf("0x%X ", d[i]);
+    }
+    printf("\n");
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtes_ping                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dest_ip -                                                                              */
+/*                  dest_mac -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GMAC ping test                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtes_ping(UINT32 dest_ip, UINT8* dest_mac)
+{
+    UINT32 i=0;
+    UINT8*  ptr;
+
+    GMAC_Initialize(0, TRUE, (ETH_Rx_Callback_t)GMACtes_ping_callback, gmac_test_mac);
+
+    // Setting MAC addresses
+    for (i=0; i<6; i++)
+    {
+        ICMP_packet.mac_dest[i] = dest_mac[i];
+        ICMP_packet.mac_src[i] = gmac_test_mac[i];
+    }
+
+    // Setting IP addresses
+    ICMP_packet.ip_addr_src     = 0xa00a8c0;
+    ICMP_packet.ip_addr_dest    = dest_ip;
+
+    // Setting Checksum
+    ICMP_packet.ip_checksum     = 0;
+    ICMP_packet.icmp_checksum   = 0;
+    ICMP_packet.ip_checksum     = ~NetCksum(((UINT8*)&ICMP_packet) + 14, 20 / 2);
+    ICMP_packet.icmp_checksum   = ~NetCksum(((UINT8*)&ICMP_packet) + 34, 8 / 2);
+
+
+    printf("Source IP=%lx, Dest IP= %lx\n",ICMP_packet.ip_addr_src, ICMP_packet.ip_addr_dest);
+    printf("Sending Data=");
+    ptr=(UINT8*)&ICMP_packet + 2;
+    for(i=0; i<sizeof(ICMP_packet)-2; ++i)
+    {
+        printf("0x%X ", ptr[i]);
+    }
+    printf("\n");
+
+    GMAC_Send(0, ((void*)&ICMP_packet) + 2, sizeof(ICMP_packet) - 2);
+
+
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        do_gmac                                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  argc -                                                                                 */
+/*                  argv -                                                                                 */
+/*                  cmdtp -                                                                                */
+/*                  flag -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main hadle for all GMAC commands                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+int do_gmac (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    UINT32 i=0;
+
+    for (i=0; i<argc; ++i)
+    {
+        printf("%ld: %s\n",i, argv[i]);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Loopback test                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!strcmp(argv[1], "lp"))
+    {
+        if (argc > 2)
+            if (!strcmp(argv[2], "int"))
+                return GMACtest_loopback(TRUE);
+
+        return GMACtest_loopback(FALSE);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Send buffer test                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else if (!strcmp(argv[1], "send_buffer"))
+    {
+        if (argc < 4)
+            return 1;
+        else if (argc < 5)
+                return GMACtest_sendbuffer((void*)simple_strtoul(argv[2], NULL, 16), \
+                                            simple_strtoul(argv[3], NULL, 16), FALSE);
+        else
+            return GMACtest_sendbuffer((void*)simple_strtoul(argv[2], NULL, 16), \
+                                        simple_strtoul(argv[3], NULL, 16), TRUE);
+
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Ping test                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else if (!strcmp(argv[1], "ping"))
+    {
+        if (argc < 5)
+        {
+            printf("Specify IP and MAC addresses\n");
+        }
+
+        UINT8   dest_mac[8];
+        UINT32  dest_ip;
+
+
+
+        dest_ip = string_to_ip(argv[2]);
+        GMACtest_getMAC(argv[3], dest_mac);
+
+        printf("IP=0x%lX MAC=", dest_ip);
+        for (i=0; i<6; i++)
+            printf("%X",dest_mac[i]);
+        printf("\n");
+
+        GMACtes_ping(dest_ip, dest_mac);
+
+
+    }
+
+    return 0;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Registering the command                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+U_BOOT_CMD(
+    gmac,  5,  1,  do_gmac,
+    "GMAC test command",
+    "<test_type> [test_param]\n\n"
+    "---------------------------------------------------------------------------|\n"
+    "| test_type  |    test_param(s)     |           Description                |\n"
+    "-------------+----------------------+--------------------------------------|\n"
+    "| lp         |     [ int ]          |                                      |\n"
+    "|            |                      | int       - using internal loopback  |\n"
+    "|            |                      | if empty  - using external loopback  |\n"
+    "| send_buffer| <ptr> <size> [ int ] |                                      |\n"
+    "|            |                      | ptr       - memory address of the    |\n"
+    "|            |                      |             buffer                   |\n"
+    "|            |                      | size      - buffer size              |\n"
+    "|            |                      | int       - using internal loopback  |\n"
+    "|            |                      | if empty  - using external loopback  |\n"
+    "| ping       | <ip>  <mac>          |                                      |\n"
+    "|            |                      | ip        - IP adress of destination |\n"
+    "|            |                      | mac       - MAC adress of destination|\n"
+    "---------------------------------------------------------------------------|\n"
+);
+
+
+#endif
+#endif   /* IF 0 */
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
old mode 100644
new mode 100755
index 43c3fb6..fa6b1ae
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -888,6 +888,13 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 	for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
 		WATCHDOG_RESET();
 		addr[offset] = pattern;
+		temp = addr[offset];
+        if (pattern != temp)
+        {
+			printf("\nFAILURE (write/read): @ 0x%.8lx:"
+				" expected 0x%.8lx, actual 0x%.8lx)\n",
+				((ulong)addr + offset*sizeof(vu_long)), pattern, temp);    
+        }
 	}
 
 	/*
@@ -897,10 +904,15 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 		WATCHDOG_RESET();
 		temp = addr[offset];
 		if (temp != pattern) {
-			printf("\nFAILURE (read/write) @ 0x%.8lx:"
-				" expected 0x%.8lx, actual 0x%.8lx)\n",
+			int i;
+			for (i=0; i<10; i++)
+			{
+				printf("\nFAILURE (read/write) @ 0x%.8lx:"
+					   " expected 0x%.8lx, actual 0x%.8lx)\n",
 				start_addr + offset*sizeof(vu_long),
 				pattern, temp);
+				temp = addr[offset];
+			}            
 			errs++;
 			if (ctrlc())
 				return -1;
@@ -917,11 +929,16 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 		WATCHDOG_RESET();
 		anti_pattern = ~pattern;
 		temp = addr[offset];
-		if (temp != anti_pattern) {
-			printf("\nFAILURE (read/write): @ 0x%.8lx:"
-				" expected 0x%.8lx, actual 0x%.8lx)\n",
+		if (temp != anti_pattern) { 
+			int i;
+			for (i=0; i<10; i++)
+			{
+				printf("\nFAILURE (read/write): @ 0x%.8lx:"
+					   " expected 0x%.8lx, actual 0x%.8lx)\n",
 				start_addr + offset*sizeof(vu_long),
 				anti_pattern, temp);
+				temp = addr[offset];
+			} 
 			errs++;
 			if (ctrlc())
 				return -1;
@@ -932,6 +949,7 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 	return 0;
 }
 
+
 static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 			    vu_long pattern, int iteration)
 {
@@ -940,6 +958,7 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 	ulong errs = 0;
 	ulong incr, length;
 	ulong val, readback;
+    ulong count_down;
 
 	/* Alternate the pattern */
 	incr = 1;
@@ -964,8 +983,16 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 		pattern, "");
 
 	for (addr = buf, val = pattern; addr < end; addr++) {
+        ulong read_val;
 		WATCHDOG_RESET();
 		*addr = val;
+        read_val = *addr;
+        if (val != read_val)
+        {
+            printf("\nWrite check fail @ 0x%.8lx: "
+		           "found 0x%.8lx, expected 0x%.8lx\n",
+		           (vu_long)addr, read_val, val);               
+        }
 		val += incr;
 	}
 
@@ -976,11 +1003,15 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 		readback = *addr;
 		if (readback != val) {
 			ulong offset = addr - buf;
-
-			printf("\nMem error @ 0x%08X: "
+           count_down=4;
+           while(count_down--)
+           {
+			    printf("\nMem error @ 0x%08X: "
 				"found %08lX, expected %08lX\n",
 				(uint)(uintptr_t)(start_addr + offset*sizeof(vu_long)),
 				readback, val);
+                readback = *addr;     
+           }
 			errs++;
 			if (ctrlc())
 				return -1;
diff --git a/common/cmd_rng.c b/common/cmd_rng.c
new file mode 100755
index 0000000..c421f84
--- /dev/null
+++ b/common/cmd_rng.c
@@ -0,0 +1,54 @@
+/*
+ * (C) Copyright 2016
+ *  Nuvoton Technology Corporation 
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * RNG Functions
+ *
+ */
+
+#include <stdlib.h>
+
+
+#include <common.h>
+#include <command.h>
+
+
+
+
+
+int do_rng(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned int ac, count, rand_num;
+
+	if (argc > 2)
+		return CMD_RET_USAGE;
+
+	ac = 1;
+    if (argc == 2)
+    {       
+	    ac = (unsigned int)simple_strtoul(argv[1], NULL, 10);
+	} 
+	
+	for (count = 0; count < ac; count++)	
+	{
+		rand_num = rand();	
+		printf("0x%x\n", rand_num);
+	}
+	
+	return 0;	
+		
+}
+
+
+U_BOOT_CMD(
+	rng,	2,	1,	do_rng,
+	"generate random number",
+	"[count]\n"
+		"    - generate [count] random numbers. count default is 1."
+);
+
+
diff --git a/common/cmd_sha256sum.c b/common/cmd_sha256sum.c
new file mode 100755
index 0000000..c079206
--- /dev/null
+++ b/common/cmd_sha256sum.c
@@ -0,0 +1,54 @@
+/*
+ * (C) Copyright 2011
+ * Joe Hershberger, National Instruments, joe.hershberger@ni.com
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <hash.h>
+#include <u-boot/sha256.h>
+
+int do_sha256sum(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int flags = HASH_FLAG_ENV;
+	int ac;
+	char * const *av;
+
+	if (argc < 3)
+		return CMD_RET_USAGE;
+
+	av = argv + 1;
+	ac = argc - 1;
+#ifdef CONFIG_SHA256SUM_VERIFY
+	if (strcmp(*av, "-v") == 0) {
+		flags |= HASH_FLAG_VERIFY;
+		av++;
+		ac--;
+	}
+#endif
+
+	return hash_command("sha256", flags, cmdtp, flag, ac, av);
+}
+
+#ifdef CONFIG_SHA256SUM_VERIFY
+U_BOOT_CMD(
+	sha256sum,	5,	1,	do_sha256sum,
+	"compute sha256 message digest",
+	"address count [[*]sum]\n"
+		"    - compute sha256 message digest [save to sum]\n"
+	"sha256sum -v address count [*]sum\n"
+		"    - verify sha256sum of memory area"
+);
+#else
+U_BOOT_CMD(
+	sha256sum,	4,	1,	do_sha256sum,
+	"compute sha256 message digest",
+	"address count [[*]sum]\n"
+		"    - compute sha256 message digest [save to sum]"
+);
+#endif
diff --git a/common/hash.c b/common/hash.c
old mode 100644
new mode 100755
index a1b0482..4b3312f
--- a/common/hash.c
+++ b/common/hash.c
@@ -30,6 +30,23 @@
 #include <u-boot/sha256.h>
 #include <u-boot/md5.h>
 
+
+#ifdef CONFIG_SHA_PROG_HW_ACCEL
+#include <hw_sha.h>
+#endif
+
+// use this to print last command runtime. Do not push to DENX. 
+#ifndef USE_HOSTCC
+#include "../include/configs/PolegSVB.h"
+extern void Tick(void);
+extern void Tock(void);
+#else // ifndef USE_HOSTCC
+#define Tick()
+#define Tock()
+#endif
+
+
+
 #ifdef CONFIG_SHA1
 static int hash_init_sha1(struct hash_algo *algo, void **ctxp)
 {
@@ -124,7 +141,8 @@ static struct hash_algo hash_algo[] = {
 	 */
 #ifdef CONFIG_SHA_HW_ACCEL
 	{
-		"sha1",
+		"hw_sha1",   //  NTIL: was "sha1". For testing, one might want to compile both HW and SW sha. use ">> hash hw_sha1 addr len"  or ">> hash sha1 addr len" on same build
+		              // on production leave only the "sha1" (will use hw always).
 		SHA1_SUM_LEN,
 		hw_sha1,
 		CHUNKSZ_SHA1,
@@ -134,7 +152,8 @@ static struct hash_algo hash_algo[] = {
 		hw_sha_finish,
 #endif
 	}, {
-		"sha256",
+		"hw_sha256",   //  NTIL: was "sha256". For testing, one might want to compile both HW and SW sha. use ">> hash hw_sha256 addr len"  or ">> hash sha256 addr len" on same build
+	                   // on production leave only the "sha256" (will use hw always).
 		SHA256_SUM_LEN,
 		hw_sha256,
 		CHUNKSZ_SHA256,
@@ -395,6 +414,8 @@ int hash_command(const char *algo_name, int flags, cmd_tbl_t *cmdtp, int flag,
 {
 	ulong addr, len;
 
+	printf("hash_command: hash algorithm '%s'\n", algo_name);
+
 	if ((argc < 2) || ((flags & HASH_FLAG_VERIFY) && (argc < 3)))
 		return CMD_RET_USAGE;
 
@@ -419,7 +440,11 @@ int hash_command(const char *algo_name, int flags, cmd_tbl_t *cmdtp, int flag,
 		}
 
 		buf = map_sysmem(addr, len);
+
+		Tick();
 		algo->hash_func_ws(buf, len, output, algo->chunk_size);
+		Tock();
+		
 		unmap_sysmem(buf);
 
 		/* Try to avoid code bloat when verify is not needed */
diff --git a/common/image-fit.c b/common/image-fit.c
old mode 100644
new mode 100755
index c531ee7..403cc5a
--- a/common/image-fit.c
+++ b/common/image-fit.c
@@ -27,6 +27,24 @@ DECLARE_GLOBAL_DATA_PTR;
 #include <u-boot/sha1.h>
 #include <u-boot/sha256.h>
 
+#ifdef CONFIG_SHA_PROG_HW_ACCEL
+#include <hw_sha.h>
+#endif
+
+
+// use this to print last command runtime. Do not push to DENX. 
+#ifndef USE_HOSTCC
+#include "../include/configs/PolegSVB.h"
+extern void Tick(void);
+extern void Tock(void);
+#else // ifndef USE_HOSTCC
+#define Tick()
+#define Tock()
+#endif
+
+
+
+
 /*****************************************************************************/
 /* New uImage format routines */
 /*****************************************************************************/
@@ -903,18 +921,31 @@ int fit_set_timestamp(void *fit, int noffset, time_t timestamp)
 int calculate_hash(const void *data, int data_len, const char *algo,
 			uint8_t *value, int *value_len)
 {
+    Tick();
+    printf(" calc hash addr 0x%lx size 0x%lx\n", (ulong)data, (ulong)data_len);
 	if (IMAGE_ENABLE_CRC32 && strcmp(algo, "crc32") == 0) {
 		*((uint32_t *)value) = crc32_wd(0, data, data_len,
 							CHUNKSZ_CRC32);
 		*((uint32_t *)value) = cpu_to_uimage(*((uint32_t *)value));
 		*value_len = 4;
 	} else if (IMAGE_ENABLE_SHA1 && strcmp(algo, "sha1") == 0) {
+
+#ifdef CONFIG_SHA_PROG_HW_ACCEL
+        hw_sha1((const uchar *)data, data_len, 
+                    (unsigned char *)value, CHUNKSZ_SHA1);
+#else	
 		sha1_csum_wd((unsigned char *)data, data_len,
 			     (unsigned char *)value, CHUNKSZ_SHA1);
+#endif			
 		*value_len = 20;
 	} else if (IMAGE_ENABLE_SHA256 && strcmp(algo, "sha256") == 0) {
+#ifdef CONFIG_SHA_PROG_HW_ACCEL
+        hw_sha256((const uchar *)data, data_len, 
+                    (unsigned char *)value, CHUNKSZ_SHA256);
+#else	
 		sha256_csum_wd((unsigned char *)data, data_len,
-			       (unsigned char *)value, CHUNKSZ_SHA256);
+			        (unsigned char *)value, CHUNKSZ_SHA256);
+#endif		       
 		*value_len = SHA256_SUM_LEN;
 	} else if (IMAGE_ENABLE_MD5 && strcmp(algo, "md5") == 0) {
 		md5_wd((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
@@ -923,6 +954,7 @@ int calculate_hash(const void *data, int data_len, const char *algo,
 		debug("Unsupported hash alogrithm\n");
 		return -1;
 	}
+	Tock();
 	return 0;
 }
 
diff --git a/configs/PolegSVB_defconfig b/configs/PolegSVB_defconfig
new file mode 100755
index 0000000..0d96e2e
--- /dev/null
+++ b/configs/PolegSVB_defconfig
@@ -0,0 +1,23 @@
+
+CONFIG_EXTRA_ENV_SETTINGS="fdtcontroladdr=0x8000\0"
+CONFIG_ARM=y
+CONFIG_TARGET_NPCM750=y
+CONFIG_SHA1=n
+CONFIG_SHA256=n
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_CONTROL=n
+CONFIG_OF_SEPARATE=n
+CONFIG_FIT_SIGNATURE=y
+CONFIG_RSA=y
+CONFIG_SHA_HW_ACCEL=y
+CONFIG_NUVOTON_SECURITY=y
+CONFIG_NUVOTON_POLEG_SHA=y
+CONFIG_NUVOTON_POLEG_RNG=y
+CONFIG_LIB_RAND=n
+CONFIG_FSL_CAAM=n
+CONFIG_SHA_PROG_HW_ACCEL=y
+CONFIG_DEFAULT_DEVICE_TREE="nuvoton-poleg"
+CONFIG_SHA256SUM_VERIFY=y
+
+
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
old mode 100644
new mode 100755
index 1ea116b..f6b70c4
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -2,4 +2,11 @@ menu "Hardware crypto devices"
 
 source drivers/crypto/fsl/Kconfig
 
+source drivers/crypto/nuvoton/Kconfig 
+
+config NUVOTON_SECURITY
+	bool "Nuvoton BMC - Hardware crypto device drivers"
+	help
+	  Enables Nuvoton Cryptographic HW accelerator.
+	  
 endmenu
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
old mode 100644
new mode 100755
index fb8c10b..a34bb33
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -8,3 +8,4 @@
 obj-$(CONFIG_EXYNOS_ACE_SHA)	+= ace_sha.o
 obj-y += rsa_mod_exp/
 obj-y += fsl/
+obj-$(CONFIG_NUVOTON_SECURITY)	+= nuvoton/
diff --git a/drivers/crypto/nuvoton/Kconfig b/drivers/crypto/nuvoton/Kconfig
new file mode 100755
index 0000000..9c1b542
--- /dev/null
+++ b/drivers/crypto/nuvoton/Kconfig
@@ -0,0 +1,10 @@
+config NUVOTON_POLEG_SHA
+    bool "Nuvoton BMC - Hardware crypto device drivers: SHA"
+	help
+	  Enables Nuvoton Cryptographic HW SHA accelerator.
+	  
+config NUVOTON_POLEG_RNG
+    bool "Nuvoton BMC - Hardware crypto device drivers: RNG"
+	help
+	  Enables Nuvoton Cryptographic HW RNG accelerator.
+	  
diff --git a/drivers/crypto/nuvoton/Makefile b/drivers/crypto/nuvoton/Makefile
new file mode 100755
index 0000000..dee40fe
--- /dev/null
+++ b/drivers/crypto/nuvoton/Makefile
@@ -0,0 +1,9 @@
+#---------------------------------------------------------------------------------------------------------#
+#	Nuvoton Technology Corporation Confidential 														  #
+#																										  #
+#	Copyright (c) 2016 by Nuvoton Technology Corporation	     										  #
+#	SPDX-License-Identifier:	GPL-2.0+																  #
+#---------------------------------------------------------------------------------------------------------#
+
+obj-$(CONFIG_NUVOTON_POLEG_SHA)	+= nuvoton_sha.o
+obj-$(CONFIG_NUVOTON_POLEG_RNG) += nuvoton_rng.o
\ No newline at end of file
diff --git a/drivers/crypto/nuvoton/nuvoton_rng.c b/drivers/crypto/nuvoton/nuvoton_rng.c
new file mode 100755
index 0000000..b39a141
--- /dev/null
+++ b/drivers/crypto/nuvoton/nuvoton_rng.c
@@ -0,0 +1,91 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*	Nuvoton Technology Corporation Confidential 														   */
+/*																										   */
+/*	Copyright (c)      2016 by Nuvoton Technology Corporation											   */
+/*	All rights reserved 																				   */
+/*																										   */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:																						   */
+/*	 nuvoton_rng.c																						   */
+/*			  This file contains HW IF to Nuvoton BMC RNG engine                				    	   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifdef CONFIG_NUVOTON_POLEG_RNG
+
+#include <common.h>
+#include <asm/io.h>
+#include "nuvoton_rng.h"
+
+//#define DEBUG_CMD     /* Comment when not needed */
+#ifdef DEBUG_CMD
+    #define DBG_MSG(f, x...)     printf(f, ## x)
+#else
+    #define DBG_MSG(f, x...)
+#endif
+
+
+static volatile nuvoton_bmc_rng *rng_dev = (nuvoton_bmc_rng *)RNG_BASE_ADDR;
+
+
+void poleg_rng_init(void)
+{
+    int init;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* check if rng  enabled                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    init = readb(&(rng_dev->RNGCS));
+    if ((init & RNG_ENABLE) == 0)
+    {
+        DBG_MSG("Nuvuton BMC init RNG mod\n");
+    	// init rng
+    	writeb(RNG_CLK_SET(RNG_CLKP_20_25_MHz) | RNG_ENABLE, &(rng_dev->RNGCS));
+    	writeb(RNGMODE_M1ROSEL,          &(rng_dev->RNGMODE));
+	}
+
+}
+
+
+void poleg_rng_disable(void)
+{
+    // disable rng
+	writeb(0, &(rng_dev->RNGCS));
+	writeb(0, &(rng_dev->RNGMODE));
+}
+
+
+void srand(unsigned int seed)
+{
+    /* no need to seed for now, TODO: revisit this*/
+	return;
+}
+
+
+unsigned int rand_r(unsigned int *seedp)
+{
+    int  i;
+    unsigned int ret_val = 0;
+
+    
+    poleg_rng_init();
+    
+	/* Wait for RNG done ( 4 bytes) */
+
+    for(i=0; i<4 ; i++){
+          while ((readb(&rng_dev->RNGCS ) & RNG_DATA_VALID) == 0); //wait until DVALID is set
+          ret_val |= (((unsigned int)readb(&rng_dev->RNGD) & 0x000000FF) << (i*8));
+    }
+
+	DBG_MSG("Nuvuton BMC RNG= 0x%lx\t\t", ret_val); 
+
+	return ret_val;
+}
+
+
+unsigned int rand(void)
+{
+	return rand_r(0);
+}
+
+
+#endif /* CONFIG_NUVOTON_POLEG_RNG */
diff --git a/drivers/crypto/nuvoton/nuvoton_rng.h b/drivers/crypto/nuvoton/nuvoton_rng.h
new file mode 100755
index 0000000..d858fe0
--- /dev/null
+++ b/drivers/crypto/nuvoton/nuvoton_rng.h
@@ -0,0 +1,86 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*	Nuvoton Technology Corporation Confidential 														   */
+/*																										   */
+/*	Copyright (c)      2016 by Nuvoton Technology Corporation											   */
+/*	All rights reserved 																				   */
+/*																										   */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:																						   */
+/*	 nuvoton_rng.h																						   */
+/*			  This file contains HW IF to nuvoton BMC RNG engine            							   */
+/*---------------------------------------------------------------------------------------------------------*/
+ 
+#ifndef __NUVOTON_NPCM750_RNG_H
+#define __NUVOTON_NPCM750_RNG_H
+
+
+#ifdef CONFIG_NUVOTON_POLEG_RNG
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RNG additional IF (rand, srand IF declared on common.h)                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void poleg_rng_init(void);
+void poleg_rng_disable(void);
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RNG registers                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RNG_BASE_ADDR            0xF000B000
+
+#pragma pack(1)
+typedef struct nuvoton_bmc_rng {
+	u32 RNGCS;
+	u32 RNGD;    
+	u32 RNGMODE; 
+} nuvoton_bmc_rng;
+#pragma pack()
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Core Domain Clock Frequency Range                                                                       */
+/* Core domain clock frequency range for the selected value is higher than or equal to the                 */
+/* actual Core domain clock frequency                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+    RNG_CLKP_80_100_MHz = 0x00, //default
+    RNG_CLKP_60_80_MHz  = 0x01,
+    RNG_CLKP_50_60_MHz  = 0x02,
+    RNG_CLKP_40_50_MHz  = 0x03,
+    RNG_CLKP_30_40_MHz  = 0x04,
+    RNG_CLKP_25_30_MHz  = 0x05,
+    RNG_CLKP_20_25_MHz  = 0x06, // recommended by poleg spec, match APB1. 
+    RNG_CLKP_5_20_MHz   = 0x07,  
+    RNG_CLKP_2_15_MHz   = 0x08,  
+    RNG_CLKP_9_12_MHz   = 0x09,  
+    RNG_CLKP_7_9_MHz    = 0x0A,   
+    RNG_CLKP_6_7_MHz    = 0x0B,   
+    RNG_CLKP_5_6_MHz    = 0x0C,   
+    RNG_CLKP_4_5_MHz    = 0x0D,   
+    RNG_CLKP_3_4_MHz    = 0x0E,   
+    RNG_NUM_OF_CLKP
+}RNG_CLKP_T;
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RNGCS register fields                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define RNG_CLK_SET(clkp)       (clkp << 2)    /* should be 20-25 MHz */
+#define RNG_DATA_VALID          (0x01 << 1)
+#define RNG_ENABLE              (0x01)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* RNGMODE register fields                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define  RNGMODE_M1ROSEL    (0x02 << 0)        /* 4-0 M1ROSEL (Ring Oscillator Select for Method I).                                                                    */
+
+
+#endif //  CONFIG_NUVOTON_POLEG_RNG
+
+#endif // __NUVOTON_NPCM750_RNG_H
diff --git a/drivers/crypto/nuvoton/nuvoton_sha.c b/drivers/crypto/nuvoton/nuvoton_sha.c
new file mode 100755
index 0000000..67f4c6b
--- /dev/null
+++ b/drivers/crypto/nuvoton/nuvoton_sha.c
@@ -0,0 +1,1264 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*	Nuvoton Technology Corporation Confidential 														   */
+/*																										   */
+/*	Copyright (c)      2016 by Nuvoton Technology Corporation											   */
+/*	All rights reserved 																				   */
+/*																										   */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:																						   */
+/*	 nuvoton_sha.c																						   */
+/*			  This file contains HW IF to Nuvoton BMC SHA SHA engine            				    	   */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#ifdef CONFIG_SHA_HW_ACCEL
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <mapmem.h>
+#include <hw_sha.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <config.h>
+
+
+#include <hash.h>
+#include <u-boot/crc.h>
+#include <u-boot/sha1.h>
+#include <u-boot/sha256.h>
+#include <u-boot/md5.h>
+
+
+#include "nuvoton_sha.h"
+
+ 
+// #define SHA_PRINT 1
+#define CONFIG_PARALLEL_SHA
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                       LOCAL FUNCTIONS DECLARATION                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+static void                             SHA_FlushLocalBuffer_l (const UINT32* buff);
+static int                              SHA_BusyWait_l (void);
+static void                             SHA_GetShaDigest_l (UINT8* hashDigest, SHA_TYPE_T shaType);
+static void                             SHA_SetShaDigest_l (const UINT32* hashDigest, SHA_TYPE_T shaType);
+static void                             SHA_SetBlock_l (const UINT8* data,UINT32 len, UINT16 position, UINT32* block);
+static void                             SHA_ClearBlock_l (UINT16 len, UINT16 position, UINT32* block);
+static void                             SHA_SetLength32_l (const SHA_HANDLE_T* handlePtr, UINT32* block);
+
+
+
+extern void Tick (void);
+extern void Tock (void);
+
+
+
+/*
+ *          static functions
+ */
+ 
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           TYPES & DEFINITIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define SHA_SECRUN_BUFF_SIZE            64
+#define SHA_TIMEOUT                     100
+#define SHA_DATA_LAST_BYTE              0x80
+// #define SHA_SET_TYPE(type)              SET_REG_FIELD(HASH_CFG, HASH_CFG_SHA1_SHA2, type)
+
+#define SHA_SET_TYPE(type)                                                                                        \
+         (type == SHA_TYPE_SHA2) ?                                                                                \
+            writeb(readb(&sha_dev->HASH_CFG) & ~HASH_CFG_SHA1_SHA2, &sha_dev->HASH_CFG)  :   \
+            writeb(readb(&sha_dev->HASH_CFG) | HASH_CFG_SHA1_SHA2, &sha_dev->HASH_CFG) 
+
+        
+#ifdef SHA_SELF_TEST
+#define SHA2_NUM_OF_SELF_TESTS          3
+#define SHA1_NUM_OF_SELF_TESTS          4
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_BUFF_POS                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  length - number of bytes written                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine compute the # of bytes currently in the sha block buffer                  */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_BUFF_POS(length)            (length & (SHA_BLOCK_LENGTH - 1))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_BUFF_FREE                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  length - number of bytes written                                                       */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine compute the # of free bytes in the sha block buffer                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_BUFF_FREE(length)           (SHA_BLOCK_LENGTH - SHA_BUFF_POS(length))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macro:           SHA_RET_CHECK                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  func    - function to check                                                            */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This macro checks if give function returns int error, and returns the error    */
+/*                  immediately after SHA disabling                                                        */
+/*                                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define SHA_RET_CHECK(func)                                         \
+{                                                                   \
+    int status;                                                     \
+                                                                    \
+    if ((status = func) != 0)                                       \
+    {                                                               \
+       DEFS_STATUS_RET_CHECK(SHA_Power(false));                     \
+       return status;                                               \
+    }                                                               \
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           INTERFACE FUNCTIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Calc                                                                               */
+/*                                                                                                         */
+/* Parameters:      shaType     - SHA module type                                                          */
+/*                  inBuff      -    Pointer to a buffer containing the data to be hashed                  */
+/*                  len         -    Length of the data to hash                                            */
+/*                  hashDigest  -   Pointer to a buffer where the reseulting digest will be copied to      */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs complete SHA calculation in one step including SHA_Init routine  */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Calc (SHA_TYPE_T shaType, const UINT8* inBuff, UINT32 len, UINT8* hashDigest);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:      handlePtr - SHA processing handle pointer                                              */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialize the SHA module                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Init (SHA_HANDLE_T* handlePtr);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Start                                                                              */
+/*                                                                                                         */
+/* Parameters:      handlePtr   - SHA processing handle pointer                                            */
+/*                  shaType     - SHA module type                                                          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine start a single SHA process                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Start (SHA_HANDLE_T* handlePtr, SHA_TYPE_T shaType);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Update                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  buffer -   Pointer to the data that will be added to the hash calculation              */
+/*                  len -      Length of data to add to SHA calculation                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine adds data to previously started SHA calculation                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Update (SHA_HANDLE_T* handlePtr, const UINT8* buffer, UINT32 len);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Finish                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  hashDigest -     Pointer to a buffer where the final digest will be copied to          */
+/*                                                                                                         */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine finish SHA calculation and get the resulting SHA digest                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Finish (SHA_HANDLE_T* handlePtr, UINT8* hashDigest);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reset SHA module                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Reset (void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Power                                                                              */
+/*                                                                                                         */
+/* Parameters:      on - TRUE enable the module, FALSE disable the module                                  */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set SHA module power on/off                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_Power (bool on);
+
+#ifdef SHA_PRINT
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintRegs                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module registers                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_PrintRegs (void);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintVersion                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module version                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_PrintVersion (void);
+#endif
+
+#ifdef SHA_SELF_TEST
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SelfTest                                                                           */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/* Returns:         DEFS_STATUS_OK on success or other int error code on error                             */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs various tests on the SHA HW and SW                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_SelfTest (SHA_TYPE_T shaType);
+#endif // SHA_SELF_TEST
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Static                                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+static SHA_HANDLE_T sha_handle;
+
+static volatile nuvoton_bmc_sha *sha_dev = (nuvoton_bmc_sha *)SHA_BASE_ADDR;
+
+
+
+
+
+
+/**
+ * Computes hash value of input pbuf using h/w acceleration
+ *
+ * @param in_addr	A pointer to the input buffer
+ * @param bufleni	Byte length of input buffer
+ * @param out_addr	A pointer to the output buffer. When complete
+ *			32 bytes are copied to pout[0]...pout[31]. Thus, a user
+ *			should allocate at least 32 bytes at pOut in advance.
+ * @param chunk_size	chunk size for sha256
+ */
+void hw_sha256(const uchar * in_addr, uint buflen,
+			uchar * out_addr, uint chunk_size)
+{
+    puts("\nhw_sha256 using BMC HW accelerator\t\t");
+    SHA_Calc(SHA_TYPE_SHA2, (UINT8 *)in_addr, buflen, (UINT8 *)out_addr); 
+    return;
+}
+
+/**
+ * Computes hash value of input pbuf using h/w acceleration
+ *
+ * @param in_addr	A pointer to the input buffer
+ * @param bufleni	Byte length of input buffer
+ * @param out_addr	A pointer to the output buffer. When complete
+ *			32 bytes are copied to pout[0]...pout[31]. Thus, a user
+ *			should allocate at least 32 bytes at pOut in advance.
+ * @param chunk_size	chunk_size for sha1
+ */
+void hw_sha1(const uchar * in_addr, uint buflen,
+			uchar * out_addr, uint chunk_size)
+{
+	puts("\nhw_sha1 using BMC HW accelerator\t\t");
+    SHA_Calc(SHA_TYPE_SHA1, (UINT8 *)in_addr, buflen, (UINT8 *)out_addr); 
+    return;
+}
+
+/*
+ * Create the context for sha progressive hashing using h/w acceleration
+ *
+ * @algo: Pointer to the hash_algo struct
+ * @ctxp: Pointer to the pointer of the context for hashing
+ * @return 0 if ok, -ve on error
+ */
+int hw_sha_init(struct hash_algo *algo, void **ctxp)
+{
+    return SHA_Init(&sha_handle);
+	
+}
+
+/*
+ * Update buffer for sha progressive hashing using h/w acceleration
+ *
+ * The context is freed by this function if an error occurs.
+ *
+ * @algo: Pointer to the hash_algo struct
+ * @ctx: Pointer to the context for hashing
+ * @buf: Pointer to the buffer being hashed
+ * @size: Size of the buffer being hashed
+ * @is_last: 1 if this is the last update; 0 otherwise
+ * @return 0 if ok, -ve on error
+ */
+int hw_sha_update(struct hash_algo *algo, void *ctx, const void *buf,
+		     unsigned int size, int is_last)
+{
+    return SHA_Update(&sha_handle, buf, size);
+}
+
+/*
+ * Copy sha hash result at destination location
+ *
+ * The context is freed after completion of hash operation or after an error.
+ *
+ * @algo: Pointer to the hash_algo struct
+ * @ctx: Pointer to the context for hashing
+ * @dest_buf: Pointer to the destination buffer where hash is to be copied
+ * @size: Size of the buffer being hashed
+ * @return 0 if ok, -ve on error
+ */
+int hw_sha_finish(struct hash_algo *algo, void *ctx, void *dest_buf,
+		     int size)
+{
+    return SHA_Finish(&sha_handle, dest_buf);
+}
+
+
+			
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                           INTERNAL  FUNCTIONS                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Calc                                                                               */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/*                  inBuff -    Pointer to a buffer containing the data to be hashed                       */
+/*                  len -    Length of the data to hash                                                    */
+/*                  hashDigest -   Pointer to a buffer where the reseulting digest will be copied to       */
+/*                                                                                                         */
+/* Returns:         0 on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs complete SHA calculation in one step                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Calc (
+    SHA_TYPE_T shaType,
+    const UINT8* inBuff,
+    UINT32 len,
+    UINT8* hashDigest
+)
+{
+    SHA_HANDLE_T handle;
+
+    DEFS_STATUS_RET_CHECK(SHA_Init(&handle));
+    DEFS_STATUS_RET_CHECK(SHA_Power(TRUE));
+    SHA_RET_CHECK(SHA_Reset());
+    SHA_RET_CHECK(SHA_Start(&handle, shaType));
+    SHA_RET_CHECK(SHA_Update(&handle, inBuff, len));
+    SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+#ifndef CONFIG_PARALLEL_SHA
+    SHA_GetShaDigest_l(hashDigest, shaType);
+#endif // CONFIG_PARALLEL_SHA   
+    DEFS_STATUS_RET_CHECK(SHA_Power(false));
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Init                                                                               */
+/*                                                                                                         */
+/* Parameters:      handlePtr - SHA processing handle pointer                                              */
+/* Returns:         0 on success or other int error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine initialize the SHA module                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Init (SHA_HANDLE_T* handlePtr)
+{
+    handlePtr->active = false;
+
+    // SHA_PrintVersion();
+
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Start                                                                              */
+/*                                                                                                         */
+/* Parameters:      handlePtr   - SHA processing handle pointer                                            */
+/*                  shaType     - SHA module type                                                          */
+/*                                                                                                         */
+/* Returns:         0 on success or other int error code on error.                    */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine start a single SHA process                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Start (
+    SHA_HANDLE_T* handlePtr,
+    SHA_TYPE_T shaType
+)
+{
+    UINT16 l;
+
+    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initialize handle                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    handlePtr->length0 = 0;
+    handlePtr->length1 = 0;
+    handlePtr->shaType = shaType;
+    handlePtr->active = TRUE;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reset SHA hardware                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // SET_REG_FIELD(HASH_CTR_STS, HASH_CTR_STS_SHA_RST, 0x01);
+    SHA_Reset();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The handlePtr->hv is initialized with the correct IV as the SHA engine automaticly                  */
+    /* fill the HASH_DIG_Hn registers according to SHA spec (following SHA_RST assertion)                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l((UINT8*)handlePtr->hv, shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Init block with zeros                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(l = 0 ; l < (SHA_BLOCK_LENGTH / sizeof(UINT32)); l++)
+    {
+        handlePtr->block[l] = 0;
+    }
+
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Update                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  buffer -   Pointer to the data that will be added to the hash calculation              */
+/*                  len -      Length of data to add to SHA calculation                                    */
+/*                                                                                                         */
+/*                                                                                                         */
+/* Returns:         0 on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine adds data to previously started SHA calculation                           */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Update (
+    SHA_HANDLE_T* handlePtr,
+    const UINT8* buffer,
+    UINT32 len
+)
+{
+#ifdef CONFIG_PARALLEL_SHA
+    UINT32 localBuffer[SHA_SECRUN_BUFF_SIZE / sizeof(UINT32)];
+	UINT8* blockPtr;
+#else
+		UINT32 i;
+	UINT8  len_sha_block = ((handlePtr->shaType == SHA_TYPE_SHA2) ? SHA_BLOCK_LENGTH : 10);
+	
+#endif
+    UINT32 bufferLen          = len;
+    UINT32 pos                = 0;
+    
+	
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error check                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_COND_CHECK(handlePtr->active == TRUE, DEFS_STATUS_SYSTEM_NOT_INITIALIZED);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set SHA type                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SET_TYPE(handlePtr->shaType);
+
+    // SHA_PrintRegs();
+
+    
+#ifdef CONFIG_PARALLEL_SHA    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Write SHA latest digest into SHA module                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetShaDigest_l(handlePtr->hv, handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set number of unhashed bytes which remained from last update                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    pos = SHA_BUFF_POS(handlePtr->length0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Copy unhashed bytes which remained from last update to secrun buffer                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l((UINT8*)handlePtr->block, pos, 0, localBuffer);
+
+    while (len)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Wait for the hardware to be available (in case we are hashing)                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Move as much bytes  as we can into the secrun buffer                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        bufferLen = (len < SHA_BUFF_FREE(handlePtr->length0)) ? len : SHA_BUFF_FREE(handlePtr->length0);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Copy current given buffer to the secrun buffer                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_SetBlock_l((UINT8*)buffer, bufferLen, pos, localBuffer);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update size of hashed bytes                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        handlePtr->length0 += bufferLen;
+
+        if ((handlePtr->length0) < bufferLen)
+        {
+            handlePtr->length1++;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update length of data left to digest                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        len -= bufferLen;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update given buffer pointer                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        buffer += bufferLen;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If secrun buffer is full                                                                        */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (SHA_BUFF_POS(handlePtr->length0) == 0)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* We just filled up the buffer perfectly, so let it hash                                      */
+            /* (we'll unload the hash only when we are done with all hashing)                              */
+            /*---------------------------------------------------------------------------------------------*/
+            SHA_FlushLocalBuffer_l(localBuffer);
+
+            pos = 0;
+            bufferLen = 0;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Copy unhashed bytes from given buffer to handle block for next update/finish                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    blockPtr = (UINT8*)handlePtr->block;
+    while (bufferLen)
+    {
+        blockPtr[--bufferLen+pos] = *(--buffer);
+    }
+	
+	
+#else
+	
+	pos = 0;
+
+	while (len)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Move as much bytes  as we can into the secrun buffer                                            */
+        /*-------------------------------------------------------------------------------------------------*/    
+        bufferLen = (len < len_sha_block) ? len : len_sha_block;
+		
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Copy current given buffer to the secrun buffer                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+		for(i = 0; i < bufferLen; i+=4)
+		{
+			writel ( *(UINT32*)(buffer+pos + i) , &sha_dev->HASH_DATA_IN); 
+			//printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n",
+			//	(UINT32*)(buffer+pos + i), pos , bufferLen, *(UINT32*)(buffer+pos + i));
+		}
+		if ( len < len_sha_block)
+		{
+			for(i = len; i < bufferLen; i+=4)
+			{
+				writel ( 0 , &sha_dev->HASH_DATA_IN); 
+			}
+		}
+		
+#if SHA_TRY_OPTIMIZE	
+		i= 0;	
+		if ( bufferLen == len_sha_block)
+		{
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+    		writel ( *(UINT32*)(buffer+pos + 4*i++) , &sha_dev->HASH_DATA_IN);  //  printf("buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n", (UINT32*)(buffer+pos + 4*i), pos , bufferLen, *(UINT32*)(buffer+pos + 4*i)); 
+		}
+		else 
+		{
+			for(i = 0; i < bufferLen; i+=4)
+			{
+		    	writel ( *(UINT32*)(buffer+pos + i) , &sha_dev->HASH_DATA_IN); 
+		    	printf("for loop buffer = 0x%x, pos = %x, bufferLen= %x, data = 0x%x\n",
+		    		(UINT32*)(buffer+pos + i), pos , bufferLen, *(UINT32*)(buffer+pos + i));
+		    }
+		}
+#endif // SHA_TRY_OPTIMIZE
+		
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Update length of data left to digest                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        len -= bufferLen;
+		pos += bufferLen;
+
+		/*-------------------------------------------------------------------------------------------------*/
+        /* Update size of hashed bytes                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        handlePtr->length0 += bufferLen;
+
+        if ((handlePtr->length0) < bufferLen)
+        {
+            handlePtr->length1++;
+        }
+
+        
+        /*-----------------------------------------------------------------------------------------------------*/
+        /* Wait till SHA is not busy                                                                           */
+        /*-----------------------------------------------------------------------------------------------------*/
+        // DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+        while((readb(&(sha_dev->HASH_CTR_STS)) & 0x02) == 0x02); 
+
+        
+	
+	}
+		
+#endif		
+
+
+    // SHA_PrintRegs();
+    
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Save SHA current digest                                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l((UINT8*)handlePtr->hv, handlePtr->shaType);
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Finish                                                                             */
+/*                                                                                                         */
+/* Parameters:      handlePtr  -   SHA processing handle pointer                                           */
+/*                  hashDigest -     Pointer to a buffer where the final digest will be copied to          */
+/*                                                                                                         */
+/* Returns:         0 on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine finish SHA calculation and get the resulting SHA digest                   */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Finish (
+    SHA_HANDLE_T* handlePtr,
+    UINT8* hashDigest
+
+)
+{
+    UINT32 localBuffer[SHA_SECRUN_BUFF_SIZE / sizeof(UINT32)];
+    const UINT8 lastbyte = SHA_DATA_LAST_BYTE;
+    UINT16 pos;
+
+    //SHA_PrintRegs();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Error check                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_COND_CHECK(handlePtr->active == TRUE, DEFS_STATUS_SYSTEM_NOT_INITIALIZED);
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set SHA type                                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SET_TYPE(handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Finish off the current buffer with the SHA spec'ed padding                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    pos = SHA_BUFF_POS(handlePtr->length0);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Init SHA digest                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetShaDigest_l(handlePtr->hv, handlePtr->shaType);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Load data into secrun buffer                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l((UINT8*)handlePtr->block, pos, 0, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set data last byte as in SHA algorithm spec                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetBlock_l(&lastbyte, 1, pos++, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If the remainder of data is longer then one block                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (pos > (SHA_BLOCK_LENGTH - 8))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* The message length will be in the next block                                                    */
+        /* Pad the rest of the last block with 0's                                                         */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_ClearBlock_l((SHA_BLOCK_LENGTH - pos), pos, localBuffer);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Hash the current block                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        SHA_FlushLocalBuffer_l(localBuffer);
+
+        pos = 0;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Wait till SHA is not busy                                                                       */
+        /*-------------------------------------------------------------------------------------------------*/
+        DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Pad the rest of the last block with 0's except for the last 8-3 bytes                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_ClearBlock_l((SHA_BLOCK_LENGTH-(8-3))-pos, pos, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* The last 8-3 bytes are set to the bit-length of the message in big-endian form                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_SetLength32_l(handlePtr, localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Hash all that, and save the hash for the caller                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_FlushLocalBuffer_l(localBuffer);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait till SHA is not busy                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    DEFS_STATUS_RET_CHECK(SHA_BusyWait_l());
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Save SHA final digest into given buffer                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SHA_GetShaDigest_l(hashDigest, handlePtr->shaType);
+
+	// SHA_PrintRegs();
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Free handle                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    handlePtr->active = false;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Reset                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reset SHA module                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Reset (void)
+{
+    writeb ( readb(&(sha_dev->HASH_CTR_STS)) | HASH_CTR_STS_SHA_RST, &(sha_dev->HASH_CTR_STS));
+
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_Power                                                                              */
+/*                                                                                                         */
+/* Parameters:      on - TRUE enable the module, false disable the module                                  */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine set SHA module power on/off                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_Power (bool on)
+{
+    if ( on == true)
+        writeb ( readb(&(sha_dev->HASH_CTR_STS)) | HASH_CTR_STS_SHA_EN, &(sha_dev->HASH_CTR_STS));
+    else
+        writeb ( readb(&(sha_dev->HASH_CTR_STS)) & ~HASH_CTR_STS_SHA_EN, &(sha_dev->HASH_CTR_STS));
+    
+    return 0;
+}
+
+#ifdef SHA_PRINT
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintRegs                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module registers                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintRegs (void)
+{
+    UINT i;
+
+    printf("/*--------------*/\n");
+    printf("/*     SHA      */\n");
+    printf("/*--------------*/\n\n");
+
+    printf("HASH_CTR_STS        = 0x%02X\n", readb(&sha_dev->HASH_CTR_STS));
+    printf("HASH_CFG            = 0x%02X\n", readb(&sha_dev->HASH_CFG));
+
+    for (i = 0; i < HASH_DIG_H_NUM; i++)
+    {
+        printf("HASH_DIG_H%d         = 0x%08X\n", i, readl(&sha_dev->HASH_DIG_H[i]));
+    }
+
+    printf("\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_PrintVersion                                                                       */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints the module version                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void SHA_PrintVersion (void)
+{
+    printf("SHA MODULE VER  = %d\n", readb(&sha_dev->HASH_VER));
+}
+#endif
+
+#ifdef SHA_SELF_TEST
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SelfTest                                                                           */
+/*                                                                                                         */
+/* Parameters:      shaType - SHA module type                                                              */
+/* Returns:         0 on success or other int error code on error                     */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs various tests on the SHA HW and SW                               */
+/*---------------------------------------------------------------------------------------------------------*/
+int SHA_SelfTest (SHA_TYPE_T shaType)
+{
+    SHA_HANDLE_T handle;
+    UINT8 hashDigest[MAX(SHA_1_HASH_LENGTH, SHA_2_HASH_LENGTH)];
+    UINT8 i;
+    UINT16 j;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA1 tests info                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    static const UINT8 sha1SelfTestBuff[SHA1_NUM_OF_SELF_TESTS][94] =
+    {
+        {"abc"},
+        {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"},
+        {"0123456789012345678901234567890123456789012345678901234567890123"},
+        {0x30, 0x5c, 0x30, 0x2c, 0x02, 0x01, 0x00, 0x30, 0x09, 0x06, 0x05, 0x2b,
+         0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x30, 0x06, 0x06, 0x04, 0x67, 0x2a,
+         0x01, 0x0c, 0x04, 0x14, 0xe1, 0xb6, 0x93, 0xfe, 0x33, 0x43, 0xc1, 0x20,
+         0x5d, 0x4b, 0xaa, 0xb8, 0x63, 0xfb, 0xcf, 0x6c, 0x46, 0x1e, 0x88, 0x04,
+         0x30, 0x2c, 0x02, 0x01, 0x00, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03,
+         0x02, 0x1a, 0x05, 0x00, 0x30, 0x06, 0x06, 0x04, 0x67, 0x2a, 0x01, 0x0c,
+         0x04, 0x14, 0x13, 0xc1, 0x0c, 0xfc, 0xc8, 0x92, 0xd7, 0xde, 0x07, 0x1c,
+         0x40, 0xde, 0x4f, 0xcd, 0x07, 0x5b, 0x68, 0x20, 0x5a, 0x6c}
+    };
+
+    static const UINT8 sha1SelfTestBuffLen[SHA1_NUM_OF_SELF_TESTS] =
+    {
+        3, 56, 64, 94
+    };
+    static const UINT8 sha1SelfTestExpRes[SHA1_NUM_OF_SELF_TESTS][SHA_1_HASH_LENGTH] =
+    {
+        {0xA9, 0x99, 0x3E, 0x36,
+         0x47, 0x06, 0x81, 0x6A,
+         0xBA, 0x3E, 0x25, 0x71,
+         0x78, 0x50, 0xC2, 0x6C,
+         0x9C, 0xD0, 0xD8, 0x9D},
+        {0x84, 0x98, 0x3E, 0x44,
+         0x1C, 0x3B, 0xD2, 0x6E,
+         0xBA, 0xAE, 0x4A, 0xA1,
+         0xF9, 0x51, 0x29, 0xE5,
+         0xE5, 0x46, 0x70, 0xF1},
+        {0xCF, 0x08, 0x00, 0xF7,
+         0x64, 0x4A, 0xCE, 0x3C,
+         0xB4, 0xC3, 0xFA, 0x33,
+         0x38, 0x8D, 0x3B, 0xA0,
+         0xEA, 0x3C, 0x8B, 0x6E},
+        {0xc9, 0x84, 0x45, 0xc8,
+         0x64, 0x04, 0xb1, 0xe3,
+         0x3c, 0x6b, 0x0a, 0x8c,
+         0x8b, 0x80, 0x94, 0xfc,
+         0xf3, 0xc9, 0x98, 0xab}
+    };
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA2 tests info                                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    static const UINT8 sha2SelfTestBuff[SHA2_NUM_OF_SELF_TESTS][100] =
+    {
+        { "abc" },
+        { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
+        {'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a',
+         'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a'}
+    };
+
+    static const UINT8 sha2SelfTestBuffLen[SHA2_NUM_OF_SELF_TESTS] =
+    {
+        3, 56, 100
+    };
+
+    static const UINT8 sha2SelfTestExpRes[SHA2_NUM_OF_SELF_TESTS][SHA_2_HASH_LENGTH] =
+    {
+        /*
+         * SHA-256 test vectors
+         */
+        { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
+          0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
+          0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
+          0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
+        { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
+          0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
+          0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
+          0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
+        { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
+          0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
+          0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
+          0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
+    };
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA 1 TESTS                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (shaType == SHA_TYPE_SHA1)
+    {
+        for(i = 0; i < SHA1_NUM_OF_SELF_TESTS; i++)
+        {
+            if (i != 3)
+            {
+                DEFS_STATUS_RET_CHECK(SHA_Calc(SHA_TYPE_SHA1, sha1SelfTestBuff[i], sha1SelfTestBuffLen[i], hashDigest));
+            }
+            else
+            {
+                SHA_Power(TRUE);
+                SHA_Reset();
+                SHA_RET_CHECK(SHA_Start(&handle, SHA_TYPE_SHA1));
+                SHA_RET_CHECK(SHA_Update(&handle, sha1SelfTestBuff[i],73));
+                SHA_RET_CHECK(SHA_Update(&handle, &(sha1SelfTestBuff[i][73]),sha1SelfTestBuffLen[i] - 73));
+                SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+                SHA_Power(false);
+            }
+            if (memcmp(hashDigest, sha1SelfTestExpRes[i], SHA_1_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+        }
+
+    }
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SHA 2 TESTS                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        for( i = 0; i < SHA2_NUM_OF_SELF_TESTS; i++ )
+        {
+            SHA_Power(TRUE);
+            SHA_Reset();
+            SHA_RET_CHECK(SHA_Start(&handle, SHA_TYPE_SHA2));
+            if( i == 2 )
+            {
+                for( j = 0; j < 10000; j++ )//not working
+                {
+                    SHA_RET_CHECK(SHA_Update(&handle, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i]));
+                }
+            }
+            else
+            {
+                SHA_RET_CHECK(SHA_Update(&handle, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i]));
+            }
+
+            SHA_RET_CHECK(SHA_Finish(&handle, hashDigest));
+            SHA_Power(false);
+            if(memcmp(hashDigest, sha2SelfTestExpRes[i], SHA_2_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+
+            SHA_Calc(SHA_TYPE_SHA2, sha2SelfTestBuff[i], sha2SelfTestBuffLen[i], hashDigest);
+            if(memcmp(hashDigest, sha2SelfTestExpRes[i], SHA_2_HASH_LENGTH))
+            {
+                return DEFS_STATUS_FAIL;
+            }
+        }
+    }
+    return 0;
+}
+#endif //SHA_SELF_TEST
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                             LOCAL FUNCTIONS                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_FlushLocalBuffer_l                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine flush secrun buffer to SHA module                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_FlushLocalBuffer_l (const UINT32* buff)
+{
+    UINT i;
+
+    for(i = 0; i < (SHA_BLOCK_LENGTH / sizeof(UINT32)); i++)
+    {
+        writel ( buff[i] , &sha_dev->HASH_DATA_IN);    
+    }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_BusyWait_l                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/* Returns:         0 if no error was found or DEFS_STATUS_ERROR otherwise                    */
+/* Side effects:                                                                                           */
+/* Description:     This routine wait for SHA unit to no longer be busy                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static int SHA_BusyWait_l (void)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* While SHA module is busy                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    UINT32 __time = SHA_TIMEOUT;                       
+                                                   
+    do                                             
+    {                                              
+        if (__time-- == 0)                         
+        {                                          
+            return -(ETIMEDOUT);   
+        }                                          
+    } while ((readb(&(sha_dev->HASH_CTR_STS)) & 0x02) == 0x02);                           
+     
+    return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_GetShaDigest_l                                                                     */
+/*                                                                                                         */
+/* Parameters:      hashDigest - buffer for the hash output.                                               */
+/*                  shaType - SHA module type                                                              */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine copy the hash digest from the hardware and into given buffer( in ram)     */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_GetShaDigest_l(
+    UINT8* hashDigest,
+    SHA_TYPE_T shaType
+)
+{
+  UINT16 j;
+  UINT32* src =     (UINT32 *)(&sha_dev->HASH_DIG_H[0]);
+  UINT32* dest =    (UINT32 *)(void*)hashDigest;
+  UINT8 len = ((shaType == SHA_TYPE_SHA2) ? SHA_2_HASH_LENGTH : SHA_1_HASH_LENGTH) / sizeof(UINT32);
+
+  /*-------------------------------------------------------------------------------------------------------*/
+  /* Copy Bytes from SHA module to given buffer                                                            */
+  /*-------------------------------------------------------------------------------------------------------*/
+  for (j = 0; j < len; j++)
+  {
+    writel(src[j], &dest[j]);
+  }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetShaDigest_l                                                                     */
+/*                                                                                                         */
+/* Parameters:      hashDigest - input buffer to set as hash digest(in SHA module).                        */
+/*                  shaType - SHA module type                                                              */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine set the hash digest in the hardware from a given buffer( in ram)          */
+/*---------------------------------------------------------------------------------------------------------*/
+static  void SHA_SetShaDigest_l(
+    const UINT32* hashDigest,
+    SHA_TYPE_T shaType
+)
+{
+  UINT16 j;
+  volatile UINT32* dest = &(sha_dev->HASH_DIG_H[0]);
+  UINT8 len = ((shaType == SHA_TYPE_SHA2) ? SHA_2_HASH_LENGTH : SHA_1_HASH_LENGTH) / sizeof(UINT32);
+
+  /*-------------------------------------------------------------------------------------------------------*/
+  /* Copy Bytes from given buffer to SHA module                                                            */
+  /*-------------------------------------------------------------------------------------------------------*/
+  for (j = 0; j < len; j++)
+  {
+    writel( hashDigest[j], &dest[j]);
+  }
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetBlock_l                                                                         */
+/*                                                                                                         */
+/* Parameters:      data        - data to copy                                                             */
+/*                  len         -  size of data                                                            */
+/*                  position    - byte offset into the block at which data should be placed                */
+/*                  block       - block buffer                                                             */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine load bytes into block buffer                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_SetBlock_l(const UINT8* data,UINT32 len, UINT16 position, UINT32* block)
+{
+    UINT8 * dest = (UINT8*)block;
+    memcpy(dest + position, data, len);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetBlock_l                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  len -  size of data                                                                    */
+/*                  position - byte offset into the block at which data should be placed                   */
+/*                  block - block buffer                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine load zero's into the block buffer                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_ClearBlock_l (
+    UINT16 len,
+    UINT16 position,
+    UINT32* block
+)
+{
+    UINT8 * dest = (UINT8*)block;
+    memset(dest + position, 0, len);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        SHA_SetLength32_l                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  handlePtr  -   SHA processing handle pointer                                           */
+/*                  block - block buffer                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:     This routine set the length of the hash's data                                         */
+/*                  len is the 32-bit byte length of the message                                           */
+/*lint -efunc(734,SHA_SetLength32_l) Supperess loss of percision lint warning                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static void SHA_SetLength32_l (const SHA_HANDLE_T* handlePtr, UINT32* block)
+{
+  UINT16*       secrunBufferSwappedPtr = (UINT16*)(void*)(block);
+
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 1] = (UINT16)
+        ((handlePtr->length0 << 3) << 8) | ((UINT16) (handlePtr->length0 << 3) >> 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 2] = (UINT16)
+        ((handlePtr->length0 >> (16-3)) >> 8) | ((UINT16) (handlePtr->length0 >> (16-3)) << 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 3] = (UINT16)
+    ((handlePtr->length1 << 3) << 8) | ((UINT16) (handlePtr->length1 << 3) >> 8);
+  secrunBufferSwappedPtr[(SHA_BLOCK_LENGTH/sizeof(UINT16)) - 4] = (UINT16)
+    ((handlePtr->length1 >> (16-3)) >> 8) | ((UINT16) (handlePtr->length1 >> (16-3)) << 8);
+}
+ 		 	
+#endif /* CONFIG_SHA_HW_ACCEL */
+
+
+
+
diff --git a/drivers/crypto/nuvoton/nuvoton_sha.h b/drivers/crypto/nuvoton/nuvoton_sha.h
new file mode 100755
index 0000000..0574a73
--- /dev/null
+++ b/drivers/crypto/nuvoton/nuvoton_sha.h
@@ -0,0 +1,103 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*	Nuvoton Technology Corporation Confidential 														   */
+/*																										   */
+/*	Copyright (c)      2016 by Nuvoton Technology Corporation											   */
+/*	All rights reserved 																				   */
+/*																										   */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:																						   */
+/*	 nuvoton_sha.h																						   */
+/*			  This file contains HW IF to nuvoton BMC SHA engine            							   */
+/*---------------------------------------------------------------------------------------------------------*/
+ 
+
+
+#ifndef __NUVOTON_NPCM750_SHA_H
+#define __NUVOTON_NPCM750_SHA_H
+
+
+#define SHA_PHYS_BASE_ADDR       0xF085A000
+#define SHA_BASE_ADDR            SHA_PHYS_BASE_ADDR
+
+#if 1
+#define padding(name,size)    __pad_##name##_[size]
+#pragma pack(1)
+typedef struct nuvoton_bmc_sha {
+	u32 HASH_DATA_IN;
+	u8  HASH_CTR_STS;       u8 padding(HASH_CTR_STS,3);
+	u8  HASH_CFG;           u8 padding(HASH_CFG,3); 
+	u8  HASH_VER;           u8 padding(HASH_VER,3);
+	u32 reserved[4];
+	u32 HASH_DIG_H[8];
+} nuvoton_bmc_sha;
+#pragma pack()
+#undef padding
+
+
+#else
+#define HASH_DATA_IN            (SHA_BASE_ADDR + 0x000)            
+#define HASH_CTR_STS            (SHA_BASE_ADDR + 0x004)            
+#define HASH_CFG                (SHA_BASE_ADDR + 0x008)            
+#define HASH_VER                (SHA_BASE_ADDR + 0x00C)            
+#define HASH_DIG_H(i)           (SHA_BASE_ADDR + 0x020 + (4 * i))  
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_CTR_STS fields                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_CTR_STS_SHA_EN     (1 << 0)
+#define HASH_CTR_STS_SHA_BUSY   (1 << 1)
+#define HASH_CTR_STS_SHA_RST    (1 << 2)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_CFG fields                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_CFG_SHA1_SHA2      (1 << 0)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* HASH_DIG_H fields                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define HASH_DIG_H_NUM          8
+
+#define SHA_MODULE_TYPE         1
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                                  TYPES & DEFINITIONS                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define SHA_BLOCK_LENGTH     (512/8)
+#define SHA_2_HASH_LENGTH    (256/8)
+#define SHA_1_HASH_LENGTH    (160/8)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SHA type                                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum
+{
+  SHA_TYPE_SHA2 = 0,/*do not change - match SHA arch spec */
+  SHA_TYPE_SHA1,
+  SHA_TYPE_NUM
+} SHA_TYPE_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SHA instance struct handler                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct SHA_HANDLE_T
+{
+  UINT32              hv[SHA_2_HASH_LENGTH / sizeof(UINT32)];
+  UINT32              length0;
+  UINT32              length1;
+  UINT32              block[SHA_BLOCK_LENGTH / sizeof(UINT32)];
+  SHA_TYPE_T          shaType;
+  BOOLEAN             active;
+} SHA_HANDLE_T;
+
+
+
+
+#endif // __NUVOTON_NPCM750_SHA_H
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
index 8d0fc3c..0f037ab
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -36,3 +36,4 @@ obj-$(CONFIG_FSL_SEC_MON) += fsl_sec_mon.o
 obj-$(CONFIG_PCA9551_LED) += pca9551_led.o
 obj-$(CONFIG_RESET) += reset-uclass.o
 obj-$(CONFIG_FSL_DEVICE_DISABLE) += fsl_devdis.o
+obj-$(CONFIG_NPCM750_OTP) += npcm750_otp.o fuse_wrapper.o
\ No newline at end of file
diff --git a/drivers/misc/fuse_wrapper.c b/drivers/misc/fuse_wrapper.c
new file mode 100755
index 0000000..bb94fd8
--- /dev/null
+++ b/drivers/misc/fuse_wrapper.c
@@ -0,0 +1,294 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*                         fuse_wrapper.c                                                                  */
+/*            This file contains fuse wrapper implementation. it wraps all access to the otp               */
+/*  Project:  Poleg                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+#include <common.h>
+#include "fuse_wrapper.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* This global array is used to host the full encloded key                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define        FUSE_ARRAY_MAX_SIZE    512
+static UINT8   fuse_encoded[FUSE_ARRAY_MAX_SIZE] = {0};
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_WRPR_set                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  fuse_address    -                                                                      */
+/*                  fuse_length     -                                                                      */
+/*                  fuse_ecc        -                                                                      */
+/*                  array           -                                                                      */
+/*                  value           -                                                                      */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine ...                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_set(UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length,  FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value)
+{
+
+    UINT16 iCnt = 0;
+    DEFS_STATUS status = DEFS_STATUS_OK;
+
+    // actual size for fuses to read:
+    /* UINT16 iSize = fuse_length; */
+    ASSERT(iSize < FUSE_ARRAY_MAX_SIZE);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Decode , if needed. If decode fails... TBD                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_NIBBLE_PARITY)
+    {
+        /* iSize = fuse_length / 2; */
+        status = FUSE_NibParEccEncode(value, fuse_encoded, fuse_length);
+    }
+
+    else if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_MAJORITY)
+    {
+        /* iSize = fuse_length / 3; */
+        status = FUSE_MajRulEccEncode(value, fuse_encoded, fuse_length);
+    }
+
+    if ( status != DEFS_STATUS_OK)
+    {
+        return status;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* And program to OTP                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // if no parity
+    if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_NONE )
+    {
+        for (iCnt = 0; iCnt < fuse_length ; iCnt++)
+        {
+            FUSE_ProgramByte((FUSE_STORAGE_ARRAY_T)array, fuse_address + iCnt , value[iCnt]);
+        }
+    }
+    else
+    {
+        for (iCnt = 0; iCnt < fuse_length ; iCnt++)
+        {
+            FUSE_ProgramByte((FUSE_STORAGE_ARRAY_T)array, fuse_address + iCnt , fuse_encoded[iCnt]);
+        }
+    }
+
+    return status;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_WRPR_get                                                                          */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  fuse_address    -   address in the fuse\key array.                                     */
+/*                  fuse_length     -   length in bytes inside the fuse array (before encoding)            */
+/*                  fuse_ecc        -   nible parity\majority\none                                         */
+/*                  array           -   key array\fuse array                                               */
+/*                  value           -                                                                      */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine read a value from the fuses.                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_get (UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length,   FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value)
+{
+    UINT16 iCnt = 0;
+
+    DEFS_STATUS status = DEFS_STATUS_OK;
+
+    DEFS_STATUS_COND_CHECK(fuse_length <= FUSE_ARRAY_MAX_SIZE, DEFS_STATUS_INVALID_PARAMETER);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read the fuses                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    // if no parity
+    if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_NONE )
+    {
+        for (iCnt = 0; iCnt < fuse_length ; iCnt++)
+        {
+            FUSE_Read((FUSE_STORAGE_ARRAY_T)array, fuse_address + iCnt , &value[iCnt]);
+        }
+    }
+    else
+    {
+        for (iCnt = 0; iCnt < fuse_length ; iCnt++)
+        {
+            FUSE_Read((FUSE_STORAGE_ARRAY_T)array, fuse_address + iCnt , &fuse_encoded[iCnt]);
+        }
+
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Either encode the data or read it as is                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_NIBBLE_PARITY)
+    {
+        status = FUSE_NibParEccDecode(fuse_encoded, value, fuse_length);
+    }
+
+    if ( (FUSE_ECC_TYPE_T)fuse_ecc == FUSE_ECC_MAJORITY)
+    {
+        status = FUSE_MajRulEccDecode(fuse_encoded, value, fuse_length);
+    }
+
+
+    return status;
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        FUSE_WRPR_get_CP_Fustrap                                                               */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  fuse_address    -                                                                      */
+/*                  fuse_length     -   length in bytes inside the fuse array (before encoding)            */
+/*                  fuse_ecc        -   nible parity\majority\none                                         */
+/*                  array           -   key array\fuse array                                               */
+/*                  value           -                                                                      */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine read a value from the fuses. It's for a field that is ten bit :(          */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_get_CP_Fustrap (UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length,   FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value)
+{
+
+    /* Due to architecture bug , CP_FUSTRAP is only 10 bits. In order not to change the rest of the FUSE_Wrapper, this code is set seperetly */
+
+    UINT16 iCnt = 0;
+    UINT  bit;
+    UINT8 E1, E2, E3;
+
+
+    DEFS_STATUS_COND_CHECK(fuse_length <= FUSE_ARRAY_MAX_SIZE, DEFS_STATUS_INVALID_PARAMETER);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Read the fuses                                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (iCnt = 0; iCnt < fuse_length ; iCnt++)
+    {
+        FUSE_Read((FUSE_STORAGE_ARRAY_T)array, fuse_address + iCnt , &fuse_encoded[iCnt]);
+    }
+
+
+    for (bit = 0; bit < 10; bit++)
+    {
+        E1 = READ_VAR_BIT(fuse_encoded[(( 0 + bit ) / 8)], (( 0 + bit ) % 8));
+        E2 = READ_VAR_BIT(fuse_encoded[((10 + bit ) / 8)], ((10 + bit ) % 8));
+        E3 = READ_VAR_BIT(fuse_encoded[((20 + bit ) / 8)], ((20 + bit ) % 8));
+        if ((E1+E2+E3) >= 2)
+        {
+            SET_VAR_BIT(value[(bit / 8)], (bit % 8));    // Majority is 1
+        }
+        else
+        {
+             CLEAR_VAR_BIT(value[(bit / 8)], (bit % 8));  // Majority is 0
+        }
+    }//Inner for (bit)
+
+
+    return DEFS_STATUS_OK;
+
+ }
+
+//#define CONFIG_FUSE_DEBUG
+#ifdef CONFIG_FUSE_DEBUG
+
+#define FUSE_GET_ADDRESS 0x2100000
+UINT8 *fuse_array_copy = (UINT8 *)FUSE_GET_ADDRESS;
+extern UINT8 *fuse_array_mem;
+
+ 
+int do_fuse_get(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{     
+    FUSE_WRPR_get(oFUSTRAP_PROPERTY, fuse_array_copy+oFUSTRAP_ARRAY*1024+oFUSTRAP_START);                         
+    FUSE_WRPR_get(oDAC_CALIB_PROPERTY, fuse_array_copy+oDAC_CALIB_ARRAY*1024+oDAC_CALIB_START);                           
+    FUSE_WRPR_get(oADC_CALIB_PROPERTY, fuse_array_copy+oADC_CALIB_ARRAY*1024+oADC_CALIB_START);                           
+    FUSE_WRPR_get(oVERIFICATION_FAULT_MODULE_PROTECTION_PROPERTY, fuse_array_copy+oVERIFICATION_FAULT_MODULE_PROTECTION_ARRAY*1024+oVERIFICATION_FAULT_MODULE_PROTECTION_START);
+    FUSE_WRPR_get(oFSVFP_PROPERTY, fuse_array_copy+oFSVFP_ARRAY*1024+oFSVFP_START);                               
+    FUSE_WRPR_get(oKAVFP_PROPERTY, fuse_array_copy+oKAVFP_ARRAY*1024+oKAVFP_START);                               
+    FUSE_WRPR_get(oFSAP_PROPERTY, fuse_array_copy+oFSAP_ARRAY*1024+oFSAP_START);                                
+    FUSE_WRPR_get(oKAP_PROPERTY, fuse_array_copy+oKAP_ARRAY*1024+oKAP_START);                             
+    FUSE_WRPR_get(oDERIVATIVE_PROPERTY, fuse_array_copy+oDERIVATIVE_ARRAY*1024+oDERIVATIVE_START);                          
+    FUSE_WRPR_get(oFINAL_TEST_SIGNATURE_PROPERTY, fuse_array_copy+oFINAL_TEST_SIGNATURE_ARRAY*1024+oFINAL_TEST_SIGNATURE_START);                
+    FUSE_WRPR_get(oDIE_LOCATION_PROPERTY, fuse_array_copy+oDIE_LOCATION_ARRAY*1024+oDIE_LOCATION_START);                        
+    FUSE_WRPR_get(RESERVED1_PROPERTY, fuse_array_copy+RESERVED1_ARRAY*1024+RESERVED1_START);                            
+    FUSE_WRPR_get(oGENERAL_PURPOSE1_PROPERTY, fuse_array_copy+oGENERAL_PURPOSE1_ARRAY*1024+oGENERAL_PURPOSE1_START);                    
+    FUSE_WRPR_get(oGENERAL_PURPOSE2_PROPERTY, fuse_array_copy+oGENERAL_PURPOSE2_ARRAY*1024+oGENERAL_PURPOSE2_START);                    
+    FUSE_WRPR_get(oPKValue2_1_PROPERTY, fuse_array_copy+oPKValue2_1_ARRAY*1024+oPKValue2_1_START);                          
+    FUSE_WRPR_get(oPKValue1_PROPERTY, fuse_array_copy+oPKValue1_ARRAY*1024+oPKValue1_START);                            
+    FUSE_WRPR_get(oAESKEY0_PROPERTY, fuse_array_copy+oAESKEY0_ARRAY*1024+oAESKEY0_START);                             
+    FUSE_WRPR_get(oAESKEY1_PROPERTY, fuse_array_copy+oAESKEY1_ARRAY*1024+oAESKEY1_START);                             
+    FUSE_WRPR_get(oAESKEY2_PROPERTY, fuse_array_copy+oAESKEY2_ARRAY*1024+oAESKEY2_START);                             
+    FUSE_WRPR_get(oAESKEY3_PROPERTY, fuse_array_copy+oAESKEY3_ARRAY*1024+oAESKEY3_START);                             
+    FUSE_WRPR_get(oPKValue2_0_PROPERTY, fuse_array_copy+oPKValue2_0_ARRAY*1024+oPKValue2_0_START);                          
+    FUSE_WRPR_get(oPKValue0_PROPERTY, fuse_array_copy+oPKValue0_ARRAY*1024+oPKValue0_START);  
+
+    return 0;
+} 
+ 
+int do_fuse_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{         
+    FUSE_WRPR_set(oFUSTRAP_PROPERTY, fuse_array_copy+oFUSTRAP_ARRAY*1024+oFUSTRAP_START);                         
+    FUSE_WRPR_set(oDAC_CALIB_PROPERTY, fuse_array_copy+oDAC_CALIB_ARRAY*1024+oDAC_CALIB_START);                           
+    FUSE_WRPR_set(oADC_CALIB_PROPERTY, fuse_array_copy+oADC_CALIB_ARRAY*1024+oADC_CALIB_START);                           
+    FUSE_WRPR_set(oVERIFICATION_FAULT_MODULE_PROTECTION_PROPERTY, fuse_array_copy+oVERIFICATION_FAULT_MODULE_PROTECTION_ARRAY*1024+oVERIFICATION_FAULT_MODULE_PROTECTION_START);
+    FUSE_WRPR_set(oFSVFP_PROPERTY, fuse_array_copy+oFSVFP_ARRAY*1024+oFSVFP_START);                               
+    FUSE_WRPR_set(oKAVFP_PROPERTY, fuse_array_copy+oKAVFP_ARRAY*1024+oKAVFP_START);                               
+    FUSE_WRPR_set(oFSAP_PROPERTY, fuse_array_copy+oFSAP_ARRAY*1024+oFSAP_START);                                
+    FUSE_WRPR_set(oKAP_PROPERTY, fuse_array_copy+oKAP_ARRAY*1024+oKAP_START);                            
+    FUSE_WRPR_set(oDERIVATIVE_PROPERTY, fuse_array_copy+oDERIVATIVE_ARRAY*1024+oDERIVATIVE_START);                          
+    FUSE_WRPR_set(oFINAL_TEST_SIGNATURE_PROPERTY, fuse_array_copy+oFINAL_TEST_SIGNATURE_ARRAY*1024+oFINAL_TEST_SIGNATURE_START);                
+    FUSE_WRPR_set(oDIE_LOCATION_PROPERTY, fuse_array_copy+oDIE_LOCATION_ARRAY*1024+oDIE_LOCATION_START);                        
+    FUSE_WRPR_set(RESERVED1_PROPERTY, fuse_array_copy+RESERVED1_ARRAY*1024+RESERVED1_START);                            
+    FUSE_WRPR_set(oGENERAL_PURPOSE1_PROPERTY, fuse_array_copy+oGENERAL_PURPOSE1_ARRAY*1024+oGENERAL_PURPOSE1_START);                    
+    FUSE_WRPR_set(oGENERAL_PURPOSE2_PROPERTY, fuse_array_copy+oGENERAL_PURPOSE2_ARRAY*1024+oGENERAL_PURPOSE2_START);                    
+    FUSE_WRPR_set(oPKValue2_1_PROPERTY, fuse_array_copy+oPKValue2_1_ARRAY*1024+oPKValue2_1_START);                          
+    FUSE_WRPR_set(oPKValue1_PROPERTY, fuse_array_copy+oPKValue1_ARRAY*1024+oPKValue1_START);                            
+    FUSE_WRPR_set(oAESKEY0_PROPERTY, fuse_array_copy+oAESKEY0_ARRAY*1024+oAESKEY0_START);                             
+    FUSE_WRPR_set(oAESKEY1_PROPERTY, fuse_array_copy+oAESKEY1_ARRAY*1024+oAESKEY1_START);                             
+    FUSE_WRPR_set(oAESKEY2_PROPERTY, fuse_array_copy+oAESKEY2_ARRAY*1024+oAESKEY2_START);                             
+    FUSE_WRPR_set(oAESKEY3_PROPERTY, fuse_array_copy+oAESKEY3_ARRAY*1024+oAESKEY3_START);                             
+    FUSE_WRPR_set(oPKValue2_0_PROPERTY, fuse_array_copy+oPKValue2_0_ARRAY*1024+oPKValue2_0_START);                          
+    FUSE_WRPR_set(oPKValue0_PROPERTY, fuse_array_copy+oPKValue0_ARRAY*1024+oPKValue0_START);    
+
+    return 0;
+} 
+
+#define STR_HELPER(x) #x
+#define STR(x) STR_HELPER(x)
+
+
+U_BOOT_CMD(
+     fuse_get,   1,   1,     do_fuse_get,
+     "read from fuse arrays decode and place at " STR(FUSE_GET_ADDRESS),
+     ""
+);
+
+U_BOOT_CMD(
+     fuse_set,   1,   1,     do_fuse_set,
+     "read from " STR(FUSE_GET_ADDRESS) " encode and program into fuse arrays" ,
+     ""
+);
+
+#endif // CONFIG_FUSE_DEBUG
+
diff --git a/drivers/misc/fuse_wrapper.h b/drivers/misc/fuse_wrapper.h
new file mode 100755
index 0000000..4f8ef4d
--- /dev/null
+++ b/drivers/misc/fuse_wrapper.h
@@ -0,0 +1,187 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2014-2016 by Nuvoton Technology Corporation                                              */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*                         fuse_wrapper.h                                                                  */
+/*            This file contains fuse wrapper implementation. it wraps all access to the otp.              */
+/*            For the user: call FUSE_WRPR_set or FUSE_WRPR_get with the property fields.                  */
+/*  Project:  Poleg                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef _FUSE_WRAPPER_
+#define _FUSE_WRAPPER_
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Address of fuse elemnt                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum FUSE_ADDRESS_START_tag
+{
+	oFUSTRAP_START                              = 0                     ,    /* Start address of FUSTRAP   */
+	oCP_FUSTRAP_START                           = 12                    ,    /* Start address of Coprocessor CP_FUSTRAP   */
+	oDAC_CALIB_START                            = 16                    ,    /* Start address of DAC Calibration Word   */
+	oADC_CALIB_START                            = 24                    ,    /* Start address of ADC Calibration Word   */
+	oVERIFICATION_FAULT_MODULE_PROTECTION_START = 32                    ,    /* Start address of Verification Fault Module Protection   */
+	oFSVFP_START                                = 40                    ,    /* Start address of Fuse Strap Array Verification Fault Protection (oFSVFP)   */
+	oKAVFP_START                                = 46                    ,    /* Start address of Key Array Verification Fault Protection (oKAVFP)   */
+	oFSAP_START                                 = 52                    ,    /* Start address of Fuse Strap Array Access Protection (oFSAP)   */
+	oKAP_START                                  = 58                    ,    /* Start address of Key Array Access Protection (oKAP)   */
+	RESERVED_START                              = 64                    ,    /* Start address of Reserved for Nuvoton use   */
+	oDERIVATIVE_START                           = 64                    ,    /* Start address of Derivative Word   */
+	oFINAL_TEST_SIGNATURE_START                 = 72                    ,    /* Start address of Final test signature   */
+	oDIE_LOCATION_START                         = 74                    ,    /* Start address of Die location: Horizontal   , Vertical, Wafer#   */
+	RESERVED1_START                             = 77                    ,    /* Start address of Reserved   */
+	oGENERAL_PURPOSE1_START                     = 80                    ,    /* Start address of General Purpose   */
+	oGENERAL_PURPOSE2_START                     = 128                   ,    /* Start address of General Purpose   */
+	oPKValue2_1_START                           = 256                   ,    /* Start address of Second Half of RSA key 2 (oPKValue2[1024:2047)   */
+	oPKValue1_START                             = 512                   ,    /* Start address of RSA Key 1 (oPKValue1)   */
+	oAESKEY0_START                              = 0                     ,    /* Start address of AES Key 0 (oAESKEY0)   */
+	oAESKEY1_START                              = 64                    ,    /* Start address of AES Key 1 (oAESKEY1)   */
+	oAESKEY2_START                              = 128                   ,    /* Start address of AES Key 2 (oAESKEY2)   */
+	oAESKEY3_START                              = 192                   ,    /* Start address of AES Key 3 (oAESKEY3)   */
+	oPKValue2_0_START                           = 256                   ,    /* Start address of First Half of RSA key 2 (oPKValue2[0:1023])   */
+	oPKValue0_START                             = 512                   ,    /* Start address of RSA Key 0 (oPKValue0)   */
+} FUSE_ADDRESS_START_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Length of fuse element. This is the full length, not the length after decode which is smaller           */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum  FUSE_LENGTH_tag
+{
+	oFUSTRAP_LENGTH                             = 12                    ,    /* length of OTP field FUSTRAP   */
+	oCP_FUSTRAP_LENGTH                          = 4                     ,    /* length of OTP field Coprocessor CP_FUSTRAP   */
+	oDAC_CALIB_LENGTH                           = 8                     ,    /* length of OTP field DAC Calibration Word   */
+	oADC_CALIB_LENGTH                           = 8                     ,    /* length of OTP field ADC Calibration Word   */
+	oVERIFICATION_FAULT_MODULE_PROTECTION_LENGTH= 8                     ,    /* length of OTP field Verification Fault Module Protection   */
+	oFSVFP_LENGTH                               = 6                     ,    /* length of OTP field Fuse Strap Array Verification Fault Protection (oFSVFP)   */
+	oKAVFP_LENGTH                               = 6                     ,    /* length of OTP field Key Array Verification Fault Protection (oKAVFP)   */
+	oFSAP_LENGTH                                = 6                     ,    /* length of OTP field Fuse Strap Array Access Protection (oFSAP)   */
+	oKAP_LENGTH                                 = 6                     ,    /* length of OTP field Key Array Access Protection (oKAP)   */
+	RESERVED_LENGTH                             = 16                    ,    /* length of OTP field Reserved for Nuvoton use   */
+	oDERIVATIVE_LENGTH                          = 8                     ,    /* length of OTP field Derivative Word   */
+	oFINAL_TEST_SIGNATURE_LENGTH                = 2                     ,    /* length of OTP field Final test signature   */
+	oDIE_LOCATION_LENGTH                        = 3                     ,    /* length of OTP field Die location: Horizontal, Vertical, Wafer#   */
+	RESERVED1_LENGTH                            = 3                     ,    /* length of OTP field Reserved   */
+	oGENERAL_PURPOSE1_LENGTH                    = 48                    ,    /* length of OTP field General Purpose   */
+	oGENERAL_PURPOSE2_LENGTH                    = 128                   ,    /* length of OTP field General Purpose   */
+	oPKValue2_1_LENGTH                          = 256                   ,    /* length of OTP field Second Half of RSA key 2 (oPKValue2[1024:2047)   */
+	oPKValue1_LENGTH                            = 512                   ,    /* length of OTP field RSA Key 1 (oPKValue1)   */
+	oAESKEY0_LENGTH                             = 64                    ,    /* length of OTP field AES Key 0 (oAESKEY0)   */
+	oAESKEY1_LENGTH                             = 64                    ,    /* length of OTP field AES Key 1 (oAESKEY1)   */
+	oAESKEY2_LENGTH                             = 64                    ,    /* length of OTP field AES Key 2 (oAESKEY2)   */
+	oAESKEY3_LENGTH                             = 64                    ,    /* length of OTP field AES Key 3 (oAESKEY3)   */
+	oPKValue2_0_LENGTH                          = 256                   ,    /* length of OTP field First Half of RSA key 2 (oPKValue2[0:1023])   */
+	oPKValue0_LENGTH                            = 512                   ,    /* length of OTP field RSA Key 0 (oPKValue0)   */
+} FUSE_LENGTH_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Type of ECC of each element in otp                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum  FUSE_ECC_TYPES_tag  /* FUSE_ECC_TYPE_T */
+{
+	oFUSTRAP_ECC                                = FUSE_ECC_MAJORITY      ,    /*  FUSTRAP   */
+	oCP_FUSTRAP_ECC                             = FUSE_ECC_MAJORITY      ,    /*  Coprocessor CP_FUSTRAP   */
+	oDAC_CALIB_ECC                              = FUSE_ECC_NIBBLE_PARITY ,    /*  DAC Calibration Word   */
+	oADC_CALIB_ECC                              = FUSE_ECC_NIBBLE_PARITY ,    /*  ADC Calibration Word   */
+	oVERIFICATION_FAULT_MODULE_PROTECTION_ECC   = FUSE_ECC_NIBBLE_PARITY ,    /*  Verification Fault Module Protection   */
+	oFSVFP_ECC                                  = FUSE_ECC_MAJORITY      ,    /*  Fuse Strap Array Verification Fault Protection (oFSVFP)   */
+	oKAVFP_ECC                                  = FUSE_ECC_MAJORITY      ,    /*  Key Array Verification Fault Protection (oKAVFP)   */
+	oFSAP_ECC                                   = FUSE_ECC_MAJORITY      ,    /*  Fuse Strap Array Access Protection (oFSAP)   */
+	oKAP_ECC                                    = FUSE_ECC_MAJORITY      ,    /*  Key Array Access Protection (oKAP)   */
+	RESERVED_ECC                                = FUSE_ECC_NONE          ,    /*  Reserved for Nuvoton use   */
+	oDERIVATIVE_ECC                             = FUSE_ECC_NIBBLE_PARITY ,    /*  Derivative Word   */
+	oFINAL_TEST_SIGNATURE_ECC                   = FUSE_ECC_NONE          ,    /*  Final test signature   */
+	oDIE_LOCATION_ECC                           = FUSE_ECC_NONE          ,    /*  Die location: Horizontal, Vertical, Wafer#   */
+	RESERVED1_ECC                               = FUSE_ECC_NONE          ,    /*  Reserved   */
+	oGENERAL_PURPOSE1_ECC                       = FUSE_ECC_NONE          ,    /*  General Purpose   */
+	oGENERAL_PURPOSE2_ECC                       = FUSE_ECC_NONE          ,    /*  General Purpose   */
+	oPKValue2_1_ECC                             = FUSE_ECC_NIBBLE_PARITY ,    /*  Second Half of RSA key 2 (oPKValue2[1024:2047)   */
+	oPKValue1_ECC                               = FUSE_ECC_NIBBLE_PARITY ,    /*  RSA Key 1 (oPKValue1)   */
+	oAESKEY0_ECC                                = FUSE_ECC_NIBBLE_PARITY ,    /*  AES Key 0 (oAESKEY0)   */
+	oAESKEY1_ECC                                = FUSE_ECC_NIBBLE_PARITY ,    /*  AES Key 1 (oAESKEY1)   */
+	oAESKEY2_ECC                                = FUSE_ECC_NIBBLE_PARITY ,    /*  AES Key 2 (oAESKEY2)   */
+	oAESKEY3_ECC                                = FUSE_ECC_NIBBLE_PARITY ,    /*  AES Key 3 (oAESKEY3)   */
+	oPKValue2_0_ECC                             = FUSE_ECC_NIBBLE_PARITY ,    /*  First Half of RSA key 2 (oPKValue2[0:1023])   */
+	oPKValue0_ECC                               = FUSE_ECC_NIBBLE_PARITY ,    /*  RSA Key 0 (oPKValue0)   */
+} FUSE_ECC_T;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Lacation of each element in otp                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef enum  FUSE_ARRAY_tag /* FUSE_STORAGE_ARRAY_T */
+{
+	oFUSTRAP_ARRAY                              =  FUSE_SA              ,  /* FUSTRAP */
+	oCP_FUSTRAP_ARRAY                           =  FUSE_SA              ,  /* Coprocessor CP_FUSTRAP */
+	oDAC_CALIB_ARRAY                            =  FUSE_SA              ,  /* DAC Calibration Word */
+	oADC_CALIB_ARRAY                            =  FUSE_SA              ,  /* ADC Calibration Word */
+	oVERIFICATION_FAULT_MODULE_PROTECTION_ARRAY =  FUSE_SA              ,  /* Verification Fault Module Protection */
+	oFSVFP_ARRAY                                =  FUSE_SA              ,  /* Fuse Strap Array Verification Fault Protection (oFSVFP) */
+	oKAVFP_ARRAY                                =  FUSE_SA              ,  /* Key Array Verification Fault Protection (oKAVFP) */
+	oFSAP_ARRAY                                 =  FUSE_SA              ,  /* Fuse Strap Array Access Protection (oFSAP) */
+	oKAP_ARRAY                                  =  FUSE_SA              ,  /* Key Array Access Protection (oKAP) */
+	RESERVED_ARRAY                              =  FUSE_SA              ,  /* Reserved for Nuvoton use */
+	oDERIVATIVE_ARRAY                           =  FUSE_SA              ,  /* Derivative Word */
+	oFINAL_TEST_SIGNATURE_ARRAY                 =  FUSE_SA              ,  /* Final test signature */
+	oDIE_LOCATION_ARRAY                         =  FUSE_SA              ,  /* Die location: Horizontal                      , Vertical, Wafer# */
+	RESERVED1_ARRAY                             =  FUSE_SA              ,  /* Reserved */
+	oGENERAL_PURPOSE1_ARRAY                     =  FUSE_SA              ,  /* General Purpose */
+	oGENERAL_PURPOSE2_ARRAY                     =  FUSE_SA              ,  /* General Purpose */
+	oPKValue2_1_ARRAY                           =  FUSE_SA              ,  /* Second Half of RSA key 2 (oPKValue2[1024:2047) */
+	oPKValue1_ARRAY                             =  FUSE_SA              ,  /* RSA Key 1 (oPKValue1) */
+	oAESKEY0_ARRAY                              =  KEY_SA               ,  /* AES Key 0 (oAESKEY0) */
+	oAESKEY1_ARRAY                              =  KEY_SA               ,  /* AES Key 1 (oAESKEY1) */
+	oAESKEY2_ARRAY                              =  KEY_SA               ,  /* AES Key 2 (oAESKEY2) */
+	oAESKEY3_ARRAY                              =  KEY_SA               ,  /* AES Key 3 (oAESKEY3) */
+	oPKValue2_0_ARRAY                           =  KEY_SA               ,  /* First Half of RSA key 2 (oPKValue2[0:1023]) */
+	oPKValue0_ARRAY                             =  KEY_SA               ,  /* RSA Key 0 (oPKValue0) */
+} FUSE_ARRAY_T;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* OTP elements. use them in setter in getter below                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define      oFUSTRAP_PROPERTY                                (UINT16)oFUSTRAP_START, (UINT16)oFUSTRAP_LENGTH, oFUSTRAP_ECC, oFUSTRAP_ARRAY
+#define      oCP_FUSTRAP_PROPERTY                             (UINT16)oCP_FUSTRAP_START, (UINT16)oCP_FUSTRAP_LENGTH, oCP_FUSTRAP_ECC, oCP_FUSTRAP_ARRAY
+#define      oDAC_CALIB_PROPERTY                              (UINT16)oDAC_CALIB_START, (UINT16)oDAC_CALIB_LENGTH, oDAC_CALIB_ECC, oDAC_CALIB_ARRAY
+#define      oADC_CALIB_PROPERTY                              (UINT16)oADC_CALIB_START, (UINT16)oADC_CALIB_LENGTH, oADC_CALIB_ECC, oADC_CALIB_ARRAY
+#define      oVERIFICATION_FAULT_MODULE_PROTECTION_PROPERTY   (UINT16)oVERIFICATION_FAULT_MODULE_PROTECTION_START,(UINT16) oVERIFICATION_FAULT_MODULE_PROTECTION_LENGTH, oVERIFICATION_FAULT_MODULE_PROTECTION_ECC, oVERIFICATION_FAULT_MODULE_PROTECTION_ARRAY
+#define      oFSVFP_PROPERTY                                  (UINT16)oFSVFP_START, (UINT16)oFSVFP_LENGTH, oFSVFP_ECC, oFSVFP_ARRAY
+#define      oKAVFP_PROPERTY                                  (UINT16)oKAVFP_START, (UINT16)oKAVFP_LENGTH, oKAVFP_ECC, oKAVFP_ARRAY
+#define      oFSAP_PROPERTY                                   (UINT16)oFSAP_START, (UINT16)oFSAP_LENGTH, oFSAP_ECC, oFSAP_ARRAY
+#define      oKAP_PROPERTY                                    (UINT16)oKAP_START, (UINT16)oKAP_LENGTH, oKAP_ECC, oKAP_ARRAY
+#define      RESERVED_PROPERTY                                (UINT16)RESERVED_START, (UINT16)RESERVED_LENGTH, RESERVED_ECC, RESERVED_ARRAY
+#define      oDERIVATIVE_PROPERTY                             (UINT16)oDERIVATIVE_START, (UINT16)oDERIVATIVE_LENGTH, oDERIVATIVE_ECC, oDERIVATIVE_ARRAY
+#define      oFINAL_TEST_SIGNATURE_PROPERTY                   (UINT16)oFINAL_TEST_SIGNATURE_START, (UINT16)oFINAL_TEST_SIGNATURE_LENGTH, oFINAL_TEST_SIGNATURE_ECC, oFINAL_TEST_SIGNATURE_ARRAY
+#define      oDIE_LOCATION_PROPERTY                           (UINT16)oDIE_LOCATION_START, (UINT16)oDIE_LOCATION_LENGTH, oDIE_LOCATION_ECC, oDIE_LOCATION_ARRAY
+#define      RESERVED1_PROPERTY                               (UINT16)RESERVED1_START, (UINT16)RESERVED1_LENGTH, RESERVED1_ECC, RESERVED1_ARRAY
+#define      oGENERAL_PURPOSE1_PROPERTY                       (UINT16)oGENERAL_PURPOSE1_START, (UINT16)oGENERAL_PURPOSE1_LENGTH, oGENERAL_PURPOSE1_ECC, oGENERAL_PURPOSE1_ARRAY
+#define      oGENERAL_PURPOSE2_PROPERTY                       (UINT16)oGENERAL_PURPOSE2_START, (UINT16)oGENERAL_PURPOSE2_LENGTH, oGENERAL_PURPOSE2_ECC, oGENERAL_PURPOSE2_ARRAY
+#define      oPKValue2_1_PROPERTY                             (UINT16)oPKValue2_1_START, (UINT16)oPKValue2_1_LENGTH, oPKValue2_1_ECC, oPKValue2_1_ARRAY
+#define      oPKValue1_PROPERTY                               (UINT16)oPKValue1_START, (UINT16)oPKValue1_LENGTH, oPKValue1_ECC, oPKValue1_ARRAY
+#define      oAESKEY0_PROPERTY                                (UINT16)oAESKEY0_START, (UINT16)oAESKEY0_LENGTH, oAESKEY0_ECC, oAESKEY0_ARRAY
+#define      oAESKEY1_PROPERTY                                (UINT16)oAESKEY1_START, (UINT16)oAESKEY1_LENGTH, oAESKEY1_ECC, oAESKEY1_ARRAY
+#define      oAESKEY2_PROPERTY                                (UINT16)oAESKEY2_START, (UINT16)oAESKEY2_LENGTH, oAESKEY2_ECC, oAESKEY2_ARRAY
+#define      oAESKEY3_PROPERTY                                (UINT16)oAESKEY3_START, (UINT16)oAESKEY3_LENGTH, oAESKEY3_ECC, oAESKEY3_ARRAY
+#define      oPKValue2_0_PROPERTY                             (UINT16)oPKValue2_0_START, (UINT16)oPKValue2_0_LENGTH, oPKValue2_0_ECC, oPKValue2_0_ARRAY
+#define      oPKValue0_PROPERTY                               (UINT16)oPKValue0_START, (UINT16)oPKValue0_LENGTH, oPKValue0_ECC, oPKValue0_ARRAY
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Setter for otp elements                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_set (UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length, FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Getter for otp elements                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_get (UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length, FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value);
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Getter for cp fustrp. It has a design bug. 10 bits instead of 16 :)                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+DEFS_STATUS FUSE_WRPR_get_CP_Fustrap (UINT16 /*FUSE_ADDRESS_START_T*/  fuse_address, UINT16 /*FUSE_LENGTH_T*/  fuse_length,   FUSE_ECC_T fuse_ecc, FUSE_ARRAY_T array, UINT8* value);
+
+#endif // _FUSE_WRAPPER_
diff --git a/drivers/misc/npcm750_otp.c b/drivers/misc/npcm750_otp.c
new file mode 100755
index 0000000..12b4561
--- /dev/null
+++ b/drivers/misc/npcm750_otp.c
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2009-2013 ADVANSEE
+ * Benot Thbaudeau <benoit.thebaudeau@advansee.com>
+ *
+ * Based on the mpc512x iim code:
+ * Copyright 2008 Silicon Turnkey Express, Inc.
+ * Martha Marx <mmarx@silicontkx.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fuse.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{   
+    FUSE_Read ((FUSE_STORAGE_ARRAY_T)bank, (u16)word, (u8*)val);
+	return 0;
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	/* We do not support overriding */
+	return -EINVAL;
+}
+
+
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	return FUSE_ProgramByte((FUSE_STORAGE_ARRAY_T)bank, (u16)word, (u8)val);
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	/* We do not support overriding */
+	return -EINVAL;
+}
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
old mode 100644
new mode 100755
index 99d0295..d31af05
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_MV_SDHCI) += mv_sdhci.o
 obj-$(CONFIG_MVEBU_MMC) += mvebu_mmc.o
 obj-$(CONFIG_MXC_MMC) += mxcmmc.o
 obj-$(CONFIG_MXS_MMC) += mxsmmc.o
+obj-$(CONFIG_NPCMX50_SDHCI) += npcmx50_sdhci.o
 obj-$(CONFIG_OMAP_HSMMC) += omap_hsmmc.o
 obj-$(CONFIG_X86) += pci_mmc.o
 obj-$(CONFIG_PXA_MMC_GENERIC) += pxa_mmc_gen.o
diff --git a/drivers/mmc/npcmx50_sdhci.c b/drivers/mmc/npcmx50_sdhci.c
new file mode 100755
index 0000000..5d0a4bc
--- /dev/null
+++ b/drivers/mmc/npcmx50_sdhci.c
@@ -0,0 +1,1112 @@
+/*
+ * Copyright 2011, Marvell Semiconductor Inc.
+ * Lei Wen <leiwen@marvell.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Back ported to the 8xx platform (from the 8260 platform) by
+ * Murray.Jensen@cmst.csiro.au, 27-Jan-01.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Host Control Register(SDHC_BA)                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCMX50_PA_SDHC(module)         SD_BASE_ADDR(module)
+
+#ifndef _PALLADIUM_
+#define SDHC_INTERRUPT
+#endif
+
+#define CONFIG_MMC_SDMA          /* Remove to enable fatwrite from flash address to MMC as file */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For debug prints                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+//#define DEBUG_SDHC
+#ifdef DEBUG_SDHC
+    #define SD_MSG(f, x...)     printf("NPCMX50 SD/MMC [%s()]: " f, __func__,## x)
+#else
+    #define SD_MSG(f, x...)
+#endif
+
+#define DEBUG_CMD     /* Comment when not needed */
+#ifdef DEBUG_CMD
+    #define DBG_MSG(f, x...)     printf(f, ## x)
+#else
+    #define DBG_MSG(f, x...)
+#endif
+
+
+#define NUM_SLOTS   2
+
+UINT32 CLK_ConfigureSDClock (UINT32 sdNum);
+HAL_STATUS CLK_ResetSD(UINT32 sdNum);
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+void *aligned_buffer = (void *)CONFIG_FIXED_SDHCI_ALIGNED_BUFFER;
+#else
+void *aligned_buffer;
+#endif
+
+struct sdhci_host *global_host[NUM_SLOTS];
+
+
+inline void set_bit(int nr, volatile void *addr)
+{
+	int	mask;
+	unsigned int *a = (unsigned int *) addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+inline void clear_bit(int nr, volatile void *addr)
+{
+	int	mask;
+	unsigned int *a = (unsigned int *) addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_dumpregs                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine dumps registers values                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_dumpregs(struct sdhci_host* host)
+{
+    int i=0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* * - Read registers and print them out.                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    printf("NPCMX50 SD/MMC: ============== REGISTER DUMP ==============\n");
+
+    printf(": Sys addr: 0x%08x | Version:  0x%08x\n",
+        sdhci_readl(host, SDHCI_DMA_ADDRESS),
+        sdhci_readw(host, SDHCI_HOST_VERSION));
+    printf(": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
+        sdhci_readw(host, SDHCI_BLOCK_SIZE),
+        sdhci_readw(host, SDHCI_BLOCK_COUNT));
+    printf(": Command:  0x%08x | SW Reset: 0x%08x\n",
+        sdhci_readw(host, SDHCI_COMMAND),
+        sdhci_readb(host, SDHCI_SOFTWARE_RESET));
+    printf(": Argument: 0x%08x | Trn mode: 0x%08x\n",
+        sdhci_readl(host, SDHCI_ARGUMENT),
+        sdhci_readw(host, SDHCI_TRANSFER_MODE));
+    printf(": Present:  0x%08x | Host ctl: 0x%08x\n",
+        sdhci_readl(host, SDHCI_PRESENT_STATE),
+        sdhci_readb(host, SDHCI_HOST_CONTROL));
+    printf(": Power:    0x%08x | Blk gap:  0x%08x\n",
+        sdhci_readb(host, SDHCI_POWER_CONTROL),
+        sdhci_readb(host, SDHCI_BLOCK_GAP_CONTROL));
+    printf(": Wake-up:  0x%08x | Clock:    0x%08x\n",
+        sdhci_readb(host, SDHCI_WAKE_UP_CONTROL),
+        sdhci_readw(host, SDHCI_CLOCK_CONTROL));
+    printf(": Timeout:  0x%08x | Int stat: 0x%08x\n",
+        sdhci_readb(host, SDHCI_TIMEOUT_CONTROL),
+        sdhci_readl(host, SDHCI_INT_STATUS));
+    printf(": Int enab: 0x%08x | Sig enab: 0x%08x\n",
+        sdhci_readl(host, SDHCI_INT_ENABLE),
+        sdhci_readl(host, SDHCI_SIGNAL_ENABLE));
+    printf(": AC12 err: 0x%08x | Slot int: 0x%08x\n",
+        sdhci_readw(host, SDHCI_ACMD12_ERR),
+        sdhci_readw(host, SDHCI_SLOT_INT_STATUS));
+    printf(": Caps:     0x%08x | Max curr: 0x%08x\n",
+        sdhci_readl(host, SDHCI_CAPABILITIES),
+        sdhci_readl(host, SDHCI_MAX_CURRENT));
+
+    printf("Response = ");
+    for (i=0; i<16; i++)
+        printf("%x ",  sdhci_readb(host, SDHCI_RESPONSE + i));
+    printf("\n");
+
+
+    printf("NPCMX50 SD/MMC: ===========================================\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_activate_led                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine activates LED                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_activate_led(struct sdhci_host *host)
+{
+    u8 ctrl;
+
+    ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+    ctrl |= SDHCI_CTRL_LED;
+    sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_deactivate_led                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine deactivates LED                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_deactivate_led(struct sdhci_host *host)
+{
+    u8 ctrl;
+
+    ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+    ctrl &= ~SDHCI_CTRL_LED;
+    sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+#if defined (NPCM750)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci1_irq                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles controller IRQs                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS sdhci1_irq(UINT32 devNum)
+{
+    HAL_STATUS result = HAL_OK;;
+    UINT32 intmask;
+    struct sdhci_host *host = global_host[devNum];
+	
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(devNum);
+    intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If no interrupt or invalid status, ignore it.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!intmask || intmask == 0xffffffff)
+    {
+        SD_MSG("Got invalid interrupt1: 0x%08x\n", intmask);
+        return result;
+    }
+
+    SD_MSG("Got interrupt1: intmask = 0x%08x\n", intmask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* For Card insert/remove                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_CARD_INSERT )
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_INSERT, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_INSERT;
+		
+        SD_MSG("MMC0 Card Inserted ...  mmc rescan \n");
+    }
+    else if (intmask & SDHCI_INT_CARD_REMOVE)
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_REMOVE, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_REMOVE;
+		
+        SD_MSG("MMC0 Card Removed ... \n");
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Show error message for the other interrupt(s).                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_BUS_POWER)
+    {
+        printf("MMC0 Card is consuming too much power!\n");
+        sdhci_writel(host, SDHCI_INT_BUS_POWER, SDHCI_INT_STATUS);
+    }
+
+    intmask &= ~SDHCI_INT_BUS_POWER;
+
+    if (intmask)
+    {
+        printf("MMC0 Card Unexpected interrupt intmask = 0x%08x.\n", intmask);
+        sdhci_dumpregs(host);
+        sdhci_writel(host, intmask, SDHCI_INT_STATUS);
+        result = HAL_ERROR;
+    }
+
+    return result;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci2_irq                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles controller IRQs                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS sdhci2_irq(UINT32 devNum)
+{
+    HAL_STATUS result = HAL_OK;;
+    UINT32 intmask;
+    struct sdhci_host *host = global_host[devNum];
+	
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(devNum);
+    intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If no interrupt or invalid status, ignore it.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!intmask || intmask == 0xffffffff)
+    {
+        SD_MSG("Got invalid interrupt2: 0x%08x\n", intmask);
+        return result;
+    }
+
+    SD_MSG("Got interrupt2: intmask = 0x%08x\n", intmask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* For Card insert/remove                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_CARD_INSERT )
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_INSERT, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_INSERT;
+		
+        printf("MMC1 Card Inseretd ...  mmc rescan \n");
+    }
+    else if (intmask & SDHCI_INT_CARD_REMOVE)
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_REMOVE, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_REMOVE;
+		
+        printf("MMC1 Card Removed ... \n");
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Show error message for the other interrupt(s).                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_BUS_POWER)
+    {
+        printf("MMC1 Card is consuming too much power!\n");
+        sdhci_writel(host, SDHCI_INT_BUS_POWER, SDHCI_INT_STATUS);
+    }
+
+    intmask &= ~SDHCI_INT_BUS_POWER;
+
+    if (intmask)
+    {
+        printf("MMC1 Card Unexpected interrupt intmask = 0x%08x.\n", intmask);
+        sdhci_dumpregs(host);
+        sdhci_writel(host, intmask, SDHCI_INT_STATUS);
+        result = HAL_ERROR;
+    }
+
+    return result;
+}
+#endif // NPCM750
+
+static void sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	unsigned long timeout;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
+	
+	/*-----------------------------------------------------------------------------------------------------*/
+    /* If it is reset all, it must delay a while.                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (mask & SDHCI_RESET_ALL)
+    {
+        host->clock = 0;
+        SD_MSG("reset host->clock = 0 for RESET_ALL\n");
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Without the delay, the driver hangs after second reset called after registering IRQ, when the   */
+        /* driver is built in kernel!                                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+		udelay(1000);
+    }
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+		if (timeout == 0) {
+			printf("%s: Reset 0x%x never completed.\n",
+			       __func__, (int)mask);
+			sdhci_dumpregs(host);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
+{
+	int i;
+	
+	SD_MSG("slot = %d, opcode = %d, resp_type = %x\n", host->index, cmd->cmdidx, cmd->resp_type);
+#ifdef DEBUG_SDHC
+	sdhci_dumpregs(host);
+#endif
+	if (cmd->resp_type & MMC_RSP_136) {
+		/* CRC is stripped so we need to do some shifting. */
+		for (i = 0; i < 4; i++) {
+			cmd->response[i] = sdhci_readl(host,
+					SDHCI_RESPONSE + (3-i)*4) << 8;
+			if (i != 3)
+				cmd->response[i] |= sdhci_readb(host,
+						SDHCI_RESPONSE + (3-i)*4-1);
+		}
+	} else {
+		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
+	}
+}
+
+static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
+{
+	int i;
+	char *offs;
+	for (i = 0; i < data->blocksize; i += 4) {
+		offs = data->dest + i;
+		if (data->flags == MMC_DATA_READ)
+			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
+		else
+			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
+	}
+}
+
+static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
+				unsigned int start_addr)
+{
+	unsigned int stat, rdy, mask, timeout, block = 0;
+#ifdef CONFIG_MMC_SDMA
+	unsigned char ctrl;
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_DMA_MASK;
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+#endif
+
+	timeout = 1000000;
+	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
+	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR) {
+			printf("%s: Error detected in status(0x%X)!\n",
+			       __func__, stat);
+			return -1;
+		}
+		if (stat & rdy) {
+			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
+				continue;
+			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
+			sdhci_transfer_pio(host, data);
+			data->dest += data->blocksize;
+			if (++block >= data->blocks)
+				break;
+		}
+#ifdef CONFIG_MMC_SDMA
+		if (stat & SDHCI_INT_DMA_END) {
+			sdhci_writel(host, SDHCI_INT_DMA_END, SDHCI_INT_STATUS);
+			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
+			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
+			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		}
+#endif
+		if (timeout-- > 0)
+			udelay(10);
+		else {
+			printf("%s: Transfer data timeout\n", __func__);
+			return -1;
+		}
+	} while (!(stat & SDHCI_INT_DATA_END));
+	return 0;
+}
+
+/*
+ * No command will be sent by driver if card is busy, so driver must wait
+ * for card ready state.
+ * Every time when card is busy after timeout then (last) timeout value will be
+ * increased twice but only if it doesn't exceed global defined maximum.
+ * Each function call will use last timeout value. Max timeout can be redefined
+ * in board config file.
+ */
+#ifndef CONFIG_SDHCI_CMD_MAX_TIMEOUT
+#define CONFIG_SDHCI_CMD_MAX_TIMEOUT		3200
+#endif
+#define CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT	100
+
+static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
+		       struct mmc_data *data)
+{
+	struct sdhci_host *host = mmc->priv;
+	unsigned int stat = 0;
+	int ret = 0;
+	int trans_bytes = 0, is_aligned = 1;
+	u32 mask, flags, mode;
+	unsigned int time = 0, start_addr = 0;
+	int mmc_dev = mmc->block_dev.dev;
+	unsigned start = get_timer(0);
+
+	/* Timeout unit - ms */
+	static unsigned int cmd_timeout = CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT;
+
+    SD_MSG("slot = %d, opcode = %d, argument = %x\n", host->index, cmd->cmdidx, cmd->cmdarg);
+
+    sdhci_activate_led(host);
+	
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		mask &= ~SDHCI_DATA_INHIBIT;
+        
+	SD_MSG("slot = %d cmdidx = 0x%x mask=0x%x\n",host->index, cmd->cmdidx, mask);            
+
+	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+		if (time >= cmd_timeout) {
+			printf("%s: MMC: %d busy ", __func__, mmc_dev);
+			if (2 * cmd_timeout <= CONFIG_SDHCI_CMD_MAX_TIMEOUT) {
+				cmd_timeout += cmd_timeout;
+				printf("timeout increasing to: %u ms.\n",
+				       cmd_timeout);
+			} else {
+                sdhci_deactivate_led(host);
+				puts("timeout.\n");
+				return COMM_ERR;
+			}
+		}
+		time++;
+		udelay(1000);
+	}
+
+	SD_MSG("slot = %d time = %d \n",host->index, time);            
+
+	mask = SDHCI_INT_RESPONSE;
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->resp_type & MMC_RSP_BUSY) {
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+		mask |= SDHCI_INT_DATA_END;
+	} else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	if (data)
+		flags |= SDHCI_CMD_DATA;
+
+	/* Set Transfer mode regarding to data flag */
+	if (data != 0) {
+		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+		mode = SDHCI_TRNS_BLK_CNT_EN;
+		trans_bytes = data->blocks * data->blocksize;
+		if (data->blocks > 1)
+			mode |= SDHCI_TRNS_MULTI;
+
+		if (data->flags == MMC_DATA_READ)
+			mode |= SDHCI_TRNS_READ;
+
+#ifdef CONFIG_MMC_SDMA
+		if (data->flags == MMC_DATA_READ)
+			start_addr = (unsigned long)data->dest;
+		else
+			start_addr = (unsigned long)data->src;
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				(start_addr & 0x7) != 0x0) {
+			is_aligned = 0;
+			start_addr = (unsigned long)aligned_buffer;
+			if (data->flags != MMC_DATA_READ)
+				memcpy(aligned_buffer, data->src, trans_bytes);
+		}
+
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+		/*
+		 * Always use this bounce-buffer when
+		 * CONFIG_FIXED_SDHCI_ALIGNED_BUFFER is defined
+		 */
+		is_aligned = 0;
+		start_addr = (unsigned long)aligned_buffer;
+		if (data->flags != MMC_DATA_READ)
+			memcpy(aligned_buffer, data->src, trans_bytes);
+#endif
+
+		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		mode |= SDHCI_TRNS_DMA;
+#endif
+		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
+				data->blocksize),
+				SDHCI_BLOCK_SIZE);
+		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
+		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
+	} else if (cmd->resp_type & MMC_RSP_BUSY) {
+		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+	}
+
+	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
+#ifdef CONFIG_MMC_SDMA
+	flush_cache(start_addr, trans_bytes);
+#endif
+	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
+	start = get_timer(0);
+	
+#ifdef DEBUG_SDHC
+	sdhci_dumpregs(host);
+#endif
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR)
+			break;
+	} while (((stat & mask) != mask) &&
+		 (get_timer(start) < CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT));
+
+	if (get_timer(start) >= CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT) {
+		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
+			return 0;
+		else {
+			printf("%s: Timeout for status update!\n", __func__);
+			return TIMEOUT;
+		}
+	}
+
+	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
+		sdhci_cmd_done(host, cmd);
+		sdhci_writel(host, mask, SDHCI_INT_STATUS);
+	} else
+		ret = -1;
+
+	if (!ret && data)
+		ret = sdhci_transfer_data(host, data, start_addr);
+
+	if (host->quirks & SDHCI_QUIRK_WAIT_SEND_CMD)
+		udelay(1000);
+
+	stat = sdhci_readl(host, SDHCI_INT_STATUS);
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	if (!ret) {
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				!is_aligned && (data->flags == MMC_DATA_READ))
+	    memcpy(data->dest, aligned_buffer, trans_bytes);
+		sdhci_deactivate_led(host);
+		return 0;
+	}
+    sdhci_deactivate_led(host);
+	sdhci_reset(host, SDHCI_RESET_CMD);
+	sdhci_reset(host, SDHCI_RESET_DATA);
+	if (stat & SDHCI_INT_TIMEOUT)
+	{
+	    DBG_MSG("CMD TIMEOUT slot=%d cmd=%d \n",host->index, cmd->cmdidx);           
+		return TIMEOUT;
+	}
+	else
+	{
+	    DBG_MSG("CMD ERROR slot=%d cmd=%d \n",host->index, cmd->cmdidx);           
+		return COMM_ERR;
+	}
+}
+
+static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
+{
+	struct sdhci_host *host = mmc->priv;
+	unsigned int div, clk, timeout;
+
+    SD_MSG("slot = %d, host->clock = %d, clock = %d\n",
+            host->index, host->clock, clock);
+			
+   /*-----------------------------------------------------------------------------------------------------*/
+    /* f the desired clock equals to the clock set in host, just return.                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (clock == host->clock)
+        return 0;
+
+#ifndef NPCM750
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If it is MMC, must disable SD sampling delay.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (clock == 26000000 || clock == 20000000)
+    {
+        clear_bit(NPCMX50_SDSD,(void *)(NPCMX50_INTCR2));
+    }
+#endif
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set clock to 0 first.                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SD sampling delay for SD standard timing if clock=0                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+	if (clock == 0)
+		return 0;
+
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
+		/* Version 3.00 divisors must be a multiple of 2. */
+		if (mmc->cfg->f_max <= clock)
+			div = 1;
+		else {
+			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
+				if ((mmc->cfg->f_max / div) <= clock)
+					break;
+			}
+		}
+	} else {
+		/* Version 2.00 divisors must be a power of 2. */
+		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
+			if ((mmc->cfg->f_max / div) <= clock)
+				break;
+		}
+	}
+	div >>= 1;
+
+	if (host->set_clock)
+		host->set_clock(host->index, div);
+
+	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
+	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
+		<< SDHCI_DIVIDER_HI_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set up register for the clock.                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait until the clock is stable, or max 20 ms                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+	timeout = 20;
+	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printf("%s: Internal clock never stabilised.\n",
+			       __func__);
+            sdhci_dumpregs(host);
+			return -1;
+		}
+		timeout--;
+		udelay(1000);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable the clock.                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    clk |= SDHCI_CLOCK_CARD_EN;
+	
+	SD_MSG("SDHCI_CLOCK_CONTROL clk = 0x%x\n", clk);
+	
+    sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	
+	return 0;
+}
+
+static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
+{
+	u8 pwr = 0;
+	
+
+	SD_MSG(" power = 0x%x\n", power);
+
+	if (power != (unsigned short)-1) {
+		switch (1 << power) {
+		case MMC_VDD_165_195:
+			pwr = SDHCI_POWER_180;
+			break;
+		case MMC_VDD_29_30:
+		case MMC_VDD_30_31:
+			pwr = SDHCI_POWER_300;
+			break;
+		case MMC_VDD_32_33:
+		case MMC_VDD_33_34:
+			pwr = SDHCI_POWER_330;
+			break;
+		}
+	}
+	
+	SD_MSG("SDHCI_POWER_CONTROL pwr = 0x%x\n", pwr);
+
+	if (pwr == 0) {
+		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+	    sdhci_reset(host, SDHCI_RESET_ALL);
+		return;
+	}
+
+	if (host->quirks & SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER)
+		sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+
+	pwr |= SDHCI_POWER_ON;
+
+	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+}
+
+static void sdhci_set_ios(struct mmc *mmc)
+{
+	u32 ctrl;
+	struct sdhci_host *host = mmc->priv;
+	
+	SD_MSG("slot = %d, mmc->clock=%d mmc->bus_width=%d\n",
+           host->index, mmc->clock, mmc->bus_width);
+
+
+	if (host->set_control_reg)
+		host->set_control_reg(host);
+
+	if (mmc->clock != host->clock)
+		sdhci_set_clock(mmc, mmc->clock);
+
+	/* Set bus width */
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	if (mmc->bus_width == 8) {
+		ctrl &= ~SDHCI_CTRL_4BITBUS;
+		if ((SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) ||
+				(host->quirks & SDHCI_QUIRK_USE_WIDE8))
+			ctrl |= SDHCI_CTRL_8BITBUS;
+	} else {
+		if ((SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) ||
+				(host->quirks & SDHCI_QUIRK_USE_WIDE8))
+			ctrl &= ~SDHCI_CTRL_8BITBUS;
+		if (mmc->bus_width == 4)
+			ctrl |= SDHCI_CTRL_4BITBUS;
+		else
+			ctrl &= ~SDHCI_CTRL_4BITBUS;
+	}
+
+	if (mmc->clock > 26000000)
+		ctrl |= SDHCI_CTRL_HISPD;
+	else
+		ctrl &= ~SDHCI_CTRL_HISPD;
+
+	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
+		ctrl &= ~SDHCI_CTRL_HISPD;
+		
+    SD_MSG("SDHCI_HOST_CONTROL ctrl = %d\n", ctrl);
+
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_init(struct mmc *mmc)
+{
+	struct sdhci_host *host = mmc->priv;
+	
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
+		aligned_buffer = memalign(8, 512*1024);
+		if (!aligned_buffer) {
+			printf("%s: Aligned buffer alloc failed!!!\n",
+			       __func__);
+			return -1;
+		}
+	}
+
+	sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
+
+	if (host->quirks & SDHCI_QUIRK_NO_CD) {
+		unsigned int status;
+
+		sdhci_writeb(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
+			SDHCI_HOST_CONTROL);
+
+		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
+		while ((!(status & SDHCI_CARD_PRESENT)) ||
+		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
+		    (!(status & SDHCI_CARD_DETECT_PIN_LEVEL)))
+			status = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	}
+
+#ifdef SDHC_INTERRUPT
+	/* Enable only interrupts served by the SD controller */
+	sdhci_writel(host, SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE | SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK, SDHCI_INT_ENABLE);
+	/* Mask all sdhci interrupt sources */
+	sdhci_writel(host, SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE, SDHCI_SIGNAL_ENABLE);
+#else
+	/* Enable only interrupts served by the SD controller */
+	sdhci_writel(host, SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK,
+		     SDHCI_INT_ENABLE);
+	/* Mask all sdhci interrupt sources */
+	sdhci_writel(host, 0x0, SDHCI_SIGNAL_ENABLE);
+
+#endif
+	return 0;
+}
+
+
+static const struct mmc_ops sdhci_ops = {
+	.send_cmd	= sdhci_send_command,
+	.set_ios	= sdhci_set_ios,
+	.init		= sdhci_init,
+};
+
+int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
+{
+	unsigned int caps;
+
+	host->cfg.name = host->name;
+	host->cfg.ops = &sdhci_ops;
+
+	caps = sdhci_readl(host, SDHCI_CAPABILITIES);
+#ifdef CONFIG_MMC_SDMA
+	if (!(caps & SDHCI_CAN_DO_SDMA)) {
+		printf("%s: Your controller doesn't support SDMA!!\n",
+		       __func__);
+		return -1;
+	}
+#endif
+
+	if (max_clk)
+		host->cfg.f_max = max_clk;
+	else {
+		if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+			host->cfg.f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		else
+			host->cfg.f_max = (caps & SDHCI_CLOCK_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		host->cfg.f_max *= 1000000;
+	}
+	if (host->cfg.f_max == 0) {
+		printf("%s: Hardware doesn't specify base clock frequency\n",
+		       __func__);
+		return -1;
+	}
+	if (min_clk)
+		host->cfg.f_min = min_clk;
+	else {
+		if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+			host->cfg.f_min = host->cfg.f_max /
+				SDHCI_MAX_DIV_SPEC_300;
+		else
+			host->cfg.f_min = host->cfg.f_max /
+				SDHCI_MAX_DIV_SPEC_200;
+	}
+
+	host->cfg.voltages = 0;
+	if (caps & SDHCI_CAN_VDD_330)
+		host->cfg.voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
+	if (caps & SDHCI_CAN_VDD_300)
+		host->cfg.voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & SDHCI_CAN_VDD_180)
+		host->cfg.voltages |= MMC_VDD_165_195;
+
+	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
+		host->cfg.voltages |= host->voltages;
+
+	host->cfg.host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
+		if (caps & SDHCI_CAN_DO_8BIT)
+			host->cfg.host_caps |= MMC_MODE_8BIT;
+	}
+	if (host->host_caps)
+		host->cfg.host_caps |= host->host_caps;
+
+	SD_MSG("host->cfg.host_caps = 0x%x\n", host->cfg.host_caps);
+    
+	host->cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	host->mmc = mmc_create(&host->cfg, host);
+	if (host->mmc == NULL) {
+		printf("%s: mmc create fail!\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                         Device init                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_init_slot                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                               */
+/*                  slot -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs slot initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static int sdhci_init_slot(int slot)
+{
+    int ret = 0;
+    unsigned int version;
+	struct sdhci_host *host = NULL;
+
+	host = (struct sdhci_host *)calloc(1,sizeof(struct sdhci_host));
+	if (!host) {
+		printf("sdhci_init_slot: sdhci_host calloc fail\n");
+		return 1;
+	}
+    global_host[slot] = host;
+
+
+	host->name = "npcmx50_sdhci";
+	host->ioaddr = (void *)NPCMX50_PA_SDHC(slot);
+	host->quirks = SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_WAIT_SEND_CMD;
+    if(slot == SD2_DEV)
+    {
+	   host->quirks |= SDHCI_QUIRK_NO_CD;     // eMMC - Set Software Card Detect
+    }
+	host->index = slot;
+		
+    sdhci_reset(host, SDHCI_RESET_ALL);
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Read version and capabilities of the SDHC.                                                      */
+    /*-------------------------------------------------------------------------------------------------*/
+    version = sdhci_readw(host, SDHCI_HOST_VERSION);
+    host->version = version = (version & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT;
+    SD_MSG("SDHC version = %d\n", version);
+    if (version > 2)
+	{
+        printf("NPCMX50 SD/MMC slot=%d: Unknown controller version (%d). "
+                "You may experience problems.\n", host->index,
+                version);
+    }
+	
+/*-----------------------------------------------------------------------------------------------------*/
+/* Enable Interrupt Group                                                                              */
+/*-----------------------------------------------------------------------------------------------------*/
+#ifdef SDHC_INTERRUPT
+#if defined (SD_INTERRUPT)
+    if(slot == SD1_DEV)
+    {
+       ret |= AIC_RegisterHandler(SD_INTERRUPT(slot), sdhci1_irq, (UINT32)slot);
+    }
+    else if(slot == SD2_DEV)
+    {
+       ret |= AIC_RegisterHandler(SD_INTERRUPT(slot), sdhci2_irq, (UINT32)slot);
+    }
+    ret |= AIC_EnableInt(SD_INTERRUPT(slot));
+#endif
+#endif
+	
+	add_sdhci(host, 0, 0);
+	
+    SD_MSG("caps = 0x%x, f_max = %d, f_min = %d\n",
+            sdhci_readl(host, SDHCI_CAPABILITIES), host->cfg.f_max, host->cfg.f_min);
+	
+	return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              Hardware init                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_module_init                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs HW init                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_module_init(UINT32 sdNum)
+{
+    SD_MSG("enter\n");
+
+#ifdef SDHC_INTERRUPT
+#if defined (SD_INTERRUPT)
+    AIC_DisableInt(SD_INTERRUPT(sdNum));
+#endif
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SDIO                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if(SD1_DEV == sdNum)
+    {
+    	GCR_Mux_SD(sdNum, SD_DEV_SD);
+    }
+    else if(SD2_DEV == sdNum)
+    { 
+    	GCR_Mux_SD(sdNum, SD_DEV_MMC8);     
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SDIO clock, CLKEN/SDIO=1                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ConfigureSDClock(sdNum);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SD Card Interface - Set/clear Software Reset Control Bit                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ResetSD(sdNum);
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        npcmx50_mmc_init                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+int npcmx50_mmc_init(void)
+{
+    int ret=0;
+    int i;
+    
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initialize registers for SDHC                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    sdhci_module_init(SD1_DEV);
+    sdhci_module_init(SD2_DEV);
+
+#ifdef _PALLADIUM_
+    printf("Palladium - Wait few minutes for SD card to be detected !!!\n");
+#endif
+
+    for (i = 0; i < NUM_SLOTS; i++)
+    {
+        ret = sdhci_init_slot(i);
+        if (ret)
+        {
+            printf("NPCMX50 SD/MMC npcmx50_mmc_init error, slot %d\n", i);
+        }	
+    }
+    return ret;
+}
\ No newline at end of file
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
old mode 100644
new mode 100755
index 150470c..ebd4588
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -72,3 +72,4 @@ obj-$(CONFIG_FSL_MC_ENET) += fsl-mc/
 obj-$(CONFIG_FSL_MC_ENET) += ldpaa_eth/
 obj-$(CONFIG_FSL_MEMAC) += fm/memac_phy.o
 obj-$(CONFIG_VSC9953) += vsc9953.o
+obj-$(CONFIG_NUC970_ETH) += nuc970_eth.o
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
old mode 100644
new mode 100755
index 6433896..e324440
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -469,6 +469,7 @@ int designware_initialize(ulong base_addr, u32 interface)
 {
 	struct eth_device *dev;
 	struct dw_eth_dev *priv;
+	int id = -1;
 
 	dev = (struct eth_device *) malloc(sizeof(struct eth_device));
 	if (!dev)
@@ -488,7 +489,15 @@ int designware_initialize(ulong base_addr, u32 interface)
 	memset(dev, 0, sizeof(struct eth_device));
 	memset(priv, 0, sizeof(struct dw_eth_dev));
 
-	sprintf(dev->name, "dwmac.%lx", base_addr);
+    if (base_addr == GMAC_BASE_ADDR(0))
+    {
+        id=2;       /* ETH2 */
+    }
+    else if (base_addr == GMAC_BASE_ADDR(1))
+    {
+        id=3;       /* ETH3 */
+    }        
+	sprintf(dev->name, "ETH%d", id);        /* Trego - Print eth name same as GMAC-HAL */
 	dev->iobase = (int)base_addr;
 	dev->priv = priv;
 
diff --git a/drivers/net/nuc970_eth.c b/drivers/net/nuc970_eth.c
new file mode 100755
index 0000000..84c91d3
--- /dev/null
+++ b/drivers/net/nuc970_eth.c
@@ -0,0 +1,349 @@
+/*
+ * Copyright (c) 2014 Nuvoton Technology Corp.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   NUC970 MAC driver source file
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <malloc.h>
+#include <linux/mii.h>
+#include <linux/err.h>
+#include "nuc970_eth.h"
+
+#define NUC_MSG(fmt,args...) printf ("EMC: %s(): " fmt ,__func__, ##args)
+
+//#define VERBOSE_EMC
+#if defined(VERBOSE_GLOBAL) || defined(VERBOSE_EMC)
+#define NUC_DEBUG_MSG(fmt,args...) NUC_MSG(fmt ,##args)
+#else
+#define NUC_DEBUG_MSG(fmt,args...)
+#endif
+
+
+static int nuc970_eth_mii_write(struct nuc970_eth_dev *priv, uchar addr, uchar reg, ushort val)
+{
+
+        writel(val, priv->iobase + MIID);
+        writel((addr << 8) | reg | PHYBUSY | PHYWR | MDCCR, priv->iobase + MIIDA);
+        
+        while (readl(priv->iobase + MIIDA) & PHYBUSY);
+
+        return(0);
+}
+
+
+static int nuc970_eth_mii_read(struct nuc970_eth_dev *priv, uchar addr, uchar reg, ushort *val)
+{
+        writel((addr << 8) | reg | PHYBUSY | MDCCR, priv->iobase + MIIDA);
+        while (readl(priv->iobase + MIIDA) & PHYBUSY);
+        
+        *val = (ushort)readl(priv->iobase + MIID);
+
+        return(0);
+}
+
+static int nuc970_reset_phy(struct nuc970_eth_dev *priv)
+{
+    unsigned short reg;
+    int delay;
+
+    NUC_DEBUG_MSG("\n");
+
+    nuc970_eth_mii_write(priv, CONFIG_NUC970_PHY_ADDR, MII_BMCR, BMCR_RESET);
+
+    delay = 2000;
+    while(delay-- > 0) {
+            nuc970_eth_mii_read(priv, CONFIG_NUC970_PHY_ADDR, MII_BMCR, &reg);
+            if((reg & BMCR_RESET) == 0)
+                    break;
+            
+    }        
+
+    if(delay == 0) {
+            NUC_MSG("Reset phy failed\n");
+            return(-1);
+    }        
+
+    nuc970_eth_mii_write(priv, CONFIG_NUC970_PHY_ADDR, MII_ADVERTISE, ADVERTISE_CSMA |
+                                                                ADVERTISE_10HALF |
+                                                                ADVERTISE_10FULL |
+                                                                ADVERTISE_100HALF |
+                                                                ADVERTISE_100FULL);
+
+    nuc970_eth_mii_read(priv, CONFIG_NUC970_PHY_ADDR, MII_BMCR, &reg);
+    nuc970_eth_mii_write(priv, CONFIG_NUC970_PHY_ADDR, MII_BMCR, reg | BMCR_ANRESTART);
+
+    delay = 20000;
+    while(delay-- > 0) {
+            nuc970_eth_mii_read(priv, CONFIG_NUC970_PHY_ADDR, MII_BMSR, &reg);
+            if((reg & (BMSR_ANEGCOMPLETE | BMSR_LSTATUS)) == (BMSR_ANEGCOMPLETE | BMSR_LSTATUS))
+                    break;
+    }
+
+    if(delay == 0) {
+            NUC_MSG("AN failed. Set to 100 FULL\n");
+            writel(readl(priv->iobase + MCMDR) | MCMDR_OPMOD | MCMDR_FDUP, priv->iobase + MCMDR);
+            return(-1);
+    } else {
+            nuc970_eth_mii_read(priv, CONFIG_NUC970_PHY_ADDR, MII_LPA, &reg);
+            
+            if(reg | ADVERTISE_100FULL)
+                    writel(readl(priv->iobase + MCMDR) | MCMDR_OPMOD | MCMDR_FDUP, priv->iobase + MCMDR);
+            else if(reg | ADVERTISE_100HALF)
+                    writel((readl(priv->iobase + MCMDR) | MCMDR_OPMOD) & ~MCMDR_FDUP, priv->iobase + MCMDR);
+            else if(reg | ADVERTISE_10FULL)
+                    writel((readl(priv->iobase + MCMDR) | MCMDR_FDUP) & ~MCMDR_OPMOD, priv->iobase + MCMDR);
+            else
+                    writel(readl(priv->iobase + MCMDR) & ~(MCMDR_OPMOD | MCMDR_FDUP), priv->iobase + MCMDR);
+    }
+
+    return(0);
+}
+
+
+static void init_tx_desc(struct nuc970_eth_dev *priv)
+{
+        int i;
+        struct eth_descriptor *tx_desc = priv->tx_desc;
+
+        do {
+            writel((unsigned int)(&tx_desc[0]), priv->iobase + TXDLSA);
+            NUC_DEBUG_MSG("TXDLSA = %08X %08X\n", (unsigned int)(&tx_desc[0]), readl(priv->iobase + TXDLSA));
+        } while (readl(priv->iobase + TXDLSA) != (unsigned int)(&tx_desc[0]));
+        
+        //priv->tx_desc_ptr = &tx_desc[0];
+        priv->tx_index = 0;
+        
+        for(i = 0; i < TX_DESCRIPTOR_NUM; i++) {
+                tx_desc[i].status1 = PaddingMode | CRCMode/* | MACTxIntEn*/;
+                tx_desc[i].buf = (unsigned char*)&(priv->txbuffs[i]);
+                tx_desc[i].status2 = 0;
+                tx_desc[i].next = (struct eth_descriptor*)((unsigned int) &tx_desc[(i + 1) % TX_DESCRIPTOR_NUM]);
+                NUC_DEBUG_MSG("tx_desc= %p: %08X, %p %08X, %p\n", &tx_desc[i], tx_desc[i].status1, tx_desc[i].buf, tx_desc[i].status2, tx_desc[i].next);    
+        }
+
+        flush_dcache_range((unsigned int)(&tx_desc[0]),(unsigned int)(&tx_desc[TX_DESCRIPTOR_NUM]));
+        
+        return;
+}
+
+static void init_rx_desc(struct nuc970_eth_dev *priv)
+{
+    int i;
+    struct eth_descriptor *rx_desc = priv->rx_desc;
+
+
+    /* Before passing buffers to GMAC we need to make sure zeros
+    * written there right after "priv" structure allocation were
+    * flushed into RAM.
+    * Otherwise there's a chance to get some of them flushed in RAM when
+    * GMAC is already pushing data to RAM via DMA. This way incoming from
+    * GMAC data will be corrupted. */
+    flush_dcache_range((unsigned int)priv->rxbuffs[0], (unsigned int)priv->rxbuffs[RX_DESCRIPTOR_NUM]);
+
+    writel((unsigned int)&rx_desc[0], priv->iobase + RXDLSA);
+    priv->rx_index = 0;
+
+    for(i = 0; i < RX_DESCRIPTOR_NUM; i++) {
+            rx_desc[i].status1 = RXfOwnership_DMA;
+            rx_desc[i].buf = priv->rxbuffs[i];
+            rx_desc[i].status2 = 0;
+            rx_desc[i].next = (struct eth_descriptor *)&rx_desc[(i + 1) % RX_DESCRIPTOR_NUM];
+            NUC_DEBUG_MSG("rx_desc= %p: %08X, %p %08X, %p\n", &rx_desc[i], rx_desc[i].status1, rx_desc[i].buf, rx_desc[i].status2, rx_desc[i].next); 
+    }
+
+    flush_dcache_range((unsigned int)(&rx_desc[0]),(unsigned int)(&rx_desc[RX_DESCRIPTOR_NUM]));
+
+    return;
+}
+
+static int nuc970_eth_write_hwaddr(struct eth_device *dev)
+{       
+    struct nuc970_eth_dev *priv = dev->priv;
+    
+    NUC_DEBUG_MSG("\n");
+    writel((dev->enetaddr[0] << 24) |
+           (dev->enetaddr[1] << 16) |
+           (dev->enetaddr[2] << 8) | 
+           dev->enetaddr[3] , priv->iobase + CAM0M);     
+    
+    writel((dev->enetaddr[4] << 24) | 
+           (dev->enetaddr[5] << 16) , priv->iobase + CAM0L);           
+        
+    //writel(CAM_ECMP | CAM_AUP, priv->iobase + CAMCMR);
+	writel(CAM_ECMP | CAM_AUP | CAM_ABP, priv->iobase + CAMCMR); 
+        writel(1, priv->iobase + CAMEN);
+        return(0);
+}    
+
+
+static int nuc970_eth_init(struct eth_device *dev, bd_t *bis)
+{
+    struct nuc970_eth_dev *priv = dev->priv;
+    
+    NUC_DEBUG_MSG("\n");
+    // Reset MAC
+    writel(MCMDR_SWR, priv->iobase + MCMDR);
+    while(readl(priv->iobase + MCMDR) & MCMDR_SWR);
+    
+
+    init_tx_desc(priv);
+    init_rx_desc(priv);
+
+    nuc970_eth_write_hwaddr(dev);  // need to reconfigure hardware address 'cos we just RESET emc...
+    
+    writel(MCMDR_SPCRC | MCMDR_RXON | MCMDR_EnMDC | MCMDR_TXON, priv->iobase + MCMDR);
+    writel(0, priv->iobase + RSDR);
+    
+    return(nuc970_reset_phy(priv));
+
+}
+
+
+
+static void  nuc970_eth_halt(struct eth_device *dev)
+{    
+    struct nuc970_eth_dev *priv = dev->priv;
+    
+    NUC_DEBUG_MSG("\n");
+    writel(readl(priv->iobase + MCMDR) & ~(MCMDR_RXON|MCMDR_TXON), priv->iobase + MCMDR);
+}
+
+static int nuc970_eth_recv (struct eth_device *dev)
+{
+    struct nuc970_eth_dev *priv = dev->priv;
+    unsigned int rx_index = priv->rx_index;
+    struct eth_descriptor *rx_desc_ptr = &(priv->rx_desc[rx_index]);
+
+    while(1) {
+    	/* Invalidate entire buffer descriptor */
+    	invalidate_dcache_range((unsigned long)rx_desc_ptr, (unsigned long)(rx_desc_ptr+1));
+        
+        if(rx_desc_ptr->status1 & RXfOwnership_DMA)
+            break;
+        
+        if(rx_desc_ptr->status1 & RXFD_RXGD) {
+            invalidate_dcache_range((unsigned long)rx_desc_ptr->buf, (unsigned long)rx_desc_ptr->buf + roundup(rx_desc_ptr->status1 & 0xFFFF, ARCH_DMA_MINALIGN));
+            net_process_received_packet(rx_desc_ptr->buf, rx_desc_ptr->status1 & 0xFFFF);
+        }
+        NUC_DEBUG_MSG("rx_desc_ptr= %p: %08X, %p %08X, %p\n", rx_desc_ptr, rx_desc_ptr->status1, rx_desc_ptr->buf, rx_desc_ptr->status2, rx_desc_ptr->next);
+         
+        rx_desc_ptr->status1 = RXfOwnership_DMA;
+    	/* Flush modified buffer descriptor */
+    	flush_dcache_range((unsigned long)rx_desc_ptr, (unsigned long)(rx_desc_ptr+1));
+        
+        rx_index = (rx_index+1) % RX_DESCRIPTOR_NUM;
+        rx_desc_ptr = &(priv->rx_desc[rx_index]);
+    }
+    
+    priv->rx_index = rx_index;
+
+    writel(0, priv->iobase + RSDR);
+
+    return 0;
+
+}
+
+static int nuc970_eth_send(struct eth_device *dev, void *packet, int length)
+{
+    struct nuc970_eth_dev *priv = dev->priv;
+    unsigned int tx_index = priv->tx_index;
+    struct eth_descriptor *tx_desc_ptr = &(priv->tx_desc[tx_index]);
+    
+	/*
+	 * Strictly we only need to invalidate the "txrx_status" field
+	 * for the following check, but on some platforms we cannot
+	 * invalidate only 4 bytes, so we flush the entire descriptor,
+	 * which is 16 bytes in total. This is safe because the
+	 * individual descriptors in the array are each aligned to
+	 * ARCH_DMA_MINALIGN and padded appropriately.
+	 */
+	//invalidate_dcache_range((unsigned long)tx_desc_ptr, (unsigned long)(tx_desc_ptr+1));
+    // wait 'til transfer complete. (e.g. ownership again set to CPU)
+    do {
+        invalidate_dcache_range((unsigned long)tx_desc_ptr, (unsigned long)(tx_desc_ptr+1));
+    }
+    while(tx_desc_ptr->status1 & TXfOwnership_DMA);
+    
+    memcpy(&(priv->txbuffs[tx_index]), packet, length);
+	/* Flush data to be sent */
+	flush_dcache_range((unsigned long)&(priv->txbuffs[tx_index]), (unsigned long)&(priv->txbuffs[tx_index])+roundup(length, ARCH_DMA_MINALIGN));
+    
+    tx_desc_ptr->status2 = (unsigned int)length;
+    tx_desc_ptr->status1 |= TXfOwnership_DMA;    
+
+	/* Flush modified buffer descriptor */
+	flush_dcache_range((unsigned long)tx_desc_ptr, (unsigned long)(tx_desc_ptr+1));
+
+    writel(0, priv->iobase + TSDR);
+    NUC_DEBUG_MSG("tx_desc_ptr= %p: %08X, %p %08X, %p\n", tx_desc_ptr, tx_desc_ptr->status1, tx_desc_ptr->buf, tx_desc_ptr->status2, tx_desc_ptr->next);
+    
+    priv->tx_index = (tx_index+1) % TX_DESCRIPTOR_NUM;
+
+ 	return 0 ;
+}
+
+    
+
+
+int nuc970_eth_register(ulong base_addr, unsigned int dev_num)
+{
+    struct eth_device *dev;
+	struct nuc970_eth_dev *priv;
+    NUC_DEBUG_MSG("\n");
+
+    dev = malloc(sizeof(*dev));
+    if (dev == NULL)
+        return(-ENOMEM);
+
+	/*
+	 * Since the priv structure contains the descriptors which need a strict
+	 * buswidth alignment, memalign is used to allocate memory
+	 */
+	priv = (struct nuc970_eth_dev *) memalign(MAX_ETH_BUFSIZE,
+					      sizeof(struct nuc970_eth_dev));
+	if (!priv) {
+		free(dev);
+		return -ENOMEM;
+	}
+
+    memset(dev, 0, sizeof(struct eth_device));
+	memset(priv, 0, sizeof(struct nuc970_eth_dev));
+    sprintf(dev->name, "ETH%d", dev_num);  
+    
+    dev->iobase = (phys_addr_t)base_addr;
+	dev->priv = priv;
+
+	priv->iobase = (phys_addr_t)base_addr;
+    
+    dev->init = nuc970_eth_init;
+    dev->halt = nuc970_eth_halt;
+    dev->send = nuc970_eth_send;
+    dev->recv = nuc970_eth_recv;
+    dev->write_hwaddr = nuc970_eth_write_hwaddr;        
+
+    eth_register(dev);
+
+    return(0);
+}        
diff --git a/drivers/net/nuc970_eth.h b/drivers/net/nuc970_eth.h
new file mode 100755
index 0000000..7602a56
--- /dev/null
+++ b/drivers/net/nuc970_eth.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2014 Nuvoton Technology Corp.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Description:   NUC970 MAC driver header file
+ */
+
+#ifndef  _NUC970_ETH_
+#define  _NUC970_ETH_
+
+/// EMC Control Registers
+#define CAMCMR       0x00   /* CAM Command Register */
+#define CAMEN        0x04   /* CAM Enable Register */
+#define CAM0M        0x08
+#define CAM0L        0x0c
+
+#define TXDLSA       0x88   /* Transmit Descriptor Link List Start Address Register */
+#define RXDLSA       0x8C   /* Receive Descriptor Link List Start Address Register */
+#define MCMDR        0x90   /* MAC Command Register */
+#define MIID         0x94   /* MII Management Data Register */
+#define MIIDA        0x98   /* MII Management Control and Address Register */
+#define FFTCR        0x9C   /* FIFO Threshold Control Register */
+#define TSDR         0xa0   /* Transmit Start Demand Register */
+#define RSDR         0xa4   /* Receive Start Demand Register */
+#define DMARFC       0xa8   /* Maximum Receive Frame Control Register */
+#define MIEN         0xac   /* MAC Interrupt Enable Register */
+// EMC Status Registers
+#define MISTA        0xb0   /* MAC Interrupt Status Register */
+#define MGSTA        0xb4   /* MAC General Status Register */
+#define MPCNT        0xb8   /* Missed Packet Count Register */
+#define MRPC         0xbc   /* MAC Receive Pause Count Register */
+#define MRPCC        0xc0   /* MAC Receive Pause Current Count Register */
+#define MREPC        0xc4   /* MAC Remote Pause Count Register */
+#define DMARFS       0xc8   /* DMA Receive Frame Status Register */
+#define CTXDSA       0xcc   /* Current Transmit Descriptor Start Address Register */
+#define CTXBSA       0xd0   /* Current Transmit Buffer Start Address Register */
+#define CRXDSA       0xd4   /* Current Receive Descriptor Start Address Register */
+#define CRXBSA       0xd8   /* Current Receive Buffer Start Address Register */
+
+
+
+// CAM Command Register(CAMCMR)
+#define CAM_AUP  0x0001  // Accept Packets with Unicast Address
+#define CAM_AMP  0x0002  // Accept Packets with Multicast Address
+#define CAM_ABP  0x0004  // Accept Packets with Broadcast Address
+#define CAM_CCAM 0x0008  // 0: Accept Packets CAM Recognizes and Reject Others
+                         // 1: Reject Packets CAM Recognizes and Accept Others
+#define CAM_ECMP 0x0010  // Enable CAM Compare
+
+
+// MAC Command Register(MCMDR)
+#define MCMDR_RXON    0x00000001  // Receive ON
+#define MCMDR_ALP     0x00000002  // Accept Long Packet
+#define MCMDR_ARP     0x00000004  // Accept Runt Packet
+#define MCMDR_ACP     0x00000008  // Accept Control Packet
+#define MCMDR_AEP     0x00000010  // Accept Error Packet
+#define MCMDR_SPCRC   0x00000020  // Accept Strip CRC Value
+#define MCMDR_TXON    0x00000100  // Transmit On
+#define MCMDR_NDEF    0x00000200  // No defer
+#define MCMDR_SDPZ    0x00010000  // Send Pause
+#define MCMDR_EnSQE   0x00020000  // Enable SQE test
+#define MCMDR_FDUP    0x00040000  // Full Duplex
+#define MCMDR_EnMDC   0x00080000  // Enable MDC signal
+#define MCMDR_OPMOD   0x00100000  // Operation Mode
+#define MCMDR_LBK     0x00200000  // Loop Back
+#define MCMDR_SWR     0x01000000  // Software Reset
+
+
+// MAC MII Management Data Control and Address Register(MIIDA)
+#define MDCCR    0x00a00000  // MDC clock rating
+//#define PHYAD    0x00000000  // PHY Address
+#define PHYWR    0x00010000  // Write Operation
+#define PHYBUSY  0x00020000  // Busy Bit
+#define PHYPreSP 0x00040000  // Preamble Suppress
+
+
+
+#define MAX_FRAME_SIZE        1520 // Rx Frame Max Size = 1520
+#define MAX_ETH_BUFSIZE	      2048
+
+#define RX_DESCRIPTOR_NUM PKTBUFSRX   // Max number of Rx Frame Descriptors
+#define TX_DESCRIPTOR_NUM 4           // Max number of Tx Frame Descriptors
+
+
+// RX Frame Descriptor's Owner bit
+#define RXfOwnership_DMA 0x80000000  // 10 = DMA
+#define RXfOwnership_CPU 0x3fffffff  // 00 = CPU
+
+// TX Frame Descriptor's Owner bit
+#define TXfOwnership_DMA 0x80000000  // 1 = DMA
+#define TXfOwnership_CPU 0x7fffffff  // 0 = CPU
+
+
+// Rx Frame Descriptor Status
+#define RXFD_RXGD    0x00100000  // Receiving Good packet received
+
+
+
+// Tx Frame Descriptor's Control bits
+#define MACTxIntEn    0x04
+#define CRCMode       0x02
+#define NoCRCMode     0x00
+#define PaddingMode   0x01
+#define NoPaddingMode 0x00
+
+// Tx Frame Descriptor Status
+#define TXFD_TXINTR 0x0001  // Interrupt on Transmit
+#define TXFD_DEF    0x0002  // Transmit deferred
+#define TXFD_TXCP   0x0008  // Transmission Completion
+#define TXFD_EXDEF  0x0010  // Exceed Deferral
+#define TXFD_NCS    0x0020  // No Carrier Sense Error
+#define TXFD_TXABT  0x0040  // Transmission Abort
+#define TXFD_LC     0x0080  // Late Collision
+#define TXFD_TXHA   0x0100  // Transmission halted
+#define TXFD_PAU    0x0200  // Paused
+#define TXFD_SQE    0x0400  // SQE error
+
+
+// Tx/Rx buffer descriptor structure
+struct eth_descriptor;
+struct eth_descriptor
+{
+        unsigned int  status1;
+        unsigned char *buf;
+        unsigned int  status2;
+        struct eth_descriptor *next;
+}__aligned(ARCH_DMA_MINALIGN);
+
+
+struct nuc970_eth_dev {
+	unsigned char rxbuffs[RX_DESCRIPTOR_NUM][MAX_ETH_BUFSIZE] __aligned(ARCH_DMA_MINALIGN);
+	unsigned char txbuffs[TX_DESCRIPTOR_NUM][MAX_ETH_BUFSIZE] __aligned(ARCH_DMA_MINALIGN);
+	struct eth_descriptor rx_desc[RX_DESCRIPTOR_NUM] __aligned(ARCH_DMA_MINALIGN);
+	struct eth_descriptor tx_desc[TX_DESCRIPTOR_NUM] __aligned(ARCH_DMA_MINALIGN);
+    unsigned int rx_index;
+    unsigned int tx_index;
+
+    phys_addr_t iobase;
+};
+
+
+#endif  /* _NUC970_ETH_ */
diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c
old mode 100644
new mode 100755
index 4b2808e..e2f882a
--- a/drivers/net/phy/broadcom.c
+++ b/drivers/net/phy/broadcom.c
@@ -30,6 +30,9 @@
 #define MIIM_BCM54XX_EXP_SEL_SSD	0x0e00	/* Secondary SerDes select */
 #define MIIM_BCM54XX_EXP_SEL_ER		0x0f00	/* Expansion register select */
 
+#define RDB_REGISTER_SELECT 0x1E
+#define RDB_REGISTER_DATA   0x1F
+
 /* Broadcom BCM5461S */
 static int bcm5461_config(struct phy_device *phydev)
 {
@@ -252,6 +255,55 @@ static int bcm5482_startup(struct phy_device *phydev)
 	return 0;
 }
 
+#ifdef PHY_READ_RDB_IN_USE // currently this function is not in use
+static int phy_read_rdb(struct phy_device *phydev, int rdb_regnum)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, RDB_REGISTER_SELECT, rdb_regnum & 0x0FFF);
+	return  phy_read(phydev, MDIO_DEVAD_NONE, RDB_REGISTER_DATA);
+}
+#endif
+
+static int phy_write_rdb(struct phy_device *phydev, int rdb_regnum, u16 rdb_val)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, RDB_REGISTER_SELECT, rdb_regnum & 0x0FFF);
+	return phy_write(phydev, MDIO_DEVAD_NONE, RDB_REGISTER_DATA, rdb_val & 0xFFFF);
+}
+
+int fiber_config(struct phy_device *phydev)
+{
+	phy_write_rdb(phydev, 0x02F, 0x71E7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x13, 0x0E00);	
+	phy_write_rdb(phydev, 0x810, 0x00B3);
+	phy_write_rdb(phydev, 0x021, 0x7C02); // I did it as in spec, in uboot script it set also bit 0 (0x7C03). seems a bug there???
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, 0x1940);
+	phy_write_rdb(phydev, 0x021, 0x7C03);
+	phy_write_rdb(phydev, 0x23E, 0x78E2);
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, 0x1140); // I did it as in spec, both in uboot and linux scripts it cleared autonegotiation bit 12 (0x0140)  ???
+
+
+	phydev->speed = SPEED_1000;
+	phydev->duplex = BMCR_FULLDPLX;
+	
+	return 0;
+}
+
+int fiber_startup(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+	
+	/* Read the link */
+	mii_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMSR);
+	if (mii_reg & BMSR_LSTATUS)
+		phydev->link = 1;
+	else
+		phydev->link = 0;
+	
+	phydev->speed = SPEED_1000;
+	phydev->duplex = BMCR_FULLDPLX;
+
+	return 0;
+}
+
 static struct phy_driver BCM5461S_driver = {
 	.name = "Broadcom BCM5461S",
 	.uid = 0x2060c0,
@@ -292,12 +344,23 @@ static struct phy_driver BCM_CYGNUS_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
+static struct phy_driver BCM_Fiber_driver = {
+	.name = "Broadcom Fiber GPHY",
+	.uid =  0x00008595, // or 0x00008599
+	.mask = 0x0000fff3,
+	.features = (SUPPORTED_1000baseT_Full),
+	.config = &fiber_config,
+	.startup = &fiber_startup,
+	.shutdown = &genphy_shutdown,
+};
+
 int phy_broadcom_init(void)
 {
 	phy_register(&BCM5482S_driver);
 	phy_register(&BCM5464S_driver);
 	phy_register(&BCM5461S_driver);
 	phy_register(&BCM_CYGNUS_driver);
+	phy_register(&BCM_Fiber_driver);
 
 	return 0;
 }
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
old mode 100644
new mode 100755
index a6023f1..6587484
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -630,8 +630,11 @@ static struct phy_device *create_phy_by_mask(struct mii_dev *bus,
 		int addr = ffs(phy_mask) - 1;
 		int r = get_phy_id(bus, addr, devad, &phy_id);
 		/* If the PHY ID is mostly f's, we didn't find anything */
-		if (r == 0 && (phy_id & 0x1fffffff) != 0x1fffffff)
+		if ((r == 0) && ((phy_id & 0x1fffffff) != 0x1fffffff) && (phy_id != 0x0000FFFF) && (phy_id != 0x00000000))
+        {
+            printf("RGMII-Phy Addr: 0x%x  ", addr);
 			return phy_device_create(bus, addr, phy_id, interface);
+        }
 		phy_mask &= ~(1 << addr);
 	}
 	return NULL;
@@ -721,6 +724,15 @@ int phy_reset(struct phy_device *phydev)
 #ifdef CONFIG_PHY_RESET_DELAY
 	udelay(CONFIG_PHY_RESET_DELAY);	/* Intel LXT971A needs this */
 #endif
+
+#ifndef CONFIG_SYS_DELL_DRB_HW
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy 125Mhz Clock Output Enable (for BMC54612e)                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/    
+	phy_write(phydev, devad, 0x17, 0xD34);    // In Phy Reg 17h -> Enable Top Level Expantion Register 34H
+    phy_write(phydev, devad, 0x15, 0x3);      // In Phy Reg 15h (34h) -> Enable 125MHZ clock output 
+  	phy_write(phydev, devad, 0x17, 0x0);      // In Phy Reg 17h -> Disable Top Level Expantion Register 34H  
+#endif
 	/*
 	 * Poll the control register for the reset bit to go to 0 (it is
 	 * auto-clearing).  This should happen within 0.5 seconds per the
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
old mode 100644
new mode 100755
index 699c410..d0a609d
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -144,6 +144,7 @@ serial_initfunc(mpc8xx_serial_initialize);
 serial_initfunc(mxc_serial_initialize);
 serial_initfunc(mxs_auart_initialize);
 serial_initfunc(ns16550_serial_initialize);
+serial_initfunc(nuvoton_serial_initialize);
 serial_initfunc(oc_serial_initialize);
 serial_initfunc(p3mx_serial_initialize);
 serial_initfunc(pl01x_serial_initialize);
@@ -237,6 +238,7 @@ void serial_initialize(void)
 	mxc_serial_initialize();
 	mxs_auart_initialize();
 	ns16550_serial_initialize();
+	nuvoton_serial_initialize();    
 	oc_serial_initialize();
 	p3mx_serial_initialize();
 	pl01x_serial_initialize();
diff --git a/include/configs/HermonSVB.h b/include/configs/HermonSVB.h
new file mode 100755
index 0000000..8c69d97
--- /dev/null
+++ b/include/configs/HermonSVB.h
@@ -0,0 +1,82 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB.h                                                                                           */
+/*            This file contains configurations for the wpcm450 compilation                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __HERMONSVB_H
+#define __HERMONSVB_H
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define DEBUG                           1
+//#define NO_INTERRUPTS
+//#define VERBOSE_GLOBAL
+
+
+#define CONFIG_SYS_L2CACHE_OFF	        1	/* No L2 CACHE */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Compilation options                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BOARD_LOWLEVEL_INIT      1
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE        128                           //size in bytes reserved for initial data
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BAUDRATE                 115200
+#define CONFIG_SYS_BAUDRATE_TABLE       { 9600, 19200, 38400, 57600, 115200 }
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS1,115200n8 initrd=0x1d00000,3000000 mem=64M"
+
+#define CONFIG_IPADDR                   192.168.0.10
+#define CONFIG_NETMASK                  255.0.0.0
+#define CONFIG_SERVERIP                 192.168.0.1
+#define CONFIG_GATEWAYIP                192.168.0.1
+#define CONFIG_ETHADDR                  00:0F:A0:00:00:00
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:0F:A0:00:00:01
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_ENV_OFFSET           0x200000                                    // environment offset in flash and ram
+#define CONFIG_ENV_SIZE                 0x10000                                     // Total Size alocated for environment
+
+#define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+#define CONFIG_SYS_ENV_SECT_SIZE        0x200                                       // Env sector size
+#define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+#define CONFIG_ENV_OVERWRITE
+
+
+
+
+#endif // __HERMONSVB_H
+
diff --git a/include/configs/PolegSVB.h b/include/configs/PolegSVB.h
new file mode 100755
index 0000000..943c6ac
--- /dev/null
+++ b/include/configs/PolegSVB.h
@@ -0,0 +1,199 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB.h                                                                                           */
+/*            This file contains configurations for the PolegSVB compilation                              */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __POLEGPALLADIUM_H
+#define __POLEGPALLADIUM_H
+
+
+/*---------------------------------------------------------------------------*/
+/* Please Start here and Select Board's configuration                        */
+/*---------------------------------------------------------------------------*/
+
+/* ########## Activate Palladium bypasses ########## */
+/*#define _PALLADIUM_                       1*/
+
+/* ########## Remove flash support ########## */ 
+/*#define _CONFIG_NO_FLASH_                 1       */
+
+
+/* ########## Enable DELL_DRB HW changes from PolegSVB ########## */
+/*#define CONFIG_SYS_DELL_DRB_HW            1*/
+
+
+
+/*
+ * Warning: changing CONFIG_SYS_TEXT_BASE requires
+ * adapting the initial boot program.
+ * Since the linker has to swallow that define, we must use a pure
+ * hex number here!
+ */
+ 
+/* DO NOT move this Define !*/
+#ifndef CONFIG_SYS_TEXT_BASE
+#ifdef _PALLADIUM_
+#define CONFIG_SYS_TEXT_BASE		0x8200           /* Palladium   */
+/*#define CONFIG_SYS_TEXT_BASE		0x80080000       // BOOT From FLASH (depend on booter)*/
+#else
+#define CONFIG_SYS_TEXT_BASE		0x8200           // BOOT Block will copy u-boot.bin image A/B to General location in DDR.    
+/*#define CONFIG_SYS_TEXT_BASE		0x80080000       // BOOT From FLASH (depend on booter)*/
+/*#define CONFIG_SYS_TEXT_BASE		0x80005200       // BOOT From FLASH (depend on booter)*/
+#endif
+#endif
+
+
+#define CONFIG_SYS_MEM_TOP_HIDE   (_16MB_ + _32MB_)  // 16MB Graphics Memory size to hide + 32MB for VCD ECE DVC.
+
+
+/* Uncomment to remove L1/L2-Caches */
+/*=========================================*/
+/*#define CONFIG_SYS_ICACHE_OFF*/
+/*#define CONFIG_SYS_DCACHE_OFF*/
+/*#define CONFIG_SYS_L2CACHE_OFF        1*/
+/*=========================================*/
+
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*#define DEBUG                           1*/
+/*#define VERBOSE_GLOBAL                  1*/
+/*#define VERBOSE_EMC                     1*/
+/*#define VERBOSE_GMAC                    1*/
+/*#define ET_DEBUG                        1*/
+/*#define VERBOSE_SPI_FLASH               1           // FIU spi Debug*/
+
+
+
+#define CONFIG_ARM_ERRATA_794072           // ARM CORTEX-A9 Errata
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* L2-Cache controler PL310 for Cortex A9                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+#define CONFIG_SYS_L2_PL310		1
+#define CONFIG_SYS_PL310_BASE	0xF03FC000       /* L2 - Cache Regs Base (4k Space)*/
+#endif
+
+#define CONFIG_SYS_CACHELINE_SIZE	   32
+
+#define CONFIG_BOARD_LOWLEVEL_INIT      1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_BAUDRATE                 600
+#else
+    #define CONFIG_BAUDRATE                 115200
+#endif
+
+#undef CONFIG_SYS_BAUDRATE_TABLE
+#define CONFIG_SYS_BAUDRATE_TABLE       { 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 }
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ETH_DEVS                 CHIP_NUM_OF_EMC_ETH + CHIP_NUM_OF_GMAC_ETH   // 2 EMC + 2 GMAC
+
+
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS3,115200n8 mem=464M initrd=0x1d00000,0x600000 ramdisk_size=24000"
+
+#define CONFIG_IPADDR                   10.191.20.48
+#define CONFIG_NETMASK                  255.255.255.0
+#define CONFIG_SERVERIP                 10.191.20.75
+#define CONFIG_GATEWAYIP                10.191.20.254
+
+#define CONFIG_ETHADDR                  00:00:F7:A0:00:45      // EMC1 
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:00:F7:A0:00:46      // EMC2
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETH2ADDR                 00:00:F7:A0:00:47      // GMAC1
+#define CONFIG_HAS_ETH3
+#define CONFIG_ETH3ADDR                 00:00:F7:A0:00:48      // GMAC2
+
+#define CONFIG_CMD_GMAC
+#define CONFIG_CMD_RNG
+
+
+
+/* Ethernet driver configuration */
+#define CONFIG_PHYLIB
+#define CONFIG_ETH_DESIGNWARE
+#define CONFIG_NUC970_ETH
+#define CONFIG_PHY_BROADCOM
+
+#define CONFIG_GMAC_RGMII_PHY           0x19           // GMAC RGMII Phy Address (see PolegSVB schematic)
+#define CONFIG_NUC970_PHY_ADDR          0x03           // EMC RMII Phy Address (see PolegSVB schematic)
+#define CONFIG_PHY_RESET_DELAY			10000		   // in usec 
+#define CONFIG_PHY_GIGE			                       // Include GbE speed/duplex detection
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* USB                                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/* USB UHH support options */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_HOST
+/*#define CONFIG_USB_OHCI*/
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_STORAGE
+#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Crypto                                                                                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+/* #define CONFIG_CMD_SHA1SUM */
+/* #define CONFIG_CMD_SHA256SUM */
+#define CONFIG_CMD_HASH
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ENV_SIZE                 0x40000                                         // Total Size of Environment Sector
+#define CONFIG_SYS_ENV_OFFSET           0xC0000                                         // environment starts here
+
+#ifdef _CONFIG_NO_FLASH_
+    #define CONFIG_SYS_NO_FLASH             1
+	#undef	CONFIG_CMD_IMLS
+    #define CONFIG_ENV_IS_NOWHERE
+#else
+    #define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+    /*#define CONFIG_SYS_ENV_SECT_SIZE        (128 << 10)                                 // Env sector size 128 KiB*/
+    #define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+
+    #define CONFIG_ENV_OVERWRITE
+    #define CONFIG_FLASH_VERIFY
+#endif
+
+
+#endif /* __POLEGPALLADIUM_H*/
+
diff --git a/include/configs/YarkonSVB.h b/include/configs/YarkonSVB.h
new file mode 100755
index 0000000..99f41a6
--- /dev/null
+++ b/include/configs/YarkonSVB.h
@@ -0,0 +1,122 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   YarkonSVB.h                                                                                           */
+/*            This file contains configurations for the YarkonSVB compilation                              */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __YARKONPALLADIUM_H
+#define __YARKONPALLADIUM_H
+
+
+/*
+ * Warning: changing CONFIG_SYS_TEXT_BASE requires
+ * adapting the initial boot program.
+ * Since the linker has to swallow that define, we must use a pure
+ * hex number here!
+ */
+
+/* DO NOT move this Define !*/
+#define CONFIG_SYS_TEXT_BASE		0x40080030       // BOOT From FLASH (0x30 depend on booter)
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define DEBUG                           1
+//#define VERBOSE_GLOBAL                  1
+//#define VERBOSE_EMC                     1
+//#define VERBOSE_GMAC                    1
+//#define ET_DEBUG                        1
+
+//#define _PALLADIUM_                     1       // Activate Palladium bypasses
+
+
+
+#define CONFIG_SYS_L2CACHE_OFF	        1	/* No L2 CACHE */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_BAUDRATE                 600
+#else
+    #define CONFIG_BAUDRATE                 115200
+#endif
+
+#undef CONFIG_SYS_BAUDRATE_TABLE
+#define CONFIG_SYS_BAUDRATE_TABLE       { 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 }
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ETH_DEVS                 CHIP_NUM_OF_ETH  // 1 EMC + 1 GMAC
+
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS1,115200n8 initrd=0x1d00000,3000000 mem=230M"
+
+#define CONFIG_IPADDR                   10.191.20.49
+#define CONFIG_NETMASK                  255.255.255.0
+#define CONFIG_SERVERIP                 10.191.20.75
+#define CONFIG_GATEWAYIP                10.191.20.254
+
+#define CONFIG_ETHADDR                  00:00:F7:A0:00:49           // EMC not used in NPCM650 
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:00:F7:A0:00:49           // GMAC  
+
+#define CONFIG_CMD_GMAC
+
+/* Ethernet driver configuration */
+#define CONFIG_DESIGNWARE_ETH                          // use Synopsys GMAC Driver
+
+#define CONFIG_DW_SEARCH_PHY
+#define CONFIG_DW0_PHY			     	1              // Phy Address  (see schematic)
+#define CONFIG_PHY_RESET_DELAY			10000		   // in usec 
+#define CONFIG_DW_AUTONEG
+#define CONFIG_PHY_GIGE			                       // Include GbE speed/duplex detection
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ENV_SIZE                 0x40000                                         // Total Size of Environment Sector
+#define CONFIG_SYS_ENV_OFFSET           0xC0000                                         // environment starts here
+
+#ifdef _PALLADIUM_
+    #define CONFIG_ENV_IS_NOWHERE
+
+#else
+    #define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+    #define CONFIG_SYS_ENV_SECT_SIZE        0x200                                       // Env sector size
+    #define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+    #define CONFIG_ENV_OVERWRITE
+
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Optimizations                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_NO_CRC32                 1
+#endif
+
+
+#endif // __YARKONPALLADIUM_H
+
diff --git a/include/configs/nuvoton.h b/include/configs/nuvoton.h
new file mode 100755
index 0000000..70981d0
--- /dev/null
+++ b/include/configs/nuvoton.h
@@ -0,0 +1,188 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton.h                                                                                             */
+/*            This file contains configurations for the wpcm450 compilation                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __NUVOTON_H
+#define __NUVOTON_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including HAL definitions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(BOARD_NAME) && !defined(__ASSEMBLY__) && !defined(USE_HOSTCC)
+#include "../../board/nuvoton/common/BMC_HAL/Boards/board.h"
+
+#undef MOD
+#undef ARRAY_SIZE
+#undef DIV_ROUND
+#undef MAX
+#undef MIN
+
+#endif
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Command line support                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_CMD_ASKENV               // ask for env variable
+#define CONFIG_SYS_ALT_MEMTEST          // Allow deeper alternet mtest 
+#define CONFIG_CMD_SETGETDCR            // DCR support on 4xx
+#define CONFIG_CMD_ELF                  // ELF support
+#define CONFIG_CMD_REGINFO              // Register dump
+#define CONFIG_CMD_SAVES                // save S record dump
+#define CONFIG_CMD_SDRAM                // SDRAM DIMM SPD info printout
+#define CONFIG_CMD_UNZIP                // unzip from memory to memory
+
+#define CONFIG_CMD_PING                 // Ping command
+#define CONFIG_CMD_DHCP                 // DHCP boot
+#define CONFIG_CMD_DIAG                 // Diagnostic commands
+
+#define CONFIG_CMD_MII                  // Network
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_CACHE
+
+/*#define CONFIG_MMC_TRACE           */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_NPCMX50_SDHCI
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_FS_GENERIC
+
+#define CONFIG_CMDLINE_EDITING
+/*#define CONFIG_CMD_SF*/
+
+/* Open Firmware flat tree */
+#define CONFIG_OF_LIBFDT
+
+
+/* Fuses */
+#define CONFIG_CMD_FUSE
+#define CONFIG_NPCM750_OTP
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* High Level Configuration Options                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CORE_TYPE                       Cortex-A9
+#define CONFIG_ARMV7	                1	        /* This is an ARM V7 CPU core */
+#define CONFIG_IDENT_STRING             " by Nuvoton Technology Corp."
+#define CONFIG_NUVOTON                  1
+
+#define CONFIG_DISPLAY_CPUINFO          1           // display cpu info (and speed)
+#define CONFIG_DISPLAY_BOARDINFO        1           // display board info
+
+
+#define CONFIG_USE_IRQ                  1
+
+#define CONFIG_MISC_INIT_R              1           /* This is used to properly link "nuvoton_eth.c" file
+                                                       for more info read the comment in the file
+                                                       over misc_init_r function */
+
+#define CONFIG_SETUP_MEMORY_TAGS        1
+#define CONFIG_SYS_GENERIC_BOARD        1        // Trego- UBOOT Relocation old way (for Now)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous configurable options                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_LONGHELP             1                           // Enable print of long help for commands
+
+#define CONFIG_SYS_CBSIZE               512                         // Console I/O Buffer Size
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE               (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS              32                          // max number of command args
+
+#define CONFIG_SYS_MEMTEST_START        0x00000000                  // memtest works on (SRAM and DDR) 
+#define CONFIG_SYS_MEMTEST_END          0x0A000000                  // MB in DRAM
+#define CONFIG_SYS_LOAD_ADDR            0x8000                      // default load address
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Linux Kernel Parameters                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_CMDLINE_TAG              1       /* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS        1
+#define CONFIG_INITRD_TAG               1       /* Required for ramdisk support */
+#define CONFIG_TAGS_LOCATION            0x100
+
+/* FIX_ISSUE_605 */
+/* #define CONFIG_TAGS_LOCATION            0x1000100 */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Hardware drivers                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_HZ                   1000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_CONS_INDEX               1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Stack sizes                                                                                             */
+/* The stack sizes are set up in start.S using the settings below                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_STACKSIZE                (128*1024)                  // regular stack
+#define CONFIG_STACKSIZE_IRQ            (4*1024)                    // IRQ stack
+#define CONFIG_STACKSIZE_FIQ            (4*1024)                    // FIQ stack
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Physical Memory Map                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#define CONFIG_NR_DRAM_BANKS            2                           // we have 2 banks: Chip SRAM2 (internal) and SDRAM DDR (external)
+#define PHYS_SDRAM_1                    SRAM_BASE_ADDR
+#define PHYS_SDRAM_1_SIZE               SRAM_MEMORY_SIZE
+#define PHYS_SDRAM_2                    SDRAM_BASE_ADDR
+#define PHYS_SDRAM_2_SIZE               SDRAM_MAPPED_SIZE
+
+#define	CONFIG_SYS_MONITOR_LEN		    (256 << 10)	/* Reserve 256 kB for Monitor	*/
+#define CONFIG_SYS_MONITOR_BASE	        CONFIG_SYS_TEXT_BASE
+       
+/*#define CONFIG_SYS_INIT_SP_ADDR		    0x00008000                  // Trego (SRAM_BASE_ADDR + SRAM_MEMORY_SIZE)*/
+#define CONFIG_SYS_INIT_SP_ADDR		    (0x00008000 - GENERATED_GBL_DATA_SIZE)
+
+/* FIX_ISSUE_605 */
+/* #define CONFIG_SYS_INIT_SP_ADDR		    (0x02008000 - GENERATED_GBL_DATA_SIZE) */
+
+#define CONFIG_SYS_SDRAM_BASE           PHYS_SDRAM_2
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define CONFIG_MII                      1
+
+#define CONFIG_BOOTP_SERVERIP           1
+
+
+#define CONFIG_ARP_TIMEOUT              100            /* ARP timeout in ms */
+#define CONFIG_NET_RETRY_COUNT          100            /* Number of retries per file transaction */
+
+#define CONFIG_SYS_RX_ETH_BUFFER        16             /* default is 4, set to 16 here. */
+
+
+#undef USB_INTERRUPT    /* No need USB Dev in UBOOT */
+
+#endif /* __NUVOTON_H */
+
diff --git a/include/usb.h b/include/usb.h
old mode 100644
new mode 100755
index 88ebbe6..86f59e8
--- a/include/usb.h
+++ b/include/usb.h
@@ -32,7 +32,10 @@
 #define USB_ALTSETTINGALLOC		4
 #define USB_MAXALTSETTING		128	/* Hard limit */
 
-#define USB_MAX_DEVICE			32
+// Trego - 
+#define USB_MAX_DEVICE			3
+//#define USB_MAX_DEVICE			32
+
 #define USB_MAXCONFIG			8
 #define USB_MAXINTERFACES		8
 #define USB_MAXENDPOINTS		16
diff --git a/poleg_fit.its b/poleg_fit.its
new file mode 100755
index 0000000..f2a72eb
--- /dev/null
+++ b/poleg_fit.its
@@ -0,0 +1,60 @@
+/dts-v1/;
+/ {
+    description = "Simple image with single Linux kernel and ramdisk";
+    #address-cells = <0x1>;
+
+    images {
+        kernel@1 {
+            description = "Nuvoton Linux kernel";
+            data = /incbin/("/home/ubuntu/shared/releases/poleg/file_sys/4112.01.13/dual/deliverables/PolegSVB/zImage");
+            type = "kernel";
+            arch = "arm";
+            os = "linux";
+            compression = "none";
+            load = <0x8000>;
+            entry = <0x8000>;
+            hash@1 {
+                algo = "sha256";
+            };
+	    signature@1 {
+                algo = "sha256,rsa2048";
+                key-name-hint = "poleg";
+                key-dir = "./build_output/tools/keys";
+            };
+        };
+        ramdisk@1 {
+            description = "Nuvoton Ramdisk Image";
+            data = /incbin/("/home/ubuntu/shared/releases/poleg/file_sys/4112.01.13/dual/deliverables/PolegSVB/romfs.img.gz");
+            type = "ramdisk";
+            arch = "arm";
+            os = "linux";
+            compression = "none";
+            load = <0x01d00000>;
+            entry = <0x01d00000>;
+            hash@1 {
+                algo = "sha256";
+            };
+	    signature@1 {
+                algo = "sha256,rsa2048";
+                key-name-hint = "poleg";
+                key-dir = "./build_output/tools/keys";
+            };
+       };
+    };
+    configurations {
+        default = "conf@1";
+        conf@1 {
+            description = "Boot Linux kernel and ramdisk";
+            kernel = "kernel@1";
+            ramdisk = "ramdisk@1";
+        };
+        hash@1 {
+                algo = "sha256";
+        };
+ 	signature@1 {
+            algo = "sha256,rsa2048";
+            key-name-hint = "poleg";
+            key-dir = "./build_output/tools/keys";
+        };
+    };
+};
diff --git a/scripts/Makefile.autoconf b/scripts/Makefile.autoconf
old mode 100644
new mode 100755
index d668982..5d90522
--- a/scripts/Makefile.autoconf
+++ b/scripts/Makefile.autoconf
@@ -84,8 +84,11 @@ include/autoconf.mk include/autoconf.mk.dep \
 
 # include/config.h
 # Prior to Kconfig, it was generated by mkconfig. Now it is created here.
+# Trego include issue
 define filechk_config_h
-	(echo "/* Automatically generated - do not edit */";		\
+	(echo "#ifndef __CONFIG_H";		\
+	echo "#define __CONFIG_H"; 	\
+	echo "/* Automatically generated - do not edit */";		\
 	for i in $$(echo $(CONFIG_SYS_EXTRA_OPTIONS) | sed 's/,/ /g'); do \
 		echo \#define CONFIG_$$i				\
 		| sed '/=/ {s/=/	/;q; } ; { s/$$/	1/; }'; \
@@ -95,7 +98,8 @@ define filechk_config_h
 	echo \#include \<config_uncmd_spl.h\>;				\
 	echo \#include \<configs/$(CONFIG_SYS_CONFIG_NAME).h\>;		\
 	echo \#include \<asm/config.h\>;				\
-	echo \#include \<config_fallbacks.h\>;)
+	echo \#include \<config_fallbacks.h\>;			\
+    echo "#endif /* __CONFIG_H */";)
 endef
 
 include/config.h: scripts/Makefile.autoconf create_symlink FORCE
-- 
1.8.3.4

