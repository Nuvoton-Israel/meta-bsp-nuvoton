From 60b48cb66cf2eca1cb7227e936ed8dc3f7c3ff4b Mon Sep 17 00:00:00 2001
From: tmaimon <tomer.maimon@nuvoton.com>
Date: Mon, 3 Apr 2017 15:10:22 +0300
Subject: [PATCH] u-boot-2015.10-PolegSVB-Rev1

---
 arch/arm/Kconfig                                   |    6 +
 arch/arm/cpu/armv7/Makefile                        |    2 +
 arch/arm/cpu/armv7/npcm750/Makefile                |    8 +
 arch/arm/cpu/armv7/npcm750/cache.c                 |   26 +
 arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c        |   15 +
 arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S   |   85 ++
 arch/arm/include/asm/arch-npcm750/gpio.h           |   12 +
 arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h  |   13 +
 arch/arm/include/asm/mach-types.h                  |   39 +
 arch/arm/include/asm/system.h                      |    4 +-
 arch/arm/lib/Makefile                              |    4 +
 arch/arm/lib/board.c                               |  698 +++++++++++
 arch/arm/lib/cache-cp15.c                          |    2 +-
 arch/arm/lib/cache-pl310.c                         |    5 +
 board/nuvoton/HermonSVB/HermonSVB_init.c           |   63 +
 board/nuvoton/HermonSVB/HermonSVB_low_level_init.S |  800 ++++++++++++
 board/nuvoton/HermonSVB/Makefile                   |   27 +
 board/nuvoton/HermonSVB/config.mk                  |    5 +
 board/nuvoton/PolegSVB/Kconfig                     |   18 +
 board/nuvoton/PolegSVB/Makefile                    |    8 +
 board/nuvoton/PolegSVB/PolegSVB_init.c             |   79 ++
 board/nuvoton/PolegSVB/PolegSVB_low_level_init.S   |   45 +
 board/nuvoton/PolegSVB/cmd_usb_device.c            |   52 +
 board/nuvoton/PolegSVB/config.mk                   |    5 +
 board/nuvoton/YarkonSVB/Makefile                   |   26 +
 board/nuvoton/YarkonSVB/YarkonSVB_init.c           |   77 ++
 board/nuvoton/YarkonSVB/config.mk                  |    5 +
 board/nuvoton/common/Makefile                      |   11 +
 board/nuvoton/common/config.mk                     |   45 +
 board/nuvoton/common/nuvoton_aic.c                 |   43 +
 board/nuvoton/common/nuvoton_eth.c                 |  678 +++++++++++
 board/nuvoton/common/nuvoton_flash.c               |  195 +++
 board/nuvoton/common/nuvoton_hal.h                 |   22 +
 board/nuvoton/common/nuvoton_init.c                |  189 +++
 board/nuvoton/common/nuvoton_low_level.S           |   75 ++
 board/nuvoton/common/nuvoton_serial.c              |  161 +++
 board/nuvoton/common/nuvoton_timer.c               |  130 ++
 board/nuvoton/common/nuvoton_usb.c                 |  107 ++
 common/Makefile                                    |    2 +
 common/board_f.c                                   |    3 +
 common/board_r.c                                   |    6 +-
 common/cmd_cache.c                                 |  482 +++++++-
 common/cmd_fuse.c                                  |   16 +-
 common/cmd_gmac.c                                  |  604 ++++++++++
 common/cmd_mem.c                                   |   45 +-
 configs/PolegSVB_defconfig                         |    2 +
 drivers/misc/Makefile                              |    1 +
 drivers/misc/npcm750_otp.c                         |   42 +
 drivers/mmc/Makefile                               |    1 +
 drivers/mmc/npcmx50_sdhci.c                        | 1270 ++++++++++++++++++++
 drivers/net/designware.c                           |   11 +-
 drivers/net/phy/phy.c                              |   16 +-
 drivers/serial/serial.c                            |    2 +
 include/configs/HermonSVB.h                        |   82 ++
 include/configs/PolegSVB.h                         |  184 +++
 include/configs/YarkonSVB.h                        |  122 ++
 include/configs/nuvoton.h                          |  195 +++
 include/usb.h                                      |    5 +-
 scripts/Makefile.autoconf                          |    8 +-
 59 files changed, 6857 insertions(+), 27 deletions(-)
 mode change 100644 => 100755 arch/arm/Kconfig
 mode change 100644 => 100755 arch/arm/cpu/armv7/Makefile
 create mode 100755 arch/arm/cpu/armv7/npcm750/Makefile
 create mode 100755 arch/arm/cpu/armv7/npcm750/cache.c
 create mode 100755 arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
 create mode 100755 arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
 create mode 100755 arch/arm/include/asm/arch-npcm750/gpio.h
 create mode 100755 arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
 mode change 100644 => 100755 arch/arm/include/asm/mach-types.h
 mode change 100644 => 100755 arch/arm/include/asm/system.h
 mode change 100644 => 100755 arch/arm/lib/Makefile
 create mode 100755 arch/arm/lib/board.c
 mode change 100644 => 100755 arch/arm/lib/cache-cp15.c
 mode change 100644 => 100755 arch/arm/lib/cache-pl310.c
 create mode 100755 board/nuvoton/HermonSVB/HermonSVB_init.c
 create mode 100755 board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
 create mode 100755 board/nuvoton/HermonSVB/Makefile
 create mode 100755 board/nuvoton/HermonSVB/config.mk
 create mode 100755 board/nuvoton/PolegSVB/Kconfig
 create mode 100755 board/nuvoton/PolegSVB/Makefile
 create mode 100755 board/nuvoton/PolegSVB/PolegSVB_init.c
 create mode 100755 board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
 create mode 100755 board/nuvoton/PolegSVB/cmd_usb_device.c
 create mode 100755 board/nuvoton/PolegSVB/config.mk
 create mode 100755 board/nuvoton/YarkonSVB/Makefile
 create mode 100755 board/nuvoton/YarkonSVB/YarkonSVB_init.c
 create mode 100755 board/nuvoton/YarkonSVB/config.mk
 create mode 100755 board/nuvoton/common/Makefile
 create mode 100755 board/nuvoton/common/config.mk
 create mode 100755 board/nuvoton/common/nuvoton_aic.c
 create mode 100755 board/nuvoton/common/nuvoton_eth.c
 create mode 100755 board/nuvoton/common/nuvoton_flash.c
 create mode 100755 board/nuvoton/common/nuvoton_hal.h
 create mode 100755 board/nuvoton/common/nuvoton_init.c
 create mode 100755 board/nuvoton/common/nuvoton_low_level.S
 create mode 100755 board/nuvoton/common/nuvoton_serial.c
 create mode 100755 board/nuvoton/common/nuvoton_timer.c
 create mode 100755 board/nuvoton/common/nuvoton_usb.c
 mode change 100644 => 100755 common/Makefile
 mode change 100644 => 100755 common/board_f.c
 mode change 100644 => 100755 common/board_r.c
 mode change 100644 => 100755 common/cmd_cache.c
 mode change 100644 => 100755 common/cmd_fuse.c
 create mode 100755 common/cmd_gmac.c
 mode change 100644 => 100755 common/cmd_mem.c
 create mode 100755 configs/PolegSVB_defconfig
 mode change 100644 => 100755 drivers/misc/Makefile
 create mode 100755 drivers/misc/npcm750_otp.c
 mode change 100644 => 100755 drivers/mmc/Makefile
 create mode 100755 drivers/mmc/npcmx50_sdhci.c
 mode change 100644 => 100755 drivers/net/designware.c
 mode change 100644 => 100755 drivers/net/phy/phy.c
 mode change 100644 => 100755 drivers/serial/serial.c
 create mode 100755 include/configs/HermonSVB.h
 create mode 100755 include/configs/PolegSVB.h
 create mode 100755 include/configs/YarkonSVB.h
 create mode 100755 include/configs/nuvoton.h
 mode change 100644 => 100755 include/usb.h
 mode change 100644 => 100755 scripts/Makefile.autoconf

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
old mode 100644
new mode 100755
index 7981355..9a67474
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -666,6 +666,11 @@ config ARCH_ROCKCHIP
 	select CPU_V7
 	select DM
 
+config TARGET_NPCM750
+	bool "Support npcm750"
+	select CPU_V7
+
+
 endchoice
 
 source "arch/arm/mach-at91/Kconfig"
@@ -762,6 +767,7 @@ source "board/h2200/Kconfig"
 source "board/hisilicon/hikey/Kconfig"
 source "board/imx31_phycore/Kconfig"
 source "board/isee/igep0033/Kconfig"
+source "board/nuvoton/PolegSVB/Kconfig"
 source "board/maxbcm/Kconfig"
 source "board/mpl/vcma9/Kconfig"
 source "board/olimex/mx23_olinuxino/Kconfig"
diff --git a/arch/arm/cpu/armv7/Makefile b/arch/arm/cpu/armv7/Makefile
old mode 100644
new mode 100755
index c8d1422..0a01ba7
--- a/arch/arm/cpu/armv7/Makefile
+++ b/arch/arm/cpu/armv7/Makefile
@@ -53,3 +53,5 @@ obj-$(CONFIG_ARCH_S5PC1XX) += s5pc1xx/
 obj-$(if $(filter stv0991,$(SOC)),y) += stv0991/
 obj-$(CONFIG_ARCH_SUNXI) += sunxi/
 obj-$(CONFIG_VF610) += vf610/
+obj-$(CONFIG_NUVOTON) += npcm750/
+
diff --git a/arch/arm/cpu/armv7/npcm750/Makefile b/arch/arm/cpu/armv7/npcm750/Makefile
new file mode 100755
index 0000000..b8977d0
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= l2_cache_pl310_init.o l2_cache_pl310.o cache.o
diff --git a/arch/arm/cpu/armv7/npcm750/cache.c b/arch/arm/cpu/armv7/npcm750/cache.c
new file mode 100755
index 0000000..a49ed07
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/cache.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2014 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * Robert Baldyga <r.baldyga@samsung.com>
+ *
+ * based on arch/arm/cpu/armv7/omap3/cache.S
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+
+void enable_caches(void)
+{
+	dcache_enable();
+}
+
+void disable_caches(void)
+{
+	dcache_disable();
+}
+
+#endif
+
diff --git a/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
new file mode 100755
index 0000000..e1ce72c
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310.c
@@ -0,0 +1,15 @@
+#include <common.h>
+ 
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+void v7_outer_cache_enable(void)
+{
+   l2_pl310_init();
+   set_pl310_ctrl(1);
+}
+
+void v7_outer_cache_disable(void)
+{
+   set_pl310_ctrl(0);
+}
+#endif /* !CONFIG_SYS_L2CACHE_OFF */
diff --git a/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
new file mode 100755
index 0000000..7479f19
--- /dev/null
+++ b/arch/arm/cpu/armv7/npcm750/l2_cache_pl310_init.S
@@ -0,0 +1,85 @@
+
+.align 5
+
+#include <linux/linkage.h>
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+
+ENTRY(l2_pl310_init)
+
+
+ @------------------------------------------------------------------
+ @ L2CC (PL310) Initialization
+ @------------------------------------------------------------------
+ 	@ In this example PL310 PA = VA. The memory was marked as Device memory
+ 	@ in previous stages when defining CORE0 private address space
+ 	LDR     r0, =0xF03FC000        @ A9_BASE_ADDR
+ 
+ 	@ Disable L2 Cache controller just in case it is already on
+ 	LDR     r1, =0x0
+ 	STR     r1, [r0,#0x100]
+ 
+ 	@ Set aux cntrl
+ 	@ Way size = 32KB
+        @ Way = 16
+ 	LDR     r1, =0x02050000         
+ 	ORR	r1, r1, #(1 << 29)	@ Instruction prefetch enable
+ 	ORR	r1, r1, #(1 << 28)	@ Data prefetch enable
+ 	STR     r1, [r0,#0x104]		@ auxilary control reg at offset 0x104
+ 
+ 	@ Set tag RAM latency
+ 	@ 1 cycle RAM write access latency
+ 	@ 1 cycle RAM read access latency
+ 	@ 1 cycle RAM setup latency
+ 	LDR     r1, =0x00000000
+ 	STR     r1, [r0,#0x108]		@ tag ram control reg at offset 0x108
+ 
+ 	@ Set Data RAM latency
+ 	@ 1 cycle RAM write access latency
+ 	@ 2 cycles RAM read access latency
+ 	@ 1 cycle RAM setup latency
+ 	//LDR     r1, =0x00000010	@ Altera uses read latency 1, but 0 seems to work
+ 	LDR     r1, =0x00000000
+ 	STR     r1, [r0,#0x10C]		@ data ram control reg at offset 0x108
+ 
+ 	@Cache maintenance - invalidate by way (0xff) - base offset 0x77C
+ 	LDR     r1, =0xFF
+ 	STR     r1, [r0,#0x77C]		@ invalidate by way register at offset 0x77C
+ poll_invalidate:
+ 	LDR     r1, [r0,#0x77C]		@ invalidate by way register at offset 0x77C
+ 	TST     r1, #1
+ 	BNE     poll_invalidate
+ 
+ /*
+ 	@ Enable Event Counter Control Register. Reset counter 0 and 1 values
+ 	LDR     r1, =0x007
+ 	STR     r1, [r0,#0x200]
+ 
+ 	@ Counter 1. Count Drhit event
+ 	LDR     r1, =0x008
+ 	STR     r1, [r0,#0x204]
+ 
+ 	@ Counter 0. Count Dwhit event
+ 	LDR     r1, =0x010
+ 	STR     r1, [r0,#0x208]
+ */
+ 
+ 	@ Ensure L2 remains disabled for the time being
+ 	LDR     r1, =0x0
+ 	STR     r1, [r0,#0x100]
+
+	MRC     p15, 4, r0, c15, c0, 0     @ Read periph base address
+ 	@ SCU offset from base of private peripheral space = 0x000
+ 
+ 	LDR     r1, [r0, #0x0]             @ Read the SCU Control Register
+ 	ORR     r1, r1, #0x1               @ Set bit 0 (The Enable bit)
+ 	STR     r1, [r0, #0x0]             @ Write back modifed value
+ 
+ 	BX	lr
+
+
+
+ENDPROC(l2_pl310_init)
+
+
+#endif
diff --git a/arch/arm/include/asm/arch-npcm750/gpio.h b/arch/arm/include/asm/arch-npcm750/gpio.h
new file mode 100755
index 0000000..ca8ee25
--- /dev/null
+++ b/arch/arm/include/asm/arch-npcm750/gpio.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright 2015 Xilinx, Inc.
+ *
+ * SPDX-License-Identifier:      GPL-2.0+
+ */
+
+#ifndef __ARCH_NPCM750_GPIO_H
+#define __ARCH_NPCM750_GPIO_H
+
+/* Empty file - sdhci requires this. */
+
+#endif
diff --git a/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h b/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
new file mode 100755
index 0000000..2eb234b
--- /dev/null
+++ b/arch/arm/include/asm/arch-npcm750/npcm750_sdhci.h
@@ -0,0 +1,13 @@
+/*
+ * (C) Copyright 2014 - 2015 Xilinx, Inc.
+ * Michal Simek <michal.simek@xilinx.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _ASM_ARCH_NPCM750_SDHCI_H
+#define _ASM_ARCH_NPCM750_SDHCI_H
+
+int npcmx50_mmc_init(void);
+
+#endif /* _ASM_ARCH_NPCM750_SDHCI_H */
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
old mode 100644
new mode 100755
index d51be0b..f035a37
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -262,6 +262,9 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_TERASTATION_PRO2     1584
 #define MACH_TYPE_LINKSTATION_PRO      1585
 #define MACH_TYPE_E350                 1596
+#define MACH_TYPE_WPCM450              1597
+#define MACH_TYPE_NPCM650              1598
+#define MACH_TYPE_NPCM750              1599
 #define MACH_TYPE_TS409                1601
 #define MACH_TYPE_CM_X300              1616
 #define MACH_TYPE_AT91SAM9G20EK        1624
@@ -4108,6 +4111,42 @@ extern unsigned int __machine_arch_type;
 # define machine_is_e350()	(0)
 #endif
 
+#ifdef CONFIG_MACH_WPCM450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WPCM450
+# endif
+# define machine_is_wpcm450()	(machine_arch_type == MACH_TYPE_WPCM450)
+#else
+# define machine_is_wpcm450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NPCM650
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NPCM650
+# endif
+# define machine_is_npcm650()	(machine_arch_type == MACH_TYPE_NPCM650)
+#else
+# define machine_is_npcm650()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NPCM750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NPCM750
+# endif
+# define machine_is_npcm750()	(machine_arch_type == MACH_TYPE_NPCM750)
+#else
+# define machine_is_npcm750()	(0)
+#endif
+
 #ifdef CONFIG_MACH_TS409
 # ifdef machine_arch_type
 #  undef machine_arch_type
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
old mode 100644
new mode 100755
index cfc7834..6586f2f
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -219,7 +219,7 @@ static inline void set_dacr(unsigned int val)
 	isb();
 }
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)
 /* Short-Descriptor Translation Table Level 1 Bits */
 #define TTB_SECT_NS_MASK	(1 << 19)
 #define TTB_SECT_NG_MASK	(1 << 17)
@@ -256,7 +256,7 @@ enum {
 	MMU_SECTION_SIZE	= 1 << MMU_SECTION_SHIFT,
 };
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)   // Trego - need to check the following TLB change
 /* TTBR0 bits */
 #define TTBR0_BASE_ADDR_MASK	0xFFFFC000
 #define TTBR0_RGN_NC			(0 << 3)
diff --git a/arch/arm/lib/Makefile b/arch/arm/lib/Makefile
old mode 100644
new mode 100755
index 2bdfaba..64b4b37
--- a/arch/arm/lib/Makefile
+++ b/arch/arm/lib/Makefile
@@ -22,6 +22,10 @@ obj-y	+= relocate_64.o
 else
 obj-y	+= relocate.o
 endif
+#Trego- UBOOT Relocation old way (for Now)
+ifndef CONFIG_SYS_GENERIC_BOARD
+obj-y	+= board.o
+endif
 
 obj-$(CONFIG_CPU_V7M) += cmd_boot.o
 obj-$(CONFIG_OF_LIBFDT) += bootm-fdt.o
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
new file mode 100755
index 0000000..5106d43
--- /dev/null
+++ b/arch/arm/lib/board.c
@@ -0,0 +1,698 @@
+/*
+ * (C) Copyright 2002-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * To match the U-Boot user interface on ARM platforms to the U-Boot
+ * standard (as on PPC platforms), some messages with debug character
+ * are removed from the default U-Boot build.
+ *
+ * Define DEBUG here if you want additional info as shown below
+ * printed upon startup:
+ *
+ * U-Boot code: 00F00000 -> 00F3C774  BSS: -> 00FC3274
+ * IRQ Stack: 00ebff7c
+ * FIQ Stack: 00ebef7c
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <malloc.h>
+#include <stdio_dev.h>
+#include <version.h>
+#include <net.h>
+#include <serial.h>
+#include <nand.h>
+#include <onenand_uboot.h>
+#include <mmc.h>
+#include <scsi.h>
+#include <status_led.h>
+#include <libfdt.h>
+#include <fdtdec.h>
+#include <post.h>
+#include <logbuff.h>
+#include <asm/sections.h>
+
+#ifdef CONFIG_BITBANGMII
+#include <miiphy.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ulong monitor_flash_len;
+
+#ifdef CONFIG_HAS_DATAFLASH
+extern int  AT91F_DataflashInit(void);
+extern void dataflash_print_info(void);
+#endif
+
+#if defined(CONFIG_HARD_I2C) || \
+	defined(CONFIG_SYS_I2C)
+#include <i2c.h>
+#endif
+
+/************************************************************************
+ * Coloured LED functionality
+ ************************************************************************
+ * May be supplied by boards if desired
+ */
+__weak void coloured_LED_init(void) {}
+__weak void red_led_on(void) {}
+__weak void red_led_off(void) {}
+__weak void green_led_on(void) {}
+__weak void green_led_off(void) {}
+__weak void yellow_led_on(void) {}
+__weak void yellow_led_off(void) {}
+__weak void blue_led_on(void) {}
+__weak void blue_led_off(void) {}
+
+/*
+ ************************************************************************
+ * Init Utilities							*
+ ************************************************************************
+ * Some of this code should be moved into the core functions,
+ * or dropped completely,
+ * but let's get it working (again) first...
+ */
+
+#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
+#define CONFIG_BAUDRATE 115200
+#endif
+
+static int init_baudrate(void)
+{
+	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
+	return 0;
+}
+
+static int display_banner(void)
+{
+	printf("\n\n%s\n\n", version_string);
+	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	       (ulong)&_start,
+	       (ulong)&__bss_start, (ulong)&__bss_end);
+#ifdef CONFIG_MODEM_SUPPORT
+	debug("Modem Support enabled\n");
+#endif
+#ifdef CONFIG_USE_IRQ
+	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
+	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
+#endif
+
+	return (0);
+}
+
+/*
+ * WARNING: this code looks "cleaner" than the PowerPC version, but
+ * has the disadvantage that you either get nothing, or everything.
+ * On PowerPC, you might see "DRAM: " before the system hangs - which
+ * gives a simple yet clear indication which part of the
+ * initialization if failing.
+ */
+static int display_dram_config(void)
+{
+	int i;
+	
+    dram_init_banksize();
+
+#ifdef DEBUG
+	puts("RAM Configuration:\n");
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		printf("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
+		print_size(gd->bd->bi_dram[i].size, "\n");
+	}
+#else
+	ulong size = 0;
+
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		size += gd->bd->bi_dram[i].size;
+
+	puts("DRAM:  ");
+	print_size(size, "\n");
+#endif
+
+	return (0);
+}
+
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
+static int init_func_i2c(void)
+{
+	puts("I2C:   ");
+#ifdef CONFIG_SYS_I2C
+	i2c_init_all();
+#else
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+#endif
+	puts("ready\n");
+	return (0);
+}
+#endif
+
+#if defined(CONFIG_CMD_PCI) || defined (CONFIG_PCI)
+#include <pci.h>
+static int arm_pci_init(void)
+{
+	pci_init();
+	return 0;
+}
+#endif /* CONFIG_CMD_PCI || CONFIG_PCI */
+
+/*
+ * Breathe some life into the board...
+ *
+ * Initialize a serial port as console, and carry out some hardware
+ * tests.
+ *
+ * The first part of initialization is running from Flash memory;
+ * its main purpose is to initialize the RAM so that we
+ * can relocate the monitor code to RAM.
+ */
+
+/*
+ * All attempts to come up with a "common" initialization sequence
+ * that works for all boards and architectures failed: some of the
+ * requirements are just _too_ different. To get rid of the resulting
+ * mess of board dependent #ifdef'ed code we now make the whole
+ * initialization sequence configurable to the user.
+ *
+ * The requirements for any new initalization function is simple: it
+ * receives a pointer to the "global data" structure as it's only
+ * argument, and returns an integer return code, where 0 means
+ * "continue" and != 0 means "fatal error, hang the system".
+ */
+typedef int (init_fnc_t) (void);
+
+__weak void dram_init_banksize(void)
+{
+    gd->bd->bi_dram[0].start    = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size     = PHYS_SDRAM_1_SIZE;
+
+    gd->bd->bi_dram[1].start    = PHYS_SDRAM_2;
+    gd->bd->bi_dram[1].size     = gd->ram_size;
+}
+
+__weak int arch_cpu_init(void)
+{
+	return 0;
+}
+
+__weak int power_init_board(void)
+{
+	return 0;
+}
+
+	/* Record the board_init_f() bootstage (after arch_cpu_init()) */
+static int mark_bootstage(void)
+{
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");
+
+	return 0;
+}
+
+init_fnc_t *init_sequence_ram[] = {
+	arch_cpu_init,		/* basic arch cpu dependent setup */
+	mark_bootstage,
+#ifdef CONFIG_OF_CONTROL
+	fdtdec_check_fdt,
+#endif
+#if defined(CONFIG_BOARD_EARLY_INIT_F)
+	board_early_init_f,
+#endif
+	interrupt_init,         // Trego - Include timer_init
+#ifdef CONFIG_BOARD_POSTCLK_INIT
+	board_postclk_init,
+#endif
+#ifdef CONFIG_FSL_ESDHC
+	get_clocks,
+#endif
+	env_init,		/* initialize environment */
+	init_baudrate,		/* initialze baudrate settings */
+	serial_init,		/* serial communications setup */
+	console_init_f,		/* stage 1 init of console */
+	display_banner,		/* say that we are here */
+#if defined(CONFIG_DISPLAY_CPUINFO)
+	print_cpuinfo,		/* display cpu info (and speed) */
+#endif
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+	checkboard,		/* display board info */
+#endif
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SYS_I2C)
+	init_func_i2c,
+#endif
+	display_dram_config,	/* configure available RAM banks and display it */
+	NULL,
+};
+
+void board_init_f(ulong bootflag)
+{
+	bd_t *bd;
+	gd_t *id;
+	ulong addr, addr_sp;
+#ifdef CONFIG_PRAM
+	ulong reg;
+#endif
+	void *new_fdt = NULL;
+	size_t fdt_size = 0;
+
+	memset((void *)gd, 0, sizeof(gd_t));
+
+	gd->mon_len = (ulong)&__bss_end - (ulong)_start;
+#ifdef CONFIG_OF_EMBED
+	/* Get a pointer to the FDT */
+	gd->fdt_blob = __dtb_dt_begin;
+#elif defined CONFIG_OF_SEPARATE
+	/* FDT is at end of image */
+	gd->fdt_blob = &_end;
+#endif
+ 
+    dram_init();
+
+#ifdef CONFIG_OF_CONTROL
+	/* For now, put this check after the console is ready */
+	if (fdtdec_prepare_fdt()) {
+		panic("** CONFIG_OF_CONTROL defined but no FDT - please see "
+			"doc/README.fdt-control");
+	}
+#endif
+
+//	debug("monitor len: %08lX\n", gd->mon_len);
+	/*
+	 * Ram is setup, size stored in gd !!
+	 */
+//	debug("ramsize: %08lX\n", gd->ram_size);
+#if defined(CONFIG_SYS_MEM_TOP_HIDE)
+	/*
+	 * Subtract specified amount of memory to hide so that it won't
+	 * get "touched" at all by U-Boot. By fixing up gd->ram_size
+	 * the Linux kernel should now get passed the now "corrected"
+	 * memory size and won't touch it either. This should work
+	 * for arch/ppc and arch/powerpc. Only Linux board ports in
+	 * arch/powerpc with bootwrapper support, that recalculate the
+	 * memory size from the SDRAM controller setup will have to
+	 * get fixed.
+	 */
+	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
+#endif
+
+	addr = CONFIG_SYS_SDRAM_BASE + get_effective_memsize();
+
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+	/* reserve kernel log buffer */
+	addr -= (LOGBUFF_RESERVE);
+//	debug("Reserving %dk for kernel logbuffer at %08lx\n", LOGBUFF_LEN,
+//		addr);
+#endif
+#endif
+
+#ifdef CONFIG_PRAM
+	/*
+	 * reserve protected RAM
+	 */
+	reg = getenv_ulong("pram", 10, CONFIG_PRAM);
+	addr -= (reg << 10);		/* size is in kB */
+//	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
+#endif /* CONFIG_PRAM */
+
+#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
+	/* reserve TLB table */
+	gd->arch.tlb_size = PGTABLE_SIZE;
+	addr -= gd->arch.tlb_size;
+
+	/* round down to next 64 kB limit */
+	addr &= ~(0x10000 - 1);
+
+	gd->arch.tlb_addr = addr;
+//	debug("TLB table from %08lx to %08lx\n", addr, addr + gd->arch.tlb_size);
+#endif
+
+	/* round down to next 4 kB limit */
+	addr &= ~(4096 - 1);
+//	debug("Top of RAM usable for U-Boot at: %08lx\n", addr);
+
+#ifdef CONFIG_LCD
+#ifdef CONFIG_FB_ADDR
+	gd->fb_base = CONFIG_FB_ADDR;
+#else
+	/* reserve memory for LCD display (always full pages) */
+	addr = lcd_setmem(addr);
+	gd->fb_base = addr;
+#endif /* CONFIG_FB_ADDR */
+#endif /* CONFIG_LCD */
+
+	/*
+	 * reserve memory for U-Boot code, data & bss
+	 * round down to next 4 kB limit
+	 */
+	addr -= gd->mon_len;
+	addr &= ~(4096 - 1);
+    addr += CONFIG_SYS_TEXT_BASE & 0xFF;     // Trego - Keep original alignments since we relocate from CONFIG_SYS_TEXT_BASE
+
+//	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10, addr);
+
+#ifndef CONFIG_SPL_BUILD
+	/*
+	 * reserve memory for malloc() arena
+	 */
+	addr_sp = addr - TOTAL_MALLOC_LEN;
+//	debug("Reserving %dk for malloc() at: %08lx\n",
+//			TOTAL_MALLOC_LEN >> 10, addr_sp);
+	/*
+	 * (permanently) allocate a Board Info struct
+	 * and a permanent copy of the "global" data
+	 */
+	addr_sp -= sizeof (bd_t);
+	bd = (bd_t *) addr_sp;
+	gd->bd = bd;
+//	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
+//			sizeof (bd_t), addr_sp);
+
+#ifdef CONFIG_MACH_TYPE
+	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
+#endif
+
+	addr_sp -= sizeof (gd_t);
+	id = (gd_t *) addr_sp;
+//	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
+//			sizeof (gd_t), addr_sp);
+
+#if defined(CONFIG_OF_SEPARATE) && defined(CONFIG_OF_CONTROL)
+	/*
+	 * If the device tree is sitting immediate above our image then we
+	 * must relocate it. If it is embedded in the data section, then it
+	 * will be relocated with other data.
+	 */
+	if (gd->fdt_blob) {
+		fdt_size = ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32);
+
+		addr_sp -= fdt_size;
+		new_fdt = (void *)addr_sp;
+//		debug("Reserving %zu Bytes for FDT at: %08lx\n",
+//		      fdt_size, addr_sp);
+	}
+#endif
+
+#ifndef CONFIG_ARM64
+	/* setup stackpointer for exeptions */
+	gd->irq_sp = addr_sp;
+#ifdef CONFIG_USE_IRQ
+	addr_sp -= (CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ);
+//	debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
+//		CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ, addr_sp);
+#endif
+	/* leave 3 words for abort-stack    */
+	addr_sp -= 12;
+
+	/* 8-byte alignment for ABI compliance */
+	addr_sp &= ~0x07;
+#else	/* CONFIG_ARM64 */
+	/* 16-byte alignment for ABI compliance */
+	addr_sp &= ~0x0f;
+#endif	/* CONFIG_ARM64 */
+#else
+	addr_sp += 128;	/* leave 32 words for abort-stack   */
+	gd->irq_sp = addr_sp;
+#endif
+
+//	debug("New Stack Pointer is: %08lx\n", addr_sp);
+
+#ifdef CONFIG_POST
+	post_bootmode_init();
+	post_run(NULL, POST_ROM | post_bootmode_get(0));
+#endif
+
+	/* Ram ist board specific, so move it to board code ... */
+
+	gd->relocaddr = addr;
+	gd->start_addr_sp = addr_sp;
+	gd->reloc_off = addr - (ulong)&_start;
+//	debug("relocation Offset is: %08lx\n", gd->reloc_off);
+	if (new_fdt) {
+		memcpy(new_fdt, gd->fdt_blob, fdt_size);
+		gd->fdt_blob = new_fdt;
+	}
+	memcpy(id, (void *)gd, sizeof(gd_t));
+}
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+static char *failed = "*** failed ***\n";
+#endif
+
+/*
+ * Tell if it's OK to load the environment early in boot.
+ *
+ * If CONFIG_OF_CONFIG is defined, we'll check with the FDT to see
+ * if this is OK (defaulting to saying it's not OK).
+ *
+ * NOTE: Loading the environment early can be a bad idea if security is
+ *       important, since no verification is done on the environment.
+ *
+ * @return 0 if environment should not be loaded, !=0 if it is ok to load
+ */
+static int should_load_env(void)
+{
+#ifdef CONFIG_OF_CONTROL
+	return fdtdec_get_config_int(gd->fdt_blob, "load-environment", 1);
+#elif defined CONFIG_DELAY_ENVIRONMENT
+	return 0;
+#else
+	return 1;
+#endif
+}
+
+#if defined(CONFIG_DISPLAY_BOARDINFO_LATE) && defined(CONFIG_OF_CONTROL)
+static void display_fdt_model(const void *blob)
+{
+	const char *model;
+
+	model = (char *)fdt_getprop(blob, 0, "model", NULL);
+	printf("Model: %s\n", model ? model : "<unknown>");
+}
+#endif
+
+/************************************************************************
+ *
+ * This is the next part if the initialization sequence: we are now
+ * running from RAM and have a "normal" C environment, i. e. global
+ * data can be written, BSS has been cleared, the stack size in not
+ * that critical any more, etc.
+ *
+ ************************************************************************
+ */
+
+void board_init_r(gd_t *id, ulong dest_addr)
+{
+	ulong malloc_start;
+#if !defined(CONFIG_SYS_NO_FLASH)
+	ulong flash_size;
+#endif
+	init_fnc_t **init_fnc_ptr;
+
+	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
+	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");
+
+	/* Allow the early environment to override the fdt address */
+	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
+						(uintptr_t)gd->fdt_blob);
+
+	for (init_fnc_ptr = init_sequence_ram; *init_fnc_ptr; ++init_fnc_ptr) {
+		if ((*init_fnc_ptr)() != 0) {
+			hang ();
+		}
+	}
+
+	monitor_flash_len = (ulong)&__rel_dyn_end - (ulong)_start;
+
+	/* Enable caches */
+	enable_caches();
+
+	debug("monitor flash len: %08lX\n", monitor_flash_len);
+	board_init();	/* Setup chipselects */
+	/*
+	 * TODO: printing of the clock inforamtion of the board is now
+	 * implemented as part of bdinfo command. Currently only support for
+	 * davinci SOC's is added. Remove this check once all the board
+	 * implement this.
+	 */
+#ifdef CONFIG_CLOCKS
+	set_cpu_clk_info(); /* Setup clock information */
+#endif
+	serial_initialize();
+
+	debug("Now running in RAM - U-Boot at: %08lx\n", dest_addr);
+
+#ifdef CONFIG_LOGBUFFER
+	logbuff_init_ptrs();
+#endif
+#ifdef CONFIG_POST
+	post_output_backlog();
+#endif
+
+	/* The Malloc area is immediately below the monitor copy in DRAM */
+	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
+
+#ifdef CONFIG_ARCH_EARLY_INIT_R
+	arch_early_init_r();
+#endif
+	power_init_board();
+
+#if !defined(CONFIG_SYS_NO_FLASH)
+	puts("Flash: ");
+
+	flash_size = flash_init();
+	if (flash_size > 0) {
+# ifdef CONFIG_SYS_FLASH_CHECKSUM
+		print_size(flash_size, "");
+		/*
+		 * Compute and print flash CRC if flashchecksum is set to 'y'
+		 *
+		 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
+		 */
+		if (getenv_yesno("flashchecksum") == 1) {
+			printf("  CRC: %08X", crc32(0,
+				(const unsigned char *) CONFIG_SYS_FLASH_BASE,
+				flash_size));
+		}
+		putc('\n');
+# else	/* !CONFIG_SYS_FLASH_CHECKSUM */
+		print_size(flash_size, "\n");
+# endif /* CONFIG_SYS_FLASH_CHECKSUM */
+	} else {
+		puts(failed);
+		hang();
+	}
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+	puts("NAND:  ");
+	nand_init();		/* go init the NAND */
+#endif
+
+#if defined(CONFIG_CMD_ONENAND)
+	onenand_init();
+#endif
+
+
+#ifdef CONFIG_HAS_DATAFLASH
+	AT91F_DataflashInit();
+	dataflash_print_info();
+#endif
+
+	/* initialize environment */
+	if (should_load_env())
+		env_relocate();
+	else
+		set_default_env(NULL);
+
+#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
+	arm_pci_init();
+#endif
+
+	stdio_init();	/* get the devices list going. */
+
+	jumptable_init();
+
+#if defined(CONFIG_API)
+	/* Initialize API */
+	api_init();
+#endif
+
+	console_init_r();	/* fully init console as a device */
+
+#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
+# ifdef CONFIG_OF_CONTROL
+	/* Put this here so it appears on the LCD, now it is ready */
+	display_fdt_model(gd->fdt_blob);
+# else
+	checkboard();
+# endif
+#endif
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+	/* miscellaneous arch dependent initialisations */
+	arch_misc_init();
+#endif
+#if defined(CONFIG_MISC_INIT_R)
+	/* miscellaneous platform dependent initialisations */
+	misc_init_r();
+#endif
+
+	 /* set up exceptions */
+	interrupt_init();
+	/* enable exceptions */
+	enable_interrupts();
+
+	/* Initialize from environment */
+	load_addr = getenv_ulong("loadaddr", 16, load_addr);
+
+#ifdef CONFIG_BOARD_LATE_INIT
+	board_late_init();
+#endif
+
+// Trego - MMC Must be after enable_interrupts
+#ifdef CONFIG_GENERIC_MMC
+	puts("MMC:   ");
+	mmc_initialize(gd->bd);
+#endif
+
+#ifdef CONFIG_CMD_SCSI
+	puts("SCSI:  ");
+	scsi_init();
+#endif
+
+#ifdef CONFIG_BITBANGMII
+	bb_miiphy_init();
+#endif
+#if defined(CONFIG_CMD_NET)
+	puts("Net:   ");
+	eth_initialize();
+#if defined(CONFIG_RESET_PHY_R)
+	debug("Reset Ethernet PHY\n");
+	reset_phy();
+#endif
+#endif
+
+#ifdef CONFIG_POST
+	post_run(NULL, POST_RAM | post_bootmode_get(0));
+#endif
+
+#if defined(CONFIG_PRAM) || defined(CONFIG_LOGBUFFER)
+	/*
+	 * Export available size of memory for Linux,
+	 * taking into account the protected RAM at top of memory
+	 */
+	{
+		ulong pram = 0;
+		uchar memsz[32];
+
+#ifdef CONFIG_PRAM
+		pram = getenv_ulong("pram", 10, CONFIG_PRAM);
+#endif
+#ifdef CONFIG_LOGBUFFER
+#ifndef CONFIG_ALT_LB_ADDR
+		/* Also take the logbuffer into account (pram is in kB) */
+		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
+#endif
+#endif
+		sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
+		setenv("mem", (char *)memsz);
+	}
+#endif
+
+	/* main_loop() can return to retry autoboot, if so just run it again. */
+	for (;;) {
+		main_loop();
+	}
+
+	/* NOTREACHED - no way out of command loop except booting */
+}
diff --git a/arch/arm/lib/cache-cp15.c b/arch/arm/lib/cache-cp15.c
old mode 100644
new mode 100755
index c65e068..defe9c9
--- a/arch/arm/lib/cache-cp15.c
+++ b/arch/arm/lib/cache-cp15.c
@@ -96,7 +96,7 @@ static inline void mmu_setup(void)
 		dram_bank_mmu_setup(i);
 	}
 
-#ifdef CONFIG_ARMV7
+#if defined (CONFIG_ARMV7) && !defined(NPCM750)     // Trego - need to check the following TLB change
 	/* Set TTBR0 */
 	reg = gd->arch.tlb_addr & TTBR0_BASE_ADDR_MASK;
 #if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
diff --git a/arch/arm/lib/cache-pl310.c b/arch/arm/lib/cache-pl310.c
old mode 100644
new mode 100755
index 1ad1f8a..a1fe32d
--- a/arch/arm/lib/cache-pl310.c
+++ b/arch/arm/lib/cache-pl310.c
@@ -39,6 +39,11 @@ static void pl310_background_op_all_ways(u32 *op_reg)
 	pl310_cache_sync();
 }
 
+void set_pl310_ctrl(u32 enable)
+{
+	writel(enable, &pl310->pl310_ctrl);
+}
+
 void v7_outer_cache_inval_all(void)
 {
 	pl310_background_op_all_ways(&pl310->pl310_inv_way);
diff --git a/board/nuvoton/HermonSVB/HermonSVB_init.c b/board/nuvoton/HermonSVB/HermonSVB_init.c
new file mode 100755
index 0000000..282ccfb
--- /dev/null
+++ b/board/nuvoton/HermonSVB/HermonSVB_init.c
@@ -0,0 +1,63 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+
+    printf("RomCode : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+
+    return 0;
+}
+
+
+
diff --git a/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S b/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
new file mode 100755
index 0000000..39749b4
--- /dev/null
+++ b/board/nuvoton/HermonSVB/HermonSVB_low_level_init.S
@@ -0,0 +1,800 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_low_level_init.S                                                                            */
+/*            This file contains WPCM450 low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include <config.h>
+#include <version.h>
+
+
+
+
+
+
+.globl board_lowlevel_init
+board_lowlevel_init:
+
+/*      
+;----------------------------------------------------------
+; Disable Interrupt, This is for safe ...
+;----------------------------------------------------------
+*/
+    LDR     r0, =AIC_MDCR
+    LDR     r1, =AIC_MASKALL
+    STR     r1, [r0]
+    MRS     r0, CPSR
+    ORR     r0, r0, #0xC0
+    MSR     CPSR_c, r0
+
+/*
+;----------------------------------------------------------
+; Set mode to SVC, interrupts disabled (just paranoid)
+;----------------------------------------------------------
+*/
+    MRS   r0, cpsr
+    BIC   r0, r0, #0xF0000000
+    BIC   r0, r0, #0x1F
+    ORR   r0, r0, #0xD3
+    MSR   cpsr_fc, r0
+
+    
+/*
+;----------------------------------------------------------
+; If Watchdog Reset was set and code arrive to this point
+; that mean FIU work properly . In this case flag bit in 
+; INTCR2 register and Watchdog Register must be reset to
+; to default values.
+;----------------------------------------------------------
+*/
+    LDR   r0, =TMR_WTCR
+    LDR   r1, [r0]
+    TST   r1, #0x2
+    BEQ   _POR_Reset_Detect
+    MOV   r1, #0x400
+    STR   r1, [r0]
+    LDR   r0, =GCR_INTCR2
+    LDR   r1, [r0]
+    BIC   r1, r1, #0x80000000
+    STR   r1, [r0]
+
+    
+    
+_POR_Reset_Detect:      
+/*
+;----------------------------------------------------------     
+; If (INTCR2.30 == 0)   can be 0 only after POR reset
+;       INTCR2.29 = 1;      coming from POR reset
+; else
+;       INTCR2.29 = 0;      coming from Watchdog/Software reset
+; INTCR2.30 = 1;        set the indication that will be cleared only at POR reset
+;----------------------------------------------------------
+*/
+
+    LDR   r0,=GCR_INTCR2
+    LDR   r1,[r0]
+    TST   r1,#0x40000000
+    ORREQ r1,r1,#0x20000000
+    BICNE r1,r1,#0x20000000
+    ORR   r1,r1, #0x40000000
+
+
+/*
+;----------------------------------------------------------     
+;Stack initialisation
+;----------------------------------------------------------
+*/
+    MSR   CPSR_c, #Mode_SYS | F_Bit 
+    LDR   sp, = top_of_usr_stack 
+
+    LDR   r0, = Top_Of_Stacks 
+      
+    MSR   CPSR_c, #Mode_FIQ | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_FIQ_Stack 
+
+    MSR   CPSR_c, #Mode_IRQ | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_IRQ_Stack 
+
+    MSR   CPSR_c, #Mode_ABT | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_ABT_Stack 
+
+    MSR   CPSR_c, #Mode_UND | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_UND_Stack 
+
+    MSR   CPSR_c, #Mode_SVC | I_Bit | F_Bit 
+    SUB   sp, r0, #Offset_SVC_Stack 
+
+
+    MOV   r0,pc
+    AND   r0,r0,#0x40000000
+    CMP   r0,#0
+    BEQ   mc_init_end
+    
+/************************************************************************/
+/*   Init Clocks                                                        */
+/************************************************************************/
+
+        
+/************************************************************************/
+/*  Read STRAP clock configuration                                      */
+/************************************************************************/
+/* idx1 = GET_FIELD(power_cfg, PWRON_CPU_CORE_CLK);                     */
+/************************************************************************/
+    LDR   r8, =GCR_BA
+	/* if clock source is not 48MHz, skip initialization as it
+	   was done by ROM code */
+	LDR   r1, [r8, #0x204]
+	mov   r1, r1, lsl #29
+	mov   r1, r1, lsr #29
+	mov   r2, #0x2
+	cmp   r1, r2
+	bne   end_clk_init
+    LDR   r0,[r8,#4]             /* Read PWRON register */
+    MOVS  r2, r0, LSL #21
+    MOVS  r2, r2, LSR #29
+          
+           
+/************************************************************************/    
+/* if(idx1 != CLK_BYPASS_MODE)                                          */
+/************************************************************************/
+    BEQ      clk_bypass_mode_init
+
+    ADD      r7,pc,#0
+    B        clk_init_func
+/************************************************************************/
+/* PLL Clock Divider + PLLCON configurayion values                      */
+/************************************************************************/
+clk_div_pll0con_reg_val:
+.word  CLK_180MHZ_DIV_REG_CFG, CLK_180MHZ_PLLCON_REG_CFG
+.word  CLK_133MHZ_DIV_REG_CFG, CLK_133MHZ_PLLCON_REG_CFG
+.word  CLK_250MHZ_DIV_REG_CFG, CLK_250MHZ_PLLCON_REG_CFG
+.word  CLK_160MHZ_DIV_REG_CFG, CLK_250MHZ_PLLCON_REG_CFG
+.word  CLK_220MHZ_DIV_REG_CFG, CLK_220MHZ_PLLCON_REG_CFG
+.word  CLK_125MHZ_DIV_REG_CFG, CLK_125MHZ_PLLCON_REG_CFG
+.word  CLK_200MHZ_DIV_REG_CFG, CLK_200MHZ_PLLCON_REG_CFG
+
+clk_init_func:
+/***********************************************************************
+ *                                                                     *
+ *   Clock configuration arrays not contain                            *
+ *   BY_PASS mode configuration values                                 *
+ *   idx1 -= 1;                                                        *
+ ***********************************************************************/
+
+    SUB      r4,r2,#1
+
+/************************************************************************/
+/*   SET_BIT(CLK_PLLCON0,CLK_PRST_BIT);                                 */
+/************************************************************************/
+;
+;	LDR   r2, [r8, #0x20c]
+;	orr   r2, r2, #0x2000
+;	str   r2, [r8, #0x20c]
+;
+
+/************************************************************************/          
+/*   CLK_PLLCON0 = CLK_PLLCON_REG_Val[idx1];                            */
+/************************************************************************/
+    ADD      r9,r7,#4
+    LDR      r2,[r9,r4,LSL #3]
+    STR      r2,[r8,#0x20c]
+          
+    
+/************************************************************************/  
+/*   Wait Loop                                                          */
+/*   WAIT_DELAY(idx2, DELAY_10_MICRO_SEC);                              */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#20
+wait_pll0_10micro:
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_pll0_10micro
+         
+/************************************************************************/          
+/*   CLEAR_BIT(CLK_PLLCON0,CLK_PRST_BIT);                               */
+/************************************************************************/
+    LDR      r1,[r8,#0x20c]
+    BIC      r1,r1,#0x2000
+    STR      r1,[r8,#0x20c]
+          
+/************************************************************************/   
+/*   Wait Loop                                                          */
+/*   WAIT_DELAY(idx2, DELAY_500_MICRO_SEC);                             */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#1000
+wait_resset_500micro:
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_resset_500micro
+          
+    
+      
+/************************************************************************/
+/* Set clock divider accordingly setted PLL configuration               */
+/************************************************************************/
+/*   CLK_DIV     = CLK_DIV_REG_Val[idx1];                               */
+/************************************************************************/
+    LDR      r1,[r7,r4,LSL #3]
+    STR      r1,[r8,#0x208]
+
+/************************************************************************/    
+/*   Wait Loop 200 cycles                                               */
+/*   WAIT_DELAY(idx2, DELAY_10_MICRO_SEC);                              */
+/************************************************************************/
+    MOV      r1,#0
+    MOV      r2,#20
+wait_div_10micro:      
+    CMP      r2,r1
+    ADDHI    r1,r1,#1
+    BHI      wait_div_10micro
+          
+            
+/************************************************************************/
+/* Set clock sources selection to PLLCON0                               */
+/************************************************************************/
+/*   SET_FIELD(CLK_SEL,CLK_CPU_CLK, CLK_PLL0_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#3
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/*   SET_FIELD(CLK_SEL,CLK_CPU_OUT, CLK_PLL0_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1, r1, #0xc
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/*   SET_FIELD(CLK_SEL,CLK_PIX_SRC, CLK_PIX_PLL_GFX_SEL );              */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#0x30
+    STR      r1, [r8, #0x204]
+
+    B        end_clk_init
+
+clk_bypass_mode_init:
+
+/************************************************************************/
+/* By pass mode                                                         */
+/* Bypass mode: Core clock from reference clock PWM3/GPIO83 pin as      */
+/* input and pixel clock from GPI96. Reference clock 24 MHz and the SPI */
+/* clock is 3 MHz by default register values.                           */
+/************************************************************************/
+/*   SET_BIT(MFSEL2, MF_PWM3SEL_BIT);                                   */
+/*   SET_FIELD(CLK_SEL,CLK_CPU_CLK, CLK_PWM3_GPIO83_SRC_SEL);           */
+/*   CLEAR_BIT(MFSEL1, MF_CLKOSEL_BIT);                                 */
+/*   SET_FIELD(CLK_SEL,CLK_PIX_SRC, CLK_PIX_GPI96_SEL );                */
+/************************************************************************/
+           
+    STR      r1,[r8,#0x204]
+/************************************************************************/          
+/* }                                                                    */
+/* SET_FIELD(CLK_SEL,CLK_USB1CKSEL, CLK_PLL1_SRC_SEL );                 */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    BIC      r1,r1,#0xc0
+    ORR      r1,r1,#0x40
+    STR      r1,[r8,#0x204]
+        
+/************************************************************************/
+/* Set HUART clock source to 24Mhz                                      */
+/************************************************************************/
+/*  SET_BIT(CLK_SEL, CLK_HUART_SRC_BIT);                                */
+/************************************************************************/
+    LDR      r1,[r8,#0x204]
+    ORR      r1,r1,#0x400
+    STR      r1,[r8,#0x204]
+
+
+
+    
+end_clk_init:    
+/*
+;----------------------------------------------------------
+; --- Init Memory Controller
+;----------------------------------------------------------
+*/
+    
+/************************************************************************/
+/*  idx1 is RAM size index                                              */
+/************************************************************************/
+/*     idx1 = GET_FIELD(power_cfg, PWRON_RAM_SIZE);                     */
+/************************************************************************/
+    LDR   r8, =GCR_BA
+    LDR   r0,[r8,#4]             /* Read PWRON register */
+    
+    MOV   r2,r0,LSL #28
+    MOV   r1,r2,LSR #30 
+    
+/************************************************************************/
+/* Release memory Controller from reset by                              */
+/* clearing Memory Controller reset bit                                 */
+/************************************************************************/
+/*        if(idx1 == MEM_128MB_MODE)                                    */
+/*        {                                                             */
+/*          SET_BIT(MFSEL1, MF_MBEN_BIT);                               */
+/*        }                                                             */
+/************************************************************************/
+    CMP   r1,#1 
+    LDREQ r2,[r8,#0xc]
+    ORREQ r2,r2,#0x4000000
+    STREQ r2,[r8,#0xc]
+
+/************************************************************************/     
+/*        CLEAR_BIT(CLK_IPSRST,CLK_IPSRST_MC_BIT);                      */
+/************************************************************************/
+    LDR   r9, =CLK_BA
+    LDR   r2,[r9,#0x20]
+    BIC   r2,r2,#0x1000
+    STR   r2,[r9,#0x20]
+
+/************************************************************************/
+/*        Wait Loop  500 micro sec                                      */
+/************************************************************************/
+
+    MOV   r2,#0
+    
+start_wait_loop:
+   CMP      r2,#0x500
+   ADD      r2,r2,#1
+   BNE      start_wait_loop
+
+
+/************************************************************************/
+/*  Save MC Config Table base Addr                                      */
+/************************************************************************/
+   ADD      r7,pc,#0
+   B        mc_init_func
+
+
+   
+mc_128M_cfg:
+
+         /* 180 MHz    133 MHz     250 MHz     160MHz      220 MHz     125MHz      200 MHz  */
+.word    0x241B457C, 0x2312240E, 0x3624079E, 0x239AA4E0, 0x362406B4, 0x231223CE, 0x241B4618
+.word    0x22162323, 0x21162223, 0x22162424, 0x22162323, 0x22162424, 0x21162223, 0x22162323
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0xA,        0x7,        0xD,        0x8,        0xD,        0x7,        0xA
+.word    0x00190202
+.word    0x00000000
+.word    0x00000001
+.word    0x00000023
+.word    0x00000005
+.word    0x2A,       0x1E,       0x30,       0x24,       0x30,       0x1E,       0x2A
+.word    0x00000001
+.word    0x00000064
+.word    0x00000000
+.word    0x00000064
+.word    0x00000000
+.word    0x000001B8
+.word    0x00000005
+.word    0x0000000C
+.word    0x00000000
+.word    0x00000002
+.word    0x00000002
+.word    0x00000004
+.word    0x00000004
+.word    0x00010106
+.word    0x00000106
+    
+mc_64M_cfg:
+
+    /* 180 MHz     133 MHz     250 MHz     160MHz      220 MHz    125MHz      200 MHz  */
+.word    0x241AA57C, 0x2311C40E, 0x3623679E, 0x239A24E0, 0x362366B4, 0x2311C3CE, 0x241AA618
+.word    0x22122323, 0x21122223, 0x22122424, 0x22122323, 0x22122424, 0x21122223, 0x22122323
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0xA,        0x7,        0xD,        0x8,        0xD,        0x7,        0xA 
+.word    0x550202
+.word    0x0
+.word    0x1
+.word    0x23
+.word    0x5
+.word    0x2A,       0x1E,       0x30,       0x24,       0x30,       0x1E,       0x2A
+.word    0x1
+.word    0x64
+.word    0x0
+.word    0x64
+.word    0x0
+.word    0x1B8
+.word    0x5
+.word    0xC
+.word    0x0
+.word    0x2
+.word    0x2
+.word    0x4
+.word    0x4
+.word    0x00010106
+.word    0x00000106
+    
+mc_32M_cfg:
+
+.word    /*180 MHz     133 MHz     250 MHz     160MHz      220 MHz     125MHz      200 MHz   */
+.word    0x249B857C, 0x2312A40E, 0x3624E79E, 0x241B24E0, 0x352466B4, 0x231283CE, 0x249BE618
+.word    0x220E2324, 0x210E2224, 0x220E2424, 0x220E2324, 0x220E2424, 0x110E2224, 0x220E2324
+.word    0x40000643, 0x40000443, 0x40000843, 0x40000643, 0x40000843, 0x40000443, 0x40000643
+.word    0x6
+.word    0x9,        0x7,        0xD,        0x8,        0xB,        0x7,        0xA
+.word    0x310202
+.word    0x0
+.word    0x1
+.word    0x23
+.word    0x5
+.word    0x30,       0x1E,       0x30,       0x24,       0x30,       0x1E,      0x30
+.word    0x1
+.word    0x64
+.word    0x0
+.word    0x64
+.word    0x0
+.word    0x1B8
+.word    0x5
+.word    0xC
+.word    0x0
+.word    0x2
+.word    0x2
+.word    0x4
+.word    0x4
+.word    0x00010106
+.word    0x00000106
+
+
+mc_init_func:          
+/************************************************************************/
+/*  idx2 is clock frequency index                                       */
+/************************************************************************/
+/* idx2 = GET_FIELD(power_cfg, PWRON_CPU_CORE_CLK);                     */
+/*  idx2 -= 1;    Clock Bypass Mode not present in Config table         */
+
+    MOV   r2,r0,LSL #21              /* Get STRAP 9-11 value bits 8-10 */
+    MOV   r2,r2,LSR #29
+    SUB   r2,r2,#1
+
+    CMP   r1,#RAM_SIZE_128M
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+
+    CMP   r1,#RAM_SIZE_64M
+    ADDEQ r7, r7, #0xe0
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+
+    CMP   r1,#RAM_SIZE_32M
+    ADDEQ r7, r7, #0x1c0
+    MOVEQ r3, r7
+    BEQ   start_mc_init
+        
+    MOV   r3, #mc_128M_cfg
+    
+start_mc_init:
+
+    LDR   r6, =MC_BA       /* r6 - base address MC Configuration registers */
+    ADD   r5,r3,r2,LSL #2  /* idx2 *= 4; create clock index shift value */
+
+
+/************************************************************************/
+/*        MC_CFG0     = MC_Cfg[idx1].mc_cfg0[idx2];                     */
+/************************************************************************/
+    LDR      r4,[r5,#0]
+    STR      r4,[r6,#0]
+/************************************************************************/
+/*        MC_CFG1     = MC_Cfg[idx1].mc_cfg1[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x1c]
+    STR      r4,[r6,#4]
+/************************************************************************/
+/*        MC_CFG2     = MC_Cfg[idx1].mc_cfg2[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x38]
+    STR      r4,[r6,#8]
+/************************************************************************/
+/*        MC_CFG3     = MC_Cfg[idx1].mc_cfg3;
+/************************************************************************/
+    LDR      r4,[r3,#0x54]
+    STR      r4,[r6,#0xc]
+/************************************************************************/
+/*        MC_CFG4     = MC_Cfg[idx1].mc_cfg4[idx2];
+/************************************************************************/
+    LDR      r4,[r5,#0x58]
+    STR      r4,[r6,#0x10]
+/************************************************************************/
+/*        MC_CFG5     = MC_Cfg[idx1].mc_cfg5;
+/************************************************************************/
+    LDR      r4,[r3,#0x74]
+    STR      r4,[r6,#0x14]
+/************************************************************************/
+/*        MC_CFG6     = MC_Cfg[idx1].mc_cfg6;
+/************************************************************************/
+    LDR      r4,[r3,#0x78]
+    STR      r4,[r6,#0x18]
+/************************************************************************/
+/*        MC_P1_ARBT  = MC_Cfg[idx1].mc_p1_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0x80]
+    STR      r4,[r6,#0x24]
+/************************************************************************/
+/*        MC_P1_CNT   = MC_Cfg[idx1].mc_p1_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0x84]
+    STR      r4,[r6,#0x20]
+/************************************************************************/
+/*        MC_P2_ARBT  = MC_Cfg[idx1].mc_p2_arbt[idx2];
+/************************************************************************/
+	LDR      r4, [r5, #0x88]
+    STR      r4,[r6,#0x2c]
+/************************************************************************/
+/*        MC_P2_CNT   = MC_Cfg[idx1].mc_p2_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xa4]
+    STR      r4,[r6,#0x28]
+/************************************************************************/
+/*        MC_P3_ARBT  = MC_Cfg[idx1].mc_p3_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xa8]
+    STR      r4,[r6,#0x34]
+/************************************************************************/
+/*        MC_P3_CNT   = MC_Cfg[idx1].mc_p3_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xac]
+    STR      r4,[r6,#0x30]
+/************************************************************************/
+/*        MC_P4_ARBT  = MC_Cfg[idx1].mc_p4_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb0]
+    STR      r4,[r6,#0x3c]
+/************************************************************************/
+/*        MC_P4_CNT   = MC_Cfg[idx1].mc_p4_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb4]
+    STR      r4,[r6,#0x38]
+/************************************************************************/
+/*        MC_P5_ARBT  = MC_Cfg[idx1].mc_p5_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xb8]
+    STR      r4,[r6,#0x44]
+/************************************************************************/
+/*        MC_P5_CNT   = MC_Cfg[idx1].mc_p5_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xbc]
+    STR      r4,[r6,#0x40]
+/************************************************************************/
+/*        MC_P6_ARBT  = MC_Cfg[idx1].mc_p6_arbt;
+/************************************************************************/
+	LDR      r4, [r3, #0xc0]
+    STR      r4,[r6,#0x4c]
+/************************************************************************/
+/*        MC_P6_CNT   = MC_Cfg[idx1].mc_p6_cnt;
+/************************************************************************/
+	LDR      r4, [r3, #0xc4]
+    STR      r4,[r6,#0x48]
+/************************************************************************/
+/*        MC_P1_INCRS = MC_Cfg[idx1].mc_p1_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xc8]
+    STR      r4,[r6,#0x50]
+/************************************************************************/
+/*        MC_P2_INCRS = MC_Cfg[idx1].mc_p2_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xcc]
+    STR      r4,[r6,#0x54]
+/************************************************************************/
+/*        MC_P3_INCRS = MC_Cfg[idx1].mc_p3_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xd0]
+    STR      r4,[r6,#0x58]
+/************************************************************************/
+/*        MC_P4_INCRS = MC_Cfg[idx1].mc_p4_incrs;
+/************************************************************************/
+	LDR      r4, [r3, #0xd4]
+    STR      r4,[r6,#0x5c]
+/************************************************************************/
+/*        MC_DLL_0    = MC_Cfg[idx1].mc_dll_0;
+/************************************************************************/
+    LDR      r4,[r3,#0xd4]
+    
+	/* on A1 chip, also set the DQSI_ENDLY bit */
+	LDR   r9, =GCR_BA
+	LDR   r9, [r9]
+	mov   r9, r9, lsr #24
+	mov   r10, #0x8
+	cmp   r9, r10
+	orrge r4, #0x400
+    STR      r4,[r6,#0x60]
+
+/************************************************************************/
+/*        MC_DLL_1    = MC_Cfg[idx1].mc_dll_1;
+/************************************************************************/
+	LDR   r4, [r3, #0xdc]
+    STR      r4,[r6,#0x64] 
+
+
+mc_init_end: 
+/*
+;----------------------------------------------------------
+; Handle Watchdog Reset    
+;----------------------------------------------------------        
+*/
+    LDR      r6, =TIMER_BA     
+    LDR      r4, [r6, #0x1c]
+    TST      r4, #0x2
+    MOVEQ    r4, #0x400 
+    STREQ    r4, [r6, #0x1c]
+   
+   
+/*
+;----------------------------------------------------------
+; Set the high exception vector of CP15 control bit    
+;----------------------------------------------------------        
+*/
+    MRC     p15, 0, r0, c1, c0, 0  /* read control register  */       
+    BIC     r0, r0, #0x2000        /* clear bit 13           */        
+    MCR     p15, 0, r0, c1, c0, 0  /* write control register */
+/*
+;----------------------------------------------------------
+; --- back to arch calling code 
+;----------------------------------------------------------
+*/
+    MOV     pc,     lr
+
+/* the literal pools origin */
+        .ltorg
+
+
+/*----------------------------------------------------------
+ *  WPCS410 platform definitions
+ *----------------------------------------------------------
+ */
+
+/*
+;----------------------------------------------------------
+; --- Standard definitions of mode bits and interrupt (I & F) flags in PSRs
+;----------------------------------------------------------
+*/
+.equ Mode_USR,             0x10
+.equ Mode_FIQ,             0x11
+.equ Mode_IRQ,             0x12
+.equ Mode_SVC,             0x13
+.equ Mode_ABT,             0x17
+.equ Mode_UND,             0x1B
+.equ Mode_SYS,             0x1F /* available on ARM Arch 4 and later*/
+
+.equ I_Bit,                0x80 /* when I bit is set, IRQ is disabled*/
+.equ F_Bit,                0x40 /* when F bit is set, FIQ is disabled*/
+
+/*
+;----------------------------------------------------------
+; --- Stack memory locations
+;----------------------------------------------------------
+*/
+
+/*
+;----------------------------------------------------------
+; Stack's length
+;----------------------------------------------------------
+*/
+.equ Len_FIQ_Stack,             256
+.equ Len_IRQ_Stack,             256
+.equ Len_SVC_Stack,             1024
+.equ Len_ABT_Stack,             256
+.equ Len_UND_Stack,             256
+.equ Len_SYS_Stack,             256
+
+/*
+;----------------------------------------------------------
+; Stack's offset
+;----------------------------------------------------------
+*/
+.equ Offset_FIQ_Stack,    0
+.equ Offset_IRQ_Stack,    Offset_FIQ_Stack + Len_FIQ_Stack 
+.equ Offset_ABT_Stack,    Offset_IRQ_Stack + Len_ABT_Stack  
+.equ Offset_UND_Stack,    Offset_ABT_Stack + Len_UND_Stack  
+.equ Offset_SVC_Stack,    Offset_UND_Stack + Len_SVC_Stack 
+
+.equ Size_Of_Stack,       Offset_SVC_Stack
+  
+      
+/*
+;----------------------------------------------------------
+; AIC Control Registers
+;----------------------------------------------------------
+*/
+.equ AIC_BA,            0xB8002000
+.equ AIC_MDCR,                  AIC_BA+0x124    /* W90P410 AIC Mask Disable Control Register */
+.equ AIC_MASKALL,           0xFFFFFFFE
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ GCR_BA,             0xB0000000
+.equ GCR_INTCR2,         GCR_BA + 0x060 
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ CLK_BA,             0xB0000200
+
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ MC_BA,             0xB0001000
+.equ RAM_SIZE_128M,     0x01
+.equ RAM_SIZE_64M,      0x02
+.equ RAM_SIZE_32M,      0x03
+
+
+/*
+;----------------------------------------------------------
+;
+;----------------------------------------------------------
+*/
+.equ TIMER_BA,             0xB8001000
+.equ TMR_WTCR,             TIMER_BA + 0x01C
+
+
+/*
+;----------------------------------------------------------
+; Stack's base location
+;----------------------------------------------------------
+*/
+
+/*
+    IMPORT      Top_Of_Stacks
+    IMPORT      top_of_usr_stack
+*/
+.equ Top_Of_Stacks,     0x1FF0
+.equ top_of_usr_stack,  0x80000
+
+/************************************************************************/
+/* CLOCK DEVIDERS REGISTER CONFIGURATIONS                               */
+/************************************************************************/
+.equ CLK_125MHZ_DIV_REG_CFG,     0x04010300
+.equ CLK_133MHZ_DIV_REG_CFG,     0x05010200
+.equ CLK_160MHZ_DIV_REG_CFG,     0x05010200
+.equ CLK_180MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_200MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_220MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_250MHZ_DIV_REG_CFG,     0x05010300
+.equ CLK_BYPASS_DIV_REG_CFG,     0x05010300
+
+
+/************************************************************************/
+/* CLOCK PLL0 REGISTER CONFIGURATIONS                                   */
+/************************************************************************/
+
+.equ CLK_125MHZ_PLLCON_REG_CFG,  0x007C210B
+.equ CLK_133MHZ_PLLCON_REG_CFG,  0x00632108
+.equ CLK_160MHZ_PLLCON_REG_CFG,  0x00272005
+.equ CLK_180MHZ_PLLCON_REG_CFG,  0x002C2005
+.equ CLK_200MHZ_PLLCON_REG_CFG,  0x00312005
+.equ CLK_220MHZ_PLLCON_REG_CFG,  0x00362005
+.equ CLK_250MHZ_PLLCON_REG_CFG,  0x007C200B
+
+/************************************************************************/
+/* Clock Source selection                                               */
+/************************************************************************/
+.equ CLK_PLL0_SRC_SEL,           0x00
+.equ CLK_PLL1_SRC_SEL,           0x01
+.equ CLK_48M_SRC_SEL,            0x02
+.equ CLK_PWM3_GPIO83_SRC_SEL,    0x03
+
+/************************************************************************/
+/* Pixel Clock Source Select Bits                                       */
+/************************************************************************/
+.equ CLK_PIX_PLL_GFX_SEL,        0x00
+.equ CLK_PIX_GPI96_SEL,          0x01
+.equ CLK_PIX_48M_SEL,            0x02  
diff --git a/board/nuvoton/HermonSVB/Makefile b/board/nuvoton/HermonSVB/Makefile
new file mode 100755
index 0000000..e32800f
--- /dev/null
+++ b/board/nuvoton/HermonSVB/Makefile
@@ -0,0 +1,27 @@
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= HermonSVB_init.o ../common/BMC_HAL/Boards/board.o
+SOBJS	:= HermonSVB_low_level_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	.local_dep $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+.local_dep:
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Boards
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Chips
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+
+#########################################################################
diff --git a/board/nuvoton/HermonSVB/config.mk b/board/nuvoton/HermonSVB/config.mk
new file mode 100755
index 0000000..ec30fca
--- /dev/null
+++ b/board/nuvoton/HermonSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(TOPDIR)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=wpcm450
diff --git a/board/nuvoton/PolegSVB/Kconfig b/board/nuvoton/PolegSVB/Kconfig
new file mode 100755
index 0000000..f34eca3
--- /dev/null
+++ b/board/nuvoton/PolegSVB/Kconfig
@@ -0,0 +1,18 @@
+if TARGET_NPCM750
+
+config SYS_BOARD
+	default "PolegSVB"
+
+config SYS_VENDOR
+	default "nuvoton"
+
+config SYS_CPU
+	default "armv7"
+
+config SYS_SOC
+	default "npcm750"
+
+config SYS_CONFIG_NAME
+	default "PolegSVB"
+
+endif
diff --git a/board/nuvoton/PolegSVB/Makefile b/board/nuvoton/PolegSVB/Makefile
new file mode 100755
index 0000000..8a3fad1
--- /dev/null
+++ b/board/nuvoton/PolegSVB/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= PolegSVB_init.o PolegSVB_low_level_init.o ../common/BMC_HAL/Boards/board.o cmd_usb_device.o
diff --git a/board/nuvoton/PolegSVB/PolegSVB_init.c b/board/nuvoton/PolegSVB/PolegSVB_init.c
new file mode 100755
index 0000000..b848170
--- /dev/null
+++ b/board/nuvoton/PolegSVB/PolegSVB_init.c
@@ -0,0 +1,79 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "../common/BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+    #define BOOTER_VER      *((PTR32)(BOOTER_VER_ADDR))
+
+    printf("RomCode   : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+    printf("BootBlock : v%02x.%02x.%02x.%02x\n", MSB0(BOOTER_VER),  MSB1(BOOTER_VER),  MSB2(BOOTER_VER),  MSB3(BOOTER_VER));
+
+    printf("\n");
+
+    printf("PolegSVB Power-On Straps = 0x%x\n",*((PTR32)(GCR_BASE_ADDR + 0x004)));
+
+    if (STRP_SecureBoot_On())
+    {
+        printf("Security: ENABLED, running in secure mode\n");
+    }
+    else
+    {
+        printf("Security: DISABLED, running in non-secure mode\n");
+    }
+
+    return 0;
+}
+
+
diff --git a/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S b/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
new file mode 100755
index 0000000..d7335a8
--- /dev/null
+++ b/board/nuvoton/PolegSVB/PolegSVB_low_level_init.S
@@ -0,0 +1,45 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB_low_level_init.S                                                                            */
+/*            This file contains NPCM750 low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <asm-offsets.h>
+#include <config.h>
+#include <version.h>
+#include <linux/linkage.h>
+
+ENTRY(board_lowlevel_init)
+
+	/*
+	 * Setup a temporary stack
+	 */
+	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR
+	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
+	sub	sp, #GD_SIZE
+	bic	sp, sp, #7
+	mov	r9, sp
+
+	/*
+	 * Save the old lr(passed in ip) and the current lr to stack
+	 */
+	push	{ip, lr}
+
+	/*
+	 *  Invalidate l2-Cache 
+	 */
+	bl	v7_outer_cache_inval_all
+	
+	pop	{ip, pc}
+
+ENDPROC(board_lowlevel_init)
+
+
diff --git a/board/nuvoton/PolegSVB/cmd_usb_device.c b/board/nuvoton/PolegSVB/cmd_usb_device.c
new file mode 100755
index 0000000..da8bad6
--- /dev/null
+++ b/board/nuvoton/PolegSVB/cmd_usb_device.c
@@ -0,0 +1,52 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * Cache support: switch on or off, get status
+ */
+#include <common.h>
+#include <command.h>
+#include <linux/compiler.h>
+
+
+
+int do_usb_device(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	uint32_t device_number = 0;
+	uint32_t *pAppAddr __attribute__((unused));
+
+	if(argc > 1)
+	{
+		device_number = (argv[1][0]) - '0';
+		if(device_number > 9)
+		{
+                printf( " Invalid device number\n" );
+				return 0;
+		}
+	}
+	
+    printf( " running device %d \n",  device_number);
+	
+	*((volatile uint32_t *)(0x7000)) = 0xa5b6c7d8;
+	*((volatile uint32_t *)(0x7004)) = device_number;
+
+	pAppAddr= (uint32_t *)(0x8000);     // load bin address
+
+	// jump to application
+	asm volatile(	"ldr r0,%[addr] \n"
+    				"bx r0 \n"
+    				: :[addr]"m"(pAppAddr):"memory");
+	
+	return 0;
+}
+
+
+U_BOOT_CMD(
+	usb_device,   2,   1,     do_usb_device,
+	"usb device test",
+	"<device_num>"
+);
diff --git a/board/nuvoton/PolegSVB/config.mk b/board/nuvoton/PolegSVB/config.mk
new file mode 100755
index 0000000..99640aa
--- /dev/null
+++ b/board/nuvoton/PolegSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(srctree)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=npcm750
diff --git a/board/nuvoton/YarkonSVB/Makefile b/board/nuvoton/YarkonSVB/Makefile
new file mode 100755
index 0000000..7eac1c3
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/Makefile
@@ -0,0 +1,26 @@
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS	:= YarkonSVB_init.o ../common/BMC_HAL/Boards/board.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	.local_dep $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS) $(SOBJS))
+
+.local_dep:
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Boards
+	mkdir -p $(OBJTREE)/board/nuvoton/common/BMC_HAL/Chips
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+
+#########################################################################
diff --git a/board/nuvoton/YarkonSVB/YarkonSVB_init.c b/board/nuvoton/YarkonSVB/YarkonSVB_init.c
new file mode 100755
index 0000000..32e6ba9
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/YarkonSVB_init.c
@@ -0,0 +1,77 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_init.c                                                                                      */
+/*            This file contains WPCM450 initialization                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Using external timer_init function                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+extern int  timer_init (void);
+extern void print_common_info(void);
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous platform dependent initialisations                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_init (void)
+{
+    gd->bd->bi_arch_number = MACH_TYPE_WPCM450;
+    gd->bd->bi_boot_params = CONFIG_TAGS_LOCATION;
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_cpuinfo                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints CPU and Board info                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+int print_cpuinfo (void)
+{
+    print_common_info();
+
+    #define ROMCODE_VER     *((PTR32)(ROMCODE_VER_ADDR))
+    #define BOOTER_VER      *((PTR32)(0x40000204))
+
+    printf("RomCode : v%02x.%02x.%02x.%02x\n", MSB0(ROMCODE_VER), MSB1(ROMCODE_VER), MSB2(ROMCODE_VER), MSB3(ROMCODE_VER));
+    printf("Booter  : v%02x.%02x.%02x.%02x\n", MSB0(BOOTER_VER),  MSB1(BOOTER_VER),  MSB2(BOOTER_VER),  MSB3(BOOTER_VER));
+
+    printf("\n");
+
+    if (STRP_Strap19_On())
+    {
+        printf("Security: ENABLED, running in secure mode\n");
+    }
+    else
+    {
+        printf("Security: DISABLED, running in non-secure mode\n");
+    }
+
+    return 0;
+}
+
+
diff --git a/board/nuvoton/YarkonSVB/config.mk b/board/nuvoton/YarkonSVB/config.mk
new file mode 100755
index 0000000..0d50543
--- /dev/null
+++ b/board/nuvoton/YarkonSVB/config.mk
@@ -0,0 +1,5 @@
+#Including Common config file
+include $(TOPDIR)/board/nuvoton/common/config.mk
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DCHIP_NAME=npcm650
diff --git a/board/nuvoton/common/Makefile b/board/nuvoton/common/Makefile
new file mode 100755
index 0000000..07b5fba
--- /dev/null
+++ b/board/nuvoton/common/Makefile
@@ -0,0 +1,11 @@
+
+#
+# (C) Copyright 2000-2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= nuvoton_aic.o nuvoton_serial.o nuvoton_eth.o nuvoton_timer.o nuvoton_flash.o nuvoton_init.o nuvoton_low_level.o
+obj-$(CONFIG_USB_HOST)	+= nuvoton_usb.o
+
diff --git a/board/nuvoton/common/config.mk b/board/nuvoton/common/config.mk
new file mode 100755
index 0000000..0e4c98a
--- /dev/null
+++ b/board/nuvoton/common/config.mk
@@ -0,0 +1,45 @@
+#Common TextBase address
+#CONFIG_SYS_TEXT_BASE = 0x01400000
+
+#Common include search pathes
+PLATFORM_CPPFLAGS += -I$(srctree)/
+PLATFORM_CPPFLAGS += -I$(srctree)/board/nuvoton/common/BMC_HAL/Chips
+PLATFORM_CPPFLAGS += -I$(srctree)/board/nuvoton/common/SWC_DEFS
+
+# We don't use LIBC in this project
+PLATFORM_CPPFLAGS += -DNO_LIBC
+
+#Setting board depending flags
+PLATFORM_CPPFLAGS += -DBOARD_NAME=$(BOARD_NAME)
+PLATFORM_CPPFLAGS += -DEXTERNAL_INCLUDE_FILE=$(srctree)/board/nuvoton/common/nuvoton_hal.h
+
+#Common optimizations flags
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCAT
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCAT
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRCHR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRRCHR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRLEN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRNLEN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRDUP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSPN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRPBRK
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRTOK
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSEP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSWAB
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMSET
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_BCOPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCPY
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMMOVE
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCMP
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMSCAN
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_STRSTR
+#PLATFORM_CPPFLAGS += -D__HAVE_ARCH_MEMCHR
+
+
+
+
+
diff --git a/board/nuvoton/common/nuvoton_aic.c b/board/nuvoton/common/nuvoton_aic.c
new file mode 100755
index 0000000..a37f5ff
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_aic.c
@@ -0,0 +1,43 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_aic.c                                                                                         */
+/*            This file contains implementation of AIC module for U-Boot                                   */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include "config.h"
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Interrupt Handler Table                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        do_irq                                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main IRQ handler                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef CONFIG_USE_IRQ
+void do_irq(void)
+{
+    AIC_Isr();
+}
+#endif
+
+
diff --git a/board/nuvoton/common/nuvoton_eth.c b/board/nuvoton/common/nuvoton_eth.c
new file mode 100755
index 0000000..13b241a
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_eth.c
@@ -0,0 +1,678 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_eth.c                                                                                         */
+/*            This file contains Ehternet module implementation                                            */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <malloc.h>
+#include <net.h>
+#include <netdev.h>
+#include <phy.h>
+#include "miiphy.h"
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Boards/board.h"
+
+#define REMOVE_EMC_SUPPORT
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function forward declarations                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+int   nuvoton_eth_probe   (struct eth_device *dev, bd_t *bis);
+int   nuvoton_eth_send    (struct eth_device *dev, volatile void* packet, int length);
+int   nuvoton_eth_recv    (struct eth_device *dev);
+void  nuvoton_eth_halt    (struct eth_device *dev );
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Utility Macros                                                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define FUNC_NAME(a,b)          CONCAT3(a,_,b)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet drivers structure                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct eth_drv_s
+{
+    const ETH_PHY_OPS_T* phy_ops;
+
+    HAL_STATUS   (*initialize)(         UINT            devNum,             \
+                                const   UINT8*          mac_addr,           \
+                                const   ETH_CALLBACK_T* callbacks,          \
+                                const   ETH_PHY_OPS_T*  phyOps,             \
+                                const   UINT8**         RxBuffersArray,     \
+                                const   UINT32          buffersSize);
+
+    HAL_STATUS   (*send)   (UINT deviceNum, UINT8* packet, UINT32 length);
+    HAL_STATUS   (*halt)   (UINT deviceNum);
+} eth_drv_t;
+
+
+#ifdef REMOVE_EMC_SUPPORT
+int Empty_Initialize(       UINT            devNum,
+                            const   UINT8*          mac_addr,
+                            const   ETH_CALLBACK_T* callbacks,
+                            const   ETH_PHY_OPS_T*  phyOps,
+                            const   UINT8**         RxBuffersArray,
+                            const   UINT32          buffersSize)
+{
+    return HAL_ERROR_NOT_IMPLEMENTED;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet drivers OPS array                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+eth_drv_t driver_api[CONFIG_ETH_DEVS] =
+{
+#if CONFIG_ETH_DEVS > 0
+    { &BOARD_ETH0_PHY_OPS, Empty_Initialize, FUNC_NAME(CHIP_ETH0_TYPE,Send), FUNC_NAME(CHIP_ETH0_TYPE,Halt) },       
+#endif
+#if CONFIG_ETH_DEVS > 1
+    { &BOARD_ETH1_PHY_OPS, Empty_Initialize, FUNC_NAME(CHIP_ETH1_TYPE,Send), FUNC_NAME(CHIP_ETH1_TYPE,Halt) },
+#endif
+};
+
+#else
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Ethernet drivers OPS array                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+eth_drv_t driver_api[CONFIG_ETH_DEVS] =
+{
+#if CONFIG_ETH_DEVS > 0
+    { &BOARD_ETH0_PHY_OPS, FUNC_NAME(CHIP_ETH0_TYPE,Initialize), FUNC_NAME(CHIP_ETH0_TYPE,Send), FUNC_NAME(CHIP_ETH0_TYPE,Halt) },
+#endif
+#if CONFIG_ETH_DEVS > 1
+    { &BOARD_ETH1_PHY_OPS, FUNC_NAME(CHIP_ETH1_TYPE,Initialize), FUNC_NAME(CHIP_ETH1_TYPE,Send), FUNC_NAME(CHIP_ETH1_TYPE,Halt) },
+#endif
+};
+
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Setting Maximum number of descriptors                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define ETH0_NUM_OF_TX_DESC         CONCAT3(CHIP_ETH0_TYPE,_,NUM_OF_TX_DESC)
+#define ETH0_NUM_OF_RX_DESC         CONCAT3(CHIP_ETH0_TYPE,_,NUM_OF_RX_DESC)
+
+#define ETH1_NUM_OF_TX_DESC         CONCAT3(CHIP_ETH1_TYPE,_,NUM_OF_TX_DESC)
+#define ETH1_NUM_OF_RX_DESC         CONCAT3(CHIP_ETH1_TYPE,_,NUM_OF_RX_DESC)
+
+
+#if (ETH0_NUM_OF_TX_DESC > ETH1_NUM_OF_TX_DESC)
+    #define ETH_NUM_OF_TX_DESC     ETH0_NUM_OF_TX_DESC
+#else
+    #define ETH_NUM_OF_TX_DESC     ETH1_NUM_OF_TX_DESC
+#endif
+
+#if (ETH0_NUM_OF_RX_DESC > ETH1_NUM_OF_RX_DESC)
+    #define ETH_NUM_OF_RX_DESC     ETH0_NUM_OF_RX_DESC
+#else
+    #define ETH_NUM_OF_RX_DESC     ETH1_NUM_OF_RX_DESC
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Buffer size                                                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+#define PACKET_BUFF_SIZE        1600
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Array of packets for Rx                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT8   Rx_Buffer_L[CONFIG_ETH_DEVS][ETH_NUM_OF_RX_DESC][PACKET_BUFF_SIZE];
+static UINT8   Tx_Buffer_L[CONFIG_ETH_DEVS][ETH_NUM_OF_TX_DESC][PACKET_BUFF_SIZE];
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Pointers to handle Tx buffer queue                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+static UINT32 Tx_Buff_First[CONFIG_ETH_DEVS];
+static UINT32 Tx_Buff_Last [CONFIG_ETH_DEVS];
+static UINT32 Tx_Buff_Count[CONFIG_ETH_DEVS];
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Macros to handle Tx buff pointers                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NEXT_PTR(x)             ((x                      + 1) % ETH_NUM_OF_TX_DESC)
+#define LAST_PTR(x)             ((x + ETH_NUM_OF_TX_DESC - 1) % ETH_NUM_OF_TX_DESC)
+
+#define TX_BUFF_FULL(dev)       ((Tx_Buff_First[dev] == Tx_Buff_Last[dev]) && (Tx_Buff_Count[dev] != 0))
+#define TX_BUFF_EMPTY(dev)      ((Tx_Buff_First[dev] == Tx_Buff_Last[dev]) && (Tx_Buff_Count[dev] == 0))
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Check if ETH type matters or not                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(EMC_NUM_OF_TX_DESC) && defined(GMAC_NUM_OF_TX_DESC)
+    #define ETH_TYPE_MATTERS     TRUE
+#else
+    #define ETH_TYPE_MATTERS     FALSE
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Driver level device number                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define DRIVER_DEVNUM(devNum)   ((ETH_TYPE_MATTERS) ? 0 : devNum)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        board_eth_init                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  bis -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs ethernet module initialization                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(CONFIG_ETH_DESIGNWARE)
+int board_eth_init(bd_t *bis)
+{
+    struct eth_device*  dev;
+    UINT32              devNum;
+    char*               s;
+    char*               e;
+    char                buf[64];
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring every ETH device                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(devNum=0; devNum < CONFIG_ETH_DEVS; devNum++)
+    {
+#if defined (NPCM750)
+       if((devNum == 0) || (devNum == 1))           // Case of 2xEMC 
+#elif defined (NPCM650)
+       if(devNum == 0)
+#endif
+       {
+          /*-------------------------------------------------------------------------------------------------*/
+          /* allocating control structure for the device                                                     */
+          /*-------------------------------------------------------------------------------------------------*/
+          dev = (struct eth_device*)calloc(sizeof(*dev), 1);
+          if (!dev)
+          {
+              printf( "%s: ETH%ld allocation failure, %s\n", __FUNCTION__, devNum, "eth_device structure");
+              return 1;
+          }
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Initializing device name                                                                        */
+          /*-------------------------------------------------------------------------------------------------*/
+          sprintf(dev->name, "ETH%ld", devNum);
+
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Extract the MAC address from the environment                                                    */
+          /*-------------------------------------------------------------------------------------------------*/
+          switch (devNum)
+          {
+            case 0: s = "ethaddr";
+			   break;
+#if defined (NPCM750)
+            case 1: s = "eth1addr";
+			   break;
+#endif               
+            default: /* this should never happen */
+                printf( "%s: Invalid device number %ld\n",  __FUNCTION__, devNum );
+                return 1;
+          }
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Reading MAC address from the environment                                                        */
+          /*-------------------------------------------------------------------------------------------------*/
+          if (getenv_f(s, buf, sizeof(buf)) > 0)
+          {
+             s = buf;
+
+             INT32 x;
+             for (x = 0; x < 6; ++x)
+             {
+                dev->enetaddr[x] = (UINT32)simple_strtoul(s, &e, 16);
+
+                if (s)
+                {
+                    s = (*e) ? e + 1 : e;
+                }
+             }
+          }
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Configuring device callback functions                                                           */
+          /*-------------------------------------------------------------------------------------------------*/
+          dev->init = nuvoton_eth_probe;
+          dev->send = nuvoton_eth_send;
+          dev->recv = nuvoton_eth_recv;
+          dev->halt = nuvoton_eth_halt;
+
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Creating cross linkage between the pointers                                                     */
+          /*-------------------------------------------------------------------------------------------------*/
+          dev->priv = (void*)devNum;
+
+          /*-------------------------------------------------------------------------------------------------*/
+          /* Registering the ETH device                                                                      */
+          /*-------------------------------------------------------------------------------------------------*/
+          eth_register(dev);     //Trego - EMC Not fuctional Yet.
+      }
+#if defined (NPCM750)
+      else if (devNum == 2)    // Case of GMAC1 used as ETH2
+#elif defined (NPCM650)
+      else if (devNum == 1)    // On NPCM650 There is only GMAC2 exist and used as ETH1.
+#endif
+      {                             
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* enabling the GMAC clocks                                                                            */
+          /*-----------------------------------------------------------------------------------------------------*/
+          CLK_ConfigureGMACClock(devNum);
+
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* Setting ETH muxing                                                                                  */
+          /*-----------------------------------------------------------------------------------------------------*/
+
+          GCR_Mux_GMII(devNum);
+
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* Reseting the device                                                                                 */
+          /*-----------------------------------------------------------------------------------------------------*/
+//        GMAC_Reset_L(devNum);
+          CLK_ResetGMAC(devNum);
+
+#if defined (NPCM750)
+          if (designware_initialize( (UINT32)GMAC_BASE_ADDR(0), PHY_INTERFACE_MODE_RGMII) < 0)
+              return -1;
+#elif defined (NPCM650)
+          if (designware_initialize( (UINT32)GMAC_BASE_ADDR(0),  PHY_INTERFACE_MODE_GMII) < 0)
+              return -1;
+#endif
+      }
+#if defined (NPCM750)
+      else if (devNum == 3)    // Case of GMAC2 used as ETH3 
+      {
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* enabling the GMAC clocks                                                                            */
+          /*-----------------------------------------------------------------------------------------------------*/
+          CLK_ConfigureGMACClock(devNum);
+
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* Setting ETH muxing                                                                                  */
+          /*-----------------------------------------------------------------------------------------------------*/
+
+          GCR_Mux_GMII(devNum);
+
+          /*-----------------------------------------------------------------------------------------------------*/
+          /* Reseting the device                                                                                 */
+          /*-----------------------------------------------------------------------------------------------------*/
+//        GMAC_Reset_L(device);
+          CLK_ResetGMAC(devNum);
+
+          if (designware_initialize( (UINT32)GMAC_BASE_ADDR(1), PHY_INTERFACE_MODE_RGMII) < 0)
+              return -1;
+       }	
+#endif	
+    }
+
+    return 0;
+}
+
+#else  /* CONFIG_DESIGNWARE_ETH */
+
+int board_eth_init(bd_t *bis)
+{
+    struct eth_device*  dev;
+    UINT32              devNum;
+    char*               s;
+    char*               e;
+    char                buf[64];
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Configuring every ETH device                                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for(devNum=0; devNum < CONFIG_ETH_DEVS; devNum++)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* allocating control structure for the device                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        dev = (struct eth_device*)calloc(sizeof(*dev), 1);
+        if (!dev)
+        {
+            printf( "%s: ETH%ld allocation failure, %s\n", __FUNCTION__, devNum, "eth_device structure");
+            return 1;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Initializing device name                                                                        */
+        /*-------------------------------------------------------------------------------------------------*/
+        sprintf(dev->name, "ETH%ld", devNum);
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Extract the MAC address from the environment                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        switch (devNum)
+        {
+            case 0: s = "ethaddr"; break;
+#if (CONFIG_ETH_DEVS > 1)
+            case 1: s = "eth1addr"; break;
+#endif
+            default: /* this should never happen */
+                printf( "%s: Invalid device number %ld\n",  __FUNCTION__, devNum );
+                return 1;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Reading MAC address from the environment                                                        */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (getenv_f(s, buf, sizeof(buf)) > 0)
+        {
+            s = buf;
+
+            INT32 x;
+            for (x = 0; x < 6; ++x)
+            {
+                dev->enetaddr[x] = (UINT32)simple_strtoul(s, &e, 16);
+
+                if (s)
+                {
+                    s = (*e) ? e + 1 : e;
+                }
+            }
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Configuring device callback functions                                                           */
+        /*-------------------------------------------------------------------------------------------------*/
+        dev->init = nuvoton_eth_probe;
+        dev->send = nuvoton_eth_send;
+        dev->recv = nuvoton_eth_recv;
+        dev->halt = nuvoton_eth_halt;
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Creating cross linkage between the pointers                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        dev->priv = (void*)devNum;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Registering the ETH device                                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+        eth_register(dev);
+    }
+
+    return 0;
+}
+#endif  /* CONFIG_DESIGNWARE_ETH */
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_rx_callback                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is Rx Callback                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+static void nuvoton_rx_callback(ETH_T type, UINT devNum, UINT8** buffer, UINT32 size, HAL_STATUS status)
+{
+    if (status == HAL_OK)
+    {
+        net_process_received_packet(*buffer, size);
+    }
+    else
+    {
+        printf("Rx error occured 0x%X\n", status);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_tx_callback                                                                    */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is Tx callback                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+static void nuvoton_tx_callback(ETH_T type, UINT devNum, UINT8* buffer, UINT32 size, HAL_STATUS status)
+{
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Check if device number is 'correct' or not                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (ETH_TYPE_MATTERS)
+    {
+        devNum = type;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Release used Tx buffer                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    Tx_Buff_Last[devNum] = NEXT_PTR(Tx_Buff_Last[devNum]);
+    Tx_Buff_Count[devNum]--;
+
+    if (status != HAL_OK)
+    {
+        printf("Tx error occured 0x%X\n", status);
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_error_callback                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                               */
+/*                  status -                                                                               */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is Ethernet error callback                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+static void nuvoton_error_callback(ETH_T type, UINT devNum, HAL_STATUS status)
+{
+    printf("Ethernet error occured 0x%X\n", status);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Check if device number is 'correct' or not                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (ETH_TYPE_MATTERS)
+    {
+        devNum = type;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Reseting the queue                                                                                  */
+    /*-----------------------------------------------------------------------------------------------------*/
+    Tx_Buff_First[devNum] = Tx_Buff_Last[devNum] = Tx_Buff_Count[devNum] = 0;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Rx/Tx callbacks structure                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+static ETH_CALLBACK_T nuvoton_callbacks =
+{
+    nuvoton_rx_callback,
+    nuvoton_tx_callback,
+    nuvoton_error_callback,
+};
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_eth_probe                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  bis -                                                                                  */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs ethernet driver init                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_eth_probe (struct eth_device *dev, bd_t *bis)
+{
+    UINT32  devNum = (UINT32)dev->priv;
+    UINT    i       = 0;
+    const UINT8*  RxBuffArray[ETH_NUM_OF_RX_DESC];
+
+
+    if ((devNum >= 0) && (devNum < CONFIG_ETH_DEVS))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Initializing Rx buffer array                                                                    */
+        /*-------------------------------------------------------------------------------------------------*/
+        for (i=0; i<ETH_NUM_OF_RX_DESC; ++i)
+            RxBuffArray[i] = &Rx_Buffer_L[devNum][i][0];
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Initializing Tx buffer ptrs                                                                     */
+        /*-------------------------------------------------------------------------------------------------*/
+        Tx_Buff_First[devNum] = Tx_Buff_Last[devNum] = Tx_Buff_Count[devNum] = 0;
+
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Executing init                                                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        return -driver_api[devNum].initialize(DRIVER_DEVNUM(devNum), dev->enetaddr, &nuvoton_callbacks, driver_api[devNum].phy_ops, &RxBuffArray[0], PACKET_BUFF_SIZE + 0x20);
+    }
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_eth_halt                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine halts the ethernet driver                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void nuvoton_eth_halt( struct eth_device *dev )
+{
+    UINT32 devNum = (UINT32)dev->priv;
+
+    if ((devNum >= 0) &&(devNum < CONFIG_ETH_DEVS))
+    {
+        driver_api[devNum].halt(DRIVER_DEVNUM(devNum));
+    }
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_eth_send                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                  length -                                                                               */
+/*                  packet -                                                                               */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs ethernet driver send                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_eth_send(struct eth_device *dev, volatile void* packet, int length)
+{
+    UINT32      devNum  = (UINT32)dev->priv;
+    void*       buffer  = NULL;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If length is to big, return error                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (length >= PACKET_BUFF_SIZE)
+    {
+        return -1;
+    }
+
+    if ((devNum >= 0) &&(devNum < CONFIG_ETH_DEVS))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If Tx queue is full, exit with error                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (TX_BUFF_FULL(devNum))
+        {
+            return -1;
+        }
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Calculating the buffer location                                                                 */
+        /*-------------------------------------------------------------------------------------------------*/
+        buffer = (void*)&Tx_Buffer_L[devNum][Tx_Buff_First[devNum]][0];
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Copy the packet into the Tx Buffers                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        memcpy(buffer, (const void*)packet, length);
+
+        //printf("Sending %d\n", Tx_Buff_First[devNum]);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Adding to the Queue                                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        Tx_Buff_First[devNum] = NEXT_PTR(Tx_Buff_First[devNum]);
+        Tx_Buff_Count[devNum]++;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Sending the packet                                                                              */
+        /*-------------------------------------------------------------------------------------------------*/
+        return -driver_api[devNum].send(DRIVER_DEVNUM(devNum), (UINT8*)buffer, length);
+    }
+
+   return 0;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        nuvoton_eth_recv                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dev -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  The recieve is interrupt driver.                                                       */
+/*                  Nothing to do on implicit 'receive' invocation                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_eth_recv(struct eth_device *dev)
+{
+    return 0;
+}
+
+
+
+
+
+
diff --git a/board/nuvoton/common/nuvoton_flash.c b/board/nuvoton/common/nuvoton_flash.c
new file mode 100755
index 0000000..70f6123
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_flash.c
@@ -0,0 +1,195 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_flash.c                                                                                       */
+/*            This file contains flash api for U-BOOT                                                      */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include "common.h"
+#include "config.h"
+#include "spi.h"
+#include "flash.h"
+#include "linux/sizes.h"
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Boards/board.h"
+
+#ifndef CONFIG_SYS_NO_FLASH
+/*---------------------------------------------------------------------------------------------------------*/
+/* Flash info array                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash initialization                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+unsigned long flash_init (void)
+{
+    INT32 idx         = 0;
+    INT32 sect_idx    = 0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing the SPI Flash                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    SPI_Flash_Init(CONFIG_FLASH_BASE);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Constructing the flash_info array                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+
+	/* Init: no FLASHes known */
+	for (idx = 0; idx < CONFIG_SYS_MAX_FLASH_BANKS; ++idx) {
+		flash_info[idx].flash_id = FLASH_UNKNOWN;
+	}
+
+    for (idx=0; idx < CONFIG_SYS_MAX_FLASH_BANKS; ++idx)
+    {
+        if (SPI_Flash_Devices[idx].mf_id != 0)
+        {
+            flash_info[idx].size            = SPI_Flash_Devices[idx].chip_size;
+            flash_info[idx].sector_count    = SPI_Flash_Devices[idx].chip_size/SPI_Flash_Devices[idx].sector_size;
+            flash_info[idx].flash_id        = SPI_Flash_Devices[idx].capacity_id << 16 | SPI_Flash_Devices[idx].mf_id;
+
+            for(sect_idx=0; sect_idx < flash_info[idx].sector_count; sect_idx++)
+            {
+                flash_info[idx].start[sect_idx] = SPI_Flash_Devices[idx].startAddr +              \
+                                                  SPI_Flash_Devices[idx].sector_size * sect_idx;
+                flash_info[idx].protect[sect_idx] = 0;
+            }
+        }
+    }
+
+    return SPI_Flash_TotalSize;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_print_info                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr - pointer to the flash into entry                                       */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine  prints info about the given flash device                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void flash_print_info (flash_info_t *flash_info_ptr)
+{
+    INT32 sect_idx;
+
+    printf(" size : [0x%lx]",    flash_info_ptr->size);
+    printf(" sect count : [%d]", flash_info_ptr->sector_count);
+    printf(" id : [0x%lx]\n",    flash_info_ptr->flash_id);
+
+    for(sect_idx=0; sect_idx < flash_info_ptr->sector_count; sect_idx++)
+    {
+        printf("[0x%lx][%s]",
+                flash_info_ptr->start[sect_idx],
+                (flash_info_ptr->protect[sect_idx])?"(RO)":"(RW)");
+
+        if(sect_idx + 1 % 6 == 0)
+        {
+            printf("\n");
+        }
+    }
+
+    printf("\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        flash_erase                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr  - pointer to flash device info entry                                   */
+/*                  s_first         - first erase sector index                                             */
+/*                  s_last          - last erase sector index                                              */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs flash erase inside given flash device                            */
+/*---------------------------------------------------------------------------------------------------------*/
+int flash_erase (flash_info_t * flash_info_ptr, int s_first, int s_last)
+{
+    HAL_STATUS ret = HAL_OK;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking if we need erase whole flash device                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if ((s_first == 0) && ((s_last + 1) == flash_info_ptr->sector_count))
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* If we do, we execute optimized erase                                                            */
+        /*-------------------------------------------------------------------------------------------------*/
+        ret = SPI_Flash_BulkErase(flash_info_ptr->start[s_first]);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Otherwise we erase sectors in the range                                                             */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else
+    {
+        UINT32 sect_idx = 0;
+        for(sect_idx = s_first; sect_idx <= s_last; ++sect_idx)
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* Erase it using SPI Flash driver                                                             */
+            /*---------------------------------------------------------------------------------------------*/
+            ret += SPI_Flash_SectorErase(flash_info_ptr->start[sect_idx]);
+        }
+    }
+
+    if (ret == HAL_OK)
+        return 0;
+    else
+        return -ret;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        write_buff                                                                             */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  flash_info_ptr  - flash device info                                                    */
+/*                  addr            - destination address on a flash                                       */
+/*                  src             - source address                                                       */
+/*                  cnt             - source data size                                                     */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes a buffer to the flash                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int write_buff (flash_info_t *flash_info_ptr, uchar *src, ulong addr, ulong cnt)
+{
+    INT ret;
+
+    if ((ret = SPI_Flash_Write((UINT32)addr, src, cnt)) == HAL_OK)
+        return 0;
+    else
+        return -ret;
+}
+#endif
+
+
diff --git a/board/nuvoton/common/nuvoton_hal.h b/board/nuvoton/common/nuvoton_hal.h
new file mode 100755
index 0000000..4a61699
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_hal.h
@@ -0,0 +1,22 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_hal.h                                                                                         */
+/*            This file contains HAL configurations from U-Boot                                            */
+/* Project:                                                                                                */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#undef GMAC_MODULE_TYPE
+#undef MC_MODULE_TYPE
+#undef AES_MODULE_TYPE
+#undef DES_MODULE_TYPE
+#undef MC_MODULE_TYPE
+#undef VCD_MODULE_TYPE
+#undef ECE_MODULE_TYPE
+#undef PSPI_MODULE_TYPE
diff --git a/board/nuvoton/common/nuvoton_init.c b/board/nuvoton/common/nuvoton_init.c
new file mode 100755
index 0000000..501e996
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_init.c
@@ -0,0 +1,189 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_misc.c                                                                                        */
+/*            This file contains misc U-Boot interface functions                                           */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include <config.h>
+#include <common.h>
+#include <sdhci.h>
+#include <asm/arch/npcm750_sdhci.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+#include "BMC_HAL/version.h"
+
+
+ DECLARE_GLOBAL_DATA_PTR;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        reset_cpu                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine makes CPU reset                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void reset_cpu (ulong addr)
+{
+    TIMER_WatchdogReset();
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        checkboard                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine Check Board Identity                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int checkboard(void)
+{
+
+    char *s = getenv("serial#");
+    if (s != NULL)
+    {
+        printf("Board serial# ");
+        printf(s);
+    }
+    printf("\n");
+
+    return (0);
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        dram_init                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs dram initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int dram_init (void)
+{
+	
+#if 0    // Trego - Done in Boot-Block
+   CLK_ConfigurePCIClock();            // For DDR config
+
+   MC_ConfigureDDR();                  // For DDR and debugger only perpose
+#endif   
+
+  
+   
+
+   gd->ram_size = GCR_PowerOn_GetMemorySize();
+	
+   return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        interrupt_init                                                                         */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs interrupt initialization                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+int arch_interrupt_init (void)
+{
+
+    AIC_Initialize();
+    timer_init();
+
+    return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        print_common_info                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine prints board independent info                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+void print_common_info(void)
+{
+    printf("HAL ver : v%s\n", BMC_HAL_VERSION_STR);
+    printf("\n");
+    printf("Board: %s\n", STRINGX(BOARD_NAME));
+    printf("Chip : %s\n", STRINGX(CHIP_NAME));
+    printf("Core : %s\n", STRINGX(CORE_TYPE));
+    printf("\n");
+    printf("CPU Freq:    % 4ldMHz\n", CLK_GetCPUFreq()/1000000L);
+#if defined (NPCM750)
+    printf("Memory Freq: % 4ldMHz\n", CLK_GetMemoryFreq()/1000000L);
+    printf("SPI0 Freq:   % 4ldMHz\n", CLK_GetSPIFreq(0)/1000000L);
+    printf("SPI3 Freq:   % 4ldMHz\n", CLK_GetSPIFreq(3)/1000000L);
+    printf("APB1 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(1)/1000000L);
+    printf("APB2 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(2)/1000000L);
+    printf("APB3 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(3)/1000000L);
+    printf("APB4 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(4)/1000000L);
+    printf("APB5 Freq:   % 4ldMHz\n", CLK_GetAPBFreq(5)/1000000L);
+#else
+    printf("APB Freq: %ldMHz\n", CLK_GetAPBFreq(1)/1000000L);
+#endif
+    printf("\n");
+
+}
+
+#ifdef CONFIG_NPCMX50_SDHCI
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        board_mmc_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      board info                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine init mmc                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int board_mmc_init(bd_t *bd)
+{
+    int ret = 0;
+
+	ret = npcmx50_mmc_init();
+	
+	return ret;
+}
+#endif
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        misc_init_r                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  PLEASE READ WITH CARE                                                                  */
+/*                                                                                                         */
+/*                  This routine is serves very important purpose and shouldn't be removed from this file. */
+/*                  The problem with current U-Boot implementation is that "board_eth_init" function is    */
+/*                  defined as weak reference inside U-Boot code.                                          */
+/*                  The archiver that makes a library out of this modules won't include "board_eth_init"   */
+/*                  function because it already resolved it elswhere DESPITE the fact it was declared as   */
+/*                  WEAK REFERENCE                                                                         */
+/*                  This function that is actually being called by U-Boot code explicitly (without week    */
+/*                  referencing) "prioritizes" this module in the function resolution process and causes   */
+/*                  the archiver to take the correct (our) implementation of "board_eth_init"              */
+/*---------------------------------------------------------------------------------------------------------*/
+int misc_init_r (void)
+{
+    return 0;
+}
diff --git a/board/nuvoton/common/nuvoton_low_level.S b/board/nuvoton/common/nuvoton_low_level.S
new file mode 100755
index 0000000..8c6e62d
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_low_level.S
@@ -0,0 +1,75 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB_low_level_init.S                                                                            */
+/*            This file contains nuvoton low level init                                                    */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#include <config.h>
+#include <version.h>
+
+
+
+
+.globl lowlevel_init
+lowlevel_init:
+
+/*
+;----------------------------------------------------------
+; Execute board dependent low level code
+; Configuring Memory if needed
+;----------------------------------------------------------
+*/
+#ifdef CONFIG_BOARD_LOWLEVEL_INIT
+	mov 	r11, lr
+	bl	board_lowlevel_init	
+	mov		lr, r11
+#endif 
+
+
+#if 0    // Trego - removed redundant code, already done in uboot.
+/*      
+;----------------------------------------------------------
+; Disable Interrupt, This is for safe ...
+;----------------------------------------------------------
+*/
+    MRS     r0, CPSR
+    ORR     r0, r0, #0xC0
+    MSR     CPSR_c, r0
+
+
+/*
+;----------------------------------------------------------
+; Set mode to SVC, interrupts disabled (just paranoid)
+;----------------------------------------------------------
+*/
+    MRS   r0, cpsr
+    BIC   r0, r0, #0xF0000000
+    BIC   r0, r0, #0x1F
+    ORR   r0, r0, #0xD3
+    MSR   cpsr_fc, r0
+
+    
+/*
+;----------------------------------------------------------
+; Enabling Instruction Cache
+;----------------------------------------------------------
+*/
+    MRC     p15, 0, r0, c1, c0          /* get control register   */
+    ORR     r0, r0, #0x00001000         /* I-cache                */
+    MCR     p15, 0, r0, c1, c0          /* enable I cache         */
+#endif
+/*
+;----------------------------------------------------------
+; --- back to arch calling code 
+;----------------------------------------------------------
+*/
+    MOV     pc,     lr
diff --git a/board/nuvoton/common/nuvoton_serial.c b/board/nuvoton/common/nuvoton_serial.c
new file mode 100755
index 0000000..311e179
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_serial.c
@@ -0,0 +1,161 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_serial.c                                                                                      */
+/*            This file contains implementation of serial driver for U-Boot                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <serial.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+#if defined (NPCM750)
+#define UART_DEV UART3_DEV
+#else
+#define UART_DEV UART1_DEV
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_init                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs UART initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_init(void)
+{
+#if defined (NPCM750)
+    UART_Init(UART_DEV, UART_MUX_MODE3_HSP1_UART1__HSP2_UART2__UART3_SI2, CONFIG_BAUDRATE);
+#else
+    UART_Init(UART_DEV, UART_MUX_CORE_TAKEOVER, CONFIG_BAUDRATE);
+#endif
+    return 0;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_putc                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  c - char to write to UART                                                              */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine write single char to UART                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+
+void nuvoton_serial_putc( const UINT8 c )
+{
+    UART_PutC(UART_DEV, c);
+
+    if (c == '\n')
+    {
+        UART_PutC(UART_DEV, '\r');
+    }
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_puts                                                                            */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  s - string to write to UART                                                            */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine writes whole string to UART                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+void nuvoton_serial_puts( const INT8 *s )
+{
+  while (*s)
+  {
+    serial_putc( *s++ );
+  }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_getc                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine reads char from UART                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_getc( void )
+{
+    return UART_GetC(UART_DEV);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_tstc                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine test if there is a char on UART                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+int nuvoton_serial_tstc( void )
+{
+    return UART_TestRX(UART_DEV);
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        serial_setbrg                                                                          */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a stub                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+void nuvoton_serial_setbrg( void )
+{
+}
+
+static struct serial_device nuvoton_serial_drv = {
+	.name	= "nuvoton_serial",
+	.start	= nuvoton_serial_init,
+	.stop	= NULL,
+	.setbrg	= nuvoton_serial_setbrg,
+	.putc	= nuvoton_serial_putc,
+	.puts	= default_serial_puts,
+	.getc	= nuvoton_serial_getc,
+	.tstc	= nuvoton_serial_tstc,
+};
+
+void nuvoton_serial_initialize(void)
+{
+	serial_register(&nuvoton_serial_drv);
+}
+
+__weak struct serial_device *default_serial_console(void)
+{
+	return &nuvoton_serial_drv;
+}
diff --git a/board/nuvoton/common/nuvoton_timer.c b/board/nuvoton/common/nuvoton_timer.c
new file mode 100755
index 0000000..deeb027
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_timer.c
@@ -0,0 +1,130 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_timer.c                                                                                       */
+/*            This file contains timer module implementation                                               */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        timer_init                                                                             */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs timer initialization                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+int timer_init (void)
+{
+    TIMER_StartPeriodic(TIMER0_DEV, CONFIG_SYS_HZ, NULL, NULL);
+
+    return 0;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        reset_timer                                                                            */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs timer reset                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void reset_timer (void)
+{
+    TIMER_Reset(TIMER0_DEV);
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_timer                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns timer value normalized with base                                  */
+/*---------------------------------------------------------------------------------------------------------*/
+ulong get_timer (ulong base)
+{
+	return TIMER_GetTick(TIMER0_DEV) - base;
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_ticks                                                                              */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns number of ticks                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+unsigned long long get_ticks(void)
+{
+    return get_timer(0);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        udelay                                                                                 */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  usec -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine delay x useconds AND perserve advance timstamp value                      */
+/*---------------------------------------------------------------------------------------------------------*/
+void __udelay (UINT32 usec)
+{
+#if defined (NPCM750)
+    CLK_Delay_MicroSec(usec);
+#else
+    UINT32 msec     = usec / 1000;
+    UINT32 start    = get_ticks();
+
+    while(get_timer(start) < msec);
+#endif
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        get_tbclk                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  usec -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine returns the number of timer ticks per second                              */
+/*---------------------------------------------------------------------------------------------------------*/
+ulong get_tbclk (void)
+{
+    return CONFIG_SYS_HZ;
+}
+
+
+
diff --git a/board/nuvoton/common/nuvoton_usb.c b/board/nuvoton/common/nuvoton_usb.c
new file mode 100755
index 0000000..5fea9ce
--- /dev/null
+++ b/board/nuvoton/common/nuvoton_usb.c
@@ -0,0 +1,107 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton_serial.c                                                                                      */
+/*            This file contains implementation of serial driver for U-Boot                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <common.h>
+#include <usb.h>
+#include "../../../drivers/usb/host/ehci.h"
+#include <asm/io.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+
+#define USB_HOST_BA				(USBH_EHCI_BASE_ADDR+0x100)  // changed by az
+
+
+#define  IPSRST2                        (CLK_BASE_ADDR + 0x24)
+#define IPSRST2_USBHOST_BIT_POS  26
+
+#define  IPSRST3                        (CLK_BASE_ADDR + 0x34)
+#define IPSRST3_USBPHY1_BIT_POS  24
+#define IPSRST3_USBPHY2_BIT_POS  25
+
+
+#define  USBTEST                        (GCR_BASE_ADDR + 0x140)
+#define USBTEST_USB1PHYCTL_BIT_POS  28
+
+#define  USB2TEST                       (GCR_BASE_ADDR + 0x144)
+#define USBTEST_USB2PHYCTL_BIT_POS  28
+
+#define SET_BIT_IN_REG(reg,bit_pos)  writel(readl(reg) |   (1 <<  bit_pos) ,reg);
+#define CLR_BIT_IN_REG(reg,bit_pos)  writel(readl(reg) & (~(1 <<  bit_pos)) ,reg);
+/*
+ * EHCI host controller init
+ */
+int ehci_hcd_init(int index, enum usb_init_type init,
+                struct ehci_hccr **hccr, struct ehci_hcor **hcor)
+{
+// 	// loopback
+// 	regVal=*((volatile uint32_t *)(REG_INTCR3));
+// 	*((volatile uint32_t *)(REG_INTCR3)) = regVal | 0x01000000;
+
+ 	// reset host
+	SET_BIT_IN_REG(IPSRST2, IPSRST2_USBHOST_BIT_POS);
+ 	mdelay(20);
+
+
+ 	// enable phy
+ 	CLR_BIT_IN_REG(IPSRST3, IPSRST3_USBPHY1_BIT_POS);
+ 	CLR_BIT_IN_REG(IPSRST3, IPSRST3_USBPHY2_BIT_POS);
+  	mdelay(20);
+
+  	// set RS (Reset Sequence) bit
+  	SET_BIT_IN_REG(USBTEST, USBTEST_USB1PHYCTL_BIT_POS);
+  	SET_BIT_IN_REG(USB2TEST, USBTEST_USB2PHYCTL_BIT_POS);
+  	mdelay(20);
+
+ 	// enable host
+	CLR_BIT_IN_REG(IPSRST2, IPSRST2_USBHOST_BIT_POS);
+ 	mdelay(20);
+
+
+	// az	if (utmi_init() < 0)
+// az		return -1;
+	// enable D-CACHE
+	unsigned int R0;
+	  asm volatile(	"MRC     p15, 0, R0, c1, c0, 0\n"  );
+	  asm volatile(	"ORR     R0, R0, #(0x1  <<2)\n"  );
+	  asm volatile(	"MCR     p15, 0, R0, c1, c0, 0\n"  );
+
+	*hccr = (struct ehci_hccr *)(USB_HOST_BA);
+	*hcor = (struct ehci_hcor *)((uint32_t) *hccr
+			+ HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
+
+//	debug("armada100-ehci: init hccr %x and hcor %x hc_length %d\n",
+//		(uint32_t)*hccr, (uint32_t)*hcor,
+//		(uint32_t)HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
+
+	return 0;
+}
+
+//az - usb
+int board_usb_init(int index, enum usb_init_type init)
+{
+	return 0;
+}
+
+
+/*
+ * EHCI host controller stop
+ */
+int ehci_hcd_stop(int index)
+{
+	return 0;
+}
diff --git a/common/Makefile b/common/Makefile
old mode 100644
new mode 100755
index 491c565..2f66552
--- a/common/Makefile
+++ b/common/Makefile
@@ -107,6 +107,7 @@ obj-$(CONFIG_CMD_FPGAD) += cmd_fpgad.o
 obj-$(CONFIG_CMD_FS_GENERIC) += cmd_fs.o
 obj-$(CONFIG_CMD_FUSE) += cmd_fuse.o
 obj-$(CONFIG_CMD_GETTIME) += cmd_gettime.o
+obj-$(CONFIG_CMD_GMAC) += cmd_gmac.o
 obj-$(CONFIG_CMD_GPIO) += cmd_gpio.o
 obj-$(CONFIG_CMD_I2C) += cmd_i2c.o
 obj-$(CONFIG_CMD_IOTRACE) += cmd_iotrace.o
@@ -194,6 +195,7 @@ obj-$(CONFIG_CMD_SPL) += cmd_spl.o
 obj-$(CONFIG_CMD_ZIP) += cmd_zip.o
 obj-$(CONFIG_CMD_ZFS) += cmd_zfs.o
 
+
 # others
 obj-$(CONFIG_BOOTSTAGE) += bootstage.o
 obj-$(CONFIG_CONSOLE_MUX) += iomux.o
diff --git a/common/board_f.c b/common/board_f.c
old mode 100644
new mode 100755
index 613332e..c2fcb64
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -458,6 +458,7 @@ static int reserve_uboot(void)
 	gd->relocaddr &= ~(65536 - 1);
 #endif
 
+	gd->relocaddr += CONFIG_SYS_TEXT_BASE & 0xFF;     // Trego - Keep original alignments since we relocate from CONFIG_SYS_TEXT_BASE
 	debug("Reserving %ldk for U-Boot at: %08lx\n", gd->mon_len >> 10,
 	      gd->relocaddr);
 
@@ -796,8 +797,10 @@ static init_fnc_t init_sequence_f[] = {
 #endif
 #if defined(CONFIG_ARM) || defined(CONFIG_MIPS) || \
 		defined(CONFIG_BLACKFIN) || defined(CONFIG_NDS32)
+#ifndef NPCM750     /* Done in interrupt_init */
 	timer_init,		/* initialize timer */
 #endif
+#endif
 #ifdef CONFIG_SYS_ALLOC_DPRAM
 #if !defined(CONFIG_CPM2)
 	dpram_init,
diff --git a/common/board_r.c b/common/board_r.c
old mode 100644
new mode 100755
index f8c1baa..f27a0f5
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -783,9 +783,6 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_CMD_ONENAND
 	initr_onenand,
 #endif
-#ifdef CONFIG_GENERIC_MMC
-	initr_mmc,
-#endif
 #ifdef CONFIG_HAS_DATAFLASH
 	initr_dataflash,
 #endif
@@ -842,6 +839,9 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init,
 #endif
+#ifdef CONFIG_GENERIC_MMC
+	initr_mmc,      /* Trego - MMC Must be after enable_interrupts */
+#endif
 #ifdef CONFIG_CMD_SCSI
 	INIT_FUNC_WATCHDOG_RESET
 	initr_scsi,
diff --git a/common/cmd_cache.c b/common/cmd_cache.c
old mode 100644
new mode 100755
index 37ab345..6bac97e
--- a/common/cmd_cache.c
+++ b/common/cmd_cache.c
@@ -12,8 +12,385 @@
 #include <command.h>
 #include <linux/compiler.h>
 
+volatile u32 memtest_pattern = 0x01;
+
+volatile u32 memtest_chunk_size = 1024*1024;
+volatile u32 memtest_src_addr = 0x600000;
+volatile u32 memtest_dst_addr = 0xA00000;
+
+
+#if defined (NPCM750)
+#define GDMA0_BASE                 0xF0850000      /* GDMA0  */
+#define GDMA1_BASE                 0xF0851000      /* GDMA1  */
+#define GDMA2_BASE                 0xF0852000      /* GDMA2  */
+#define GDMA3_BASE                 0xF0853000      /* GDMA3  */
+#else
+#define GDMA0_BASE                 0xF4202000      // Yarkon
+#endif
+
+void set_memory(u32 start, u32 size, u8 start_pattern)
+{
+	u8 *src = (u8 *)start;
+	int i;
+	for (i=0; i<size; i++)
+		src[i] = start_pattern++;
+}
+
+int validate_memory(u32 start, u32 size, u8 start_pattern)
+{
+	u8 *src = (u8 *)start;
+	int i;
+	for (i=0; i<size; i++) {
+		if(src[i] != start_pattern++) {
+			printf("memory error at %08x:%02x start_pattern=%d \n", start+i, src[i],--start_pattern);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+void my_memcpy(u32 source, u32 dest, u32 size)
+{
+#if 0
+	memcpy((void *)dest, (void *)source, size);
+#else
+
+	u8 *src = (u8 *)source;
+	u8 *dst = (u8 *)dest;
+	int i;
+	for (i=0; i<size; i++)
+		dst[i] = src[i];
+#endif
+}
+
+u32 my_memread(u32 source, u32 size)
+{
+	int i;
+	u32 *ptr = (u32 *) source;
+	u32 sigma = 0;
+
+	for (i = 0, sigma = 0; i < size/4; i++)
+	    sigma += *(ptr + i);
+
+	return sigma;
+}
+
+
+void test_basic_performance(void)
+{
+	u32 i,j,chunk_size = 4096;
+	u32 loops = 4096;
+	volatile u32 temp;
+#if defined (NPCM750)
+    UINT32 iUsCnt_start[2], iUsCnt_end[2];
+    u32 ticks;
+#else
+	unsigned long long start, end;
+    int ticks;
+#endif
+	
+	for (j=0; j<10; j++)
+	{
+		chunk_size <<= 1;
+		loops >>=1;
+		/* Setup the buffer */
+		temp = my_memread(memtest_src_addr, chunk_size);
+	
+#if defined (NPCM750)
+		CLK_GetTimeStamp(iUsCnt_start);
+#else
+		start = get_ticks();
+#endif	
+		for (i = 0; i < loops; i++)
+			temp = my_memread(memtest_src_addr, chunk_size);
+
+#if defined (NPCM750)
+		CLK_GetTimeStamp(iUsCnt_end);
+		ticks = ((EXT_CLOCK_FREQUENCY_MHZ * _1MHz_ * (iUsCnt_end[1] - iUsCnt_start[1])) + iUsCnt_end[0] - iUsCnt_start[0])/EXT_CLOCK_FREQUENCY_MHZ;
+		printf("Duration = %8d usec loops= %4d ",ticks, loops );
+		printf("Chunk Size = %5d KB: Performance %6d KBps \n", chunk_size/1024, chunk_size*loops*100/ticks*10);
+#else
+		end = get_ticks();
+		ticks = (end-start);
+		printf("Duration = %d msec loops= %d ",ticks, loops );
+		printf("Chunk Size = %d KB: Performance %d KBps \n", chunk_size/1024, chunk_size*loops/(end-start));
+#endif
+
+	}
+}
+
+void test_basic_copy(void)
+{
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_basic_copy failed\n");
+	else
+		puts("test_basic_copy success\n");
+}
+
+void test_inval_d_range(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_inval_d_range success\n");
+	else
+		puts("test_inval_d_range failed\n");
+}
+
+void test_flush_d_range(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	flush_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_flush_d_range failed\n");
+	else
+		puts("test_flush_d_range success\n");
+}
+
+void test_flush_d_all(void)
+{
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	flush_dcache_all();
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	flush_dcache_all();
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_flush_d_all failed\n");
+	else
+		puts("test_flush_d_all success\n");
+}
+
+
+void test_inval_d_all(void)
+{
+	memtest_pattern++;
+	set_memory(memtest_src_addr, memtest_chunk_size, memtest_pattern);
+	my_memcpy(memtest_src_addr, memtest_dst_addr, memtest_chunk_size);
+	puts("test_inval_d_all - destructive test - expect a crash after this. If there is a crash test is successful!\n");
+	invalidate_dcache_all();
+	invalidate_dcache_range(memtest_dst_addr, memtest_dst_addr+memtest_chunk_size);
+	if(validate_memory(memtest_dst_addr, memtest_chunk_size, memtest_pattern))
+		puts("test_inval_d_all failed\n");
+	else
+		puts("test_inval_d_all success\n");
+}
+
+
+#if defined (NPCM750)               // Only Poleg
+#define TEST_BUF_SIZE (1024*256)
+
+void l2_cache_test(void)
+{
+	int i, j;
+	u32 *ptr = (u32 *) 0x400000;
+	volatile u64 sigma = 0;
+
+	/* Setup the buffer */
+	for (i = 0; i < TEST_BUF_SIZE; i++) {
+		*(ptr + i) = i;
+	}
+
+	flush_dcache_range((u32) ptr, (u32) ptr + (TEST_BUF_SIZE * sizeof(u32)));
+
+	/* Here data at Cache is in sync with SDRAM */
+	for (j = 0; j < 5000; j++) 
+	{
+		for (i = 0, sigma = 0; i < TEST_BUF_SIZE; i++)
+		{
+			sigma += *(ptr + i);
+        }
+		
+		if (!(j % 500))
+		{
+			puts(".");
+    		printf("sigma: 0x%llx\n", sigma);
+        }
+	}
+
+	printf("total sigma: 0x%llx\n", sigma);
+}
+
+#define CP15_PRINT(crn, opc1, crm, opc2) \
+    asm volatile("mrc p15, "#opc1", %0, "#crn", "#crm", "#opc2"" : "=r" (reg_val)); \
+	printf("mrc p15, "#opc1", "#crn", "#crm", "#opc2" = 0x%08X\n", reg_val)
+
+void cp15_regs(void)
+{
+	u32 reg_val=0;
+
+
+	CP15_PRINT(c0, 0, c0, 0);
+	CP15_PRINT(c0, 0, c0, 1);
+	CP15_PRINT(c0, 0, c0, 2);
+	CP15_PRINT(c0, 0, c0, 3);
+	CP15_PRINT(c0, 0, c0, 5);
+	CP15_PRINT(c0, 0, c0, 6);
+    
+	CP15_PRINT(c0, 0, c1, 0);
+	CP15_PRINT(c0, 0, c1, 1);
+	CP15_PRINT(c0, 0, c1, 2);
+	CP15_PRINT(c0, 0, c1, 3);
+	CP15_PRINT(c0, 0, c1, 4);
+	CP15_PRINT(c0, 0, c1, 5);
+	CP15_PRINT(c0, 0, c1, 6);
+	CP15_PRINT(c0, 0, c1, 7);
+    
+	CP15_PRINT(c0, 0, c2, 0);
+	CP15_PRINT(c0, 0, c2, 1);
+	CP15_PRINT(c0, 0, c2, 2);
+	CP15_PRINT(c0, 0, c2, 3);
+	CP15_PRINT(c0, 0, c2, 4);
+    
+	CP15_PRINT(c0, 1, c0, 0);
+	CP15_PRINT(c0, 1, c0, 1);
+	CP15_PRINT(c0, 1, c0, 7);
+	
+	CP15_PRINT(c0, 2, c0, 0);
+
+	CP15_PRINT(c1, 0, c0, 0);
+	CP15_PRINT(c1, 0, c0, 1);
+	CP15_PRINT(c1, 0, c0, 2);
+	CP15_PRINT(c1, 0, c1, 0);
+	CP15_PRINT(c1, 0, c1, 1);
+	CP15_PRINT(c1, 0, c1, 2);
+    CP15_PRINT(c1, 0, c1, 3);
+    
+	CP15_PRINT(c2, 0, c0, 0);
+	CP15_PRINT(c2, 0, c0, 1);
+	CP15_PRINT(c2, 0, c0, 2);
+    
+	CP15_PRINT(c3, 0, c0, 0);
+    
+	CP15_PRINT(c5, 0, c0, 0);
+	CP15_PRINT(c5, 0, c0, 1);
+	CP15_PRINT(c5, 0, c1, 0);
+	CP15_PRINT(c5, 0, c1, 1);
+    
+	CP15_PRINT(c6, 0, c0, 0);
+	CP15_PRINT(c6, 0, c0, 2);
+    
+	CP15_PRINT(c7, 0, c4, 0);
+    
+	CP15_PRINT(c10, 0, c0, 0);
+	CP15_PRINT(c10, 0, c2, 0);
+	CP15_PRINT(c10, 0, c2, 1);
+    
+	CP15_PRINT(c11, 0, c0, 0);
+	CP15_PRINT(c11, 0, c0, 2);
+	CP15_PRINT(c11, 0, c0, 4);
+	CP15_PRINT(c11, 0, c1, 0);
+	CP15_PRINT(c11, 0, c1, 1);
+    
+	CP15_PRINT(c12, 0, c0, 0);
+	CP15_PRINT(c12, 0, c0, 2);
+	CP15_PRINT(c12, 0, c1, 0);
+	CP15_PRINT(c12, 0, c1, 2);
+    
+	CP15_PRINT(c15, 0, c0, 0);
+	CP15_PRINT(c15, 0, c1, 0);
+	CP15_PRINT(c15, 4, c0, 0);
+	CP15_PRINT(c15, 5, c5, 2);
+	CP15_PRINT(c15, 5, c6, 2);
+	CP15_PRINT(c15, 5, c7, 2);
+}
+
+
+#endif
+
+void gdma0_transfer(u32 source, u32 dest, u32 size)
+{
+    u32 control = 0x2201;   // Singel Mode 4 byte 4 times  burst of 16 bytes.
+	
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x04) ) = source; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x08) ) = dest; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x0C) ) = size; 
+
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) = control; 
+   control |= 0x10000;
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) = control;
+  
+//   while ((*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) & (u32)0x10000 );
+
+}
+
+
+void gdma1_transfer(u32 source, u32 dest, u32 size)
+{
+    u32 control = 0x2201;   // Singel Mode 4 byte 4 times  burst of 16 bytes.
+	
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x24) ) = source; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x28) ) = dest; 
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x2C) ) = size; 
+
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) = control; 
+   control |= 0x10000;
+   (*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) = control;
+  
+//   while ((*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) & (u32)0x10000 );
+
+}
+
+
+void gdma_mem_test(u32 src_addr, u32 dst_addr, u32 chunk_size)
+{
+
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr);
+	printf("dst_addr 0x%x\n", dst_addr);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr, chunk_size, memtest_pattern);
+	
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr + 0x100000);
+	printf("dst_addr 0x%x\n", dst_addr + 0x100000);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr + 0x100000, chunk_size, memtest_pattern);
+
+	memtest_pattern++;
+	printf("memtest_pattern %d\n", memtest_pattern);
+	printf("src_addr 0x%x\n", src_addr + 0x200000);
+	printf("dst_addr 0x%x\n", dst_addr + 0x200000);
+	printf("chunk_size 0x%x\n", chunk_size);
+	set_memory(src_addr + 0x200000, chunk_size, memtest_pattern);
+	
+	gdma0_transfer(src_addr, dst_addr, chunk_size);
+	gdma1_transfer(src_addr + 0x100000, dst_addr + 0x100000, chunk_size);
+	my_memcpy(src_addr + 0x200000, dst_addr + 0x200000, chunk_size);
+
+    while ((*(volatile unsigned int*)(GDMA0_BASE + 0x00) ) & (u32)0x10000 );   // GDMA0
+    while ((*(volatile unsigned int*)(GDMA0_BASE + 0x20) ) & (u32)0x10000 );   // GDMA1
+
+	if(validate_memory(dst_addr + 0x200000, chunk_size, memtest_pattern))
+		puts("mem_mem_test failed\n");
+	else
+		puts("mem_mem_test success\n");
+
+	if(validate_memory(dst_addr + 0x100000, chunk_size, --memtest_pattern))
+		puts("gdma1_mem_test failed\n");
+	else
+		puts("gdma1_mem_test success\n");
+
+	if(validate_memory(dst_addr, chunk_size, --memtest_pattern))
+		puts("gdma0_mem_test failed\n");
+	else
+		puts("gdma0_mem_test success\n");
+}
+
+
 static int parse_argv(const char *);
 
+// Trego- We use function at arch/arm/cpu/armv7/cache_v7.c
 void __weak invalidate_icache_all(void)
 {
 	/* please define arch specific invalidate_icache_all */
@@ -46,6 +423,7 @@ static int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+// Trego- We use function at arch/arm/lib/cache.c
 void __weak flush_dcache_all(void)
 {
 	puts("No arch specific flush_dcache_all available!\n");
@@ -69,7 +447,7 @@ static int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 		}
 		break;
 	case 1:			/* get status */
-		printf("Data (writethrough) Cache is %s\n",
+		printf("Data (write-back) Cache is %s\n",
 			dcache_status() ? "ON" : "OFF");
 		return 0;
 	default:
@@ -90,7 +468,72 @@ static int parse_argv(const char *s)
 	return -1;
 }
 
+int do_icache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
 
+    printf("I-Cache test not implemented \n");
+
+	return 0;
+}
+
+int do_dcache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+ 	test_basic_copy();
+	test_flush_d_range();
+	test_inval_d_range();
+	test_flush_d_all();
+	test_inval_d_all();
+	
+	return 0;
+}
+
+int do_cache_perf_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	test_basic_performance();
+
+	return 0;
+}
+
+int do_gdma_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 src, dst, size;
+
+
+	if (argc > 1)
+		src = simple_strtoul(argv[1], NULL, 16);
+	else
+		src = memtest_src_addr;
+
+	if (argc > 2)
+		dst = simple_strtoul(argv[2], NULL, 16);
+	else
+		dst = memtest_dst_addr;
+
+	if (argc > 3)
+		size = (ulong)simple_strtoul(argv[3], NULL, 16);
+	else
+		size = memtest_chunk_size;
+	
+	gdma_mem_test(src, dst, size);
+
+	return 0;
+}
+
+#if defined (NPCM750)               // Only Poleg
+int do_l2_cache_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	l2_cache_test();
+
+	return 0;
+}
+
+int do_cp15_regs(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	cp15_regs();
+
+	return 0;
+}
+#endif
 U_BOOT_CMD(
 	icache,   2,   1,     do_icache,
 	"enable or disable instruction cache",
@@ -104,3 +547,40 @@ U_BOOT_CMD(
 	"[on, off, flush]\n"
 	"    - enable, disable, or flush data (writethrough) cache"
 );
+
+U_BOOT_CMD(
+	dcache_test,   1,   1,     do_dcache_test,
+	"D-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	icache_test,   1,   1,     do_icache_test,
+	"I-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	cache_perf_test,   1,   1,     do_cache_perf_test,
+	"Cache performance test",
+	""
+);
+ 
+U_BOOT_CMD(
+	gdma_test,   4,   1,     do_gdma_test,
+	"GDMA test",
+	"<source> <destination> <size>"
+);
+#if defined (NPCM750)               // Only Poleg
+U_BOOT_CMD(
+	l2_cache_test,   1,   1,     do_l2_cache_test,
+	"L2-Cache test",
+	""
+);
+
+U_BOOT_CMD(
+	cp15_regs,   1,   1,     do_cp15_regs,
+	"CP15-REG's read",
+	""
+);
+#endif
\ No newline at end of file
diff --git a/common/cmd_fuse.c b/common/cmd_fuse.c
old mode 100644
new mode 100755
index d4bc0f6..0d4cc9f
--- a/common/cmd_fuse.c
+++ b/common/cmd_fuse.c
@@ -44,7 +44,7 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 {
 	const char *op = argc >= 2 ? argv[1] : NULL;
 	int confirmed = argc >= 3 && !strcmp(argv[2], "-y");
-	u32 bank, word, cnt, val;
+	u32 bank, word, cnt, val=0;
 	int ret, i;
 
 	argc -= 2 + confirmed;
@@ -63,13 +63,13 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 		printf("Reading bank %u:\n", bank);
 		for (i = 0; i < cnt; i++, word++) {
 			if (!(i % 4))
-				printf("\nWord 0x%.8x:", word);
+				printf("\nWord %d:", word);
 
 			ret = fuse_read(bank, word, &val);
 			if (ret)
 				goto err;
 
-			printf(" %.8x", val);
+			printf(" 0x%.2x", val);
 		}
 		putc('\n');
 	} else if (!strcmp(op, "sense")) {
@@ -81,13 +81,13 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 		printf("Sensing bank %u:\n", bank);
 		for (i = 0; i < cnt; i++, word++) {
 			if (!(i % 4))
-				printf("\nWord 0x%.8x:", word);
+				printf("\nWord %d:", word);
 
 			ret = fuse_sense(bank, word, &val);
 			if (ret)
 				goto err;
 
-			printf(" %.8x", val);
+			printf(" %.2x", val);
 		}
 		putc('\n');
 	} else if (!strcmp(op, "prog")) {
@@ -98,7 +98,7 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 			if (strtou32(argv[i], 16, &val))
 				return CMD_RET_USAGE;
 
-			printf("Programming bank %u word 0x%.8x to 0x%.8x...\n",
+			printf("Programming bank %u word=%d val=0x%.2x...\n",
 					bank, word, val);
 			if (!confirmed && !confirm_prog())
 				return CMD_RET_FAILURE;
@@ -114,8 +114,8 @@ static int do_fuse(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
 			if (strtou32(argv[i], 16, &val))
 				return CMD_RET_USAGE;
 
-			printf("Overriding bank %u word 0x%.8x with "
-					"0x%.8x...\n", bank, word, val);
+			printf("Overriding bank %u word %d with "
+					"0x%.2x...\n", bank, word, val);
 			ret = fuse_override(bank, word, val);
 			if (ret)
 				goto err;
diff --git a/common/cmd_gmac.c b/common/cmd_gmac.c
new file mode 100755
index 0000000..d201ebf
--- /dev/null
+++ b/common/cmd_gmac.c
@@ -0,0 +1,604 @@
+#if 0
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2008 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   cmd_gmac.c                                                                                            */
+/*            This file contains GMAC test commands                                                        */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#include <common.h>
+#include <command.h>
+#include <net.h>
+
+#undef MAX
+#undef MIN
+
+#include "BMC_HAL/Chips/chip_if.h"
+#include "BMC_HAL/Modules/gmac/Yarkon_IP/gmac_drv.h"
+
+#ifdef CONFIG_CMD_GMAC
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Sellecting GMAC port                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define EMC_TYPE                0
+#define GMAC_TYPE               1
+
+#if     CONCAT2(ETH0_TYPE, _TYPE) == GMAC_TYPE
+    #define GMAC_TEST_PORT   0
+#elif   CONCAT2(ETH1_TYPE, _TYPE) == GMAC_TYPE
+    #define GMAC_TEST_PORT   1
+#else
+    #error GMAC Port was not defined!
+#endif
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local defines                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#define GMAC_TEST_BUFFER_SIZE   128
+#define GMAC_TEST_BUFFER_NUM    1
+#define GMAC_TEST_SEED          0xFA462131
+
+#define GMAC_TEST_BUFF_WAITING  0
+#define GMAC_TEST_BUFF_SUCC     1
+#define GMAC_TEST_BUFF_FAIL     2
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Local Variables                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+// For loopback test
+static UINT8 gmac_test_mac[] = {0x00, 0x16, 0x46 ,0x9d, 0xcc, 0xc3 };
+static UINT8 gmac_test_buffer[GMAC_TEST_BUFFER_NUM][GMAC_TEST_BUFFER_SIZE] = {{0}};
+static UINT8 gmac_test_sync  [GMAC_TEST_BUFFER_NUM] = {0};
+static UINT8 gmac_test_curbuf = 0;
+
+// for buffer test
+static UINT32 gmac_test_buff_ptr    = 0;
+static UINT32 gmac_test_buff_size   = 0;
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* ICMP stuff for PING                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct
+{
+    // Ethernet
+    UINT16  padding;
+
+    UINT8   mac_dest[6];
+    UINT8   mac_src[6];
+    UINT8   eth_type[2];
+
+    // IP
+    UINT8   ip_ver;
+    UINT8   ip_type;
+    UINT16  length;
+    UINT16  ip_id;
+    UINT16  ip_flags;
+    UINT8   ip_ttl;
+    UINT8   ip_protocol;
+    UINT16  ip_checksum;
+    UINT32  ip_addr_src;
+    UINT32  ip_addr_dest;
+
+    // ICMP
+    UINT8   icmp_type;
+    UINT8   icmp_code;
+    UINT16  icmp_checksum;
+    UINT16  icmp_ident;
+    UINT16  icmp_seq;
+}  ICMP_packet_t;
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Default ICMP ping request packet                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+ICMP_packet_t ICMP_packet =
+
+{
+    0x0000,
+
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},     // Dest MAC
+    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00},     // Src MAC
+    {0x8,  0x0},                              // ETH type
+
+    0x45,    0x0,     0x1C00,
+    0x0100,          0x0040,
+    0xFF,    0x1,     0x0000,
+    0x00000000,
+    0x00000000,
+
+    0x8,     0x0,     0xFEF7,
+    0x0000,     0x0100,
+};
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Simple non-cryptographic random function implementation                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+typedef struct rand_strct {UINT32 a; UINT32 b; UINT32 c; UINT32 d; } rand_device_t;
+#define rand_rot(x,k) (((x)<<(k))|((x)>>(32-(k))))
+
+UINT32 RandGet( rand_device_t *x )
+{
+    UINT32 e = x->a - rand_rot(x->b, 27);
+    x->a = x->b ^ rand_rot(x->c, 17);
+    x->b = x->c + x->d;
+    x->c = x->d + e;
+    x->d = e + x->a;
+    return x->d;
+}
+
+void RandInit( rand_device_t *x, UINT32 seed )
+{
+    UINT32 i;
+    x->a = 0xf1ea5eed, x->b = x->c = x->d = seed;
+    for (i=0; i<20; ++i)
+    {
+        RandGet(x);
+    }
+}
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_LoopbackCallback                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for loopback test                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtest_LoopbackCallback(UINT8* buffer, UINT32 size)
+{
+    UINT8 i = 0;
+
+    printf("Executing loopback test callback\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If size is different definetly something wrong                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (size != GMAC_TEST_BUFFER_SIZE)
+    {
+        gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_FAIL;
+
+        printf("GMAC buffer test: received buffer size (0x%lX) not much the expected (0x%X)", \
+                size, GMAC_TEST_BUFFER_SIZE);
+        return;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking the buffer content                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<size; ++i)
+    {
+        if (gmac_test_buffer[gmac_test_curbuf][i] != buffer[i])
+        {
+            /*---------------------------------------------------------------------------------------------*/
+            /* If buffer is different, we mark it as failure                                               */
+            /*---------------------------------------------------------------------------------------------*/
+            gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_FAIL;
+            return;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If everything is OK, we marked the buffer as succefull                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    gmac_test_sync[gmac_test_curbuf] = GMAC_TEST_BUFF_SUCC;
+
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_bufferCallback                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  buffer -                                                                               */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for buffer send test                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtest_bufferCallback(UINT32* buffer, UINT32 size)
+{
+    UINT8 i = 0;
+
+    printf("Executing buffer test callback\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking buffer size                                                                                */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (size != gmac_test_buff_size)
+    {
+        printf("GMAC buffer test: received buffer size (0x%lX) not much the expected (0x%lX)", \
+                size, gmac_test_buff_size);
+        return;
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking the buffer content                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<size; ++i)
+    {
+        if (((UINT8*)gmac_test_buff_ptr)[i] != buffer[i])
+        {
+            printf("GMAC buffer test: received buffer element (0x%lX) not much the expected (0x%X) in offset %d", \
+                    buffer[i], ((UINT8*)gmac_test_buff_ptr)[i], i);
+            return;
+        }
+    }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_loopback                                                                      */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  internal -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GMAC loopback test                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+UINT32 GMACtest_loopback(BOOLEAN internal)
+{
+    UINT32         i = 0;
+    UINT32         j = 0;
+    rand_device_t  RandDevice;
+
+
+    printf("-----==== GMAC Loopback test ====-----\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing random device                                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    RandInit(&RandDevice, GMAC_TEST_SEED);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing test buffers                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<GMAC_TEST_BUFFER_NUM; ++i)
+    {
+        gmac_test_sync[i] = GMAC_TEST_BUFF_WAITING;
+
+        for (j=0; j<GMAC_TEST_BUFFER_SIZE; ++j)
+        {
+           gmac_test_buffer[i][j] = RandGet(&RandDevice) & 0xFF;
+        }
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing GMAC Driver                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Initialize(GMAC_TEST_PORT, TRUE, (ETH_Rx_Callback_t)GMACtest_LoopbackCallback, gmac_test_mac);
+
+    if (internal)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting internal loopback if needed                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_LoopbackInternalMode(GMAC_TEST_PORT, TRUE);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Checking loop                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    for (i=0; i<GMAC_TEST_BUFFER_NUM; ++i)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting current buffer                                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        gmac_test_curbuf = i;
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Sending the buffer to GMAC driver                                                               */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_Send(GMAC_TEST_PORT, &gmac_test_buffer[i], GMAC_TEST_BUFFER_SIZE);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Waiting for callback execution                                                                  */
+        /*-------------------------------------------------------------------------------------------------*/
+        //while(gmac_test_sync[i] == GMAC_TEST_BUFF_WAITING);
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Callback executed, checking the result                                                          */
+        /*-------------------------------------------------------------------------------------------------*/
+        if (gmac_test_sync[i] == GMAC_TEST_BUFF_FAIL)
+        {
+            printf("Buffer %ld failed in verification\n", i);
+            return 1;
+        }
+    }
+
+
+    return 0;
+}
+
+
+UINT32 GMACtest_sendbuffer(void* buffer, UINT32 size, BOOLEAN internal)
+{
+    printf("-----==== GMAC Buffer test ====-----\n");
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initializing GMAC Driver                                                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Initialize(GMAC_TEST_PORT, TRUE, (ETH_Rx_Callback_t)GMACtest_bufferCallback, gmac_test_mac);
+
+    if (internal)
+    {
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Setting internal loopback if needed                                                             */
+        /*-------------------------------------------------------------------------------------------------*/
+        GMAC_LoopbackInternalMode(GMAC_TEST_PORT, TRUE);
+    }
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Setting parapeters for the callback                                                                 */
+    /*-----------------------------------------------------------------------------------------------------*/
+    gmac_test_buff_ptr  = (UINT32)buffer;
+    gmac_test_buff_size = size;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Sending the buffer to GMAC driver                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    GMAC_Send(GMAC_TEST_PORT, buffer, size);
+
+    return 0;
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtest_getMAC                                                                        */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  mac -                                                                                  */
+/*                  str -                                                                                  */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine parse MAC string into MAC array                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static void GMACtest_getMAC(char* str, UINT8* mac)
+{
+    char *s;
+    char *e;
+    INT32 x;
+
+    s = str;
+
+    for (x = 0; x < 6; ++x)
+    {
+        mac[x] = (UINT32)simple_strtoul(s, &e, 16);
+
+        if (s)
+        {
+            s = (*e) ? e + 1 : e;
+        }
+    }
+}
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtes_ping_callback                                                                  */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  data -                                                                                 */
+/*                  size -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is a callback for GMAC ping test                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtes_ping_callback(UINT32* data, UINT32 size)
+{
+    UINT32 i=0;
+    UINT8* d = (UINT8*)data;
+
+    printf("Returned Size = %ld Data=", size);
+    for (i=0; i<size; i++)
+    {
+        printf("0x%X ", d[i]);
+    }
+    printf("\n");
+}
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        GMACtes_ping                                                                           */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  dest_ip -                                                                              */
+/*                  dest_mac -                                                                             */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs GMAC ping test                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+void GMACtes_ping(UINT32 dest_ip, UINT8* dest_mac)
+{
+    UINT32 i=0;
+    UINT8*  ptr;
+
+    GMAC_Initialize(0, TRUE, (ETH_Rx_Callback_t)GMACtes_ping_callback, gmac_test_mac);
+
+    // Setting MAC addresses
+    for (i=0; i<6; i++)
+    {
+        ICMP_packet.mac_dest[i] = dest_mac[i];
+        ICMP_packet.mac_src[i] = gmac_test_mac[i];
+    }
+
+    // Setting IP addresses
+    ICMP_packet.ip_addr_src     = 0xa00a8c0;
+    ICMP_packet.ip_addr_dest    = dest_ip;
+
+    // Setting Checksum
+    ICMP_packet.ip_checksum     = 0;
+    ICMP_packet.icmp_checksum   = 0;
+    ICMP_packet.ip_checksum     = ~NetCksum(((UINT8*)&ICMP_packet) + 14, 20 / 2);
+    ICMP_packet.icmp_checksum   = ~NetCksum(((UINT8*)&ICMP_packet) + 34, 8 / 2);
+
+
+    printf("Source IP=%lx, Dest IP= %lx\n",ICMP_packet.ip_addr_src, ICMP_packet.ip_addr_dest);
+    printf("Sending Data=");
+    ptr=(UINT8*)&ICMP_packet + 2;
+    for(i=0; i<sizeof(ICMP_packet)-2; ++i)
+    {
+        printf("0x%X ", ptr[i]);
+    }
+    printf("\n");
+
+    GMAC_Send(0, ((void*)&ICMP_packet) + 2, sizeof(ICMP_packet) - 2);
+
+
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        do_gmac                                                                                */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  argc -                                                                                 */
+/*                  argv -                                                                                 */
+/*                  cmdtp -                                                                                */
+/*                  flag -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine is the main hadle for all GMAC commands                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+int do_gmac (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    UINT32 i=0;
+
+    for (i=0; i<argc; ++i)
+    {
+        printf("%ld: %s\n",i, argv[i]);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Loopback test                                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!strcmp(argv[1], "lp"))
+    {
+        if (argc > 2)
+            if (!strcmp(argv[2], "int"))
+                return GMACtest_loopback(TRUE);
+
+        return GMACtest_loopback(FALSE);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Send buffer test                                                                                    */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else if (!strcmp(argv[1], "send_buffer"))
+    {
+        if (argc < 4)
+            return 1;
+        else if (argc < 5)
+                return GMACtest_sendbuffer((void*)simple_strtoul(argv[2], NULL, 16), \
+                                            simple_strtoul(argv[3], NULL, 16), FALSE);
+        else
+            return GMACtest_sendbuffer((void*)simple_strtoul(argv[2], NULL, 16), \
+                                        simple_strtoul(argv[3], NULL, 16), TRUE);
+
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Ping test                                                                                           */
+    /*-----------------------------------------------------------------------------------------------------*/
+    else if (!strcmp(argv[1], "ping"))
+    {
+        if (argc < 5)
+        {
+            printf("Specify IP and MAC addresses\n");
+        }
+
+        UINT8   dest_mac[8];
+        UINT32  dest_ip;
+
+
+
+        dest_ip = string_to_ip(argv[2]);
+        GMACtest_getMAC(argv[3], dest_mac);
+
+        printf("IP=0x%lX MAC=", dest_ip);
+        for (i=0; i<6; i++)
+            printf("%X",dest_mac[i]);
+        printf("\n");
+
+        GMACtes_ping(dest_ip, dest_mac);
+
+
+    }
+
+    return 0;
+}
+
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Registering the command                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+U_BOOT_CMD(
+    gmac,  5,  1,  do_gmac,
+    "GMAC test command",
+    "<test_type> [test_param]\n\n"
+    "---------------------------------------------------------------------------|\n"
+    "| test_type  |    test_param(s)     |           Description                |\n"
+    "-------------+----------------------+--------------------------------------|\n"
+    "| lp         |     [ int ]          |                                      |\n"
+    "|            |                      | int       - using internal loopback  |\n"
+    "|            |                      | if empty  - using external loopback  |\n"
+    "| send_buffer| <ptr> <size> [ int ] |                                      |\n"
+    "|            |                      | ptr       - memory address of the    |\n"
+    "|            |                      |             buffer                   |\n"
+    "|            |                      | size      - buffer size              |\n"
+    "|            |                      | int       - using internal loopback  |\n"
+    "|            |                      | if empty  - using external loopback  |\n"
+    "| ping       | <ip>  <mac>          |                                      |\n"
+    "|            |                      | ip        - IP adress of destination |\n"
+    "|            |                      | mac       - MAC adress of destination|\n"
+    "---------------------------------------------------------------------------|\n"
+);
+
+
+#endif
+#endif   /* IF 0 */
diff --git a/common/cmd_mem.c b/common/cmd_mem.c
old mode 100644
new mode 100755
index 43c3fb6..fa6b1ae
--- a/common/cmd_mem.c
+++ b/common/cmd_mem.c
@@ -888,6 +888,13 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 	for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
 		WATCHDOG_RESET();
 		addr[offset] = pattern;
+		temp = addr[offset];
+        if (pattern != temp)
+        {
+			printf("\nFAILURE (write/read): @ 0x%.8lx:"
+				" expected 0x%.8lx, actual 0x%.8lx)\n",
+				((ulong)addr + offset*sizeof(vu_long)), pattern, temp);    
+        }
 	}
 
 	/*
@@ -897,10 +904,15 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 		WATCHDOG_RESET();
 		temp = addr[offset];
 		if (temp != pattern) {
-			printf("\nFAILURE (read/write) @ 0x%.8lx:"
-				" expected 0x%.8lx, actual 0x%.8lx)\n",
+			int i;
+			for (i=0; i<10; i++)
+			{
+				printf("\nFAILURE (read/write) @ 0x%.8lx:"
+					   " expected 0x%.8lx, actual 0x%.8lx)\n",
 				start_addr + offset*sizeof(vu_long),
 				pattern, temp);
+				temp = addr[offset];
+			}            
 			errs++;
 			if (ctrlc())
 				return -1;
@@ -917,11 +929,16 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 		WATCHDOG_RESET();
 		anti_pattern = ~pattern;
 		temp = addr[offset];
-		if (temp != anti_pattern) {
-			printf("\nFAILURE (read/write): @ 0x%.8lx:"
-				" expected 0x%.8lx, actual 0x%.8lx)\n",
+		if (temp != anti_pattern) { 
+			int i;
+			for (i=0; i<10; i++)
+			{
+				printf("\nFAILURE (read/write): @ 0x%.8lx:"
+					   " expected 0x%.8lx, actual 0x%.8lx)\n",
 				start_addr + offset*sizeof(vu_long),
 				anti_pattern, temp);
+				temp = addr[offset];
+			} 
 			errs++;
 			if (ctrlc())
 				return -1;
@@ -932,6 +949,7 @@ static ulong mem_test_alt(vu_long *buf, ulong start_addr, ulong end_addr,
 	return 0;
 }
 
+
 static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 			    vu_long pattern, int iteration)
 {
@@ -940,6 +958,7 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 	ulong errs = 0;
 	ulong incr, length;
 	ulong val, readback;
+    ulong count_down;
 
 	/* Alternate the pattern */
 	incr = 1;
@@ -964,8 +983,16 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 		pattern, "");
 
 	for (addr = buf, val = pattern; addr < end; addr++) {
+        ulong read_val;
 		WATCHDOG_RESET();
 		*addr = val;
+        read_val = *addr;
+        if (val != read_val)
+        {
+            printf("\nWrite check fail @ 0x%.8lx: "
+		           "found 0x%.8lx, expected 0x%.8lx\n",
+		           (vu_long)addr, read_val, val);               
+        }
 		val += incr;
 	}
 
@@ -976,11 +1003,15 @@ static ulong mem_test_quick(vu_long *buf, ulong start_addr, ulong end_addr,
 		readback = *addr;
 		if (readback != val) {
 			ulong offset = addr - buf;
-
-			printf("\nMem error @ 0x%08X: "
+           count_down=4;
+           while(count_down--)
+           {
+			    printf("\nMem error @ 0x%08X: "
 				"found %08lX, expected %08lX\n",
 				(uint)(uintptr_t)(start_addr + offset*sizeof(vu_long)),
 				readback, val);
+                readback = *addr;     
+           }
 			errs++;
 			if (ctrlc())
 				return -1;
diff --git a/configs/PolegSVB_defconfig b/configs/PolegSVB_defconfig
new file mode 100755
index 0000000..330302c
--- /dev/null
+++ b/configs/PolegSVB_defconfig
@@ -0,0 +1,2 @@
+CONFIG_ARM=y
+CONFIG_TARGET_NPCM750=y
\ No newline at end of file
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
index 8d0fc3c..3b2fb0a
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -36,3 +36,4 @@ obj-$(CONFIG_FSL_SEC_MON) += fsl_sec_mon.o
 obj-$(CONFIG_PCA9551_LED) += pca9551_led.o
 obj-$(CONFIG_RESET) += reset-uclass.o
 obj-$(CONFIG_FSL_DEVICE_DISABLE) += fsl_devdis.o
+obj-$(CONFIG_NPCM750_OTP) += npcm750_otp.o
\ No newline at end of file
diff --git a/drivers/misc/npcm750_otp.c b/drivers/misc/npcm750_otp.c
new file mode 100755
index 0000000..5fc67e5
--- /dev/null
+++ b/drivers/misc/npcm750_otp.c
@@ -0,0 +1,42 @@
+/*
+ * (C) Copyright 2009-2013 ADVANSEE
+ * Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
+ *
+ * Based on the mpc512x iim code:
+ * Copyright 2008 Silicon Turnkey Express, Inc.
+ * Martha Marx <mmarx@silicontkx.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fuse.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{   
+    FUSE_Read ((FUSE_STORAGE_ARRAY_T)bank, (u16)word, val);
+	return 0;
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	/* We do not support overriding */
+	return -EINVAL;
+}
+
+
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	return FUSE_ProgramByte((FUSE_STORAGE_ARRAY_T)bank, (u16)word, (u8)val);
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	/* We do not support overriding */
+	return -EINVAL;
+}
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
old mode 100644
new mode 100755
index 99d0295..d31af05
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_MV_SDHCI) += mv_sdhci.o
 obj-$(CONFIG_MVEBU_MMC) += mvebu_mmc.o
 obj-$(CONFIG_MXC_MMC) += mxcmmc.o
 obj-$(CONFIG_MXS_MMC) += mxsmmc.o
+obj-$(CONFIG_NPCMX50_SDHCI) += npcmx50_sdhci.o
 obj-$(CONFIG_OMAP_HSMMC) += omap_hsmmc.o
 obj-$(CONFIG_X86) += pci_mmc.o
 obj-$(CONFIG_PXA_MMC_GENERIC) += pxa_mmc_gen.o
diff --git a/drivers/mmc/npcmx50_sdhci.c b/drivers/mmc/npcmx50_sdhci.c
new file mode 100755
index 0000000..32ea0b6
--- /dev/null
+++ b/drivers/mmc/npcmx50_sdhci.c
@@ -0,0 +1,1270 @@
+/*
+ * Copyright 2011, Marvell Semiconductor Inc.
+ * Lei Wen <leiwen@marvell.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Back ported to the 8xx platform (from the 8260 platform) by
+ * Murray.Jensen@cmst.csiro.au, 27-Jan-01.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <sdhci.h>
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* SD Host Control Register(SDHC_BA)                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCMX50_PA_SDHC(module)         SD_BASE_ADDR(module)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Global Control Register                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define NPCMX50_GCR(x)                  (GCR_BASE_ADDR + x)
+
+#define NPCMX50_PDID                    NPCMX50_GCR(0x00)
+#if defined (NPCM750)
+#define NPCMX50_PDID_Z1                 (0x00a92750)
+#define NPCMX50_PDID_Z2                 (0x04a92750)
+#define NPCMX50_PDID_A1                 (0x08a92750)
+#elif defined (NPCM650)
+#define NPCMX50_PDID_Z1                 (0x00926650)
+#define NPCMX50_PDID_Z2                 (0x04926650)
+#define NPCMX50_PDID_A1                 (0x08926650)
+#elif defined (WPCM450)
+#define NPCMX50_PDID_Z1                 (0x00926450)
+#define NPCMX50_PDID_Z2                 (0x04926450)
+#define NPCMX50_PDID_A1                 (0x08926450)
+#endif
+
+#ifndef NPCM750
+#define NPCMX50_INTCR2                  NPCMX50_GCR(0x60)
+#define NPCMX50_SDSD                    (0)
+#endif
+
+
+#ifndef _PALLADIUM_
+#define SDHC_INTERRUPT
+#endif
+
+#define CONFIG_MMC_SDMA          /* Remove to enable fatwrite from flash address to MMC as file */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For debug prints                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+
+//#define DEBUG_SDHC
+#ifdef DEBUG_SDHC
+    #define SD_MSG(f, x...)     printf("NPCMX50 SD/MMC [%s()]: " f, __func__,## x)
+#else
+    #define SD_MSG(f, x...)
+#endif
+
+#define DEBUG_CMD     /* Comment when not needed */
+#ifdef DEBUG_CMD
+    #define CMD_MSG(f, x...)     printf(f, ## x)
+#else
+    #define CMD_MSG(f, x...)
+#endif
+
+
+#define NUM_SLOTS   2
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+void *aligned_buffer = (void *)CONFIG_FIXED_SDHCI_ALIGNED_BUFFER;
+#else
+void *aligned_buffer;
+#endif
+
+
+inline void set_bit(int nr, volatile void *addr)
+{
+	int	mask;
+	unsigned int *a = (unsigned int *) addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+inline void clear_bit(int nr, volatile void *addr)
+{
+	int	mask;
+	unsigned int *a = (unsigned int *) addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_dumpregs                                                                         */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine dumps registers values                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_dumpregs(struct sdhci_host* host)
+{
+    int i=0;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* * - Read registers and print them out.                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    printf("NPCMX50 SD/MMC: ============== REGISTER DUMP ==============\n");
+
+    printf(": Sys addr: 0x%08x | Version:  0x%08x\n",
+        sdhci_readl(host, SDHCI_DMA_ADDRESS),
+        sdhci_readw(host, SDHCI_HOST_VERSION));
+    printf(": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
+        sdhci_readw(host, SDHCI_BLOCK_SIZE),
+        sdhci_readw(host, SDHCI_BLOCK_COUNT));
+    printf(": Command:  0x%08x | SW Reset: 0x%08x\n",
+        sdhci_readw(host, SDHCI_COMMAND),
+        sdhci_readb(host, SDHCI_SOFTWARE_RESET));
+    printf(": Argument: 0x%08x | Trn mode: 0x%08x\n",
+        sdhci_readl(host, SDHCI_ARGUMENT),
+        sdhci_readw(host, SDHCI_TRANSFER_MODE));
+    printf(": Present:  0x%08x | Host ctl: 0x%08x\n",
+        sdhci_readl(host, SDHCI_PRESENT_STATE),
+        sdhci_readb(host, SDHCI_HOST_CONTROL));
+    printf(": Power:    0x%08x | Blk gap:  0x%08x\n",
+        sdhci_readb(host, SDHCI_POWER_CONTROL),
+        sdhci_readb(host, SDHCI_BLOCK_GAP_CONTROL));
+    printf(": Wake-up:  0x%08x | Clock:    0x%08x\n",
+        sdhci_readb(host, SDHCI_WAKE_UP_CONTROL),
+        sdhci_readw(host, SDHCI_CLOCK_CONTROL));
+    printf(": Timeout:  0x%08x | Int stat: 0x%08x\n",
+        sdhci_readb(host, SDHCI_TIMEOUT_CONTROL),
+        sdhci_readl(host, SDHCI_INT_STATUS));
+    printf(": Int enab: 0x%08x | Sig enab: 0x%08x\n",
+        sdhci_readl(host, SDHCI_INT_ENABLE),
+        sdhci_readl(host, SDHCI_SIGNAL_ENABLE));
+    printf(": AC12 err: 0x%08x | Slot int: 0x%08x\n",
+        sdhci_readw(host, SDHCI_ACMD12_ERR),
+        sdhci_readw(host, SDHCI_SLOT_INT_STATUS));
+    printf(": Caps:     0x%08x | Max curr: 0x%08x\n",
+        sdhci_readl(host, SDHCI_CAPABILITIES),
+        sdhci_readl(host, SDHCI_MAX_CURRENT));
+
+    printf("Response = ");
+    for (i=0; i<16; i++)
+        printf("%x ",  sdhci_readb(host, SDHCI_RESPONSE + i));
+    printf("\n");
+
+
+    printf("NPCMX50 SD/MMC: ===========================================\n");
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_activate_led                                                                     */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine activates LED                                                             */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_activate_led(struct sdhci_host *host)
+{
+    u8 ctrl;
+
+    ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+    ctrl |= SDHCI_CTRL_LED;
+    sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_deactivate_led                                                                   */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  host -                                                                                 */
+/*                                                                                                         */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine deactivates LED                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_deactivate_led(struct sdhci_host *host)
+{
+    u8 ctrl;
+
+    ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+    ctrl &= ~SDHCI_CTRL_LED;
+    sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+#if defined (NPCM750)
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci1_irq                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles controller IRQs                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS sdhci1_irq(UINT32 devNum)
+{
+    HAL_STATUS result = HAL_OK;;
+    UINT32 intmask;
+    struct sdhci_host *host;
+	
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(devNum);
+    intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If no interrupt or invalid status, ignore it.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!intmask || intmask == 0xffffffff)
+    {
+        SD_MSG("Got invalid interrupt1: 0x%08x\n", intmask);
+        return result;
+    }
+
+    SD_MSG("Got interrupt1: intmask = 0x%08x\n", intmask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* For Card insert/remove                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_CARD_INSERT )
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_INSERT, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_INSERT;
+		
+        printf("MMC0 Card Inseretd ...  mmc rescan \n");
+    }
+    else if (intmask & SDHCI_INT_CARD_REMOVE)
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_REMOVE, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_REMOVE;
+		
+        printf("MMC0 Card Removed ... \n");
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Show error message for the other interrupt(s).                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_BUS_POWER)
+    {
+        printf("MMC0 Card is consuming too much power!\n");
+        sdhci_writel(host, SDHCI_INT_BUS_POWER, SDHCI_INT_STATUS);
+    }
+
+    intmask &= ~SDHCI_INT_BUS_POWER;
+
+    if (intmask)
+    {
+        printf("MMC0 Card Unexpected interrupt intmask = 0x%08x.\n", intmask);
+        sdhci_dumpregs(host);
+        sdhci_writel(host, intmask, SDHCI_INT_STATUS);
+        result = HAL_ERROR;
+    }
+
+    return result;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci2_irq                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles controller IRQs                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS sdhci2_irq(UINT32 devNum)
+{
+    HAL_STATUS result = HAL_OK;;
+    UINT32 intmask;
+    struct sdhci_host *host;
+	
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(devNum);
+    intmask = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If no interrupt or invalid status, ignore it.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (!intmask || intmask == 0xffffffff)
+    {
+        SD_MSG("Got invalid interrupt2: 0x%08x\n", intmask);
+        return result;
+    }
+
+    SD_MSG("Got interrupt2: intmask = 0x%08x\n", intmask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* For Card insert/remove                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_CARD_INSERT )
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_INSERT, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_INSERT;
+		
+        printf("MMC1 Card Inseretd ...  mmc rescan \n");
+    }
+    else if (intmask & SDHCI_INT_CARD_REMOVE)
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_REMOVE, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_REMOVE;
+		
+        printf("MMC1 Card Removed ... \n");
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Show error message for the other interrupt(s).                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_BUS_POWER)
+    {
+        printf("MMC1 Card is consuming too much power!\n");
+        sdhci_writel(host, SDHCI_INT_BUS_POWER, SDHCI_INT_STATUS);
+    }
+
+    intmask &= ~SDHCI_INT_BUS_POWER;
+
+    if (intmask)
+    {
+        printf("MMC1 Card Unexpected interrupt intmask = 0x%08x.\n", intmask);
+        sdhci_dumpregs(host);
+        sdhci_writel(host, intmask, SDHCI_INT_STATUS);
+        result = HAL_ERROR;
+    }
+
+    return result;
+}
+
+#elif defined (NPCM650)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_irq                                                                              */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                  devNum -                                                                                  */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine handles controller IRQs                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+static HAL_STATUS sdhci_irq(UINT32 devNum)
+{
+    HAL_STATUS result = HAL_OK;;
+    UINT32 intmask=0, intmask1=0, intmask2=0;
+    struct sdhci_host *host;
+    UINT32 slot =0;
+	
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(SD1_DEV);
+    intmask1 = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    host->ioaddr = (void *)NPCMX50_PA_SDHC(SD2_DEV);
+    intmask2 = sdhci_readl(host, SDHCI_INT_STATUS);
+
+    if (intmask1 && (intmask1 != 0xffffffff))
+    {
+        host->ioaddr = (void *)NPCMX50_PA_SDHC(SD1_DEV);
+        intmask=intmask1;
+        slot= 1;
+    }
+    else if (intmask2 && (intmask2 != 0xffffffff))
+    {
+	    host->ioaddr = (void *)NPCMX50_PA_SDHC(SD2_DEV);
+        intmask=intmask2;
+        slot= 2;
+    }
+    else
+    {
+       /*-----------------------------------------------------------------------------------------------------*/
+       /* If no interrupt or invalid status, ignore it.                                                       */
+       /*-----------------------------------------------------------------------------------------------------*/
+       SD_MSG("Got invalid interrupt1: intmask1=0x%08x\n", intmask1);
+       SD_MSG("Got invalid interrupt2: intmask2=0x%08x\n", intmask2);
+       return result;
+    }
+
+    SD_MSG("Got interrupt%d: intmask = 0x%08x\n", slot,intmask);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* For Card insert/remove                                                                              */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_CARD_INSERT )
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_INSERT, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_INSERT;
+		
+        printf("MMC%d Card Inseretd ...  mmc rescan \n",slot);
+    }
+    else if (intmask & SDHCI_INT_CARD_REMOVE)
+    {
+        sdhci_writel(host, intmask & SDHCI_INT_CARD_REMOVE, SDHCI_INT_STATUS);
+        intmask &= ~SDHCI_INT_CARD_REMOVE;
+		
+        printf("MMC%d Card Removed ... \n",slot);
+    }
+
+
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Show error message for the other interrupt(s).                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (intmask & SDHCI_INT_BUS_POWER)
+    {
+        printf("MMC%d Card is consuming too much power!\n",slot);
+        sdhci_writel(host, SDHCI_INT_BUS_POWER, SDHCI_INT_STATUS);
+    }
+
+    intmask &= ~SDHCI_INT_BUS_POWER;
+
+    if (intmask)
+    {
+        printf("MMC%d Card Unexpected interrupt intmask = 0x%08x.\n", slot, intmask);
+        sdhci_dumpregs(host);
+        sdhci_writel(host, intmask, SDHCI_INT_STATUS);
+        result = HAL_ERROR;
+    }
+
+    return result;
+}
+#endif
+
+static void sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	unsigned long timeout;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
+	
+	/*-----------------------------------------------------------------------------------------------------*/
+    /* If it is reset all, it must delay a while.                                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (mask & SDHCI_RESET_ALL)
+    {
+        host->clock = 0;
+        SD_MSG("reset host->clock = 0 for RESET_ALL\n");
+
+        /*-------------------------------------------------------------------------------------------------*/
+        /* Without the delay, the driver hangs after second reset called after registering IRQ, when the   */
+        /* driver is built in kernel!                                                                      */
+        /*-------------------------------------------------------------------------------------------------*/
+		udelay(1000);
+    }
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+		if (timeout == 0) {
+			printf("%s: Reset 0x%x never completed.\n",
+			       __func__, (int)mask);
+			sdhci_dumpregs(host);
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
+{
+	int i;
+	
+	SD_MSG("slot = %d, opcode = %d, resp_type = %x\n", host->index, cmd->cmdidx, cmd->resp_type);
+#ifdef DEBUG_SDHC
+	sdhci_dumpregs(host);
+#endif
+	if (cmd->resp_type & MMC_RSP_136) {
+		/* CRC is stripped so we need to do some shifting. */
+		for (i = 0; i < 4; i++) {
+			cmd->response[i] = sdhci_readl(host,
+					SDHCI_RESPONSE + (3-i)*4) << 8;
+			if (i != 3)
+				cmd->response[i] |= sdhci_readb(host,
+						SDHCI_RESPONSE + (3-i)*4-1);
+		}
+	} else {
+		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
+	}
+}
+
+static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
+{
+	int i;
+	char *offs;
+	for (i = 0; i < data->blocksize; i += 4) {
+		offs = data->dest + i;
+		if (data->flags == MMC_DATA_READ)
+			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
+		else
+			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
+	}
+}
+
+static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
+				unsigned int start_addr)
+{
+	unsigned int stat, rdy, mask, timeout, block = 0;
+#ifdef CONFIG_MMC_SDMA
+	unsigned char ctrl;
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	ctrl &= ~SDHCI_CTRL_DMA_MASK;
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+#endif
+
+	timeout = 1000000;
+	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
+	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR) {
+			printf("%s: Error detected in status(0x%X)!\n",
+			       __func__, stat);
+			return -1;
+		}
+		if (stat & rdy) {
+			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
+				continue;
+			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
+			sdhci_transfer_pio(host, data);
+			data->dest += data->blocksize;
+			if (++block >= data->blocks)
+				break;
+		}
+#ifdef CONFIG_MMC_SDMA
+		if (stat & SDHCI_INT_DMA_END) {
+			sdhci_writel(host, SDHCI_INT_DMA_END, SDHCI_INT_STATUS);
+			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
+			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
+			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		}
+#endif
+		if (timeout-- > 0)
+			udelay(10);
+		else {
+			printf("%s: Transfer data timeout\n", __func__);
+			return -1;
+		}
+	} while (!(stat & SDHCI_INT_DATA_END));
+	return 0;
+}
+
+/*
+ * No command will be sent by driver if card is busy, so driver must wait
+ * for card ready state.
+ * Every time when card is busy after timeout then (last) timeout value will be
+ * increased twice but only if it doesn't exceed global defined maximum.
+ * Each function call will use last timeout value. Max timeout can be redefined
+ * in board config file.
+ */
+#ifndef CONFIG_SDHCI_CMD_MAX_TIMEOUT
+#define CONFIG_SDHCI_CMD_MAX_TIMEOUT		3200
+#endif
+#define CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT	100
+
+static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
+		       struct mmc_data *data)
+{
+	struct sdhci_host *host = mmc->priv;
+	unsigned int stat = 0;
+	int ret = 0;
+	int trans_bytes = 0, is_aligned = 1;
+	u32 mask, flags, mode;
+	unsigned int time = 0, start_addr = 0;
+	int mmc_dev = mmc->block_dev.dev;
+	unsigned start = get_timer(0);
+
+	/* Timeout unit - ms */
+	static unsigned int cmd_timeout = CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT;
+
+    SD_MSG("slot = %d, opcode = %d, argument = %x\n", host->index, cmd->cmdidx, cmd->cmdarg);
+
+    sdhci_activate_led(host);
+	
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
+
+	/* We shouldn't wait for data inihibit for stop commands, even
+	   though they might use busy signaling */
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		mask &= ~SDHCI_DATA_INHIBIT;
+        
+	SD_MSG("slot = %d cmdidx = 0x%x mask=0x%x\n",host->index, cmd->cmdidx, mask);            
+
+	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
+		if (time >= cmd_timeout) {
+			printf("%s: MMC: %d busy ", __func__, mmc_dev);
+			if (2 * cmd_timeout <= CONFIG_SDHCI_CMD_MAX_TIMEOUT) {
+				cmd_timeout += cmd_timeout;
+				printf("timeout increasing to: %u ms.\n",
+				       cmd_timeout);
+			} else {
+                sdhci_deactivate_led(host);
+				puts("timeout.\n");
+				return COMM_ERR;
+			}
+		}
+		time++;
+		udelay(1000);
+	}
+
+	SD_MSG("slot = %d time = %d \n",host->index, time);            
+
+	mask = SDHCI_INT_RESPONSE;
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = SDHCI_CMD_RESP_NONE;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = SDHCI_CMD_RESP_LONG;
+	else if (cmd->resp_type & MMC_RSP_BUSY) {
+		flags = SDHCI_CMD_RESP_SHORT_BUSY;
+		mask |= SDHCI_INT_DATA_END;
+	} else
+		flags = SDHCI_CMD_RESP_SHORT;
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= SDHCI_CMD_CRC;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= SDHCI_CMD_INDEX;
+	if (data)
+		flags |= SDHCI_CMD_DATA;
+
+	/* Set Transfer mode regarding to data flag */
+	if (data != 0) {
+		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+		mode = SDHCI_TRNS_BLK_CNT_EN;
+		trans_bytes = data->blocks * data->blocksize;
+		if (data->blocks > 1)
+			mode |= SDHCI_TRNS_MULTI;
+
+		if (data->flags == MMC_DATA_READ)
+			mode |= SDHCI_TRNS_READ;
+
+#ifdef CONFIG_MMC_SDMA
+		if (data->flags == MMC_DATA_READ)
+			start_addr = (unsigned long)data->dest;
+		else
+			start_addr = (unsigned long)data->src;
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				(start_addr & 0x7) != 0x0) {
+			is_aligned = 0;
+			start_addr = (unsigned long)aligned_buffer;
+			if (data->flags != MMC_DATA_READ)
+				memcpy(aligned_buffer, data->src, trans_bytes);
+		}
+
+#if defined(CONFIG_FIXED_SDHCI_ALIGNED_BUFFER)
+		/*
+		 * Always use this bounce-buffer when
+		 * CONFIG_FIXED_SDHCI_ALIGNED_BUFFER is defined
+		 */
+		is_aligned = 0;
+		start_addr = (unsigned long)aligned_buffer;
+		if (data->flags != MMC_DATA_READ)
+			memcpy(aligned_buffer, data->src, trans_bytes);
+#endif
+
+		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
+		mode |= SDHCI_TRNS_DMA;
+#endif
+		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
+				data->blocksize),
+				SDHCI_BLOCK_SIZE);
+		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
+		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
+	} else if (cmd->resp_type & MMC_RSP_BUSY) {
+		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
+	}
+
+	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
+#ifdef CONFIG_MMC_SDMA
+	flush_cache(start_addr, trans_bytes);
+#endif
+	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
+	start = get_timer(0);
+	
+#ifdef DEBUG_SDHC
+	sdhci_dumpregs(host);
+#endif
+	do {
+		stat = sdhci_readl(host, SDHCI_INT_STATUS);
+		if (stat & SDHCI_INT_ERROR)
+			break;
+	} while (((stat & mask) != mask) &&
+		 (get_timer(start) < CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT));
+
+	if (get_timer(start) >= CONFIG_SDHCI_CMD_DEFAULT_TIMEOUT) {
+		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
+			return 0;
+		else {
+			printf("%s: Timeout for status update!\n", __func__);
+			return TIMEOUT;
+		}
+	}
+
+	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
+		sdhci_cmd_done(host, cmd);
+		sdhci_writel(host, mask, SDHCI_INT_STATUS);
+	} else
+		ret = -1;
+
+	if (!ret && data)
+		ret = sdhci_transfer_data(host, data, start_addr);
+
+	if (host->quirks & SDHCI_QUIRK_WAIT_SEND_CMD)
+		udelay(1000);
+
+	stat = sdhci_readl(host, SDHCI_INT_STATUS);
+	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
+	if (!ret) {
+		if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) &&
+				!is_aligned && (data->flags == MMC_DATA_READ))
+	    memcpy(data->dest, aligned_buffer, trans_bytes);
+		sdhci_deactivate_led(host);
+		return 0;
+	}
+    sdhci_deactivate_led(host);
+	sdhci_reset(host, SDHCI_RESET_CMD);
+	sdhci_reset(host, SDHCI_RESET_DATA);
+	if (stat & SDHCI_INT_TIMEOUT)
+	{
+	    CMD_MSG("CMD TIMEOUT slot=%d cmd=%d \n",host->index, cmd->cmdidx);           
+		return TIMEOUT;
+	}
+	else
+	{
+	    CMD_MSG("CMD ERROR slot=%d cmd=%d \n",host->index, cmd->cmdidx);           
+		return COMM_ERR;
+	}
+}
+
+static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
+{
+	struct sdhci_host *host = mmc->priv;
+	unsigned int div, clk, timeout;
+
+    SD_MSG("slot = %d, host->clock = %d, clock = %d\n",
+            host->index, host->clock, clock);
+			
+   /*-----------------------------------------------------------------------------------------------------*/
+    /* f the desired clock equals to the clock set in host, just return.                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (clock == host->clock)
+        return 0;
+
+#ifndef NPCM750
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* If it is MMC, must disable SD sampling delay.                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if (clock == 26000000 || clock == 20000000)
+    {
+        clear_bit(NPCMX50_SDSD,(void *)(NPCMX50_INTCR2));
+    }
+#endif
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set clock to 0 first.                                                                               */
+    /*-----------------------------------------------------------------------------------------------------*/
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SD sampling delay for SD standard timing if clock=0                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+	if (clock == 0)
+		return 0;
+
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
+		/* Version 3.00 divisors must be a multiple of 2. */
+		if (mmc->cfg->f_max <= clock)
+			div = 1;
+		else {
+			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
+				if ((mmc->cfg->f_max / div) <= clock)
+					break;
+			}
+		}
+	} else {
+		/* Version 2.00 divisors must be a power of 2. */
+		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
+			if ((mmc->cfg->f_max / div) <= clock)
+				break;
+		}
+	}
+	div >>= 1;
+
+	if (host->set_clock)
+		host->set_clock(host->index, div);
+
+	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
+	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
+		<< SDHCI_DIVIDER_HI_SHIFT;
+	clk |= SDHCI_CLOCK_INT_EN;
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Set up register for the clock.                                                                      */
+    /*-----------------------------------------------------------------------------------------------------*/
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Wait until the clock is stable, or max 20 ms                                                        */
+    /*-----------------------------------------------------------------------------------------------------*/
+	timeout = 20;
+	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
+		& SDHCI_CLOCK_INT_STABLE)) {
+		if (timeout == 0) {
+			printf("%s: Internal clock never stabilised.\n",
+			       __func__);
+            sdhci_dumpregs(host);
+			return -1;
+		}
+		timeout--;
+		udelay(1000);
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable the clock.                                                                                   */
+    /*-----------------------------------------------------------------------------------------------------*/
+    clk |= SDHCI_CLOCK_CARD_EN;
+	
+	SD_MSG("SDHCI_CLOCK_CONTROL clk = 0x%x\n", clk);
+	
+    sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	
+	return 0;
+}
+
+static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
+{
+	u8 pwr = 0;
+	
+
+	SD_MSG(" power = 0x%x\n", power);
+
+	if (power != (unsigned short)-1) {
+		switch (1 << power) {
+		case MMC_VDD_165_195:
+			pwr = SDHCI_POWER_180;
+			break;
+		case MMC_VDD_29_30:
+		case MMC_VDD_30_31:
+			pwr = SDHCI_POWER_300;
+			break;
+		case MMC_VDD_32_33:
+		case MMC_VDD_33_34:
+			pwr = SDHCI_POWER_330;
+			break;
+		}
+	}
+	
+	SD_MSG("SDHCI_POWER_CONTROL pwr = 0x%x\n", pwr);
+
+	if (pwr == 0) {
+		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+	    sdhci_reset(host, SDHCI_RESET_ALL);
+		return;
+	}
+
+	if (host->quirks & SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER)
+		sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+
+	pwr |= SDHCI_POWER_ON;
+
+	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
+}
+
+static void sdhci_set_ios(struct mmc *mmc)
+{
+	u32 ctrl;
+	struct sdhci_host *host = mmc->priv;
+	
+	SD_MSG("slot = %d, mmc->clock=%d mmc->bus_width=%d\n",
+           host->index, mmc->clock, mmc->bus_width);
+
+
+	if (host->set_control_reg)
+		host->set_control_reg(host);
+
+	if (mmc->clock != host->clock)
+		sdhci_set_clock(mmc, mmc->clock);
+
+	/* Set bus width */
+	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+	if (mmc->bus_width == 8) {
+		ctrl &= ~SDHCI_CTRL_4BITBUS;
+		if ((SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) ||
+				(host->quirks & SDHCI_QUIRK_USE_WIDE8))
+			ctrl |= SDHCI_CTRL_8BITBUS;
+	} else {
+		if ((SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) ||
+				(host->quirks & SDHCI_QUIRK_USE_WIDE8))
+			ctrl &= ~SDHCI_CTRL_8BITBUS;
+		if (mmc->bus_width == 4)
+			ctrl |= SDHCI_CTRL_4BITBUS;
+		else
+			ctrl &= ~SDHCI_CTRL_4BITBUS;
+	}
+
+	if (mmc->clock > 26000000)
+		ctrl |= SDHCI_CTRL_HISPD;
+	else
+		ctrl &= ~SDHCI_CTRL_HISPD;
+
+	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
+		ctrl &= ~SDHCI_CTRL_HISPD;
+		
+    SD_MSG("SDHCI_HOST_CONTROL ctrl = %d\n", ctrl);
+
+	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_init(struct mmc *mmc)
+{
+	struct sdhci_host *host = mmc->priv;
+	
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
+		aligned_buffer = memalign(8, 512*1024);
+		if (!aligned_buffer) {
+			printf("%s: Aligned buffer alloc failed!!!\n",
+			       __func__);
+			return -1;
+		}
+	}
+
+	sdhci_set_power(host, fls(mmc->cfg->voltages) - 1);
+
+	if (host->quirks & SDHCI_QUIRK_NO_CD) {
+		unsigned int status;
+
+		sdhci_writeb(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
+			SDHCI_HOST_CONTROL);
+
+		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
+		while ((!(status & SDHCI_CARD_PRESENT)) ||
+		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
+		    (!(status & SDHCI_CARD_DETECT_PIN_LEVEL)))
+			status = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	}
+
+#ifdef SDHC_INTERRUPT
+	/* Enable only interrupts served by the SD controller */
+	sdhci_writel(host, SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE | SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK, SDHCI_INT_ENABLE);
+	/* Mask all sdhci interrupt sources */
+	sdhci_writel(host, SDHCI_INT_CARD_INSERT | SDHCI_INT_CARD_REMOVE, SDHCI_SIGNAL_ENABLE);
+#else
+	/* Enable only interrupts served by the SD controller */
+	sdhci_writel(host, SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK,
+		     SDHCI_INT_ENABLE);
+	/* Mask all sdhci interrupt sources */
+	sdhci_writel(host, 0x0, SDHCI_SIGNAL_ENABLE);
+
+#endif
+	return 0;
+}
+
+
+static const struct mmc_ops sdhci_ops = {
+	.send_cmd	= sdhci_send_command,
+	.set_ios	= sdhci_set_ios,
+	.init		= sdhci_init,
+};
+
+int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
+{
+	unsigned int caps;
+
+	host->cfg.name = host->name;
+	host->cfg.ops = &sdhci_ops;
+
+	caps = sdhci_readl(host, SDHCI_CAPABILITIES);
+#ifdef CONFIG_MMC_SDMA
+	if (!(caps & SDHCI_CAN_DO_SDMA)) {
+		printf("%s: Your controller doesn't support SDMA!!\n",
+		       __func__);
+		return -1;
+	}
+#endif
+
+	if (max_clk)
+		host->cfg.f_max = max_clk;
+	else {
+		if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+			host->cfg.f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		else
+			host->cfg.f_max = (caps & SDHCI_CLOCK_BASE_MASK)
+				>> SDHCI_CLOCK_BASE_SHIFT;
+		host->cfg.f_max *= 1000000;
+	}
+	if (host->cfg.f_max == 0) {
+		printf("%s: Hardware doesn't specify base clock frequency\n",
+		       __func__);
+		return -1;
+	}
+	if (min_clk)
+		host->cfg.f_min = min_clk;
+	else {
+		if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+			host->cfg.f_min = host->cfg.f_max /
+				SDHCI_MAX_DIV_SPEC_300;
+		else
+			host->cfg.f_min = host->cfg.f_max /
+				SDHCI_MAX_DIV_SPEC_200;
+	}
+
+	host->cfg.voltages = 0;
+	if (caps & SDHCI_CAN_VDD_330)
+		host->cfg.voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
+	if (caps & SDHCI_CAN_VDD_300)
+		host->cfg.voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & SDHCI_CAN_VDD_180)
+		host->cfg.voltages |= MMC_VDD_165_195;
+
+	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
+		host->cfg.voltages |= host->voltages;
+
+	host->cfg.host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300) {
+		if (caps & SDHCI_CAN_DO_8BIT)
+			host->cfg.host_caps |= MMC_MODE_8BIT;
+	}
+	if (host->host_caps)
+		host->cfg.host_caps |= host->host_caps;
+
+	SD_MSG("host->cfg.host_caps = 0x%x\n", host->cfg.host_caps);
+    
+	host->cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+
+	sdhci_reset(host, SDHCI_RESET_ALL);
+
+	host->mmc = mmc_create(&host->cfg, host);
+	if (host->mmc == NULL) {
+		printf("%s: mmc create fail!\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                         Device init                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_init_slot                                                                       */
+/*                                                                                                         */
+/* Parameters:                                                                                             */
+/*                                                                               */
+/*                  slot -                                                                                 */
+/*                                                                                                         */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs slot initialization                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+static int sdhci_init_slot(int slot)
+{
+    int ret = 0;
+    unsigned int version;
+    unsigned int caps=0;
+	unsigned int  f_min;
+	unsigned int  f_max;
+	struct sdhci_host *host = NULL;
+
+	host = (struct sdhci_host *)calloc(1,sizeof(struct sdhci_host));
+	if (!host) {
+		printf("sdhci_init_slot: sdhci_host calloc fail\n");
+		return 1;
+	}
+
+
+	host->name = "npcmx50_sdhci";
+	host->ioaddr = (void *)NPCMX50_PA_SDHC(slot);
+	host->quirks = SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_WAIT_SEND_CMD;
+#if defined (NPCM750)
+    if(slot == SD2_DEV)
+    {
+	   host->quirks |= SDHCI_QUIRK_NO_CD;     // eMMC - Set Software Card Detect
+    }
+#endif
+	host->index = slot;
+		
+    sdhci_reset(host, SDHCI_RESET_ALL);
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Read version and capabilities of the SDHC.                                                      */
+    /*-------------------------------------------------------------------------------------------------*/
+    version = sdhci_readw(host, SDHCI_HOST_VERSION);
+    host->version = version = (version & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT;
+    SD_MSG("SDHC version = %d\n", version);
+    if (version > 2)
+	{
+        printf("NPCMX50 SD/MMC slot=%d: Unknown controller version (%d). "
+                "You may experience problems.\n", host->index,
+                version);
+    }
+		
+    caps = sdhci_readl(host, SDHCI_CAPABILITIES);
+
+
+
+    /*-------------------------------------------------------------------------------------------------*/
+    /* Set MMC host parameters according to device's capabilities.                                     */
+    /*-------------------------------------------------------------------------------------------------*/
+//    f_min = 52000000 / 128;
+    f_min = 52000000 / 256;
+    f_max = 52000000;
+	
+    SD_MSG("caps = 0x%x, f_max = %d, f_min = %d\n",
+            caps, f_max, f_min);
+
+	
+/*-----------------------------------------------------------------------------------------------------*/
+/* Enable Interrupt Group                                                                              */
+/*-----------------------------------------------------------------------------------------------------*/
+#ifdef SDHC_INTERRUPT
+#if defined (SD_INTERRUPT)
+#if defined (NPCM750)
+    if(slot == SD1_DEV)
+    {
+       ret |= AIC_RegisterHandler(SD_INTERRUPT(slot), sdhci1_irq, (UINT32)slot);
+    }
+    else if(slot == SD2_DEV)
+    {
+       ret |= AIC_RegisterHandler(SD_INTERRUPT(slot), sdhci2_irq, (UINT32)slot);
+    }
+    ret |= AIC_EnableInt(SD_INTERRUPT(slot));
+#elif defined (NPCM650)
+    ret |= AIC_EnableGroupInt(SD_GROUP_INTERRUPT(slot));
+    ret |= AIC_RegisterHandler(SD_INTERRUPT(slot), sdhci_irq, (UINT32)SD1_DEV);
+    ret |= AIC_EnableInt(SD_INTERRUPT(SD1_DEV));                                      // SDHC_INT - One interrupt vector for 2 SD card slots in NPCM650
+#endif
+#endif
+#endif
+	
+	add_sdhci(host, f_max, f_min);
+	
+	return 0;
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+/*                                              Hardware init                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        sdhci_module_init                                                                      */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:         none                                                                                   */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*                  This routine performs HW init                                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+static void sdhci_module_init(UINT32 sdNum)
+{
+    SD_MSG("enter\n");
+
+#ifdef SDHC_INTERRUPT
+#if defined (SD_INTERRUPT)
+#if defined (NPCM750)
+    AIC_DisableInt(SD_INTERRUPT(sdNum));
+#elif defined (NPCM650)
+    AIC_DisableGroupInt(SD_GROUP_INTERRUPT(sdNum));
+    AIC_DisableInt(SD_INTERRUPT(SD1_DEV));            // One interrupt vector for 2 SD card slots in NPCM650
+#endif
+#endif
+#endif
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SDIO                                                                                         */
+    /*-----------------------------------------------------------------------------------------------------*/
+    if(SD1_DEV == sdNum)
+    {
+    	GCR_Mux_SD(sdNum, SD_DEV_SD);
+    }
+    else if(SD2_DEV == sdNum)
+    {
+#if defined (NPCM750)    
+    	GCR_Mux_SD(sdNum, SD_DEV_MMC8);
+#elif defined (NPCM650)
+    	GCR_Mux_SD(sdNum, SD_DEV_SD);
+#endif        
+    }
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Enable SDIO clock, CLKEN/SDIO=1                                                                     */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ConfigureSDClock(sdNum);
+
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* SD Card Interface - Set/clear Software Reset Control Bit                                            */
+    /*-----------------------------------------------------------------------------------------------------*/
+    CLK_ResetSD(sdNum);
+
+}
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Function:        npcmx50_mmc_init                                                                 */
+/*                                                                                                         */
+/* Parameters:      none                                                                                   */
+/* Returns:                                                                                                */
+/* Side effects:                                                                                           */
+/* Description:                                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+int npcmx50_mmc_init(void)
+{
+    int ret=0;
+    int i;
+    int pdid;
+	
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Verify H/W version. If it is Z1, it does not support SDHC.                                          */
+    /*-----------------------------------------------------------------------------------------------------*/
+    pdid = readl(NPCMX50_PDID);
+    SD_MSG("PDID=0x%x\n", pdid);
+#if defined (WPCM450)
+    if (pdid == NPCMX50_PDID_Z1)
+    {
+        printf("NPCMX50 SD/MMC H/W is not supported!!! PDID=0x%x\n", pdid);
+		return -1;
+    }
+#endif
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Initialize registers for SDHC                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/
+    sdhci_module_init(SD1_DEV);
+    sdhci_module_init(SD2_DEV);
+
+#ifdef _PALLADIUM_
+    printf("Palladium - Wait few minutes for SD card to be detected !!!\n");
+#endif
+
+    for (i = 0; i < NUM_SLOTS; i++)
+    {
+        ret = sdhci_init_slot(i);
+        if (ret)
+        {
+            printf("NPCMX50 SD/MMC npcmx50_mmc_init error, slot %d\n", i);
+        }	
+    }
+    return ret;
+}
\ No newline at end of file
diff --git a/drivers/net/designware.c b/drivers/net/designware.c
old mode 100644
new mode 100755
index 6433896..e324440
--- a/drivers/net/designware.c
+++ b/drivers/net/designware.c
@@ -469,6 +469,7 @@ int designware_initialize(ulong base_addr, u32 interface)
 {
 	struct eth_device *dev;
 	struct dw_eth_dev *priv;
+	int id = -1;
 
 	dev = (struct eth_device *) malloc(sizeof(struct eth_device));
 	if (!dev)
@@ -488,7 +489,15 @@ int designware_initialize(ulong base_addr, u32 interface)
 	memset(dev, 0, sizeof(struct eth_device));
 	memset(priv, 0, sizeof(struct dw_eth_dev));
 
-	sprintf(dev->name, "dwmac.%lx", base_addr);
+    if (base_addr == GMAC_BASE_ADDR(0))
+    {
+        id=2;       /* ETH2 */
+    }
+    else if (base_addr == GMAC_BASE_ADDR(1))
+    {
+        id=3;       /* ETH3 */
+    }        
+	sprintf(dev->name, "ETH%d", id);        /* Trego - Print eth name same as GMAC-HAL */
 	dev->iobase = (int)base_addr;
 	dev->priv = priv;
 
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
old mode 100644
new mode 100755
index a6023f1..07f4e0a
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -630,8 +630,11 @@ static struct phy_device *create_phy_by_mask(struct mii_dev *bus,
 		int addr = ffs(phy_mask) - 1;
 		int r = get_phy_id(bus, addr, devad, &phy_id);
 		/* If the PHY ID is mostly f's, we didn't find anything */
-		if (r == 0 && (phy_id & 0x1fffffff) != 0x1fffffff)
+		if ((r == 0) && ((phy_id & 0x1fffffff) != 0x1fffffff) && (phy_id != 0x0000FFFF) && (phy_id != 0x00000000))
+        {
+            printf("RGMII-Phy Addr: 0x%x  ", addr);
 			return phy_device_create(bus, addr, phy_id, interface);
+        }
 		phy_mask &= ~(1 << addr);
 	}
 	return NULL;
@@ -721,6 +724,17 @@ int phy_reset(struct phy_device *phydev)
 #ifdef CONFIG_PHY_RESET_DELAY
 	udelay(CONFIG_PHY_RESET_DELAY);	/* Intel LXT971A needs this */
 #endif
+
+#ifdef NPCM750
+#ifndef CONFIG_SYS_DELL_DRB_HW
+    /*-----------------------------------------------------------------------------------------------------*/
+    /* Phy 125Mhz Clock Output Enable (for BMC54612e)                                                                       */
+    /*-----------------------------------------------------------------------------------------------------*/    
+	phy_write(phydev, devad, 0x17, 0xD34);    // In Phy Reg 17h -> Enable Top Level Expantion Register 34H
+    phy_write(phydev, devad, 0x15, 0x3);      // In Phy Reg 15h (34h) -> Enable 125MHZ clock output 
+  	phy_write(phydev, devad, 0x17, 0x0);      // In Phy Reg 17h -> Disable Top Level Expantion Register 34H  
+#endif
+#endif
 	/*
 	 * Poll the control register for the reset bit to go to 0 (it is
 	 * auto-clearing).  This should happen within 0.5 seconds per the
diff --git a/drivers/serial/serial.c b/drivers/serial/serial.c
old mode 100644
new mode 100755
index 699c410..d0a609d
--- a/drivers/serial/serial.c
+++ b/drivers/serial/serial.c
@@ -144,6 +144,7 @@ serial_initfunc(mpc8xx_serial_initialize);
 serial_initfunc(mxc_serial_initialize);
 serial_initfunc(mxs_auart_initialize);
 serial_initfunc(ns16550_serial_initialize);
+serial_initfunc(nuvoton_serial_initialize);
 serial_initfunc(oc_serial_initialize);
 serial_initfunc(p3mx_serial_initialize);
 serial_initfunc(pl01x_serial_initialize);
@@ -237,6 +238,7 @@ void serial_initialize(void)
 	mxc_serial_initialize();
 	mxs_auart_initialize();
 	ns16550_serial_initialize();
+	nuvoton_serial_initialize();    
 	oc_serial_initialize();
 	p3mx_serial_initialize();
 	pl01x_serial_initialize();
diff --git a/include/configs/HermonSVB.h b/include/configs/HermonSVB.h
new file mode 100755
index 0000000..8c69d97
--- /dev/null
+++ b/include/configs/HermonSVB.h
@@ -0,0 +1,82 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   HermonSVB.h                                                                                           */
+/*            This file contains configurations for the wpcm450 compilation                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __HERMONSVB_H
+#define __HERMONSVB_H
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define DEBUG                           1
+//#define NO_INTERRUPTS
+//#define VERBOSE_GLOBAL
+
+
+#define CONFIG_SYS_L2CACHE_OFF	        1	/* No L2 CACHE */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Compilation options                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BOARD_LOWLEVEL_INIT      1
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE        128                           //size in bytes reserved for initial data
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BAUDRATE                 115200
+#define CONFIG_SYS_BAUDRATE_TABLE       { 9600, 19200, 38400, 57600, 115200 }
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS1,115200n8 initrd=0x1d00000,3000000 mem=64M"
+
+#define CONFIG_IPADDR                   192.168.0.10
+#define CONFIG_NETMASK                  255.0.0.0
+#define CONFIG_SERVERIP                 192.168.0.1
+#define CONFIG_GATEWAYIP                192.168.0.1
+#define CONFIG_ETHADDR                  00:0F:A0:00:00:00
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:0F:A0:00:00:01
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_ENV_OFFSET           0x200000                                    // environment offset in flash and ram
+#define CONFIG_ENV_SIZE                 0x10000                                     // Total Size alocated for environment
+
+#define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+#define CONFIG_SYS_ENV_SECT_SIZE        0x200                                       // Env sector size
+#define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+#define CONFIG_ENV_OVERWRITE
+
+
+
+
+#endif // __HERMONSVB_H
+
diff --git a/include/configs/PolegSVB.h b/include/configs/PolegSVB.h
new file mode 100755
index 0000000..1e75565
--- /dev/null
+++ b/include/configs/PolegSVB.h
@@ -0,0 +1,184 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   PolegSVB.h                                                                                           */
+/*            This file contains configurations for the PolegSVB compilation                              */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __POLEGPALLADIUM_H
+#define __POLEGPALLADIUM_H
+
+
+/*---------------------------------------------------------------------------*/
+/* Please Start here and Select Board's configuration                        */
+/*---------------------------------------------------------------------------*/
+
+/* ########## Activate Palladium bypasses ########## */
+/*#define _PALLADIUM_                       1*/
+
+/* ########## Remove flash support ########## */ 
+/*#define _CONFIG_NO_FLASH_                 1       */
+
+
+/* ########## Enable DELL_DRB HW changes from PolegSVB ########## */
+/*#define CONFIG_SYS_DELL_DRB_HW            1*/
+
+
+
+/*
+ * Warning: changing CONFIG_SYS_TEXT_BASE requires
+ * adapting the initial boot program.
+ * Since the linker has to swallow that define, we must use a pure
+ * hex number here!
+ */
+ 
+/* DO NOT move this Define !*/
+#ifdef _PALLADIUM_
+#define CONFIG_SYS_TEXT_BASE		0x8200           /* Palladium   */
+/*#define CONFIG_SYS_TEXT_BASE		0x80080000       // BOOT From FLASH (depend on booter)*/
+#else
+#define CONFIG_SYS_TEXT_BASE		0x8200           // BOOT Block will copy u-boot.bin image A/B to General location in DDR.    
+/*#define CONFIG_SYS_TEXT_BASE		0x80080000       // BOOT From FLASH (depend on booter)*/
+/*#define CONFIG_SYS_TEXT_BASE		0x80005200       // BOOT From FLASH (depend on booter)*/
+#endif
+
+
+#define CONFIG_SYS_MEM_TOP_HIDE   _48MB_             // Graphics Memory size to hide.
+
+
+/* Uncomment to remove L1/L2-Caches */
+/*=========================================*/
+/*#define CONFIG_SYS_ICACHE_OFF*/
+/*#define CONFIG_SYS_DCACHE_OFF*/
+/*#define CONFIG_SYS_L2CACHE_OFF        1*/
+/*=========================================*/
+
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+/*#define DEBUG                           1*/
+/*#define VERBOSE_GLOBAL                  1*/
+/*#define VERBOSE_EMC                     1*/
+/*#define VERBOSE_GMAC                    1*/
+/*#define ET_DEBUG                        1*/
+/*#define VERBOSE_SPI_FLASH               1           // FIU spi Debug*/
+
+
+
+#define CONFIG_ARM_ERRATA_794072           // ARM CORTEX-A9 Errata
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* L2-Cache controler PL310 for Cortex A9                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef CONFIG_SYS_L2CACHE_OFF
+#define CONFIG_SYS_L2_PL310		1
+#define CONFIG_SYS_PL310_BASE	0xF03FC000       /* L2 - Cache Regs Base (4k Space)*/
+#endif
+
+#define CONFIG_SYS_CACHELINE_SIZE	   32
+
+#define CONFIG_BOARD_LOWLEVEL_INIT      1
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_BAUDRATE                 600
+#else
+    #define CONFIG_BAUDRATE                 115200
+#endif
+
+#undef CONFIG_SYS_BAUDRATE_TABLE
+#define CONFIG_SYS_BAUDRATE_TABLE       { 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 }
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ETH_DEVS                 CHIP_NUM_OF_EMC_ETH + CHIP_NUM_OF_GMAC_ETH   // 2 EMC + 2 GMAC
+
+
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS1,115200n8 initrd=0x1d00000,3000000 mem=230M"
+
+#define CONFIG_IPADDR                   10.191.20.48
+#define CONFIG_NETMASK                  255.255.255.0
+#define CONFIG_SERVERIP                 10.191.20.75
+#define CONFIG_GATEWAYIP                10.191.20.254
+
+#define CONFIG_ETHADDR                  00:00:F7:A0:00:45      // EMC1 
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:00:F7:A0:00:46      // EMC2
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETH2ADDR                 00:00:F7:A0:00:47      // GMAC1
+#define CONFIG_HAS_ETH3
+#define CONFIG_ETH3ADDR                 00:00:F7:A0:00:48      // GMAC2
+
+#define CONFIG_CMD_GMAC
+
+/* Ethernet driver configuration */
+#define CONFIG_PHYLIB
+#define CONFIG_ETH_DESIGNWARE
+
+#define CONFIG_DW_SEARCH_PHY
+#define CONFIG_GMAC_RGMII_PHY           0x19           // GMAC RGMII Phy Address (see PolegSVB schematic)
+#define CONFIG_EMC_RMII_PHY             0x03           // EMC RMII Phy Address (see PolegSVB schematic)
+#define CONFIG_PHY_RESET_DELAY			10000		   // in usec 
+#define CONFIG_DW_AUTONEG
+#define CONFIG_PHY_GIGE			                       // Include GbE speed/duplex detection
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* USB                                                                                         */
+/*---------------------------------------------------------------------------------------------------------*/
+
+/* USB UHH support options */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_HOST
+/*#define CONFIG_USB_OHCI*/
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_STORAGE
+#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS 1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ENV_SIZE                 0x40000                                         // Total Size of Environment Sector
+#define CONFIG_SYS_ENV_OFFSET           0xC0000                                         // environment starts here
+
+#ifdef _CONFIG_NO_FLASH_
+    #define CONFIG_SYS_NO_FLASH             1
+	#undef	CONFIG_CMD_IMLS
+    #define CONFIG_ENV_IS_NOWHERE
+#else
+    #define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+    /*#define CONFIG_SYS_ENV_SECT_SIZE        (128 << 10)                                 // Env sector size 128 KiB*/
+    #define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+
+    #define CONFIG_ENV_OVERWRITE
+    #define CONFIG_FLASH_VERIFY
+#endif
+
+
+#endif /* __POLEGPALLADIUM_H*/
+
diff --git a/include/configs/YarkonSVB.h b/include/configs/YarkonSVB.h
new file mode 100755
index 0000000..99f41a6
--- /dev/null
+++ b/include/configs/YarkonSVB.h
@@ -0,0 +1,122 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   YarkonSVB.h                                                                                           */
+/*            This file contains configurations for the YarkonSVB compilation                              */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __YARKONPALLADIUM_H
+#define __YARKONPALLADIUM_H
+
+
+/*
+ * Warning: changing CONFIG_SYS_TEXT_BASE requires
+ * adapting the initial boot program.
+ * Since the linker has to swallow that define, we must use a pure
+ * hex number here!
+ */
+
+/* DO NOT move this Define !*/
+#define CONFIG_SYS_TEXT_BASE		0x40080030       // BOOT From FLASH (0x30 depend on booter)
+
+#include "nuvoton.h"
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* For Debugging                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+//#define DEBUG                           1
+//#define VERBOSE_GLOBAL                  1
+//#define VERBOSE_EMC                     1
+//#define VERBOSE_GMAC                    1
+//#define ET_DEBUG                        1
+
+//#define _PALLADIUM_                     1       // Activate Palladium bypasses
+
+
+
+#define CONFIG_SYS_L2CACHE_OFF	        1	/* No L2 CACHE */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Size of malloc() pool                                                                                   */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_MALLOC_LEN           (CONFIG_ENV_SIZE + 1024*1024)
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_BAUDRATE                 600
+#else
+    #define CONFIG_BAUDRATE                 115200
+#endif
+
+#undef CONFIG_SYS_BAUDRATE_TABLE
+#define CONFIG_SYS_BAUDRATE_TABLE       { 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 }
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ETH_DEVS                 CHIP_NUM_OF_ETH  // 1 EMC + 1 GMAC
+
+#define CONFIG_BOOTDELAY                3
+
+#define CONFIG_BOOTARGS                 "root=/dev/ram0 console=ttyS1,115200n8 initrd=0x1d00000,3000000 mem=230M"
+
+#define CONFIG_IPADDR                   10.191.20.49
+#define CONFIG_NETMASK                  255.255.255.0
+#define CONFIG_SERVERIP                 10.191.20.75
+#define CONFIG_GATEWAYIP                10.191.20.254
+
+#define CONFIG_ETHADDR                  00:00:F7:A0:00:49           // EMC not used in NPCM650 
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETH1ADDR                 00:00:F7:A0:00:49           // GMAC  
+
+#define CONFIG_CMD_GMAC
+
+/* Ethernet driver configuration */
+#define CONFIG_DESIGNWARE_ETH                          // use Synopsys GMAC Driver
+
+#define CONFIG_DW_SEARCH_PHY
+#define CONFIG_DW0_PHY			     	1              // Phy Address  (see schematic)
+#define CONFIG_PHY_RESET_DELAY			10000		   // in usec 
+#define CONFIG_DW_AUTONEG
+#define CONFIG_PHY_GIGE			                       // Include GbE speed/duplex detection
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Environment organization                                                                                */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_ENV_SIZE                 0x40000                                         // Total Size of Environment Sector
+#define CONFIG_SYS_ENV_OFFSET           0xC0000                                         // environment starts here
+
+#ifdef _PALLADIUM_
+    #define CONFIG_ENV_IS_NOWHERE
+
+#else
+    #define CONFIG_ENV_IS_IN_FLASH          1                                           // We save the environment in flash
+    #define CONFIG_SYS_ENV_SECT_SIZE        0x200                                       // Env sector size
+    #define CONFIG_ENV_ADDR                 (CONFIG_FLASH_BASE + CONFIG_SYS_ENV_OFFSET) // Flash addr of environment
+    #define CONFIG_ENV_OVERWRITE
+
+#endif
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Optimizations                                                                                           */
+/*---------------------------------------------------------------------------------------------------------*/
+#ifdef _PALLADIUM_
+    #define CONFIG_NO_CRC32                 1
+#endif
+
+
+#endif // __YARKONPALLADIUM_H
+
diff --git a/include/configs/nuvoton.h b/include/configs/nuvoton.h
new file mode 100755
index 0000000..92f9a98
--- /dev/null
+++ b/include/configs/nuvoton.h
@@ -0,0 +1,195 @@
+/*---------------------------------------------------------------------------------------------------------*/
+/*  Nuvoton Technology Corporation confidential                                                            */
+/*                                                                                                         */
+/*  Copyright (c) 2009 by Nuvoton Technology Corporation                                                   */
+/*  All rights reserved                                                                                    */
+/*                                                                                                         */
+/*<<<------------------------------------------------------------------------------------------------------*/
+/* File Contents:                                                                                          */
+/*   nuvoton.h                                                                                             */
+/*            This file contains configurations for the wpcm450 compilation                                */
+/*  Project:                                                                                               */
+/*            U-Boot                                                                                       */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#ifndef __NUVOTON_H
+#define __NUVOTON_H
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Including HAL definitions                                                                               */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined(BOARD_NAME) && !defined(__ASSEMBLY__) && !defined(USE_HOSTCC)
+#include "../../board/nuvoton/common/BMC_HAL/Boards/board.h"
+
+#undef MOD
+#undef ARRAY_SIZE
+#undef DIV_ROUND
+#undef MAX
+#undef MIN
+
+#endif
+
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Command line support                                                                                    */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_CMD_ASKENV               // ask for env variable
+#define CONFIG_SYS_ALT_MEMTEST          // Allow deeper alternet mtest 
+#define CONFIG_CMD_SETGETDCR            // DCR support on 4xx
+#define CONFIG_CMD_ELF                  // ELF support
+#define CONFIG_CMD_REGINFO              // Register dump
+#define CONFIG_CMD_SAVES                // save S record dump
+#define CONFIG_CMD_SDRAM                // SDRAM DIMM SPD info printout
+#define CONFIG_CMD_UNZIP                // unzip from memory to memory
+
+#define CONFIG_CMD_PING                 // Ping command
+#define CONFIG_CMD_DHCP                 // DHCP boot
+#define CONFIG_CMD_DIAG                 // Diagnostic commands
+
+#define CONFIG_CMD_MII                  // Network
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_CACHE
+
+/*#define CONFIG_MMC_TRACE           */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_NPCMX50_SDHCI
+#define CONFIG_CMD_MMC
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_FAT
+#define CONFIG_FAT_WRITE
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_FS_GENERIC
+
+#define CONFIG_CMDLINE_EDITING
+/*#define CONFIG_CMD_SF*/
+
+/* Open Firmware flat tree */
+#define CONFIG_OF_LIBFDT
+
+/* Fuses */
+#define CONFIG_CMD_FUSE
+#define CONFIG_NPCM750_OTP
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* High Level Configuration Options                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#if defined (NPCM750)
+#define CORE_TYPE                       Cortex-A9
+#define CONFIG_ARMV7	                1	        /* This is an ARM V7 CPU core */
+#else
+#define CORE_TYPE                       ARM926EJS
+#define CONFIG_ARM926EJS                1           // This is an arm926ejs CPU core
+#endif
+#define CONFIG_IDENT_STRING             " by Nuvoton Technology Corp."
+#define CONFIG_NUVOTON                  1
+
+#define CONFIG_DISPLAY_CPUINFO          1           // display cpu info (and speed)
+#define CONFIG_DISPLAY_BOARDINFO        1           // display board info
+
+
+#define CONFIG_USE_IRQ                  1
+#define CONFIG_INTEGRATOR               1
+
+#define CONFIG_MISC_INIT_R              1           /* This is used to properly link "nuvoton_eth.c" file
+                                                       for more info read the comment in the file
+                                                       over misc_init_r function */
+
+#define CONFIG_SETUP_MEMORY_TAGS        1
+#define CONFIG_SYS_GENERIC_BOARD        1        // Trego- UBOOT Relocation old way (for Now)
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Miscellaneous configurable options                                                                      */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_LONGHELP             1                           // Enable print of long help for commands
+
+#define CONFIG_SYS_CBSIZE  256                                      // Console I/O Buffer Size
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE               (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS              16                          // max number of command args
+#define CONFIG_BARGSIZE                 CONFIG_CBSIZE               // Boot Argument Buffer Size
+
+#define CONFIG_SYS_MEMTEST_START        0x00000000                  // memtest works on (SRAM and DDR) 
+#define CONFIG_SYS_MEMTEST_END          0x0A000000                  // MB in DRAM
+#undef  CONFIG_SYS_CLKS_IN_HZ                                       /* everything, incl board info, in Hz */
+#define CONFIG_SYS_LOAD_ADDR            0x8000                      // default load address
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Linux Kernel Parameters                                                                                 */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_CMDLINE_TAG              1       /* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS        1
+#define CONFIG_INITRD_TAG               1       /* Required for ramdisk support */
+#define CONFIG_TAGS_LOCATION            0x100
+
+/* FIX_ISSUE_605 */
+/* #define CONFIG_TAGS_LOCATION            0x1000100 */
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Hardware drivers                                                                                        */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_SYS_HZ                   1000
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Serial Console Configuration                                                                            */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_UART0_CONSOLE            1
+#define CONFIG_CONS_INDEX               1
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Stack sizes                                                                                             */
+/* The stack sizes are set up in start.S using the settings below                                          */
+/*---------------------------------------------------------------------------------------------------------*/
+#define CONFIG_STACKSIZE                (128*1024)                  // regular stack
+#define CONFIG_STACKSIZE_IRQ            (4*1024)                    // IRQ stack
+#define CONFIG_STACKSIZE_FIQ            (4*1024)                    // FIQ stack
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Physical Memory Map                                                                                     */
+/*---------------------------------------------------------------------------------------------------------*/
+
+
+#define CONFIG_NR_DRAM_BANKS            2                           // we have 2 banks: Chip SRAM2 (internal) and SDRAM DDR (external)
+#define PHYS_SDRAM_1                    SRAM_BASE_ADDR
+#define PHYS_SDRAM_1_SIZE               SRAM_MEMORY_SIZE
+#define PHYS_SDRAM_2                    SDRAM_BASE_ADDR
+#define PHYS_SDRAM_2_SIZE               SDRAM_MAPPED_SIZE
+
+#define	CONFIG_SYS_MONITOR_LEN		    (256 << 10)	/* Reserve 256 kB for Monitor	*/
+#define CONFIG_SYS_MONITOR_BASE	        CONFIG_SYS_TEXT_BASE
+       
+/*#define CONFIG_SYS_INIT_SP_ADDR		    0x00008000                  // Trego (SRAM_BASE_ADDR + SRAM_MEMORY_SIZE)*/
+#define CONFIG_SYS_INIT_SP_ADDR		    (0x00008000 - GENERATED_GBL_DATA_SIZE)
+
+/* FIX_ISSUE_605 */
+/* #define CONFIG_SYS_INIT_SP_ADDR		    (0x02008000 - GENERATED_GBL_DATA_SIZE) */
+
+#define CONFIG_SYS_SDRAM_BASE           PHYS_SDRAM_2
+
+
+
+/*---------------------------------------------------------------------------------------------------------*/
+/* Networking                                                                                              */
+/*---------------------------------------------------------------------------------------------------------*/
+
+#define CONFIG_NET_MULTI                1
+#define CONFIG_MII                      1
+
+#define CONFIG_MAC_INTERRUPT_ENABLE     1
+#define CONFIG_BOOTP_SERVERIP           1
+
+
+#define CONFIG_ARP_TIMEOUT              100            // ARP timeout in ms
+#define CONFIG_NET_RETRY_COUNT          100            // Number of retries per file transaction
+
+#undef USB_INTERRUPT    /* No need USB Dev in UBOOT */
+
+#endif /* __NUVOTON_H */
+
diff --git a/include/usb.h b/include/usb.h
old mode 100644
new mode 100755
index 88ebbe6..86f59e8
--- a/include/usb.h
+++ b/include/usb.h
@@ -32,7 +32,10 @@
 #define USB_ALTSETTINGALLOC		4
 #define USB_MAXALTSETTING		128	/* Hard limit */
 
-#define USB_MAX_DEVICE			32
+// Trego - 
+#define USB_MAX_DEVICE			3
+//#define USB_MAX_DEVICE			32
+
 #define USB_MAXCONFIG			8
 #define USB_MAXINTERFACES		8
 #define USB_MAXENDPOINTS		16
diff --git a/scripts/Makefile.autoconf b/scripts/Makefile.autoconf
old mode 100644
new mode 100755
index d668982..5d90522
--- a/scripts/Makefile.autoconf
+++ b/scripts/Makefile.autoconf
@@ -84,8 +84,11 @@ include/autoconf.mk include/autoconf.mk.dep \
 
 # include/config.h
 # Prior to Kconfig, it was generated by mkconfig. Now it is created here.
+# Trego include issue
 define filechk_config_h
-	(echo "/* Automatically generated - do not edit */";		\
+	(echo "#ifndef __CONFIG_H";		\
+	echo "#define __CONFIG_H"; 	\
+	echo "/* Automatically generated - do not edit */";		\
 	for i in $$(echo $(CONFIG_SYS_EXTRA_OPTIONS) | sed 's/,/ /g'); do \
 		echo \#define CONFIG_$$i				\
 		| sed '/=/ {s/=/	/;q; } ; { s/$$/	1/; }'; \
@@ -95,7 +98,8 @@ define filechk_config_h
 	echo \#include \<config_uncmd_spl.h\>;				\
 	echo \#include \<configs/$(CONFIG_SYS_CONFIG_NAME).h\>;		\
 	echo \#include \<asm/config.h\>;				\
-	echo \#include \<config_fallbacks.h\>;)
+	echo \#include \<config_fallbacks.h\>;			\
+    echo "#endif /* __CONFIG_H */";)
 endef
 
 include/config.h: scripts/Makefile.autoconf create_symlink FORCE
-- 
1.8.3.4

